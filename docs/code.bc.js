//# 1 "code.bc.runtime.js"
// Generated by js_of_ocaml 3.4.0
(function(joo_global_object)
   {"use strict";
    var caml_oo_last_id=0;
    function caml_ml_string_length(s){return s.l}
    function caml_string_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_int64_add(x,y)
     {var
       z1=x[1] + y[1],
       z2=x[2] + y[2] + (z1 >> 24),
       z3=x[3] + y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_int64_mul(x,y)
     {var
       z1=x[1] * y[1],
       z2=(z1 * caml_int64_offset | 0) + x[2] * y[1] + x[1] * y[2],
       z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_neg(x)
     {var y1=- x[1],y2=- x[2] + (y1 >> 24),y3=- x[3] + (y2 >> 24);
      return [255,y1 & 0xffffff,y2 & 0xffffff,y3 & 0xffff]}
    function caml_int64_of_int32(x)
     {return [255,x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_int64_sub(x,y)
     {var
       z1=x[1] - y[1],
       z2=x[2] - y[2] + (z1 >> 24),
       z3=x[3] - y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_ucompare(x,y)
     {if(x[3] > y[3])return 1;
      if(x[3] < y[3])return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 0xffffff;
      x[1] = x[1] << 1 & 0xffffff}
    function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 0xffffff;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 0xffffff;
      x[3] = x[3] >>> 1}
    function caml_int64_udivmod(x,y)
     {var
       offset=0,
       modulus=caml_obj_dup(x),
       divisor=caml_obj_dup(y),
       quotient=[255,0,0,0];
      while(caml_int64_ucompare(modulus,divisor) > 0)
       {offset++;caml_int64_lsl1(divisor)}
      while(offset >= 0)
       {offset--;
        caml_int64_lsl1(quotient);
        if(caml_int64_ucompare(modulus,divisor) >= 0)
         {quotient[1]++;modulus = caml_int64_sub(modulus,divisor)}
        caml_int64_lsr1(divisor)}
      return [0,quotient,modulus]}
    function caml_int64_ult(x,y){return caml_int64_ucompare(x,y) < 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break
         }
      return [i,sign,base]}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(s.repeat)return s.repeat(n);
      var r="",l=0;
      if(n == 0)return r;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function raw_array_sub(a,i,l)
     {var b=new Array(l);for(var j=0;j < l;j++)b[j] = a[i + j];return b}
    function caml_subarray_to_string(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,raw_array_sub(a,i,Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0}
    function caml_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_to_js_string(s)
     {switch(s.t)
       {case 9:return s.c;
        default:caml_convert_string_to_bytes(s);case 0:
         if(caml_is_ascii(s.c)){s.t = 9;return s.c}s.t = 8;
        case 8:return caml_utf16_of_utf8(s.c)
        }}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString = function(){return caml_to_js_string(this)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_new_string(s){return new MlBytes(0,s,s.length)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_new_string(msg))}
    var caml_global_data=[0];
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=caml_int64_udivmod([255,0xffffff,0xfffffff,0xffff],base64)[1],
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(r[2] == 10 && caml_int64_ult([255,0,0,0x8000],res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_int64_is_zero(x){return (x[3] | x[2] | x[1]) == 0}
    function caml_int64_to_int32(x){return x[1] | x[2] << 24}
    function caml_int64_is_negative(x){return x[3] << 16 < 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_new_string(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = name instanceof MlBytes?name.toString():name;
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_string_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_string_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_string_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun(caml_new_string(this.root),caml_new_string(name));
        if(res !== 0)this.content[name] = new MlFakeFile(res[1])}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(content instanceof MlBytes)
       this.content[name] = new MlFakeFile(content);
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_string_of_array(content));
       else
        if(content.toString)
         {var mlstring=caml_new_string(content.toString());
          this.content[name] = new MlFakeFile(mlstring)}};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_string(s)
     {if(s.t != 4)caml_convert_string_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    var Buffer=joo_global_object.Buffer;
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len){this.fs.ftruncateSync(this.fd,len | 0)};
    MlNodeFile.prototype.length
    =
    function(){return this.fs.fstatSync(this.fd).size};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.writeSync(this.fd,buffer,buf_offset,len,offset);
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,buf_offset,len,offset);
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (joo_global_object.Uint8Array)(1),buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,0,1,offset);
      return buffer[0]};
    MlNodeFile.prototype.close = function(){this.fs.closeSync(this.fd)};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name){return this.fs.existsSync(this.nm(name))?1:0};
    MlNodeDevice.prototype.readdir
    =
    function(name){return this.fs.readdirSync(this.nm(name))};
    MlNodeDevice.prototype.is_dir
    =
    function(name){return this.fs.statSync(this.nm(name)).isDirectory()?1:0};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {var b=this.fs.existsSync(this.nm(name))?1:0;
      this.fs.unlinkSync(this.nm(name));
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      var fd=this.fs.openSync(this.nm(name),res);
      return new MlNodeFile(fd)};
    MlNodeDevice.prototype.rename
    =
    function(o,n){this.fs.renameSync(this.nm(o),this.nm(n))};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_string_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_ba_set_1(ba,i0,v){return ba.set1(i0,v)}
    function bigstring_blit_string_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1
        (v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));
      return 0}
    var caml_blit_string_to_bigstring=bigstring_blit_string_bigstring_stub;
    function caml_make_vect(len,init)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function js_print_stderr(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_js_to_string(s)
     {var tag=9;
      if(! caml_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=name.toString();
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_js_to_string(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_js_to_string(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_raise_not_a_dir(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_new_string(a[i]);
      return l}
    var caml_ml_channels=new Array();
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var string;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       string = buffer;
      else
       {string = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,string,0,len)}
      var
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes(chanid,buffer,offset,len)}
    function caml_ml_output_char(chanid,c)
     {var s=caml_new_string(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_bytes_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_int64_float_of_bits(x)
     {var exp=(x[3] & 0x7fff) >> 4;
      if(exp == 2047)
       return (x[1] | x[2] | x[3] & 0xf) == 0
               ?x[3] & 0x8000?- Infinity:Infinity
               :NaN;
      var k=Math.pow(2,- 24),res=(x[1] * k + x[2]) * k + (x[3] & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(x[3] & 0x8000)res = - res;
      return res}
    function caml_int64_of_bytes(a)
     {return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8]}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_js_var(x)
     {var x=x.toString();
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_new_string(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function caml_gc_minor(){return 0}
    function caml_trunc_float(x){return Math.trunc(x)}
    var caml_ephe_data_offset=2;
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_ba_uint8_get64(ba,i0)
     {var
       b1=ba.get1(i0),
       b2=ba.get1(i0 + 1) << 8,
       b3=ba.get1(i0 + 2) << 16,
       b4=ba.get1(i0 + 3),
       b5=ba.get1(i0 + 4) << 8,
       b6=ba.get1(i0 + 5) << 16,
       b7=ba.get1(i0 + 6),
       b8=ba.get1(i0 + 7) << 8;
      return [255,b1 | b2 | b3,b4 | b5 | b6,b7 | b8]}
    function caml_int64_compare(x,y)
     {var x3=x[3] << 16,y3=y[3] << 16;
      if(x3 > y3)return 1;
      if(x3 < y3)return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_string_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         if(a instanceof MlBytes)
          if(b instanceof MlBytes)
           {if(a !== b){var x=caml_string_compare(a,b);if(x != 0)return x}}
          else
           return 1;
         else
          if(a instanceof Array && a[0] === (a[0] | 0))
           {var ta=a[0];
            if(ta === 254)ta = 0;
            if(ta === 250)
             {a = a[1];continue}
            else
             if(b instanceof Array && b[0] === (b[0] | 0))
              {var tb=b[0];
               if(tb === 254)tb = 0;
               if(tb === 250)
                {b = b[1];continue}
               else
                if(ta != tb)
                 return ta < tb?- 1:1;
                else
                 switch(ta)
                  {case 248:
                    var x=caml_int_compare(a[2],b[2]);if(x != 0)return x;break;
                   case 251:caml_invalid_argument("equal: abstract value");
                   case 255:
                    var x=caml_int64_compare(a,b);if(x != 0)return x;break;
                   default:
                    if(a.length != b.length)return a.length < b.length?- 1:1;
                    if(a.length > 1)stack.push(a,b,1)}}
             else
              return 1}
          else
           if
            (b instanceof MlBytes
             ||
             b instanceof Array
             &&
             b[0]
             ===
             (b[0] | 0))
            return - 1;
           else
            if(typeof a != "number" && a && a.compare)
             {var cmp=a.compare(b,total);if(cmp != 0)return cmp}
            else
             if(typeof a == "function")
              caml_invalid_argument("compare: functional value");
             else
              {if(a < b)return - 1;
               if(a > b)return 1;
               if(a != b)
                {if(! total)return NaN;
                 if(a == a)return 1;
                 if(b == b)return - 1}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_ba_num_dims(ba,_dim){return ba.num_dims}
    function caml_ba_get_1(ba,i0){return ba.get1(i0)}
    function bigstring_blit_bigstring_bytes_stub
     (v_bstr,v_src_pos,v_str,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var c=caml_ba_get_1(v_bstr,v_src_pos + i);
        caml_bytes_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      return 0}
    if(! Math.imul)
     Math.imul
     =
     function(x,y){y |= 0;return ((x >> 16) * y << 16) + (x & 0xffff) * y | 0};
    var caml_mul=Math.imul;
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_string_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_return_exn_constant(tag){return tag}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_js_to_string(String(e))]}
    function caml_final_register_called_without_value(){return 0}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_ba_get_2(ba,i0,i1){return ba.get([i0,i1])}
    function caml_set_parser_trace(){return 0}
    function win_handle_fd(x){return x}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_ba_uint8_set16(ba,i0,v)
     {ba.set1(i0,v & 0xff);ba.set1(i0 + 1,v >>> 8 & 0xff);return 0}
    function raw_array_append_one(a,x)
     {var l=a.length,b=new Array(l + 1),i=0;
      for(;i < l;i++)b[i] = a[i];
      b[i] = x;
      return b}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      var n=f.length,argsLen=args.length,d=n - argsLen;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen
                (f.apply(null,raw_array_sub(args,0,n)),
                 raw_array_sub(args,n,argsLen - n));
       else
        return function(x)
         {return caml_call_gen(f,raw_array_append_one(args,x))}}
    function caml_js_wrap_callback(f)
     {return function()
       {return arguments.length > 0
                ?caml_call_gen(f,arguments)
                :caml_call_gen(f,[undefined])}}
    function caml_js_wrap_callback_arguments(f)
     {return function(){return caml_js_wrap_callback(f)(arguments)}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {caml_current_dir = root.rest?root.path + root.rest + "/":root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;prev = [0,caml_new_string(jsoo_mount_point[i].path),old]}
      return prev}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12};
    function caml_js_equals(x,y){return + (x == y)}
    function caml_hash_mix_string_str(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_ba_blit(src,dst){dst.blit(src);return 0}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             switch(s)
              {case "_j":
                var t=new Array(8);
                for(var j=0;j < 8;j++)t[j] = reader.read8u();
                var v=caml_int64_of_bytes(t);
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_i":
                var v=reader.read32s();
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_n":
                switch(reader.read8u())
                 {case 1:
                   var v=reader.read32s();
                   if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                   return v;
                  case 2:
                   caml_failwith("input_value: native integer value too large");
                  default:
                   caml_failwith("input_value: ill-formed native integer")}
               default:
                caml_failwith("input_value: unknown custom block identifier")}
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_js_from_array(a){return raw_array_sub(a,1,a.length - 1)}
    function caml_ba_slice(ba,vind){return ba.slice(caml_js_from_array(vind))}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function caml_int64_div(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3] ^ y[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var q=caml_int64_udivmod(x,y)[1];
      if(sign & 0x8000)q = caml_int64_neg(q);
      return q}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_js_html_entities(s)
     {var str,temp=document.createElement("p");
      temp.innerHTML = s;
      str = temp.textContent || temp.innerText;
      temp = null;
      return str}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return [255,
              x & 0xffffff,
              Math.floor(x * caml_int64_offset) & 0xffffff,
              Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff]}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){return ba.set([i0,i1],v)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function caml_js_eval_string(s){return eval(s.toString())}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlBytesReader(s,i){this.s = caml_jsbytes_of_string(s);this.i = i}
    MlBytesReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_new_string(this.s.substring(i,i + len))}};
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_string(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_ba_reshape(ba,vind)
     {return ba.reshape(caml_js_from_array(vind))}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_string_arr(h,bs.data)}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_record_backtrace(){return 0}
    function caml_get_global_data(){return caml_global_data}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_ba_uint8_get16(ba,i0)
     {var b1=ba.get1(i0),b2=ba.get1(i0 + 1) << 8;return b1 | b2}
    function caml_int64_shift_right_unsigned(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | x[3] << 24 - s) & 0xffffff,
               x[3] >> s];
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] >> s - 24,
               0];
      return [255,x[3] >> s - 48,0,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_new_string("js_of_ocaml")]}
    function caml_sys_get_config(){return [0,caml_new_string("Unix"),32,0]}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    var
     bigstring_blit_bigstring_string_stub=
      bigstring_blit_bigstring_bytes_stub;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x)
     {return (x[3] << 16) * Math.pow(2,32) + x[2] * Math.pow(2,24) + x[1]}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_ba_create_from(data,data2,data_type,kind,layout,dims)
     {var n_dims=dims.length,size=caml_ba_get_size(dims);
      function offset_c(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
        for(var i=0;i < n_dims;i++)
         {if(index[i] < 0 || index[i] >= dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + index[i]}
        return ofs}
      function offset_fortran(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: wrong number of indices");
        for(var i=n_dims - 1;i >= 0;i--)
         {if(index[i] < 1 || index[i] > dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + (index[i] - 1)}
        return ofs}
      var offset=layout == 0?offset_c:offset_fortran,dim0=dims[0];
      function get_std(index){var ofs=offset(index),v=data[ofs];return v}
      function get_int64(index)
       {var off=offset(index),l=data[off],h=data2[off];
        return [255,
                l & 0xffffff,
                l >>> 24 & 0xff | (h & 0xffff) << 8,
                h >>> 16 & 0xffff]}
      function get_complex(index)
       {var off=offset(index),r=data[off],i=data2[off];return [254,r,i]}
      var get=data_type == 1?get_int64:data_type == 2?get_complex:get_std;
      function get1_c(i)
       {if(i < 0 || i >= dim0)caml_array_bound_error();return data[i]}
      function get1_fortran(i)
       {if(i < 1 || i > dim0)caml_array_bound_error();return data[i - 1]}
      function get1_any(i){return get([i])}
      var get1=data_type == 0?layout == 0?get1_c:get1_fortran:get1_any;
      function set_std_raw(off,v){data[off] = v}
      function set_int64_raw(off,v)
       {data[off] = v[1] | (v[2] & 0xff) << 24;
        data2[off] = v[2] >>> 8 & 0xffff | v[3] << 16}
      function set_complex_raw(off,v){data[off] = v[1];data2[off] = v[2]}
      function set_std(index,v)
       {var ofs=offset(index);return set_std_raw(ofs,v)}
      function set_int64(index,v){return set_int64_raw(offset(index),v)}
      function set_complex(index,v){return set_complex_raw(offset(index),v)}
      var set=data_type == 1?set_int64:data_type == 2?set_complex:set_std;
      function set1_c(i,v)
       {if(i < 0 || i >= dim0)caml_array_bound_error();data[i] = v}
      function set1_fortran(i,v)
       {if(i < 1 || i > dim0)caml_array_bound_error();data[i - 1] = v}
      function set1_any(i,v){set([i],v)}
      var set1=data_type == 0?layout == 0?set1_c:set1_fortran:set1_any;
      function nth_dim(i)
       {if(i < 0 || i >= n_dims)caml_invalid_argument("Bigarray.dim");
        return dims[i]}
      function fill(v)
       {if(data_type == 0)for(var i=0;i < data.length;i++)set_std_raw(i,v);
        if(data_type == 1)for(var i=0;i < data.length;i++)set_int64_raw(i,v);
        if(data_type == 2)for(var i=0;i < data.length;i++)set_complex_raw(i,v)}
      function blit(from)
       {if(n_dims != from.num_dims)
         caml_invalid_argument("Bigarray.blit: dimension mismatch");
        for(var i=0;i < n_dims;i++)
         if(dims[i] != from.nth_dim(i))
          caml_invalid_argument("Bigarray.blit: dimension mismatch");
        data.set(from.data);
        if(data_type != 0)data2.set(from.data2)}
      function sub(ofs,len)
       {var changed_dim,mul=1;
        if(layout == 0)
         {for(var i=1;i < n_dims;i++)mul = mul * dims[i];changed_dim = 0}
        else
         {for(var i=0;i < n_dims - 1;i++)mul = mul * dims[i];
          changed_dim = n_dims - 1;
          ofs = ofs - 1}
        if(ofs < 0 || len < 0 || ofs + len > dims[changed_dim])
         caml_invalid_argument("Bigarray.sub: bad sub-array");
        var
         new_data=data.subarray(ofs * mul,(ofs + len) * mul),
         new_data2=
          data_type == 0?null:data2.subarray(ofs * mul,(ofs + len) * mul),
         new_dims=[];
        for(var i=0;i < n_dims;i++)new_dims[i] = dims[i];
        new_dims[changed_dim] = len;
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,new_dims)}
      function slice(vind)
       {var num_inds=vind.length,index=[],sub_dims=[],ofs;
        if(num_inds >= n_dims)
         caml_invalid_argument("Bigarray.slice: too many indices");
        if(layout == 0)
         {for(var i=0;i < num_inds;i++)index[i] = vind[i];
          for(;i < n_dims;i++)index[i] = 0;
          ofs = offset(index);
          sub_dims = dims.slice(num_inds)}
        else
         {for(var i=0;i < num_inds;i++)index[n_dims - num_inds + i] = vind[i];
          for(var i=0;i < n_dims - num_inds;i++)index[i] = 1;
          ofs = offset(index);
          sub_dims = dims.slice(0,num_inds)}
        var
         size=caml_ba_get_size(sub_dims),
         new_data=data.subarray(ofs,ofs + size),
         new_data2=data_type == 0?null:data2.subarray(ofs,ofs + size);
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,sub_dims)}
      function reshape(vdim)
       {var new_dim=[],num_dims=vdim.length;
        if(num_dims < 1)
         caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
        var num_elts=1;
        for(var i=0;i < num_dims;i++)
         {new_dim[i] = vdim[i];
          if(new_dim[i] < 0)
           caml_invalid_argument("Bigarray.reshape: negative dimension");
          num_elts = num_elts * new_dim[i]}
        if(num_elts != size)
         caml_invalid_argument("Bigarray.reshape: size mismatch");
        return caml_ba_create_from(data,data2,data_type,kind,layout,new_dim)}
      function compare(b,total)
       {if(layout != b.layout)return b.layout - layout;
        if(n_dims != b.num_dims)return b.num_dims - n_dims;
        for(var i=0;i < n_dims;i++)
         if(nth_dim(i) != b.nth_dim(i))return nth_dim(i) < b.nth_dim(i)?- 1:1;
        switch(kind)
         {case 0:
          case 1:
          case 10:
          case 11:
           var x,y;
           for(var i=0;i < data.length;i++)
            {x = data[i];
             y = b.data[i];
             if(x < y)return - 1;
             if(x > y)return 1;
             if(x != y)
              if(x != y)
               {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}
             if(data2)
              {x = data2[i];
               y = b.data2[i];
               if(x < y)return - 1;
               if(x > y)return 1;
               if(x != y)
                if(x != y)
                 {if(! total)return NaN;
                  if(x == x)return 1;
                  if(y == y)return - 1}}}
           break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 12:
           for(var i=0;i < data.length;i++)
            {if(data[i] < b.data[i])return - 1;
             if(data[i] > b.data[i])return 1}
           break;
          case 7:
           for(var i=0;i < data.length;i++)
            {if(data2[i] < b.data2[i])return - 1;
             if(data2[i] > b.data2[i])return 1;
             if(data[i] < b.data[i])return - 1;
             if(data[i] > b.data[i])return 1}
           break
          }
        return 0}
      return {data:data,
              data2:data2,
              data_type:data_type,
              num_dims:n_dims,
              nth_dim:nth_dim,
              kind:kind,
              layout:layout,
              size:size,
              sub:sub,
              slice:slice,
              blit:blit,
              fill:fill,
              reshape:reshape,
              get:get,
              get1:get1,
              set:set,
              set1:set1,
              compare:compare}}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_from(ta,null,0,12,0,[ta.length])}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.data2 != null)
       caml_invalid_argument("bigstring_destroy: unsupported kind");
      if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      var
       destroyed_data=new (v_bstr.data.__proto__.constructor)(0),
       destroyed_bigstring=
        caml_ba_create_from
         (destroyed_data,null,v_bstr.data_type,v_bstr.kind,v_bstr.layout,[0]);
      destroyed_bigstring.__is_deallocated = true;
      Object.assign(v_bstr,destroyed_bigstring);
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_ba_uint8_get32(ba,i0)
     {var
       b1=ba.get1(i0),
       b2=ba.get1(i0 + 1) << 8,
       b3=ba.get1(i0 + 2) << 16,
       b4=ba.get1(i0 + 3) << 24;
      return b1 | b2 | b3 | b4}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_ba_init(){return 0}
    function caml_final_release(){return 0}
    function caml_ba_get_generic(ba,index)
     {return ba.get(caml_js_from_array(index))}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_get_exception_backtrace(){return 0}
    function raw_array_cons(a,x)
     {var l=a.length,b=new Array(l + 1);
      b[0] = x;
      for(var i=1;i <= l;i++)b[i] = a[i - 1];
      return b}
    function caml_js_to_array(a){return raw_array_cons(a,0)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_format_float(fmt,x)
     {var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = x.toFixed(prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_int64_to_bytes(x)
     {return [x[3] >> 8,
              x[3] & 0xff,
              x[2] >> 16,
              x[2] >> 8 & 0xff,
              x[2] & 0xff,
              x[1] >> 16,
              x[1] >> 8 & 0xff,
              x[1] & 0xff]}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_string_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {return [255,
              (x[3] & 0x0000ff00)
              >>
              8
              |
              (x[3] & 0x000000ff)
              <<
              8
              |
              x[2]
              &
              0x00ff0000,
              (x[2] & 0x0000ff00)
              >>
              8
              |
              (x[2] & 0x000000ff)
              <<
              8
              |
              x[1]
              &
              0x00ff0000,
              (x[1] & 0x0000ff00) >> 8 | (x[1] & 0x000000ff) << 8]}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_string_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_string_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_gc_major(){return 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_get_argv()
     {var g=joo_global_object,main="a.out",args=[];
      if(g.process && g.process.argv && g.process.argv.length > 1)
       {var argv=g.process.argv;
        main = argv[1];
        args = raw_array_sub(argv,2,argv.length - 2)}
      var p=caml_js_to_string(main),args2=[0,p];
      for(var i=0;i < args.length;i++)args2.push(caml_js_to_string(args[i]));
      return [0,p,args2]}
    function caml_js_to_bool(x){return + x}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    var caml_ephe_key_offset=3;
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    var caml_ba_views;
    function caml_ba_init_views()
     {if(! caml_ba_views)
       {var g=joo_global_object;
        caml_ba_views
        =
        [[g.Float32Array,
          g.Float64Array,
          g.Int8Array,
          g.Uint8Array,
          g.Int16Array,
          g.Uint16Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Float32Array,
          g.Float64Array,
          g.Uint8Array],
         [0,0,0,0,0,0,0,1,0,0,2,2,0]]}}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_ba_uint8_set64(ba,i0,v)
     {ba.set1(i0,v[1] & 0xff);
      ba.set1(i0 + 1,v[1] >> 8 & 0xff);
      ba.set1(i0 + 2,v[1] >> 16);
      ba.set1(i0 + 3,v[2] & 0xff);
      ba.set1(i0 + 4,v[2] >> 8 & 0xff);
      ba.set1(i0 + 5,v[2] >> 16);
      ba.set1(i0 + 6,v[3] & 0xff);
      ba.set1(i0 + 7,v[3] >> 8);
      return 0}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        mem[dst + 1] = src == 0xff?curr_pos:mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        mem[dst + 1] = src == 0xff?- 1:mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          pc_off
          =
          tbl.lex_check_code[base_code + c] == pstate
           ?tbl.lex_trans_code[base_code + c]
           :tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return [255,1,0,0x7ff0];
        return x > 0?[255,0,0,0x7ff0]:[255,0,0,0xfff0]}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return [255,r1,r2,r3]}
    var
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v)
          {var writer=new Writer(),stack=[];
           function extern_rec(v)
            {if(v instanceof Array && v[0] === (v[0] | 0))
              {if(v[0] == 255)
                {writer.write(8,0x12);
                 for(var i=0;i < 3;i++)writer.write(8,"_j\0".charCodeAt(i));
                 var b=caml_int64_to_bytes(v);
                 for(var i=0;i < 8;i++)writer.write(8,b[i]);
                 writer.size_32 += 4;
                 writer.size_64 += 3;
                 return}
               if(v[0] == 251)
                caml_failwith("output_value: abstract value (Abstract)");
               if(v[0] < 16 && v.length - 1 < 8)
                writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
               else
                writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
               writer.size_32 += v.length;
               writer.size_64 += v.length;
               if(v.length > 1)stack.push(v,1)}
             else
              if(v instanceof MlBytes)
               {var len=caml_ml_string_length(v);
                if(len < 0x20)
                 writer.write(8,0x20 + len);
                else
                 if(len < 0x100)
                  writer.write_code(8,0x09,len);
                 else
                  writer.write_code(32,0x0A,len);
                for(var i=0;i < len;i++)
                 writer.write(8,caml_string_unsafe_get(v,i));
                writer.size_32 += 1 + ((len + 4) / 4 | 0);
                writer.size_64 += 1 + ((len + 8) / 8 | 0)}
              else
               if(v != (v | 0))
                {var type_of_v=typeof v;
                 caml_failwith
                  ("output_value: abstract value (" + type_of_v + ")")}
               else
                if(v >= 0 && v < 0x40)
                 writer.write(8,0X40 + v);
                else
                 if(v >= - (1 << 7) && v < 1 << 7)
                  writer.write_code(8,0x00,v);
                 else
                  if(v >= - (1 << 15) && v < 1 << 15)
                   writer.write_code(16,0x01,v);
                  else
                   writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_channels[chanid].offset = caml_int64_to_float(pos);return 0}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function js_print_stdout(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_gc_compaction(){return 0}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    var
     caml_ephe_get_key=caml_weak_get,
     caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function caml_ba_dim_2(ba){return ba.nth_dim(1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function(){return caml_call_gen(f,[this,arguments])}}
    function unix_inet_addr_of_string(){return 0}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,arguments);
        var args=new Array(arity);
        for(var i=0;i < n && i < arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_get_current_callstack(){return [0]}
    function caml_int64_mod(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var r=caml_int64_udivmod(x,y)[2];
      if(sign & 0x8000)r = caml_int64_neg(r);
      return r}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function win_startup(){}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_ba_set_3(ba,i0,i1,i2,v){return ba.set([i0,i1,i2],v)}
    function caml_js_instanceof(o,c){return o instanceof c}
    function caml_hash_mix_float(h,v0)
     {var
       v=caml_int64_bits_of_float(v0),
       lo=v[1] | v[2] << 24,
       hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,lo);
      h = caml_hash_mix_int(h,hi);
      return h}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_int64_shift_left(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               x[1] << s & 0xffffff,
               (x[2] << s | x[1] >> 24 - s) & 0xffffff,
               (x[3] << s | x[2] >> 24 - s) & 0xffff];
      if(s < 48)
       return [255,
               0,
               x[1] << s - 24 & 0xffffff,
               (x[2] << s - 24 | x[1] >> 48 - s) & 0xffff];
      return [255,0,0,x[1] << s - 48 & 0xffff]}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {return caml_call_gen(f,raw_array_cons(arguments,this))}}
    function caml_sys_const_int_size(){return 32}
    var caml_blit_bigstring_to_string=bigstring_blit_bigstring_bytes_stub;
    function caml_is_js(){return 1}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_ba_dim_1(ba){return ba.nth_dim(0)}
    function caml_js_meth_call(o,f,args)
     {return o[f.toString()].apply(o,caml_js_from_array(args))}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_new_string(s)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    var JSON=joo_global_object.JSON;
    if(typeof JSON !== "object")JSON = {};
    (function()
       {"use strict";
        var
         rx_one=/^[\],:{}\s]*$/,
         rx_two=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
         rx_three=
          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
         rx_four=/(?:^|:|,)(?:\s*\[)+/g,
         rx_escapable=
          /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
         rx_dangerous=
          /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        function f(n){return n < 10?"0" + n:n}
        function this_value(){return this.valueOf()}
        if(typeof Date.prototype.toJSON !== "function")
         {Date.prototype.toJSON
          =
          function()
           {return isFinite(this.valueOf())
                    ?this.getUTCFullYear()
                     +
                     "-"
                     +
                     f(this.getUTCMonth() + 1)
                     +
                     "-"
                     +
                     f(this.getUTCDate())
                     +
                     "T"
                     +
                     f(this.getUTCHours())
                     +
                     ":"
                     +
                     f(this.getUTCMinutes())
                     +
                     ":"
                     +
                     f(this.getUTCSeconds())
                     +
                     "Z"
                    :null};
          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value}
        var gap,indent,meta,rep;
        function quote(string)
         {rx_escapable.lastIndex = 0;
          return rx_escapable.test(string)
                  ?'"'
                   +
                   string.replace
                    (rx_escapable,
                     function(a)
                      {var c=meta[a];
                       return typeof c === "string"
                               ?c
                               :"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)})
                   +
                   '"'
                  :'"' + string + '"'}
        function str(key,holder)
         {var i,k,v,length,mind=gap,partial,value=holder[key];
          if
           (value
            &&
            typeof value
            ===
            "object"
            &&
            typeof value.toJSON
            ===
            "function")
           value = value.toJSON(key);
          if(typeof rep === "function")value = rep.call(holder,key,value);
          switch(typeof value)
           {case "string":return quote(value);
            case "number":return isFinite(value)?String(value):"null";
            case "boolean":
            case "null":return String(value);
            case "object":
             if(! value)return "null";
             gap += indent;
             partial = [];
             if(Object.prototype.toString.apply(value) === "[object Array]")
              {length = value.length;
               for(i = 0;i < length;i += 1)
                partial[i] = str(i,value) || "null";
               v
               =
               partial.length === 0
                ?"[]"
                :gap
                  ?"[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                  :"[" + partial.join(",") + "]";
               gap = mind;
               return v}
             if(rep && typeof rep === "object")
              {length = rep.length;
               for(i = 0;i < length;i += 1)
                if(typeof rep[i] === "string")
                 {k = rep[i];
                  v = str(k,value);
                  if(v)partial.push(quote(k) + (gap?": ":":") + v)}}
             else
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = str(k,value);
                 if(v)partial.push(quote(k) + (gap?": ":":") + v)}
             v
             =
             partial.length === 0
              ?"{}"
              :gap
                ?"{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                :"{" + partial.join(",") + "}";
             gap = mind;
             return v
            }}
        if(typeof JSON.stringify !== "function")
         {meta
          =
          {"\b":"\\b",
           "\t":"\\t",
           "\n":"\\n",
           "\f":"\\f",
           "\r":"\\r",
           '"':'\\"',
           "\\":"\\\\"};
          JSON.stringify
          =
          function(value,replacer,space)
           {var i;
            gap = "";
            indent = "";
            if(typeof space === "number")
             for(i = 0;i < space;i += 1)indent += " ";
            else
             if(typeof space === "string")indent = space;
            rep = replacer;
            if
             (replacer
              &&
              typeof replacer
              !==
              "function"
              &&
              (typeof replacer
               !==
               "object"
               ||
               typeof replacer.length
               !==
               "number"))
             throw new Error("JSON.stringify");
            return str("",{"":value})}}
        if(typeof JSON.parse !== "function")
         JSON.parse
         =
         function(text,reviver)
          {var j;
           function walk(holder,key)
            {var k,v,value=holder[key];
             if(value && typeof value === "object")
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = walk(value,k);
                 if(v !== undefined)value[k] = v;else delete value[k]}
             return reviver.call(holder,key,value)}
           text = String(text);
           rx_dangerous.lastIndex = 0;
           if(rx_dangerous.test(text))
            text
            =
            text.replace
             (rx_dangerous,
              function(a)
               {return "\\u"
                       +
                       ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)});
           if
            (rx_one.test
              (text.replace(rx_two,"@").replace(rx_three,"]").replace
                (rx_four,"")))
            {j = eval("(" + text + ")");
             return typeof reviver === "function"?walk({"":j},""):j}
           throw new SyntaxError("JSON.parse")}}
      ());
    function caml_json(){return JSON}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_ml_pos_out(chanid){return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_string_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++){var p=a[i];o[p[1].toString()] = p[2]}
      return o}
    function caml_runtime_parameters(_unit){return caml_new_string("")}
    function caml_ba_create(kind,layout,dims_ml)
     {caml_ba_init_views();
      var
       dims=caml_js_from_array(dims_ml),
       size=caml_ba_get_size(dims),
       view=caml_ba_views[0][kind];
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size),data_type=caml_ba_views[1][kind],data2=null;
      if(data_type != 0)data2 = new view(size);
      return caml_ba_create_from(data,data2,data_type,kind,layout,dims)}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_sys_getcwd(){return caml_new_string(caml_current_dir)}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_sys_const_big_endian(){return 0}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value_to_string(v,_fl)
     {return caml_string_of_array(caml_output_val(v))}
    function caml_output_value(chanid,v,_flags)
     {var s=caml_output_value_to_string(v);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_sys_system_command(cmd)
     {var cmd=cmd.toString();
      joo_global_object.console.log(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try {require("child_process").execSync(cmd);return 0}catch(e){return 1}
      else
       return 127}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get([i0,i1,i2])}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_bytes_of_string(s){return s}
    function caml_hash_mix_int64(h,v)
     {var lo=v[1] | v[2] << 24,hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,lo);
      h = caml_hash_mix_int(h,hi);
      return h}
    function caml_hash_mix_string(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_string_str(h,v.c);break;
        case 2:h = caml_hash_mix_string_arr(h,v.c)
        }
      return h}
    var HASH_QUEUE_SIZE=256;
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > HASH_QUEUE_SIZE)sz = HASH_QUEUE_SIZE;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v instanceof Array && v[0] === (v[0] | 0))
         switch(v[0])
          {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
           case 250:queue[--rd] = v[1];break;
           case 255:h = caml_hash_mix_int64(h,v);num--;break;
           default:
            var tag=v.length - 1 << 10 | v[0];
            h = caml_hash_mix_int(h,tag);
            for(i = 1,len = v.length;i < len;i++)
             {if(wr >= sz)break;queue[wr++] = v[i]}
            break}
        else
         if(v instanceof MlBytes)
          {h = caml_hash_mix_string(h,v);num--}
         else
          if(v === (v | 0))
           {h = caml_hash_mix_int(h,v + v + 1);num--}
          else
           if(v === + v)
            {h = caml_hash_mix_float(h,v);num--}
           else
            if(v && v.hash && typeof v.hash === "function")
             h = caml_hash_mix_int(h,v.hash())}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_obj_tag(x)
     {return x instanceof Array?x[0]:x instanceof MlBytes?252:1000}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=jsoo_floor_log2(x) + 1;
      x *= Math.pow(2,- exp);
      if(x < 0.5){x *= 2;exp -= 1}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function bigstring_blit_bytes_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1(v_bstr,v_dst_pos + i,caml_bytes_get(v_str,v_src_pos + i));
      return 0}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_ba_set_generic(ba,index,v)
     {return ba.set(caml_js_from_array(index),v)}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_ml_pos_out_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_string_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      bits = x < y == x > 0?caml_int64_add(bits,one):caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y)
     {return [255,x[1] & y[1],x[2] & y[2],x[3] & y[3]]}
    function caml_sys_const_word_size(){return 32}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var dims=[];
      for(var i=0;i < ba.num_dims;i++)dims[i] = ba.nth_dim(i);
      return caml_ba_create_from
              (ba.data,ba.data2,ba.data_type,ba.kind,layout,dims)}
    function caml_input_value_from_bytes(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")return caml_new_string("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_js_from_string(s){return s.toString()}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_ba_sub(ba,ofs,len){return ba.sub(ofs,len)}
    function caml_gc_full_major(){return 0}
    function caml_int64_is_minus_one(x)
     {return x[3] == 0xffff && (x[1] & x[2]) == 0xffffff}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      caml_string_unsafe_set(s,i + 2,b3);
      caml_string_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_runtime_variant(_unit){return caml_new_string("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_ba_uint8_set32(ba,i0,v)
     {ba.set1(i0,v & 0xff);
      ba.set1(i0 + 1,v >>> 8 & 0xff);
      ba.set1(i0 + 2,v >>> 16 & 0xff);
      ba.set1(i0 + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_channels[chanid].offset = pos;return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function(){f.apply(null,raw_array_cons(arguments,this))}}
    function caml_ba_dim_3(ba){return ba.nth_dim(2)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_int64_or(x,y)
     {return [255,x[1] | y[1],x[2] | y[2],x[3] | y[3]]}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_lazy_make_forward(v){return [250,v]}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_ba_layout(ba){return ba.layout}
    var
     caml_md5_string=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(buf,0,len)}
    function caml_int64_shift_right(x,s)
     {s = s & 63;
      if(s == 0)return x;
      var h=x[3] << 16 >> 16;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | h << 24 - s) & 0xffffff,
               x[3] << 16 >> s >>> 16];
      var sign=x[3] << 16 >> 31;
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] << 16 >> s - 24 >> 16 & 0xffffff,
               sign & 0xffff];
      return [255,
              x[3] << 16 >> s - 32 & 0xffffff,
              sign & 0xffffff,
              sign & 0xffff]}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape)
        {case 0:real.fun = x;break;case 1:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_string_of_bytes(s){return s}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_int64_is_min_int(x)
     {return x[3] == 0x8000 && (x[1] | x[2]) == 0}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_js_to_string("nan");
        return caml_js_to_string(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_js_to_string
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,raw_array_cons(arguments,this));
        var args=new Array(arity + 1);
        args[0] = this;
        for(var i=1;i < n && i <= arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,init){ba.fill(init);return 0}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_output_value_to_bytes(v,_fl)
     {return caml_string_of_array(caml_output_val(v))}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
            break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(obj instanceof MlBytes)
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(obj === (obj | 0))
           {count--;hash_accu = hash_accu * 65599 + obj | 0}
          else
           if(obj === + obj)
            {count--;
             var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
             for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
           else
            if(obj && obj.hash && typeof obj.hash === "function")
             hash_accu = hash_accu * 65599 + obj.hash() | 0}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          state
          =
          n1
           !=
           0
           &&
           n2
           >=
           0
           &&
           n2
           <=
           tables[tbl_tablesize]
           &&
           tables.check[n2]
           ==
           state1
           ?tables.table[n2]
           :tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function raw_array_copy(a)
     {var l=a.length,b=new Array(l);
      for(var i=0;i < l;i++)b[i] = a[i];
      return b}
    function caml_output_value_to_buffer(s,ofs,len,v,_fl)
     {var t=caml_output_val(v);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_blit_string(s1,i1,s2,i2,len)
     {return caml_blit_bytes(s1,i1,s2,i2,len)}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_int64_xor(x,y)
     {return [255,x[1] ^ y[1],x[2] ^ y[2],x[3] ^ y[3]]}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_read_file_content(name)
     {var root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return buf}
      caml_raise_no_such_file(name)}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_js_to_float(x){return x}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_ba_dim(ba,dim){return ba.nth_dim(dim)}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_find:bigstring_find,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     bigstring_blit_bigstring_string_stub:bigstring_blit_bigstring_string_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_destroy_stub:bigstring_destroy_stub,
     bigstring_alloc:bigstring_alloc,
     caml_json:caml_json,
     JSON:JSON,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_from_string:caml_js_from_string,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_is_js:caml_is_js,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_exit:caml_sys_exit,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_get_public_method:caml_get_public_method,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_time:caml_sys_time,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_string_arr:caml_hash_mix_string_arr,
     caml_hash_mix_string_str:caml_hash_mix_string_str,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_format_float:caml_format_float,
     caml_format_int:caml_format_int,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_is_printable:caml_is_printable,
     caml_float_of_string:caml_float_of_string,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_failwith:caml_failwith,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     raw_array_append_one:raw_array_append_one,
     raw_array_cons:raw_array_cons,
     raw_array_copy:raw_array_copy,
     raw_array_sub:raw_array_sub,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_views:caml_ba_views,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init_views:caml_ba_init_views,
     caml_ba_init:caml_ba_init,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlBytesReader:MlBytesReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_udivmod:caml_int64_udivmod,
     caml_int64_lsr1:caml_int64_lsr1,
     caml_int64_lsl1:caml_int64_lsl1,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_minus_one:caml_int64_is_minus_one,
     caml_int64_is_min_int:caml_int64_is_min_int,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     caml_int64_ucompare:caml_int64_ucompare,
     caml_int64_offset:caml_int64_offset,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_ml_string_length:caml_ml_string_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_lessthan:caml_string_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_string_lessequal:caml_string_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_equal:caml_string_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_string_compare:caml_string_compare,
     caml_string_of_array:caml_string_of_array,
     caml_new_string:caml_new_string,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_js_to_string:caml_js_to_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_array_of_string:caml_array_of_string,
     caml_convert_string_to_array:caml_convert_string_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_string_bound_error:caml_string_bound_error,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_to_js_string:caml_to_js_string,
     caml_is_ascii:caml_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_string:caml_subarray_to_string,
     caml_str_repeat:caml_str_repeat};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_new_string("Out_of_memory"),0],"Out_of_memory");
    caml_register_global(1,[248,caml_new_string("Sys_error"),-1],"Sys_error");
    caml_register_global(2,[248,caml_new_string("Failure"),-2],"Failure");
    caml_register_global
     (3,[248,caml_new_string("Invalid_argument"),-3],"Invalid_argument");
    caml_register_global
     (4,[248,caml_new_string("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,[248,caml_new_string("Division_by_zero"),-5],"Division_by_zero");
    caml_register_global(6,[248,caml_new_string("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_new_string("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_new_string("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_new_string("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_new_string("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_new_string("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_input_int=runtime.caml_ml_input_int,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_output_int=runtime.caml_ml_output_int,
     caml_ml_pos_in=runtime.caml_ml_pos_in,
     caml_ml_pos_out=runtime.caml_ml_pos_out,
     caml_ml_seek_in=runtime.caml_ml_seek_in,
     caml_ml_seek_out=runtime.caml_ml_seek_out,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_weak_blit=runtime.caml_weak_blit,
     caml_weak_check=runtime.caml_weak_check,
     caml_weak_create=runtime.caml_weak_create,
     caml_weak_get=runtime.caml_weak_get,
     caml_weak_get_copy=runtime.caml_weak_get_copy,
     caml_weak_set=runtime.caml_weak_set,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Stdlib_Pervasives_Exit=caml_new_string("Stdlib.Pervasives.Exit"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_new_string("Stdlib.Sys.Break"),
     ocaml_version=caml_new_string("4.07.0"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst_Bytes_of_seq_cannot_grow_bytes=
      caml_new_string("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst_Sort_array=caml_new_string("Sort.array"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Stdlib_Array_Bottom=caml_new_string("Stdlib.Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$0=[255,0,0,0],
     one$0=[255,1,0,0],
     minus_one$0=[255,16777215,16777215,65535],
     min_int$1=[255,0,0,32768],
     max_int$1=[255,16777215,16777215,32767],
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_new_string("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_new_string("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_new_string("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_new_string("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$5=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$6=caml_new_string(", "),
     cst$7=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_new_string("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_new_string("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$20=caml_new_string("%{"),
     cst$21=caml_new_string("%}"),
     cst$22=caml_new_string("%("),
     cst$23=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$24=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$28=caml_new_string("@{"),
     cst$29=caml_new_string("@["),
     cst$30=caml_new_string("@{"),
     cst$31=caml_new_string("@["),
     cst$32=caml_new_string("@{"),
     cst$33=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$38=caml_new_string("'*'"),
     cst$36=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$37=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$39=caml_new_string("'+'"),
     cst$40=caml_new_string("'#'"),
     cst$41=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$42=caml_new_string("'+'"),
     cst$43=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$47=caml_new_string("'#'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("'+'"),
     cst$44=caml_new_string("' '"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("'+'"),
     cst$48=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$34=caml_new_string(""),
     cst$35=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$27=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd=caml_new_string("%nd"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nu=caml_new_string("%nu"),
     cst_ld=caml_new_string("%ld"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$0=caml_new_string("%li"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$2=caml_new_string("%d"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$0=caml_new_string("%i"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_u=caml_new_string("%u"),
     cst$25=caml_new_string("%!"),
     cst$26=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$19=caml_new_string("%%"),
     cst$11=caml_new_string("@]"),
     cst$12=caml_new_string("@}"),
     cst$13=caml_new_string("@?"),
     cst$14=caml_new_string("@\n"),
     cst$15=caml_new_string("@."),
     cst$16=caml_new_string("@@"),
     cst$17=caml_new_string("@%"),
     cst$18=caml_new_string("@"),
     cst$10=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_new_string(""),
     cst$59=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$55=caml_new_string(""),
     cst$56=caml_new_string(" "),
     cst$57=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$54=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$51=caml_new_string("}"),
     cst$52=caml_new_string("|"),
     cst$53=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Stdlib_Arg_Bad=caml_new_string("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_new_string("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_new_string("Stdlib.Arg.Stop"),
     cst$61=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$64=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$62=caml_new_string(""),
     cst$63=caml_new_string(""),
     cst$60=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$65=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst$71=caml_new_string("."),
     cst$69=caml_new_string(">"),
     cst$70=caml_new_string("</"),
     cst$67=caml_new_string(">"),
     cst$68=caml_new_string("<"),
     cst$66=caml_new_string("\n"),
     cst_Stdlib_Format_Empty_queue=
      caml_new_string("Stdlib.Format.Empty_queue"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$75=caml_new_string('"'),
     cst$76=caml_new_string('"'),
     cst$74=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$2=caml_new_string("false"),
     cst_true$2=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$73=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Pervasives_input_channel=
      caml_new_string("unnamed Pervasives input channel"),
     cst$72=caml_new_string("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_new_string("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$77=caml_new_string(""),
     cst$78=caml_new_string(""),
     cst$79=caml_new_string(""),
     cst$80=caml_new_string(""),
     cst$81=caml_new_string(""),
     cst$83=caml_new_string(""),
     cst$82=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$94=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$93=caml_new_string(""),
     cst$91=caml_new_string("./"),
     cst$90=caml_new_string(".\\"),
     cst$89=caml_new_string("../"),
     cst$88=caml_new_string("..\\"),
     cst$87=caml_new_string("./"),
     cst$86=caml_new_string("../"),
     cst$85=caml_new_string(""),
     cst$84=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$92=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$2=[254,0.,0.],
     one$2=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     cst_Bigarray_array3_of_genarray=
      caml_new_string("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarray=
      caml_new_string("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarray=
      caml_new_string("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarray=
      caml_new_string("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_non_cubic_data=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_non_cubic_data$0=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_non_rectangular_data=
      caml_new_string("Bigarray.Array2.of_array: non-rectangular data"),
     End_of_file=global_data.End_of_file,
     Sys_error=global_data.Sys_error,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Match_failure=global_data.Match_failure,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _m_=[0,0,[0,6,0]],
     _l_=[0,0,[0,7,0]],
     _k_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _j_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _h_=[0,1],
     _i_=[0,0],
     _a_=[255,0,0,32752],
     _b_=[255,0,0,65520],
     _c_=[255,1,0,32752],
     _d_=[255,16777215,16777215,32751],
     _e_=[255,0,0,16],
     _f_=[255,0,0,15536],
     _t_=[0,0,0],
     _u_=[0,caml_new_string("list.ml"),268,11],
     _J_=[0,caml_new_string("array.ml"),233,4],
     _N_=[255,16777215,16777215,65535],
     _M_=[255,0,0,0],
     _L_=[255,1,0,0],
     _K_=[255,1,0,0],
     _O_=[0,0,0,0],
     _P_=[0,0,0],
     _Q_=[0,caml_new_string("set.ml"),514,18],
     _R_=[0,0,0,0],
     _S_=[0,caml_new_string("map.ml"),397,10],
     _T_=[0,0,0],
     _U_=[0,caml_new_string("stream.ml"),53,12],
     _V_=[0,0],
     _W_=[0,caml_new_string("stream.ml"),82,12],
     _ab_=[0,caml_new_string("buffer.ml"),205,9],
     _aa_=[0,caml_new_string("buffer.ml"),141,19],
     _$_=[0,caml_new_string("buffer.ml"),159,8],
     ___=[0,caml_new_string("buffer.ml"),120,19],
     _Z_=[0,caml_new_string("buffer.ml"),138,8],
     _Y_=[0,caml_new_string("buffer.ml"),84,19],
     _X_=[0,caml_new_string("buffer.ml"),117,8],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _at_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _au_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _av_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _aw_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _a0_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aZ_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aC_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aD_=[0,1,0],
     _aE_=[0,0],
     _aG_=[1,0],
     _aF_=[1,1],
     _aI_=[1,1],
     _aH_=[1,1],
     _aM_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aJ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aK_=[0,0],
     _aL_=[0,0],
     _aN_=[0,[12,64,0]],
     _aO_=[0,caml_new_string("@ "),1,0],
     _aP_=[0,caml_new_string("@,"),0,0],
     _aQ_=[2,60],
     _aR_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aS_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aT_=[0,caml_new_string("camlinternalFormat.ml"),2811,11],
     _aU_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aV_=[0,caml_new_string("camlinternalFormat.ml"),2873,34],
     _aW_=[0,caml_new_string("camlinternalFormat.ml"),2906,28],
     _aX_=[0,caml_new_string("camlinternalFormat.ml"),2940,25],
     _aY_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aB_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _aA_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _az_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _ay_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _ax_=[0,0,4],
     _bk_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _be_=[0,[2,0,0],caml_new_string("%s")],
     _bf_=[0,[2,0,0],caml_new_string("%s")],
     _bc_=[0,[2,0,0],caml_new_string("%s")],
     _bd_=[0,[2,0,0],caml_new_string("%s")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _a6_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a$_=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a7_=[0,caml_new_string("-help")],
     _a8_=[0,caml_new_string("--help")],
     _a5_=[0,[2,0,0],caml_new_string("%s")],
     _a4_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _a3_=[0,caml_new_string("-help")],
     _a1_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _a2_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bp_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _by_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bw_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bx_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bu_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _bv_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _bt_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bs_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bq_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _br_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bo_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bn_=[0,[3,0,0],caml_new_string("%S")],
     _bH_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bI_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bJ_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bK_=[0,[12,10,0],caml_new_string("\n")],
     _bL_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bM_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bN_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bO_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bP_=[0,[12,10,0],caml_new_string("\n")],
     _bQ_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bR_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bW_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bX_=[0,[12,10,0],caml_new_string("\n")],
     _bY_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _b0_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _b3_=[255,1,0,0],
     _b4_=[255,0,0,0],
     _b5_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b9_=[0,0],
     _b8_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b$_=[3,0,3],
     _b__=[0,caml_new_string("")],
     _cr_=[0,91],
     _cq_=[0,123],
     _cs_=[0,caml_new_string("scanf.ml"),1455,13],
     _ct_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cp_=[0,37,caml_new_string("")],
     _co_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _cn_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cm_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _cl_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ck_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cj_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _ci_=[0,caml_new_string("scanf.ml"),555,9],
     _ch_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _cg_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _cf_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _ce_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _cd_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cA_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _cz_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cy_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cx_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _cw_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cv_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cD_=[0,0],
     _cC_=[0,0],
     _cB_=[0,0],
     _cH_=[0,7,0],
     _cG_=[0,1,[0,3,[0,5,0]]],
     _cF_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cI_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (646,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function _g_(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_h_
              :_i_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _y9_=[0,caml_int_of_string(s)];return _y9_}
      catch(_y__)
       {_y__ = caml_wrap_exception(_y__);
        if(_y__[1] === Failure)return 0;
        throw _y__}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return _g_(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function string_of_float(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function float_of_string_opt(s)
     {try
       {var _y7_=[0,caml_float_of_string(s)];return _y7_}
      catch(_y8_)
       {_y8_ = caml_wrap_exception(_y8_);
        if(_y8_[1] === Failure)return 0;
        throw _y8_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_j_,438,name)}
    function open_out_bin(name){return open_out_gen(_k_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_y6_)
             {_y6_ = caml_wrap_exception(_y6_);
              if(_y6_[1] !== Sys_error)throw _y6_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_y5_){}
      try
       {var _y3_=caml_ml_close_channel(oc);return _y3_}
      catch(_y4_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_l_,0,name)}
    function open_in_bin(name){return open_in_gen(_m_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _y2_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _y2_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _y2_=res}
        return caml_string_of_bytes(_y2_)}}
    function close_in_noerr(ic)
     {try
       {var _y0_=caml_ml_close_channel(ic);return _y0_}
      catch(_y1_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,string_of_float(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,string_of_float(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return float_of_string_opt(read_line(0))}
    var LargeFile=[0];
    function string_of_format(param){var str=param[2];return str}
    function _n_(param,_yY_)
     {var
       str2=_yY_[2],
       fmt2=_yY_[1],
       str1=param[2],
       fmt1=param[1],
       _yZ_=_g_(str1,_g_(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_yZ_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     _o_=
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       caml_ml_output_int,
       output_value,
       caml_ml_seek_out,
       caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       caml_ml_input_int,
       caml_input_value,
       caml_ml_seek_in,
       caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit],
     Stdlib=
      [0,
       _o_,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       caml_ml_output_int,
       output_value,
       caml_ml_seek_out,
       caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       caml_ml_input_int,
       caml_input_value,
       caml_ml_seek_in,
       caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       LargeFile,
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    caml_register_global(651,Stdlib,"Stdlib");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _yW_=function(_yX_){return map(f,next,_yX_)};
        return [0,caml_call1(f,x),_yW_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_yV_){return filter_map(f,next,_yV_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_yU_){return filter(f,next,_yU_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_yT_=caml_call1(f,x),_yS_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_yT_,next,_yS_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_yT_,next,_yS_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_yR_){return flat_map_app(f,next,tail,_yR_)}]}
      var _yQ_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_yQ_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_yQ_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    var
     Stdlib_seq=
      [0,empty,return$0,map,filter,filter_map,flat_map,fold_left,iter];
    caml_register_global(652,Stdlib_seq,"Stdlib__seq");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare(c1,c2){return c1 - c2 | 0}
    function equal(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
    caml_register_global(653,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _yM_=0 <= i?1:0,_yN_=_yM_?i <= 55295?1:0:_yM_;
      if(_yN_)
       var _yO_=_yN_;
      else
       var _yP_=57344 <= i?1:0,_yO_=_yP_?i <= 1114111?1:0:_yP_;
      return _yO_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (_g_
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (_g_
                  (cst_U,
                   _g_
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_yL_){return _yL_}
    function equal$0(_yK_,_yJ_){return _yK_ === _yJ_?1:0}
    var compare$0=caml_int_compare;
    function hash(_yI_){return _yI_}
    function _p_(_yH_){return _yH_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_yG_){return _yG_},
       _p_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$0,
       compare$0,
       hash];
    caml_register_global(654,Stdlib_uchar,"Stdlib__uchar");
    var
     match=runtime.caml_sys_get_argv(0),
     _q_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     match$1=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _r_=match[1],
     big_endian=0,
     size=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _yE_=[0,caml_sys_getenv(s)];return _yE_}
      catch(_yF_)
       {_yF_ = caml_wrap_exception(_yF_);
        if(_yF_ === Not_found)return 0;
        throw _yF_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Stdlib_sys=
      [0,
       _q_,
       _r_,
       getenv_opt,
       interactive,
       os_type,
       match$1,
       unix,
       win32,
       cygwin,
       size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(656,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$1 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$0(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$0(f,l)]}
      return 0}
    function _s_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_s_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _s_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yD_=caml_call1(p,a);
          if(_yD_){var param$0=l;continue}
          return _yD_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yC_=caml_call1(p,a);
          if(_yC_)return _yC_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _yB_=caml_call2(p,a1,a2);
            if(_yB_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _yB_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _yA_=caml_call2(p,a1,a2);
            if(_yA_)return _yA_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yz_=0 === caml_compare(a,x)?1:0;
          if(_yz_)return _yz_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yy_=a === x?1:0;
          if(_yy_)return _yy_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _yx_=0 === caml_compare(a,x)?1:0;
          if(_yx_)return _yx_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_yw_=a === x?1:0;
          if(_yw_)return _yw_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _yv_=rev(no);
        return [0,rev(yes),_yv_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _t_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_u_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _ys_=l[2];
            if(_ys_)
             {var x2=_ys_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yt_=l[2];
            if(_yt_)
             {var _yu_=_yt_[2];
              if(_yu_)
               {var x3=_yu_[1],x2$0=_yt_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _yp_=l[2];
            if(_yp_)
             {var x2=_yp_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yq_=l[2];
            if(_yq_)
             {var _yr_=_yq_[2];
              if(_yr_)
               {var x3=_yr_[1],x2$0=_yq_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _ym_=l[2];
            if(_ym_)
             {var x2=_ym_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yn_=l[2];
            if(_yn_)
             {var _yo_=_yn_[2];
              if(_yo_)
               {var
                 x3=_yo_[1],
                 x2$0=_yn_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _yj_=l[2];
            if(_yj_)
             {var x2=_yj_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yk_=l[2];
            if(_yk_)
             {var _yl_=_yk_[2];
              if(_yl_)
               {var
                 x3=_yl_[1],
                 x2$0=_yk_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_yi_){return aux(tail,_yi_)}]}
        return 0}
      return function(_yh_){return aux(l,_yh_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _yg_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_yg_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$0,
       iteri,
       map$0,
       mapi,
       rev_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
    caml_register_global(658,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_ye_=n - 1 | 0,_yd_=0;
      if(! (_ye_ < 0))
       {var i=_yd_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _yf_=i + 1 | 0;
          if(_ye_ !== i){var i=_yf_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function _v_(a,b)
     {var
       c=a + b | 0,
       _yc_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _yc_?0 === match?0:1:0
         :0 === _yc_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=_v_(_v_(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$1(f,a)
     {var _ya_=caml_ml_bytes_length(a) - 1 | 0,_x$_=0;
      if(! (_ya_ < 0))
       {var i=_x$_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _yb_=i + 1 | 0;
          if(_ya_ !== i){var i=_yb_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _x9_=caml_ml_bytes_length(a) - 1 | 0,_x8_=0;
      if(! (_x9_ < 0))
       {var i=_x8_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _x__=i + 1 | 0;
          if(_x9_ !== i){var i=_x__;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _x3_=param[2],_x4_=param[1];
            if(_x3_)
             {var
               x=(caml_ml_bytes_length(_x4_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_x3_;
              continue}
            var _x7_=caml_ml_bytes_length(_x4_) + acc | 0}
          else
           var _x7_=acc;
          var dst=caml_create_bytes(_x7_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _x5_=param$0[2],_x6_=param$0[1];
              if(_x5_)
               {caml_blit_bytes(_x6_,0,dst,pos,caml_ml_bytes_length(_x6_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_x6_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_x6_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_x5_;
                continue}
              caml_blit_bytes(_x6_,0,dst,pos,caml_ml_bytes_length(_x6_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _x2_=param - 9 | 0,
       switch$0=4 < _x2_ >>> 0?23 === _x2_?1:0:2 === _x2_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_xV_=caml_ml_bytes_length(s) - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i$0=_xU_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _xZ_=match - 34 | 0;
            if(58 < _xZ_ >>> 0)
             if(93 <= _xZ_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_xZ_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _x0_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _x0_=4;break;case 1:var _x0_=2;break}
          n[1] = n[1] + _x0_ | 0;
          var _x1_=i$0 + 1 | 0;
          if(_xV_ !== i$0){var i$0=_x1_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _xX_=caml_ml_bytes_length(s) - 1 | 0,_xW_=0;
      if(! (_xX_ < 0))
       {var i=_xW_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _xY_=i + 1 | 0;
          if(_xX_ !== i){var i=_xY_;continue}
          break}}
      return s$0}
    function map$1(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_xS_=l - 1 | 0,_xR_=0;
      if(! (_xS_ < 0))
       {var i=_xR_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_xP_=l - 1 | 0,_xO_=0;
      if(! (_xP_ < 0))
       {var i=_xO_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$1(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$1(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _xM_=1;return _xM_}
        catch(_xN_)
         {_xN_ = caml_wrap_exception(_xN_);
          if(_xN_ === Not_found)return 0;
          throw _xN_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _xK_=1;return _xK_}
        catch(_xL_)
         {_xL_ = caml_wrap_exception(_xL_);
          if(_xL_ === Not_found)return 0;
          throw _xL_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$1=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$1(uppercase,s)}
    function lowercase$0(s){return map$1(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$0(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_xI_=i + 1 | 0;
        return [0,x,function(_xJ_){return aux(_xI_,_xJ_)}]}
      var _xG_=0;
      return function(_xH_){return aux(_xG_,_xH_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_xE_=i + 1 | 0;
        return [0,[0,i,x],function(_xF_){return aux(_xE_,_xF_)}]}
      var _xC_=0;
      return function(_xD_){return aux(_xC_,_xD_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_bytes);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    var
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$1=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$1,
       iteri$0,
       map$1,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$0,
       to_seqi,
       of_seq$0];
    caml_register_global(659,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _xx_=param[2],_xy_=param[1];
            if(_xx_)
             {var
               x=(caml_ml_string_length(_xy_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_xx_;
              continue}
            var _xB_=caml_ml_string_length(_xy_) + acc | 0}
          else
           var _xB_=acc;
          var dst=caml_create_bytes(_xB_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _xz_=param$0[2],_xA_=param$0[1];
              if(_xz_)
               {caml_blit_string(_xA_,0,dst,pos,caml_ml_string_length(_xA_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_xA_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_xA_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_xz_;
                continue}
              caml_blit_string(_xA_,0,dst,pos,caml_ml_string_length(_xA_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$2(f,s)
     {var _xv_=caml_ml_string_length(s) - 1 | 0,_xu_=0;
      if(! (_xv_ < 0))
       {var i=_xu_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _xw_=i + 1 | 0;
          if(_xv_ !== i){var i=_xw_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _xs_=caml_ml_string_length(s) - 1 | 0,_xr_=0;
      if(! (_xs_ < 0))
       {var i=_xr_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _xt_=i + 1 | 0;
          if(_xs_ !== i){var i=_xt_;continue}
          break}}
      return 0}
    function map$2(f,s)
     {return caml_string_of_bytes(map$1(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var
       _xq_=param - 9 | 0,
       switch$0=4 < _xq_ >>> 0?23 === _xq_?1:0:2 === _xq_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_string_unsafe_get(s,0)))
       if
        (!
         is_space$0
          (caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var
         match=caml_string_unsafe_get(s,i),
         _xp_=match - 32 | 0,
         switch$0=
          59 < _xp_ >>> 0?33 < (_xp_ - 61 | 0) >>> 0?1:0:2 === _xp_?1:0;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _xn_=1;return _xn_}
        catch(_xo_)
         {_xo_ = caml_wrap_exception(_xo_);
          if(_xo_ === Not_found)return 0;
          throw _xo_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _xl_=1;return _xl_}
        catch(_xm_)
         {_xm_ = caml_wrap_exception(_xm_);
          if(_xm_ === Not_found)return 0;
          throw _xm_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    var compare$2=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _xh_=caml_ml_string_length(s) - 1 | 0;
      if(! (_xh_ < 0))
       {var i=_xh_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _xj_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_xj_];
            j[1] = i}
          var _xk_=i - 1 | 0;
          if(0 !== i){var i=_xk_;continue}
          break}}
      var _xi_=r[1];
      return [0,sub$0(s,0,j[1]),_xi_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$1(s){return to_seq$0(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$2=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$2,
       iteri$1,
       map$2,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char,
       to_seq$1,
       to_seqi$0,
       of_seq$1];
    caml_register_global(660,include$1,"Stdlib__string");
    function merge$0(order,l1,l2)
     {if(l1)
       {var t1=l1[2],h1=l1[1];
        if(l2)
         {var t2=l2[2],h2=l2[1];
          return caml_call2(order,h1,h2)
                  ?[0,h1,merge$0(order,t1,l2)]
                  :[0,h2,merge$0(order,l1,t2)]}
        return l1}
      return l2}
    function list(order,l)
     {function initlist(param)
       {if(param)
         {var _xd_=param[2],_xe_=param[1];
          if(_xd_)
           {var
             rest=_xd_[2],
             e2=_xd_[1],
             _xf_=initlist(rest),
             _xg_=
              caml_call2(order,_xe_,e2)?[0,_xe_,[0,e2,0]]:[0,e2,[0,_xe_,0]];
            return [0,_xg_,_xf_]}
          return [0,[0,_xe_,0],0]}
        return 0}
      function merge2(x)
       {if(x)
         {var _xb_=x[2];
          if(_xb_)
           {var rest=_xb_[2],l2=_xb_[1],l1=x[1],_xc_=merge2(rest);
            return [0,merge$0(order,l1,l2),_xc_]}}
        return x}
      var llist$1=initlist(l),llist=llist$1;
      for(;;)
       {if(llist)
         {if(llist[2]){var llist$0=merge2(llist),llist=llist$0;continue}
          var l$0=llist[1];
          return l$0}
        return 0}}
    function swap(arr,i,j)
     {var tmp=arr[i + 1];arr[i + 1] = arr[j + 1];return arr[j + 1] = tmp}
    function array(cmp,arr)
     {function qsort(lo,hi)
       {var lo$0=lo,hi$0=hi;
        a:
        for(;;)
         {var _w__=6 <= (hi$0 - lo$0 | 0)?1:0;
          if(_w__)
           {var mid=(lo$0 + hi$0 | 0) >>> 1 | 0;
            if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0);
            if(caml_call2(cmp,arr[hi$0 + 1],arr[mid + 1]))
             {swap(arr,mid,hi$0);
              if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0)}
            var
             pivot=arr[mid + 1],
             i=[0,lo$0 + 1 | 0],
             j=[0,hi$0 - 1 | 0],
             _w$_=1 - caml_call2(cmp,pivot,arr[hi$0 + 1]),
             _xa_=_w$_ || 1 - caml_call2(cmp,arr[lo$0 + 1],pivot);
            if(_xa_)throw [0,Invalid_argument,cst_Sort_array];
            b:
            for(;;)
             {if(i[1] < j[1])
               for(;;)
                {if(caml_call2(cmp,pivot,arr[i[1] + 1]))
                  for(;;)
                   {if(caml_call2(cmp,arr[j[1] + 1],pivot))
                     {if(i[1] < j[1])swap(arr,i[1],j[1]);
                      i[1]++;
                      j[1] += -1;
                      continue b}
                    j[1] += -1;
                    continue}
                 i[1]++;
                 continue}
              if((j[1] - lo$0 | 0) <= (hi$0 - i[1] | 0))
               {qsort(lo$0,j[1]);var lo$1=i[1],lo$0=lo$1;continue a}
              qsort(i[1],hi$0);
              var hi$1=j[1],hi$0=hi$1;
              continue a}}
          return _w__}}
      qsort(0,arr.length - 1 - 1 | 0);
      var _w8_=arr.length - 1 - 1 | 0,_w7_=1;
      if(! (_w8_ < 1))
       {var i=_w7_;
        for(;;)
         {var val_i=arr[i + 1];
          if(1 - caml_call2(cmp,arr[(i - 1 | 0) + 1],val_i))
           {arr[i + 1] = arr[(i - 1 | 0) + 1];
            var j=[0,i - 1 | 0];
            for(;;)
             {if(1 <= j[1])
               if(! caml_call2(cmp,arr[(j[1] - 1 | 0) + 1],val_i))
                {arr[j[1] + 1] = arr[(j[1] - 1 | 0) + 1];j[1] += -1;continue}
              arr[j[1] + 1] = val_i;
              break}}
          var _w9_=i + 1 | 0;
          if(_w8_ !== i){var i=_w9_;continue}
          break}}
      return 0}
    var Stdlib_sort=[0,list,array,merge$0];
    caml_register_global(661,Stdlib_sort,"Stdlib__sort");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(662,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var
     double_field=runtime.caml_array_get,
     set_double_field=runtime.caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _w6_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_w6_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function extension_constructor(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function extension_name(slot){return slot[1]}
    function extension_id(slot){return slot[2]}
    function length$0(x){return x.length - 1 - 2 | 0}
    var _w_=runtime.caml_ephe_blit_data,_x_=runtime.caml_ephe_check_data;
    function _y_(_w5_){return runtime.caml_ephe_unset_data(_w5_)}
    var
     _z_=runtime.caml_ephe_set_data,
     _A_=runtime.caml_ephe_get_data_copy,
     _B_=runtime.caml_ephe_get_data;
    function _C_(_w4_,_w3_,_w2_,_w1_,_w0_)
     {return runtime.caml_ephe_blit_key(_w4_,_w3_,_w2_,_w1_,_w0_)}
    function _D_(_wZ_,_wY_){return runtime.caml_ephe_check_key(_wZ_,_wY_)}
    var _E_=runtime.caml_ephe_unset_key,_F_=runtime.caml_ephe_set_key;
    function _G_(_wX_,_wW_){return runtime.caml_ephe_get_key_copy(_wX_,_wW_)}
    function _H_(_wV_,_wU_){return runtime.caml_ephe_get_key(_wV_,_wU_)}
    var
     _I_=
      [0,
       function(_wT_){return runtime.caml_ephe_create(_wT_)},
       length$0,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _I_];
    caml_register_global(663,Stdlib_obj,"Stdlib__obj");
    var
     infinity$0=_o_[10],
     neg_infinity$0=_o_[11],
     nan$0=_o_[12],
     max_float$0=_o_[13],
     min_float$0=_o_[14],
     epsilon=_o_[15],
     of_string_opt=_o_[24],
     to_string$0=_o_[23],
     pi=3.14159265358979312;
    function equal$3(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function hash$0(x){return caml_hash(10,100,0,x)}
    var
     Array=[0],
     Stdlib_float=
      [0,
       infinity$0,
       neg_infinity$0,
       nan$0,
       pi,
       max_float$0,
       min_float$0,
       epsilon,
       of_string_opt,
       to_string$0,
       caml_float_compare,
       equal$3,
       hash$0,
       Array];
    caml_register_global(664,Stdlib_float,"Stdlib__float");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_wR_=l - 1 | 0,_wQ_=1;
        if(! (_wR_ < 1))
         {var i=_wQ_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _wS_=i + 1 | 0;
            if(_wR_ !== i){var i=_wS_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_wO_=sx - 1 | 0,_wN_=0;
      if(! (_wO_ < 0))
       {var x=_wN_;
        for(;;)
         {res[x + 1] = caml_make_vect(sy,init);
          var _wP_=x + 1 | 0;
          if(_wO_ !== x){var x=_wP_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _wL_=(ofs + len | 0) - 1 | 0;
          if(! (_wL_ < ofs))
           {var i=ofs;
            for(;;)
             {a[i + 1] = v;
              var _wM_=i + 1 | 0;
              if(_wL_ !== i){var i=_wM_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$3(f,a)
     {var _wJ_=a.length - 1 - 1 | 0,_wI_=0;
      if(! (_wJ_ < 0))
       {var i=_wI_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _wK_=i + 1 | 0;
          if(_wJ_ !== i){var i=_wK_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _wG_=a.length - 1 - 1 | 0,_wF_=0;
      if(! (_wG_ < 0))
       {var i=_wF_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _wH_=i + 1 | 0;
          if(_wG_ !== i){var i=_wH_;continue}
          break}}
      return 0}
    function map$3(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_wD_=l - 1 | 0,_wC_=1;
      if(! (_wD_ < 1))
       {var i=_wC_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _wE_=i + 1 | 0;
          if(_wD_ !== i){var i=_wE_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_wA_=la - 1 | 0,_wz_=1;
      if(! (_wA_ < 1))
       {var i=_wz_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _wB_=i + 1 | 0;
          if(_wA_ !== i){var i=_wB_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _wx_=a.length - 1 - 1 | 0,_ww_=0;
      if(! (_wx_ < 0))
       {var i=_ww_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _wy_=i + 1 | 0;
          if(_wx_ !== i){var i=_wy_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_wu_=l - 1 | 0,_wt_=1;
      if(! (_wu_ < 1))
       {var i=_wt_;
        for(;;)
         {r[i + 1] = caml_call2(f,i,a[i + 1]);
          var _wv_=i + 1 | 0;
          if(_wu_ !== i){var i=_wv_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[i + 1],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_wr_=a.length - 1 - 1 | 0,_wq_=0;
      if(! (_wr_ < 0))
       {var i=_wq_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _ws_=i + 1 | 0;
          if(_wr_ !== i){var i=_ws_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_wo_=a.length - 1 - 1 | 0;
      if(! (_wo_ < 0))
       {var i=_wo_;
        for(;;)
         {r[1] = caml_call2(f,a[i + 1],r[1]);
          var _wp_=i - 1 | 0;
          if(0 !== i){var i=_wp_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[i + 1]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[i + 1])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[i + 1])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _wh_=i31 + 1 | 0,_wi_=caml_check_bound(a,_wh_)[_wh_ + 1];
          if(caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_wi_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _wj_=i31 + 2 | 0,
           _wk_=caml_check_bound(a,_wj_)[_wj_ + 1],
           _wl_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_wl_)[_wl_ + 1],_wk_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _wm_=i31 + 1 | 0,_wn_=caml_check_bound(a,_wm_)[_wm_ + 1];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_wn_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[j + 1],e))
           {var _wg_=caml_check_bound(a,j)[j + 1];
            caml_check_bound(a,i$0)[i$0 + 1] = _wg_;
            var i$0=j;
            continue}
          return caml_check_bound(a,i$0)[i$0 + 1] = e}}
      function trickle(l,i,e)
       {try
         {var _wf_=trickledown(l,i,e);return _wf_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];return caml_check_bound(a,i$0)[i$0 + 1] = e}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_we_=caml_check_bound(a,i$1)[i$1 + 1];
          caml_check_bound(a,i$0)[i$0 + 1] = _we_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wd_=bubbledown(l,i);return _wd_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_v7_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_v7_ < 0))
       {var i$2=_v7_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[i$2 + 1]);
          var _wc_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wc_;continue}
          break}}
      var _v8_=l - 1 | 0;
      if(! (_v8_ < 2))
       {var i$0=_v8_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[i$0 + 1],
           _wa_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[i$0 + 1] = _wa_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_J_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[father + 1],e$0))
             caml_check_bound(a,i)[i + 1] = e$0;
            else
             {var _v6_=caml_check_bound(a,father)[father + 1];
              caml_check_bound(a,i)[i + 1] = _v6_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _wb_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wb_;continue a}
            break}
          break}}
      var _v9_=1 < l?1:0;
      if(_v9_)
       {var e=caml_check_bound(a,1)[2],_v__=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _v__;
        var _v$_=caml_check_bound(a,0)[1] = e}
      else
       var _v$_=_v9_;
      return _v$_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[src2ofs + 1],
         s1$1=caml_check_bound(a,src1ofs)[src1ofs + 1],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[d + 1] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[i2$0 + 1],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[d + 1] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[i1$0 + 1],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _vY_=len - 1 | 0,_vX_=0;
        if(! (_vY_ < 0))
         {var i=_vX_;
          a:
          for(;;)
           {var
             _vZ_=srcofs + i | 0,
             e=caml_check_bound(a,_vZ_)[_vZ_ + 1],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _v0_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_v0_)[_v0_ + 1],e))
                 {var
                   _v1_=j[1],
                   _v2_=caml_check_bound(dst,_v1_)[_v1_ + 1],
                   _v3_=j[1] + 1 | 0;
                  caml_check_bound(dst,_v3_)[_v3_ + 1] = _v2_;
                  j[1] += -1;
                  continue}}
              var _v4_=j[1] + 1 | 0;
              caml_check_bound(dst,_v4_)[_v4_ + 1] = e;
              var _v5_=i + 1 | 0;
              if(_vY_ !== i){var i=_v5_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_vV_=i + 1 | 0;
          return [0,x,function(_vW_){return aux(_vV_,_vW_)}]}
        return 0}
      var _vT_=0;
      return function(_vU_){return aux(_vT_,_vU_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_vR_=i + 1 | 0;
          return [0,[0,i,x],function(_vS_){return aux(_vR_,_vS_)}]}
        return 0}
      var _vP_=0;
      return function(_vQ_){return aux(_vP_,_vQ_)}}
    function of_seq$2(i$2)
     {var _vO_=0,l=fold_left(function(acc,x){return [0,x,acc]},_vO_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 1 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$3,
       iteri$2,
       map$3,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$2,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(665,include$2,"Stdlib__array");
    var zero=0,one=1,minus_one=-1;
    function succ$0(n){return n + 1 | 0}
    function pred$0(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$0=-2147483648,max_int$0=2147483647;
    function lognot(n){return n ^ -1}
    function to_string$1(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _vM_=[0,caml_int_of_string(s)];return _vM_}
      catch(_vN_)
       {_vN_ = caml_wrap_exception(_vN_);
        if(_vN_[1] === Failure)return 0;
        throw _vN_}}
    var compare$3=caml_int_compare;
    function equal$4(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Stdlib_int32=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       of_string_opt$0,
       to_string$1,
       compare$3,
       equal$4];
    caml_register_global(666,Stdlib_int32,"Stdlib__int32");
    function succ$1(n){return caml_int64_add(n,_K_)}
    function pred$1(n){return caml_int64_sub(n,_L_)}
    function abs$1(n)
     {return caml_greaterequal(n,_M_)?n:runtime.caml_int64_neg(n)}
    function lognot$0(n){return runtime.caml_int64_xor(n,_N_)}
    function to_string$2(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _vK_=[0,caml_int64_of_string(s)];return _vK_}
      catch(_vL_)
       {_vL_ = caml_wrap_exception(_vL_);
        if(_vL_[1] === Failure)return 0;
        throw _vL_}}
    var compare$4=caml_int64_compare;
    function equal$5(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    var
     Stdlib_int64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       of_string_opt$1,
       to_string$2,
       compare$4,
       equal$5];
    caml_register_global(667,Stdlib_int64,"Stdlib__int64");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$2(n){return n + 1 | 0}
    function pred$2(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$2=-2147483648,max_int$2=2147483647;
    function lognot$1(n){return n ^ -1}
    function to_string$3(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _vI_=[0,caml_int_of_string(s)];return _vI_}
      catch(_vJ_)
       {_vJ_ = caml_wrap_exception(_vJ_);
        if(_vJ_[1] === Failure)return 0;
        throw _vJ_}}
    var compare$5=caml_int_compare;
    function equal$6(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Stdlib_nativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$2,
       pred$2,
       abs$2,
       size,
       max_int$2,
       min_int$2,
       lognot$1,
       of_string_opt$2,
       to_string$3,
       compare$5,
       equal$6];
    caml_register_global(668,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var result=runtime.caml_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _vH_=buf[12];
        buf[12] = [0,_vH_[1],_vH_[2],_vH_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var result=runtime.caml_new_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _vG_=buf[12];
        buf[12] = [0,_vG_[1],_vG_[2],_vG_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(f)
     {var
       aux_buffer=caml_create_bytes(512),
       _vu_=[0],
       _vv_=0,
       _vw_=0,
       _vx_=0,
       _vy_=0,
       _vz_=0,
       _vA_=0,
       _vB_=0,
       _vC_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_vE_=t.length - 1 - 1 | 0,_vD_=0;
                  if(! (_vE_ < 0))
                   {var i=_vD_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[i + 1];
                      if(0 <= v)caml_check_bound(t,i)[i + 1] = v - s | 0;
                      var _vF_=i + 1 | 0;
                      if(_vE_ !== i){var i=_vF_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _vC_,
              _vB_,
              _vA_,
              _vz_,
              _vy_,
              _vx_,
              _vw_,
              _vv_,
              _vu_,
              zero_pos,
              zero_pos]}
    function from_channel(ic)
     {return from_function(function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(s)
     {var
       _vl_=[0],
       _vm_=1,
       _vn_=0,
       _vo_=0,
       _vp_=0,
       _vq_=0,
       _vr_=0,
       _vs_=caml_ml_string_length(s),
       _vt_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vt_,
              _vs_,
              _vr_,
              _vq_,
              _vp_,
              _vo_,
              _vn_,
              _vm_,
              _vl_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var lcp=lexbuf[12];
      lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
      return 0}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var _vk_=lb[12];
      lb[12] = [0,_vk_[1],_vk_[2],_vk_[3],0];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(669,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vf_=env[13],
                _vg_=
                 caml_call1(caml_check_bound(tables[1],_vf_)[_vf_ + 1],env),
                _vh_=4,
                cmd$0=_vh_,
                arg$1=_vg_}
             catch(_vj_)
              {_vj_ = caml_wrap_exception(_vj_);
               if(_vj_ !== Parse_error)throw _vj_;
               var cmd$0=5,arg$1=0}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vi_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vi_)[_vi_ + 1] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[tok + 1] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _ve_=env[11] - n | 0;return caml_check_bound(env[2],_ve_)[_ve_ + 1]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vb_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vb_)[_vb_ + 1],
           _vc_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_vc_)[_vc_ + 1];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vd_=env[11];
        return caml_check_bound(env[4],_vd_)[_vd_ + 1]}}
    function symbol_end_pos(param)
     {var _va_=env[11];return caml_check_bound(env[4],_va_)[_va_ + 1]}
    function rhs_start_pos(n)
     {var _u$_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_u$_)[_u$_ + 1]}
    function rhs_end_pos(n)
     {var _u__=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_u__)[_u__ + 1]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_u9_){return runtime.caml_set_parser_trace(_u9_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(670,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _u8_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u8_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_u3_=height(lr);
               if(_u3_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_u4_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_u4_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_u5_=height(rl);
               if(_u5_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_u6_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_u6_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _u7_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u7_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u2_=param$0[1];
               if(_u2_){var param$0=_u2_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u1_=param$0[1];
               if(_u1_){var param$0=_u1_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uZ_=param$0[3],_u0_=param$0[2];
               if(_uZ_){var param$0=_uZ_;continue}
               return _u0_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uX_=param$0[3],_uY_=param$0[2];
               if(_uX_){var param$0=_uX_;continue}
               return [0,_uY_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _uW_=param[1];
             if(_uW_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_uW_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _uV_=remove_min_elt(match);
               return join(t,min_elt(match),_uV_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _O_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _uU_=0 === c?1:0;
               if(_uU_)return _uU_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _uT_=remove_min_elt(r);return bal(l,min_elt(r),_uT_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _uR_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_uR_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _uS_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_uS_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _uN_=split(v1,match),
                _uO_=_uN_[1];
               if(0 === _uN_[2])
                {var r2=_uN_[3],_uP_=inter(r1,r2);
                 return concat(inter(l1,_uO_),_uP_)}
               var r2$0=_uN_[3],_uQ_=inter(r1,r2$0);
               return join(inter(l1,_uO_),v1,_uQ_)}
             return 0}
           return 0}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _uJ_=split(v1,match),
                _uK_=_uJ_[1];
               if(0 === _uJ_[2])
                {var r2=_uJ_[3],_uL_=diff(r1,r2);
                 return join(diff(l1,_uK_),v1,_uL_)}
               var r2$0=_uJ_[3],_uM_=diff(r1,r2$0);
               return concat(diff(l1,_uK_),_uM_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _uG_=subset(l1,l2);
                   if(_uG_){var s1$0=r1,s2$0=r2;continue}
                   return _uG_}
                 if(0 <= c)
                  {var _uH_=subset([0,0,v1,r1,0],r2);
                   if(_uH_){var s1$0=l1;continue}
                   return _uH_}
                 var _uI_=subset([0,l1,v1,0,0],l2);
                 if(_uI_){var s1$0=r1;continue}
                 return _uI_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uD_=caml_call1(p,v);
               if(_uD_)
                {var _uE_=for_all(p,l);
                 if(_uE_){var param$0=r;continue}
                 var _uF_=_uE_}
               else
                var _uF_=_uD_;
               return _uF_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uA_=caml_call1(p,v);
               if(_uA_)
                var _uB_=_uA_;
               else
                {var _uC_=exists(p,l);
                 if(! _uC_){var param$0=r;continue}
                 var _uB_=_uC_}
               return _uB_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uy_=concat(lf,rf);return [0,join(lt,v,rt),_uy_]}
             var _uz_=join(lf,v,rf);
             return [0,concat(lt,rt),_uz_]}
           return _P_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_ux_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _ux_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _uw_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_uw_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _uv_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_uv_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _uk_=l[2],_ul_=l[1];
             if(_uk_)
              {var _um_=_uk_[2],_un_=_uk_[1];
               if(_um_)
                {var _uo_=_um_[2],_up_=_um_[1];
                 if(_uo_)
                  {var _uq_=_uo_[2],_ur_=_uo_[1];
                   if(_uq_)
                    {if(_uq_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _us_=l[2];
                                 if(_us_)
                                  {var l$4=_us_[2],x1=_us_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _ut_=l[2];
                                 if(_ut_)
                                  {var _uu_=_ut_[2];
                                   if(_uu_)
                                    {var l$5=_uu_[2],x2=_uu_[1],x1$0=_ut_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_Q_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uq_[1];
                     return add(x4,add(_ur_,add(_up_,add(_un_,singleton(_ul_)))))}
                   return add(_ur_,add(_up_,add(_un_,singleton(_ul_))))}
                 return add(_up_,add(_un_,singleton(_ul_)))}
               return add(_un_,singleton(_ul_))}
             return singleton(_ul_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_ui_=cons_enum(t,rest);
             return [0,x,function(_uj_){return seq_of_enum(_ui_,_uj_)}]}
           return 0}
         function to_seq(c)
          {var _ug_=cons_enum(c,0);
           return function(_uh_){return seq_of_enum(_ug_,_uh_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _ue_=[0,v,r,c]}
             else
              var _ue_=c;
             return function(_uf_){return seq_of_enum(_ue_,_uf_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(671,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_ud_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_ud_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_t__=height(lr);
               if(_t__ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _t$_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_t$_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_ua_=height(rl);
               if(_ua_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _ub_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_ub_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _uc_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uc_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _t9_=0 === c?1:0;
               if(_t9_)return _t9_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t8_=param$0[1];
               if(_t8_){var param$0=_t8_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t7_=param$0[1];
               if(_t7_){var param$0=_t7_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t4_=param$0[4],_t5_=param$0[3],_t6_=param$0[2];
               if(_t4_){var param$0=_t4_;continue}
               return [0,_t6_,_t5_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t1_=param$0[4],_t2_=param$0[3],_t3_=param$0[2];
               if(_t1_){var param$0=_t1_;continue}
               return [0,[0,_t3_,_t2_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _t0_=param[1];
             if(_t0_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_t0_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _tD_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _tD_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _tD_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tX_=caml_call2(p,v,d);
               if(_tX_)
                {var _tY_=for_all(p,l);
                 if(_tY_){var param$0=r;continue}
                 var _tZ_=_tY_}
               else
                var _tZ_=_tX_;
               return _tZ_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tU_=caml_call2(p,v,d);
               if(_tU_)
                var _tV_=_tU_;
               else
                {var _tW_=exists(p,l);
                 if(! _tW_){var param$0=r;continue}
                 var _tV_=_tW_}
               return _tV_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _R_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _tQ_=merge(f,r1,r2),
                _tR_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_tR_,_tQ_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _tS_=merge(f,r1$0,r2$0),
              _tT_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_tT_,_tS_)}
           throw [0,Assert_failure,_S_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _tO_=concat(lf,rf);return [0,join(lt,v,d,rt),_tO_]}
             var _tP_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_tP_]}
           return _T_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _tL_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_tL_)
                  {var _tM_=caml_call2(cmp,d1,d2);
                   if(_tM_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _tN_=_tM_}
                 else
                  var _tN_=_tL_;
                 return _tN_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_tK_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _tK_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_tI_=cons_enum(t,rest);
             return [0,[0,k,v],function(_tJ_){return seq_of_enum(_tI_,_tJ_)}]}
           return 0}
         function to_seq(m)
          {var _tG_=cons_enum(m,0);
           return function(_tH_){return seq_of_enum(_tG_,_tH_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _tE_=[0,v,d,r,c]}
             else
              var _tE_=c;
             return function(_tF_){return seq_of_enum(_tE_,_tF_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(672,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$2(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _tC_=s[1];
      if(_tC_)
       {var tl=_tC_[2],hd=_tC_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function top(s)
     {var _tB_=s[1];if(_tB_){var hd=_tB_[1];return hd}throw Empty}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$4(f,s){return iter$0(f,s[1])}
    function fold(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$3(s){return to_seq(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$3(g){var s=create(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create,
       push,
       pop,
       top,
       clear,
       copy$2,
       is_empty,
       length$1,
       iter$4,
       fold,
       to_seq$3,
       add_seq,
       of_seq$3];
    caml_register_global(673,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tA_=q[3];
      return _tA_
              ?(q[1] = q[1] + 1 | 0,_tA_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tz_=q[2];if(_tz_){var content=_tz_[1];return content}throw Empty$0}
    function take(q)
     {var _tw_=q[2];
      if(_tw_)
       {var _tx_=_tw_[1],_ty_=_tw_[2];
        return _ty_?(q[1] = q[1] - 1 | 0,q[2] = _ty_,_tx_):(clear$0(q),_tx_)}
      throw Empty$0}
    function copy$3(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$5(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$0(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tu_=0 < q1[1]?1:0;
      if(_tu_)
       {var _tv_=q2[3];
        return _tv_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tv_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tu_}
    function to_seq$4(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tt_){return aux(next,_tt_)}]}
        return 0}
      var _tr_=q[2];
      return function(_ts_){return aux(_tr_,_ts_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$4(g){var q=create$0(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$0,
       add,
       add,
       take,
       take,
       peek,
       peek,
       clear$0,
       copy$3,
       is_empty$0,
       length$2,
       iter$5,
       fold$0,
       transfer,
       to_seq$4,
       add_seq$0,
       of_seq$4];
    caml_register_global(674,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(675,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(676,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_U_]}
           case 2:
            var
             f=d$0[1],
             _tn_=caml_obj_tag(f),
             d$1=250 === _tn_?f[1]:246 === _tn_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _to_=d$0[1],_tp_=_to_[1];
            if(_tp_)
             {var _tq_=_tp_[1];
              if(_tq_){var a$0=_tq_[1];_to_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_to_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _to_[1] = _V_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _ti_=s[2];
        if(typeof _ti_ === "number")
         return 0;
        else
         switch(_ti_[0])
          {case 0:var a=_ti_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_W_]}
           case 2:
            var
             f=_ti_[1],
             _tj_=caml_obj_tag(f),
             _tk_=250 === _tj_?f[1]:246 === _tj_?force_lazy_block(f):f;
            s[2] = _tk_;
            continue;
           case 3:
            var _tl_=_ti_[1],_tm_=_tl_[1];
            if(_tm_){var a$1=_tm_[1];return a$1}
            var x=caml_call1(_tl_[2],s[1]);
            _tl_[1] = [0,x];
            return x;
           default:
            var b=_ti_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tg_=s[2];
        if(typeof _tg_ !== "number")
         switch(_tg_[0])
          {case 0:var d=_tg_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _th_=_tg_[1];
            if(_th_[1]){s[1] = s[1] + 1 | 0;_th_[1] = 0;return 0}
            break;
           case 4:
            var b=_tg_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$6(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$0(l)
     {var _tf_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_tf_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _te_=data(s);return [0,[0,0,[1,data(i),_te_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tc_)
                  {var _td_=data(s);return [1,data(caml_call1(f,0)),_td_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_ta_)
                  {var _tb_=data(s);return [0,caml_call1(f,0),_tb_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_s$_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_s__){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$5);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$6);
          dump_data(f,d);
          return print_string(cst$7);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$8);
          dump_data(f,d2);
          return print_string(cst$9);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$0,
       of_string$0,
       of_bytes,
       of_channel,
       iter$6,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(677,Stdlib_stream,"Stdlib__stream");
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$2(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_X_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_Y_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_Z_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,___]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_$_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_aa_]}
    function add_substring(b,s,offset,len)
     {var _s7_=offset < 0?1:0;
      if(_s7_)
       var _s8_=_s7_;
      else
       var
        _s9_=len < 0?1:0,
        _s8_=_s9_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_s8_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _s5_=len$1 < 0?1:0,_s6_=_s5_ || (max_string_length < len$1?1:0);
      if(_s6_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _s4_=0 < len?1:0;
        if(_s4_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _s4_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _s2_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_ab_];var _s2_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _s2_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _s3_=92 === previous?1:0;
        return _s3_?add_char(b,previous):_s3_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$5(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_s0_=i + 1 | 0;
        return [0,x,function(_s1_){return aux(_s0_,_s1_)}]}
      var _sY_=0;
      return function(_sZ_){return aux(_sY_,_sZ_)}}
    function to_seqi$2(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_sW_=i + 1 | 0;
        return [0,[0,i,x],function(_sX_){return aux(_sW_,_sX_)}]}
      var _sU_=0;
      return function(_sV_){return aux(_sU_,_sV_)}}
    function add_seq$1(b,seq)
     {return iter(function(_sT_){return add_char(b,_sT_)},seq)}
    function of_seq$5(i){var b=create$1(32);add_seq$1(b,i);return b}
    var
     Stdlib_buffer=
      [0,
       create$1,
       contents,
       to_bytes,
       sub$2,
       blit$2,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$5,
       to_seqi$2,
       add_seq$1,
       of_seq$5];
    caml_register_global(678,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _sS_=i + 1 | 0;
        if(31 !== i){var i=_sS_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_sR_=[0,ndec];else var _sR_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_sR_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _sP_=len < min_len?1:0;
      if(_sP_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _sQ_=0}
      else
       var _sQ_=_sP_;
      return _sQ_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 12:return 117;
        case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 0:
        case 1:
        case 2:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$10);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$11;
         case 1:return cst$12;
         case 2:return cst$13;
         case 3:return cst$14;
         case 4:return cst$15;
         case 5:return cst$16;
         default:return cst$17}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return _g_(cst$18,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$19):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _sN_=caml_ml_string_length(str) - 1 | 0,_sM_=0;
      if(! (_sN_ < 0))
       {var i=_sM_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _sO_=i + 1 | 0;
          if(_sN_ !== i){var i=_sO_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$20);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$21);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$22);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$23);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$25);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$26);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sC_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_sH_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _sI_=is_in_char_set(_sH_,c);
                 if(_sI_)
                  var
                   _sJ_=is_in_char_set(_sH_,before),
                   _sK_=_sJ_?is_in_char_set(_sH_,after):_sJ_,
                   _sL_=1 - _sK_;
                 else
                  var _sL_=_sI_;
                 return _sL_}
               return is_alone},
            is_alone=is_alone$0(_sC_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sC_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sC_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sC_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_sC_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_sC_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _sD_=108;break;
             case 1:var _sD_=110;break;
             default:var _sD_=78}
           buffer_add_char(buf,_sD_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _sF_=int_of_custom_arity(arity),
            _sE_=1;
           if(! (_sF_ < 1))
            {var i$8=_sE_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _sG_=i$8 + 1 | 0;
               if(_sF_ !== i$8){var i$8=_sG_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _se_=function(param){return 0},
         _sf_=function(param){return 0},
         _sg_=function(param){return 0};
        return [0,function(param){return 0},_sg_,_sf_,_se_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _sh_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_sh_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _si_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _si_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _sj_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _sj_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _sk_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _sk_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _sl_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _sl_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _sm_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _sm_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _sn_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _sn_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _so_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _so_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _sp_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _sp_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _sq_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sr_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _ss_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _ss_,
                  _sr_,
                  _sq_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _st_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _st_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _su_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _su_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sv_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sv_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sw_=function(param){caml_call1(de$12,0);return 0},
           _sx_=function(param){caml_call1(ed$12,0);return 0},
           _sy_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _sy_,
                  _sx_,
                  _sw_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _sz_=function(param){caml_call1(de$13,0);return 0},
           _sA_=function(param){caml_call1(ed$13,0);return 0},
           _sB_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sB_,
                  _sA_,
                  _sz_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,_ac_]}
      else
       switch(ty1[0])
        {case 0:
          var _rX_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_rX_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _rY_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_rY_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _rZ_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_rZ_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _r0_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_r0_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _r1_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_r1_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _r2_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_r2_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _r3_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_r3_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _r4_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_r4_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _r5_=ty1[2],_r6_=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_r7_=trans(_r5_,rest2$7);
              return [8,trans(_r6_,ty2),_r7_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_al_];
          break;
         case 9:
          var _r8_=ty1[3],_r9_=ty1[2],_r__=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_r9_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_r__,ty22,trans(_r8_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_am_];
          break;
         case 10:
          var _r$_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_r$_,rest2$9)]}
          throw [0,Assert_failure,_an_];
         case 11:
          var _sa_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_sa_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_ao_];
          break;
         case 12:
          var _sb_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_sb_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_ap_];
          break;
         case 13:
          var _sc_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_sc_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_aq_];
          break;
         default:
          var _sd_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_sd_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_ar_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_af_];
        case 1:throw [0,Assert_failure,_ag_];
        case 2:throw [0,Assert_failure,_ah_];
        case 3:throw [0,Assert_failure,_ai_];
        case 4:throw [0,Assert_failure,_aj_];
        case 5:throw [0,Assert_failure,_ad_];
        case 6:throw [0,Assert_failure,_ae_];
        default:throw [0,Assert_failure,_ak_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _rV_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_rW_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _rW_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_rW_,_rV_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _rU_=match[2];
        if(typeof _rU_ !== "number" && 2 === _rU_[0])
         {var rest$0=_rU_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _rT_=type_format_gen(fmt,fmtty);
      if(typeof _rT_[2] === "number"){var fmt$0=_rT_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _ro_=type_padding(pad,fmtty),
           _rp_=_ro_[2],
           _rq_=_ro_[1];
          if(typeof _rp_ !== "number" && 1 === _rp_[0])
           {var
             fmtty_rest$1=_rp_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_rq_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _rr_=type_padding(pad$0,fmtty),
           _rs_=_rr_[2],
           _rt_=_rr_[1];
          if(typeof _rs_ !== "number" && 1 === _rs_[0])
           {var
             fmtty_rest$2=_rs_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_rt_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _ru_=type_padprec(pad$1,prec,fmtty),
           _rv_=_ru_[3],
           _rw_=_ru_[2],
           _rx_=_ru_[1];
          if(typeof _rv_ !== "number" && 2 === _rv_[0])
           {var
             fmtty_rest$3=_rv_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_rx_,_rw_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _ry_=type_padprec(pad$2,prec$0,fmtty),
           _rz_=_ry_[3],
           _rA_=_ry_[2],
           _rB_=_ry_[1];
          if(typeof _rz_ !== "number" && 3 === _rz_[0])
           {var
             fmtty_rest$4=_rz_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_rB_,_rA_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _rC_=type_padprec(pad$3,prec$1,fmtty),
           _rD_=_rC_[3],
           _rE_=_rC_[2],
           _rF_=_rC_[1];
          if(typeof _rD_ !== "number" && 4 === _rD_[0])
           {var
             fmtty_rest$5=_rD_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_rF_,_rE_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _rG_=type_padprec(pad$4,prec$2,fmtty),
           _rH_=_rG_[3],
           _rI_=_rG_[2],
           _rJ_=_rG_[1];
          if(typeof _rH_ !== "number" && 5 === _rH_[0])
           {var
             fmtty_rest$6=_rH_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_rJ_,_rI_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _rK_=type_padprec(pad$5,prec$3,fmtty),
           _rL_=_rK_[3],
           _rM_=_rK_[2],
           _rN_=_rK_[1];
          if(typeof _rL_ !== "number" && 6 === _rL_[0])
           {var
             fmtty_rest$7=_rL_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_rN_,_rM_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _rO_=type_padding(pad$6,fmtty),
           _rP_=_rO_[2],
           _rQ_=_rO_[1];
          if(typeof _rP_ !== "number" && 7 === _rP_[0])
           {var
             fmtty_rest$8=_rP_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_rQ_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _rR_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_rR_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _rS_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_rS_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_rS_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _rm_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_rm_))
             throw Type_mismatch;
            var _rn_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_rn_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _rl_=2 === padty$0?48:32,res=make(width$0,_rl_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return caml_string_of_bytes(res$1)}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return caml_string_of_bytes(res$0)}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _rk_=cst_d$2;break;
        case 1:var _rk_=cst_d$3;break;
        case 2:var _rk_=cst_d$4;break;
        case 3:var _rk_=cst_i$0;break;
        case 4:var _rk_=cst_i$1;break;
        case 5:var _rk_=cst_i$2;break;
        case 6:var _rk_=cst_x;break;
        case 7:var _rk_=cst_x$0;break;
        case 8:var _rk_=cst_X$0;break;
        case 9:var _rk_=cst_X$1;break;
        case 10:var _rk_=cst_o;break;
        case 11:var _rk_=cst_o$0;break;
        default:var _rk_=cst_u}
      return caml_format_int(_rk_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _rj_=cst_ld;break;
        case 1:var _rj_=cst_ld$0;break;
        case 2:var _rj_=cst_ld$1;break;
        case 3:var _rj_=cst_li$0;break;
        case 4:var _rj_=cst_li$1;break;
        case 5:var _rj_=cst_li$2;break;
        case 6:var _rj_=cst_lx;break;
        case 7:var _rj_=cst_lx$0;break;
        case 8:var _rj_=cst_lX;break;
        case 9:var _rj_=cst_lX$0;break;
        case 10:var _rj_=cst_lo;break;
        case 11:var _rj_=cst_lo$0;break;
        default:var _rj_=cst_lu}
      return caml_format_int(_rj_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _ri_=cst_nd;break;
        case 1:var _ri_=cst_nd$0;break;
        case 2:var _ri_=cst_nd$1;break;
        case 3:var _ri_=cst_ni$0;break;
        case 4:var _ri_=cst_ni$1;break;
        case 5:var _ri_=cst_ni$2;break;
        case 6:var _ri_=cst_nx;break;
        case 7:var _ri_=cst_nx$0;break;
        case 8:var _ri_=cst_nX;break;
        case 9:var _ri_=cst_nX$0;break;
        case 10:var _ri_=cst_no;break;
        case 11:var _ri_=cst_no$0;break;
        default:var _ri_=cst_nu}
      return caml_format_int(_ri_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _rh_=cst_Ld;break;
        case 1:var _rh_=cst_Ld$0;break;
        case 2:var _rh_=cst_Ld$1;break;
        case 3:var _rh_=cst_Li$0;break;
        case 4:var _rh_=cst_Li$1;break;
        case 5:var _rh_=cst_Li$2;break;
        case 6:var _rh_=cst_Lx;break;
        case 7:var _rh_=cst_Lx$0;break;
        case 8:var _rh_=cst_LX;break;
        case 9:var _rh_=cst_LX$0;break;
        case 10:var _rh_=cst_Lo;break;
        case 11:var _rh_=cst_Lo$0;break;
        default:var _rh_=cst_Lu}
      return caml_int64_format(_rh_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _re_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _re_=buffer_contents(buf)}
      var str$0=caml_format_float(_re_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0.?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _rg_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _rf_=match - 46 | 0,
             switch$1=
              23 < _rf_ >>> 0?55 === _rf_?1:0:21 < (_rf_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _rg_=1}
          return _rg_?str$0:_g_(str$0,cst$27)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rb_=pad[2],_rc_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_rc_,_rb_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_rc_,_rb_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_rc_,_rb_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _rd_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_rd_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_rd_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_rd_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _q__=pad$5[2],_q$_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_q$_,_q__,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_q$_,_q__,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_q$_,_q__,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _ra_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_ra_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_ra_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ra_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _q8_=fmt$0[1];
           if(0 === _q8_[0])
            {var
              rest$13=fmt$0[2],
              match=_q8_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_q8_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_as_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _q9_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_q9_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_q9_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_at_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_q7_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_au_];
         default:throw [0,Assert_failure,_av_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _q6_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_q6_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_q6_,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _q5_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_q5_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_q5_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _qB_=make_iprintf(k,o,fmt);return function(_qT_){return _qB_}}
          var _qC_=make_iprintf(k,o,fmt),_qD_=function(_qS_){return _qC_};
          return function(_qR_){return _qD_}}
        var _qE_=make_iprintf(k,o,fmt);
        return function(_qQ_){return _qE_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _qF_=make_iprintf(k,o,fmt);
              return function(_q4_){return _qF_}}
            var _qG_=make_iprintf(k,o,fmt),_qH_=function(_q3_){return _qG_};
            return function(_q2_){return _qH_}}
          var _qI_=make_iprintf(k,o,fmt);
          return function(_q1_){return _qI_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _qJ_=make_iprintf(k,o,fmt),_qK_=function(_q0_){return _qJ_};
            return function(_qZ_){return _qK_}}
          var
           _qL_=make_iprintf(k,o,fmt),
           _qM_=function(_qY_){return _qL_},
           _qN_=function(_qX_){return _qM_};
          return function(_qW_){return _qN_}}
        var _qO_=make_iprintf(k,o,fmt),_qP_=function(_qV_){return _qO_};
        return function(_qU_){return _qP_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_pS_=make_iprintf(k$0,o,rest);
           return function(_qA_){return _pS_};
          case 1:
           var rest$0=fmt$0[1],_pT_=make_iprintf(k$0,o,rest$0);
           return function(_qz_){return _pT_};
          case 2:
           var _pU_=fmt$0[1];
           if(typeof _pU_ === "number")
            {var rest$1=fmt$0[2],_pV_=make_iprintf(k$0,o,rest$1);
             return function(_qv_){return _pV_}}
           else
            {if(0 === _pU_[0])
              {var rest$2=fmt$0[2],_pW_=make_iprintf(k$0,o,rest$2);
               return function(_qy_){return _pW_}}
             var
              rest$3=fmt$0[2],
              _pX_=make_iprintf(k$0,o,rest$3),
              _pY_=function(_qx_){return _pX_};
             return function(_qw_){return _pY_}}
          case 3:
           var _pZ_=fmt$0[1];
           if(typeof _pZ_ === "number")
            {var rest$4=fmt$0[2],_p0_=make_iprintf(k$0,o,rest$4);
             return function(_qr_){return _p0_}}
           else
            {if(0 === _pZ_[0])
              {var rest$5=fmt$0[2],_p1_=make_iprintf(k$0,o,rest$5);
               return function(_qu_){return _p1_}}
             var
              rest$6=fmt$0[2],
              _p2_=make_iprintf(k$0,o,rest$6),
              _p3_=function(_qt_){return _p2_};
             return function(_qs_){return _p3_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _p4_=fmt$0[1];
           if(typeof _p4_ === "number")
            {var rest$12=fmt$0[2],_p5_=make_iprintf(k$0,o,rest$12);
             return function(_qn_){return _p5_}}
           else
            {if(0 === _p4_[0])
              {var rest$13=fmt$0[2],_p6_=make_iprintf(k$0,o,rest$13);
               return function(_qq_){return _p6_}}
             var
              rest$14=fmt$0[2],
              _p7_=make_iprintf(k$0,o,rest$14),
              _p8_=function(_qp_){return _p7_};
             return function(_qo_){return _p8_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_p9_=make_iprintf(k$0,o,rest$15);
           return function(_qm_){return _p9_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _p__=make_iprintf(k$0,o,rest$17),
            _p$_=function(_ql_){return _p__};
           return function(_qk_){return _p$_};
          case 16:
           var rest$18=fmt$0[1],_qa_=make_iprintf(k$0,o,rest$18);
           return function(_qj_){return _qa_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _qb_=fmt$0[1];
           if(0 === _qb_[0])
            {var
              rest$19=fmt$0[2],
              match=_qb_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_qb_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_aw_];
          case 20:
           var rest$21=fmt$0[3],_qc_=make_iprintf(k$0,o,rest$21);
           return function(_qi_){return _qc_};
          case 21:
           var rest$22=fmt$0[2],_qd_=make_iprintf(k$0,o,rest$22);
           return function(_qh_){return _qd_};
          case 22:
           var rest$23=fmt$0[1],_qe_=make_iprintf(k$0,o,rest$23);
           return function(_qg_){return _qe_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_qf_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _qf_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_pQ_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_pR_){return _pQ_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _pO_=acc$0[2],_pP_=acc$0[1];
           if(0 === _pO_[0])
            {var acc$1=_pO_[1];
             output_acc(o,_pP_);
             output_string(o,cst$28);
             var acc$0=acc$1;
             continue}
           var acc$2=_pO_[1];
           output_acc(o,_pP_);
           output_string(o,cst$29);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pM_=acc$0[2],_pN_=acc$0[1];
           if(0 === _pM_[0])
            {var acc$1=_pM_[1];
             bufput_acc(b,_pN_);
             add_string(b,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_pM_[1];
           bufput_acc(b,_pN_);
           add_string(b,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pK_=acc$0[2],_pL_=acc$0[1];
           if(0 === _pK_[0])
            {var acc$1=_pK_[1];
             strput_acc(b,_pL_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_pK_[1];
           strput_acc(b,_pL_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$1(256);
      function k(param,acc)
       {strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$34))return _ax_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ay_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _pI_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_pI_}
       catch(_pJ_)
        {_pJ_ = caml_wrap_exception(_pJ_);
         if(_pJ_[1] !== Failure)throw _pJ_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$35))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_az_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_aA_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aB_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pH_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pH_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aN_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aO_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aP_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aI_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$36);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$37)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _pg_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _pg_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_pg_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _pi_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_pi_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_po_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _po_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_po_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _pp_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _pp_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_pp_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pG_=i + 1 | 0;
                    if(c !== i){var i=_pG_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aR_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _pF_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_pF_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_pF_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _pD_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_pD_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_pD_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _pE_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_pE_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_pE_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _pC_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_pC_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_pC_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pu_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pu_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pu_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pv_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _pw_=_pv_;
              else
               var
                _pw_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _px_=_pw_}
            else
             var _px_=char_format(fmt_rest$21);
            var fmt_result=_px_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _py_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_py_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pz_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pz_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pz_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pA_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pA_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pA_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _ph_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _ph_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_ph_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_pB_=symb$0 - 88 | 0;
              if(32 < _pB_ >>> 0)
               var switch$2=0;
              else
               switch(_pB_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _pn_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _pn_=0;
              if(_pn_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aV_];
              if(get_ign(0))
               var ignored$5=[11,counter],_pm_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _pm_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_pm_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aM_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _pq_=get_space(0),
             _pr_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pr_,_pq_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ps_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _pt_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_pt_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ps_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ps_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aX_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$48)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$50)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _pj_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$38);
                else
                 var ndec=match[1],_pj_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_pj_],
                 _pk_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _pl_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_pl_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _pk_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_pk_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _o2_=caml_string_get(str,str_ind),
                 _o3_=get_space(0),
                 _o4_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_o4_,_o3_,_o2_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _o5_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _o7_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_o7_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _o5_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _o6_=_o5_,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _o8_=caml_string_get(str,str_ind),
                 _o9_=get_space(0),
                 _o__=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_o__,_o9_,_o8_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _o$_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _pa_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_pa_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _o$_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _o6_=_o$_,switch$8=1}
             if(switch$8)var fmt_result=_o6_,switch$7=1}
          else
           if(76 === symb)
            {var
              _pb_=caml_string_get(str,str_ind),
              _pc_=get_space(0),
              _pd_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_pd_,_pc_,_pb_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _pe_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _pf_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_pf_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _pe_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_pe_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aJ_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _oT_=1 - plus_used[1],plus$0=_oT_?plus:_oT_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$39);
          var _oU_=1 - hash_used[1],hash$0=_oU_?hash:_oU_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _oV_=1 - space_used[1],space$0=_oV_?space:_oV_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _oW_=1 - pad_used[1],_oX_=_oW_?caml_notequal([0,pad],_aK_):_oW_;
          if(_oX_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _oY_=1 - prec_used[1],
           _oZ_=_oY_?caml_notequal([0,prec],_aL_):_oY_;
          if(_oZ_)
           {var _o0_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_o0_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$42)}
        var _o1_=1 - ign_used[1],ign$0=_o1_?ign:_o1_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$43)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aF_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aG_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _oS_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_oS_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aE_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _oP_=flag[1],_oQ_=_oP_?1 - legacy_behavior$0:_oP_;
          if(_oQ_)
           {var _oR_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aC_),str,str_ind,_oR_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _oK_=space[1],
           _oL_=hash[1],
           _oM_=plus[1],
           _oN_=minus[1],
           _oO_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _oO_
             ?0 === _oN_?1:0
             :0 === _oN_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _oN_,
                       _oM_,
                       _oL_,
                       _oK_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _oN_,
                     _oM_,
                     _oL_,
                     _oK_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,_aD_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_oJ_)
                   {_oJ_ = caml_wrap_exception(_oJ_);
                    if(_oJ_[1] !== Failure)throw _oJ_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _oH_=[0,[18,formatting$0,fmt_rest$0]];
            return _oH_}
          throw Not_found}
        catch(_oI_)
         {_oI_ = caml_wrap_exception(_oI_);
          if(_oI_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _oI_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _oA_=str_ind === end_ind?1:0,
           _oB_=_oA_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_oB_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oC_=[0,s,width,0],
             _oD_=str_ind_3 + 1 | 0,
             next_ind=_oD_,
             formatting_lit$0=_oC_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _oE_=[0,s$0,width,offset],
               _oF_=str_ind_5 + 1 | 0,
               next_ind=_oF_,
               formatting_lit$0=_oE_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_oG_)
         {_oG_ = caml_wrap_exception(_oG_);
          if(_oG_ !== Not_found)if(_oG_[1] !== Failure)throw _oG_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oy_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _oy_=0;
          var _ox_=_oy_}
        catch(_oz_)
         {_oz_ = caml_wrap_exception(_oz_);
          if(_oz_ !== Not_found)if(_oz_[1] !== Failure)throw _oz_;
          var _ox_=0}
        if(_ox_)
         {var
           match=_ox_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aQ_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aS_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aT_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aU_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aY_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {if(88 === symb)return 9;
              if(111 === symb)return 11;
              if(120 === symb)return 7;
              var switch$0=0}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$0=symb - 88 | 0;
            if(! (32 < switcher$0 >>> 0))
             switch(switcher$0)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$47)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aW_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$44)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$46)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _ov_=[0,type_format(fmt,fmtty),str];return _ov_}
      catch(_ow_)
       {_ow_ = caml_wrap_exception(_ow_);
        if(_ow_ === Type_mismatch)
         {var _ou_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aZ_),str,_ou_)}
        throw _ow_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _os_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _os_}
      catch(_ot_)
       {_ot_ = caml_wrap_exception(_ot_);
        if(_ot_ === Type_mismatch)
         return caml_call2(failwith_message(_a0_),str,str$0);
        throw _ot_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(679,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_or_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return caml_call1(k,o)},
               o,
               _or_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_oq_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return caml_call1(k,b)},
               b,
               _oq_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_op_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_oo_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_on_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(param,acc)
       {var buf=create$1(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(680,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _om_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_om_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_ol_=_g_(prefix,h);
        return _g_
                (fold_left$0(function(x,y){return _g_(x,_g_(sep,y))},_ol_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a3_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _oi_=0,_og_=_oi_}
      catch(_ok_)
       {_ok_ = caml_wrap_exception(_ok_);
        if(_ok_ !== Not_found)throw _ok_;
        var
         _og_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _oh_=0,add2=_oh_}
      catch(_oj_)
       {_oj_ = caml_wrap_exception(_oj_);
        if(_oj_ !== Not_found)throw _oj_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_og_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a4_),errmsg);
      var _od_=add_help(speclist);
      return iter$0
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _oe_=0 < caml_ml_string_length(doc)?1:0;
                 if(_oe_)
                  {if(11 === spec[0])
                    {var l=spec[1],_of_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a2_),key,_of_,doc)}
                   return caml_call2(bprintf(buf,_a1_),key,doc)}
                 return _oe_},
               _od_)}
    function usage_string(speclist,errmsg)
     {var b=create$1(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _oc_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a5_),_oc_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _oa_=[0,bool_of_string(x)];return _oa_}
      catch(_ob_)
       {_ob_ = caml_wrap_exception(_ob_);
        if(_ob_[1] === Invalid_argument)return 0;
        throw _ob_}}
    function int_of_string_opt$0(x)
     {try
       {var _n__=[0,caml_int_of_string(x)];return _n__}
      catch(_n$_)
       {_n$_ = caml_wrap_exception(_n$_);
        if(_n$_[1] === Failure)return 0;
        throw _n$_}}
    function float_of_string_opt$0(x)
     {try
       {var _n8_=[0,caml_float_of_string(x)];return _n8_}
      catch(_n9_)
       {_n9_ = caml_wrap_exception(_n9_);
        if(_n9_[1] === Failure)return 0;
        throw _n9_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$1(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[initpos + 1]
           :cst$54;
        switch(error[0])
         {case 0:
           var _n7_=error[1];
           if(caml_string_notequal(_n7_,cst_help$3))
            if(caml_string_notequal(_n7_,cst_help$4))
             caml_call2(bprintf(b,_a6_),progname,_n7_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a9_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a__),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a$_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a7_))
         if(! caml_equal(error,_a8_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _n0_=current[1],s=caml_check_bound(argv[1],_n0_)[_n0_ + 1];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _n2_=assoc3(s,speclist[1]),
                  action=_n2_,
                  follow$0=follow$1}
               catch(_n5_)
                {_n5_ = caml_wrap_exception(_n5_);
                 if(_n5_ !== Not_found)throw _n5_;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _n1_=assoc3(keyword,speclist[1])}
                 catch(_n6_)
                  {_n6_ = caml_wrap_exception(_n6_);
                   if(_n6_ === Not_found)throw [0,Stop,[0,s]];
                   throw _n6_}
                 var action=_n1_,follow$0=follow}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _n4_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_n4_)[_n4_ + 1]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt$0(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt$0(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:
                        var specs=param[1];return iter$0(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                _g_(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                       case 12:
                        var f$5=param[1];
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _n3_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_n3_)[_n3_ + 1]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Bad){var m=exn[2];throw convert_error([3,m])}
            if(exn[1] === Stop){var e=exn[2];throw convert_error(e)}
            throw exn}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _nZ_=parse_argv(0,_q_,l,f,msg);return _nZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _nY_=parse_argv_dynamic(0,_q_,l,f,msg);return _nY_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bc_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bd_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_q_],
         spec=[0,l],
         current$0=[0,current[1]],
         _nX_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _nX_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_be_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bf_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_nV_)
       {_nV_ = caml_wrap_exception(_nV_);
        if(_nV_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_nW_)
           {_nW_ = caml_wrap_exception(_nW_);
            if(_nW_ === Not_found)return len;
            throw _nW_}
          return loop(n + 1 | 0)}
        throw _nV_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$2
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$0
              (function(ksd)
                {var _nT_=ksd[2],_nU_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _nT_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _nU_,
                             _nT_,
                             _g_(cst$59,_g_(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_nU_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_nU_,_nT_,_g_(prefix,_g_(spaces,suffix))]}
                   return [0,_nU_,_nT_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$1(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _nS_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _nS_=s;
          var word=_nS_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_nR_)
       {_nR_ = caml_wrap_exception(_nR_);
        if(_nR_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _nR_}}
    var _bg_=10,_bh_=1;
    function read_arg(_nQ_){return read_aux(_bh_,_bg_,_nQ_)}
    var _bi_=0,_bj_=0;
    function read_arg0(_nP_){return read_aux(_bj_,_bi_,_nP_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$3(function(s){return caml_call2(fprintf(oc,_bk_),s,sep)},args);
      return close_out(oc)}
    var _bl_=10;
    function write_arg(_nN_,_nO_){return write_aux(_bl_,_nN_,_nO_)}
    var _bm_=0;
    function write_arg0(_nL_,_nM_){return write_aux(_bm_,_nL_,_nM_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(681,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[i + 1];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bn_),f)
                :caml_obj_tag(f) === 253?string_of_float(f):cst$60
              :caml_call1(sprintf(_bo_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _nJ_=other_fields(x,i + 1 | 0),_nK_=field(x,i);
      return caml_call2(sprintf(_bp_),_nK_,_nJ_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _nG_=other_fields(x,2),_nH_=field(x,1);
        return caml_call2(sprintf(_bq_),_nH_,_nG_)}
      switch(match)
       {case 0:return cst$62;
        case 1:return cst$63;
        default:var _nI_=field(x,1);return caml_call1(sprintf(_br_),_nI_)}}
    function to_string$4(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _nE_=caml_call1(hd,x),_nD_=_nE_}catch(_nF_){var _nD_=0}
            if(_nD_){var s=_nD_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return _g_(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _nC_=caml_call1(fct,arg);return _nC_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _nB_=to_string$4(x);
        caml_call1(eprintf(_bs_),_nB_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _nA_=caml_call1(fct,arg);return _nA_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _nz_=to_string$4(x);
        caml_call1(eprintf(_bt_),_nz_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _ns_=slot[5],
         _nt_=slot[4],
         _nu_=slot[3],
         _nv_=slot[6]?cst_inlined:cst$64,
         _nw_=slot[2],
         _nx_=info(slot[1]);
        return [0,caml_call6(sprintf(_bu_),_nx_,_nw_,_nv_,_nu_,_nt_,_ns_)]}
      if(slot[1])return 0;
      var _ny_=info(0);
      return [0,caml_call1(sprintf(_bv_),_ny_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nq_=a.length - 1 - 1 | 0,_np_=0;
        if(! (_nq_ < 0))
         {var i=_np_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bw_),str)}
            var _nr_=i + 1 | 0;
            if(_nq_ !== i){var i=_nr_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bx_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$1(1024),_nn_=a.length - 1 - 1 | 0,_nm_=0;
        if(! (_nn_ < 0))
         {var i=_nm_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(bprintf(b,_by_),str)}
            var _no_=i + 1 | 0;
            if(_nn_ !== i){var i=_no_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nl_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[i + 1],
             _nk_=0 === param[0]?1:0;
            if(! _nk_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nl_=_nk_}
          return _nl_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bz_(_nj_){return runtime.caml_raw_backtrace_next_slot(_nj_)}
    function _bA_(_ni_){return runtime.caml_convert_raw_backtrace_slot(_ni_)}
    function _bB_(_nh_,_ng_)
     {return runtime.caml_raw_backtrace_slot(_nh_,_ng_)}
    function _bC_(_nf_){return runtime.caml_raw_backtrace_length(_nf_)}
    var
     _bD_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bE_(_ne_){return runtime.caml_get_current_callstack(_ne_)}
    function _bF_(_nd_){return caml_get_exception_raw_backtrace(_nd_)}
    function _bG_(_nc_){return runtime.caml_backtrace_status(_nc_)}
    var
     Stdlib_printexc=
      [0,
       to_string$4,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_nb_){return runtime.caml_record_backtrace(_nb_)},
       _bG_,
       register_printer,
       _bF_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bE_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bD_,
       _bC_,
       _bB_,
       _bA_,
       _bz_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(686,Stdlib_printexc,"Stdlib__printexc");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_mW_=st[4];
      caml_call1(fprintf(c,_bH_),_mW_);
      var _mX_=st[5];
      caml_call1(fprintf(c,_bI_),_mX_);
      var _mY_=st[14];
      caml_call1(fprintf(c,_bJ_),_mY_);
      fprintf(c,_bK_);
      var
       _mZ_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bL_),_mZ_)),
       _m0_=st[1];
      caml_call2(fprintf(c,_bM_),l1,_m0_);
      var _m1_=st[2];
      caml_call2(fprintf(c,_bN_),l1,_m1_);
      var _m2_=st[3];
      caml_call2(fprintf(c,_bO_),l1,_m2_);
      fprintf(c,_bP_);
      var
       _m3_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bQ_),_m3_)),
       _m4_=st[15];
      caml_call2(fprintf(c,_bR_),l2,_m4_);
      var _m5_=st[6];
      caml_call2(fprintf(c,_bS_),l2,_m5_);
      var _m6_=st[8];
      caml_call2(fprintf(c,_bT_),l2,_m6_);
      var _m7_=st[10];
      caml_call2(fprintf(c,_bU_),l2,_m7_);
      var _m8_=st[12];
      caml_call2(fprintf(c,_bV_),l2,_m8_);
      var _m9_=st[13];
      caml_call2(fprintf(c,_bW_),l2,_m9_);
      fprintf(c,_bX_);
      var _m__=st[9];
      caml_call1(fprintf(c,_bY_),_m__);
      var _m$_=st[11];
      caml_call1(fprintf(c,_bZ_),_m$_);
      var _na_=st[7];
      return caml_call1(fprintf(c,_b0_),_na_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b1_(_mV_){return runtime.caml_final_release(_mV_)}
    function _b2_(_mU_,_mT_)
     {return runtime.caml_final_register_called_without_value(_mU_,_mT_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_mS_,_mR_){return runtime.caml_final_register(_mS_,_mR_)},
       _b2_,
       _b1_,
       create_alarm,
       delete_alarm];
    caml_register_global(687,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _mQ_=10 <= n?87:48;return n + _mQ_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _mP_=i + 1 | 0;
        if(15 !== i){var i=_mP_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_mN_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _mN_ | 0));
        var _mO_=i + 1 | 0;
        if(15 !== i){var i=_mO_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$2,
       equal$2,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(688,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[i$0 + 1] = i$0;
        var _mM_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_mM_;continue}
        var accu=[0,cst_x$1],_mI_=54 + max(55,l) | 0,_mH_=0;
        if(! (_mI_ < 0))
         {var i=_mH_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[k + 1];
            accu[1] = string(_g_(accu[1],caml_new_string("" + x)));
            var
             _mJ_=accu[1],
             _mD_=caml_string_get(_mJ_,3) << 24,
             _mE_=caml_string_get(_mJ_,2) << 16,
             _mF_=caml_string_get(_mJ_,1) << 8,
             _mG_=((caml_string_get(_mJ_,0) + _mF_ | 0) + _mE_ | 0) + _mD_ | 0,
             _mK_=(caml_check_bound(s[1],j)[j + 1] ^ _mG_) & 1073741823;
            caml_check_bound(s[1],j)[j + 1] = _mK_;
            var _mL_=i + 1 | 0;
            if(_mI_ !== i){var i=_mL_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$1(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$1(caml_sys_random_seed(0))}
    function copy$4(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mA_=s[2],
       curval=caml_check_bound(s[1],_mA_)[_mA_ + 1],
       _mB_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_mB_)[_mB_ + 1]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _mC_=s[2];
      caml_check_bound(s[1],_mC_)[_mC_ + 1] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b4_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$1,bound),_b3_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b5_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$3(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$4(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b6_=
      [0,
       make$1,
       make_self_init,
       copy$4,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$3,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b6_,
       get_state,
       set_state];
    caml_register_global(689,Stdlib_random,"Stdlib__random");
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _my_=h.length - 1 < 4?1:0,_mz_=_my_ || (h[4] < 0?1:0);return _mz_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cN_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cN_}
    catch(_mw_)
     {_mw_ = caml_wrap_exception(_mw_);
      if(_mw_ !== Not_found)throw _mw_;
      try
       {var _cM_=caml_sys_getenv(cst_CAMLRUNPARAM),_b7_=_cM_}
      catch(_mx_)
       {_mx_ = caml_wrap_exception(_mx_);
        if(_mx_ !== Not_found)throw _mx_;
        var _b7_=cst$65}
      var params=_b7_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mv_){return caml_call1(_b6_[2],0)}];
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mt_=caml_obj_tag(prng),
          _mu_=250 === _mt_?prng[1]:246 === _mt_?force_lazy_block(prng):prng,
          seed=caml_call1(_b6_[4],_mu_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_mr_=len - 1 | 0,_mq_=0;
      if(! (_mr_ < 0))
       {var i=_mq_;
        for(;;)
         {caml_check_bound(h[2],i)[i + 1] = 0;
          var _ms_=i + 1 | 0;
          if(_mr_ !== i){var i=_ms_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b8_]}
          return prec$0}}
      return 0}
    function copy$5(init)
     {var _mn_=init[4],_mo_=init[3],_mp_=map$3(copy_bucketlist,init[2]);
      return [0,init[1],_mp_,_mo_,_mn_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _me_=nsize < max_array_length?1:0;
      if(_me_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mg_=osize - 1 | 0,_mf_=0;
        if(! (_mg_ < 0))
         {var i$0=_mf_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[i$0 + 1],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[nidx + 1];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[nidx + 1] = cell$0;
                caml_check_bound(ndata_tail,nidx)[nidx + 1] = cell$0;
                var cell=next;
                continue}
              var _mm_=i$0 + 1 | 0;
              if(_mg_ !== i$0){var i$0=_mm_;continue a}
              break}
            break}}
        if(inplace)
         {var _mi_=nsize - 1 | 0,_mh_=0;
          if(! (_mi_ < 0))
           {var i=_mh_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[i + 1];
              if(match$0)match$0[3] = 0;
              var _ml_=i + 1 | 0;
              if(_mi_ !== i){var i=_ml_;continue}
              break}}
          var _mj_=0}
        else
         var _mj_=inplace;
        var _mk_=_mj_}
      else
       var _mk_=_me_;
      return _mk_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
      caml_check_bound(h[2],i)[i + 1] = bucket;
      h[1] = h[1] + 1 | 0;
      var _md_=h[2].length - 1 << 1 < h[1]?1:0;
      return _md_?resize$0(key_index,h):_md_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[i + 1],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :caml_check_bound(h[2],i)[i + 1] = next}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mc_=key_index(h,key),match=caml_check_bound(h[2],_mc_)[_mc_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mb_=key_index(h,key),match=caml_check_bound(h[2],_mb_)[_mb_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _ma_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_ma_)[_ma_ + 1])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[i + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _l9_=0}
        else
         var _l9_=1;
        if(_l9_)
         {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _l__=h[2].length - 1 << 1 < h[1]?1:0;
          if(_l__)return resize$0(key_index,h);
          var _l$_=_l__}
        else
         var _l$_=_l9_;
        return _l$_}}
    function mem$1(h,key)
     {var
       _l8_=key_index(h,key),
       param$0=caml_check_bound(h[2],_l8_)[_l8_ + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_l7_=0 === caml_compare(k,key)?1:0;
          if(_l7_)return _l7_;
          var param=next;
          continue}
        return 0}}
    function iter$7(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_l3_=d.length - 1 - 1 | 0,_l2_=0;
        if(! (_l3_ < 0))
         {var i=_l2_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[i + 1]);
            var _l6_=i + 1 | 0;
            if(_l3_ !== i){var i=_l6_;continue}
            break}}
        var _l4_=1 - old_trav,_l5_=_l4_?flip_ongoing_traversal(h):_l4_;
        return _l5_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[i + 1] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0?(prec$0[3] = 0,0):caml_check_bound(h[2],i)[i + 1] = 0}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _lZ_=d.length - 1 - 1 | 0,_lY_=0;
        if(! (_lZ_ < 0))
         {var i=_lY_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[i + 1]);
            var _l1_=i + 1 | 0;
            if(_lZ_ !== i){var i=_l1_;continue}
            break}}
        var _l0_=0;
        return _l0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$1(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_lU_=d.length - 1 - 1 | 0,_lT_=0;
        if(! (_lU_ < 0))
         {var i=_lT_;
          for(;;)
           {var _lW_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[i + 1],_lW_);
            var _lX_=i + 1 | 0;
            if(_lU_ !== i){var i=_lX_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _lV_=accu[1];
        return _lV_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _lQ_=h[2],
       _lR_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_lR_,_lQ_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _lS_=h[2];
      iter$3
       (function(b)
         {var l=bucket_length(0,b);
          return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
        _lS_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$6(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_lP_){return aux(i$0,next,_lP_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _lM_=0,_lN_=0;
      return function(_lO_){return aux(_lN_,_lM_,_lO_)}}
    function to_seq_keys(m)
     {var _lI_=to_seq$6(m);
      function _lJ_(_lL_){return _lL_[1]}
      return function(_lK_){return map(_lJ_,_lI_,_lK_)}}
    function to_seq_values(m)
     {var _lE_=to_seq$6(m);
      function _lF_(_lH_){return _lH_[2]}
      return function(_lG_){return map(_lF_,_lE_,_lG_)}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$6(i){var tbl=create$2(0,16);replace_seq(tbl,i);return tbl}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _lD_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _lD_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _lC_=h[2].length - 1 << 1 < h[1]?1:0;
        return _lC_?resize$0(key_index,h):_lC_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[i + 1],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :caml_check_bound(h[2],i)[i + 1] = next}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _lB_=key_index(h,key),match=caml_check_bound(h[2],_lB_)[_lB_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _lA_=key_index(h,key),match=caml_check_bound(h[2],_lA_)[_lA_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _lz_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_lz_)[_lz_ + 1])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[i + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _lw_=0}
          else
           var _lw_=1;
          if(_lw_)
           {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _lx_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_lx_)return resize$0(key_index,h);
            var _ly_=_lx_}
          else
           var _ly_=_lw_;
          return _ly_}}
      function mem(h,key)
       {var
         _lv_=key_index(h,key),
         param$0=caml_check_bound(h[2],_lv_)[_lv_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_lu_=caml_call2(H[1],k,key);
            if(_lu_)return _lu_;
            var param=next;
            continue}
          return 0}}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$5,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$7,
              filter_map_inplace,
              fold$1,
              length$4,
              stats,
              to_seq$6,
              to_seq_keys,
              to_seq_values,
              add_seq$2,
              replace_seq,
              of_seq$6]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       _lt_=include[1];
      function create(sz){return caml_call2(_lt_,_b9_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    var
     Stdlib_hashtbl=
      [0,
       create$2,
       clear$2,
       reset$0,
       copy$5,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$1,
       remove,
       replace,
       iter$7,
       filter_map_inplace,
       fold$1,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$6,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$6,
       Make,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(690,Stdlib_hashtbl,"Stdlib__hashtbl");
    function length$5(x){return x.length - 1 - 2 | 0}
    function fill$1(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! (length$5(ar) < (ofs + len | 0)))
         {var _lr_=(ofs + len | 0) - 1 | 0;
          if(! (_lr_ < ofs))
           {var i=ofs;
            for(;;)
             {caml_weak_set(ar,i,x);
              var _ls_=i + 1 | 0;
              if(_lr_ !== i){var i=_ls_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=caml_weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lp_=t[1].length - 1 - 1 | 0,_lo_=0;
        if(! (_lp_ < 0))
         {var i=_lo_;
          for(;;)
           {caml_check_bound(t[1],i)[i + 1] = emptybucket;
            caml_check_bound(t[2],i)[i + 1] = [0];
            var _lq_=i + 1 | 0;
            if(_lp_ !== i){var i=_lq_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _ln_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _ln_,
                 init)}
      function iter(f,t)
       {var _lm_=t[1],i=0;
        return iter$3
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lm_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _ll_=caml_weak_check(b,i$0)?1:0,
           accu$1=accu$0 + _ll_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _lg_=0,_lh_=t[1],_li_=0;
        return fold_right$0
                (function(_lj_,_lk_){return count_bucket(_li_,_lj_,_lk_)},
                 _lh_,
                 _lg_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=caml_weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            caml_weak_blit(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[sz + 1] = h;
            caml_check_bound(t[1],index)[index + 1] = newbucket;
            caml_check_bound(t[2],index)[index + 1] = newhashes;
            var _lc_=sz <= t[3]?1:0,_ld_=_lc_?t[3] < newsz?1:0:_lc_;
            if(_ld_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _k7_=t[5],
                 bucket=caml_check_bound(t[1],_k7_)[_k7_ + 1],
                 _k8_=t[5],
                 hbucket=caml_check_bound(t[2],_k8_)[_k8_ + 1],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(caml_weak_check(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(caml_weak_check(bucket,j))
                       {caml_weak_blit(bucket,j,bucket,i$0,1);
                        var _k9_=caml_check_bound(hbucket,j)[j + 1];
                        caml_check_bound(hbucket,i$0)[i$0 + 1] = _k9_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _k__=t[5];
                      caml_check_bound(t[1],_k__)[_k__ + 1] = emptybucket;
                      var _k$_=t[5];
                      caml_check_bound(t[2],_k$_)[_k$_ + 1] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _la_=t[3] < n?1:0,_lb_=_la_?prev_len <= t[3]?1:0:_la_;
                    if(_lb_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _lf_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_lf_;continue}
                break}}
            var _le_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_le_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_k6_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=caml_weak_check(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[j + 1],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param)
                           {return caml_weak_blit(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[i$0 + 1];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _k6_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _le_}
          if(caml_weak_check(bucket$0,i$3))
           {var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          return caml_check_bound(hashes,i$3)[i$3 + 1] = h}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,caml_weak_set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {add_aux(t,caml_weak_set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=caml_weak_get(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _k5_=0;
        return find_shadow
                (t,d,function(w,i){return caml_weak_set(w,i,0)},_k5_)}
      function mem(t,d)
       {var _k4_=0;return find_shadow(t,d,function(w,i){return 1},_k4_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$3(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _kW_=0,
         totlen=
          fold_left$1(function(_k3_,_k2_){return _k3_ + _k2_ | 0},_kW_,lens),
         _kX_=len - 1 | 0,
         _kZ_=len / 2 | 0,
         _kY_=caml_check_bound(lens,_kX_)[_kX_ + 1],
         _k0_=caml_check_bound(lens,_kZ_)[_kZ_ + 1],
         _k1_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_k1_,_k0_,_kY_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,
       caml_weak_create,
       length$5,
       caml_weak_set,
       caml_weak_get,
       caml_weak_get_copy,
       caml_weak_check,
       fill$1,
       caml_weak_blit,
       Make$0];
    caml_register_global(691,Stdlib_weak,"Stdlib__weak");
    function add_queue(x,q)
     {var c=[0,x,0],_kV_=q[1];
      return _kV_?(q[1] = c,_kV_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,cst_Stdlib_Format_Empty_queue,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _kU_=q[2];
      if(_kU_)
       {var x=_kU_[1],tl=_kU_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _kR_=state[2];
      if(_kR_)
       {var
         match=_kR_[1],
         width=match[2],
         bl_ty=match[1],
         _kS_=state[9] < width?1:0;
        if(_kS_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _kT_=0}
        else
         var _kT_=_kS_;
        return _kT_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _kG_=state[3];
          if(_kG_)
           {var
             match=_kG_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return runtime.caml_lessthan(n,x)
                          ?[0,n,ls]
                          :[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _kH_=state[2];
          if(_kH_){var ls=_kH_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _kI_=state[3];
          if(_kI_){var ls$0=_kI_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _kJ_=state[2];
          if(_kJ_)
           {var match$0=_kJ_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _kK_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _kK_?pp_skip_token(state):_kK_;
         default:
          var _kL_=state[5];
          if(_kL_)
           {var
             tags=_kL_[2],
             tag_name=_kL_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_kM_=state[2];
          if(_kM_)
           {var match$1=_kM_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _kN_=state[3];
          if(_kN_)
           {var
             match$2=_kN_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _kO_=tabs$0[1];
            if(_kO_)
             {var x=_kO_[1];
              try
               {var _kP_=find(insertion_point,tabs$0[1]),x$0=_kP_}
              catch(_kQ_)
               {_kQ_ = caml_wrap_exception(_kQ_);
                if(_kQ_ !== Not_found)throw _kQ_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _kC_=state[28][2];
        if(_kC_)
         {var
           x=_kC_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _kD_=size < 0?1:0,
           _kE_=_kD_?(state[13] - state[12] | 0) < state[9]?1:0:_kD_,
           _kF_=1 - _kE_;
          if(_kF_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _kF_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _kA_=advance_loop(state);return _kA_}
      catch(_kB_)
       {_kB_ = caml_wrap_exception(_kB_);
        if(_kB_ === Empty_queue)return 0;
        throw _kB_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_b__,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _kw_=state[1];
      if(_kw_)
       {var
         match=_kw_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_kw_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _ky_=1 - ty,
             _kz_=
              _ky_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_ky_;
            return _kz_;
           case 1:
           case 2:
            var
             _kx_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _kx_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _ku_=state[14] === state[15]?1:0;
      if(_ku_)
       {var _kv_=state[16],len=caml_ml_string_length(_kv_);
        return enqueue_string_as(state,len,_kv_)}
      return _ku_}
    function pp_close_box(state,param)
     {var _ks_=1 < state[14]?1:0;
      if(_ks_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _kt_=0}
      else
       var _kt_=_ks_;
      return _kt_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _kr_=state[23];
      return _kr_?pp_enqueue(state,[0,0,[5,tag_name],0]):_kr_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _ko_=state[22];
      if(_ko_)
       {var _kp_=state[4];
        if(_kp_)
         {var tags=_kp_[2],tag_name=_kp_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _kq_=0}
      else
       var _kq_=_ko_;
      return _kq_}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_tag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _kn_=state[28];
      _kn_[1] = 0;
      _kn_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _km_=state[4];
      iter$0(function(param){return pp_close_tag(state,0)},_km_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kl_=state[14] < state[15]?1:0;
      return _kl_?enqueue_string_as(state,size,s):_kl_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,string_of_float(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _kk_=state[14] < state[15]?1:0;
      return _kk_?enqueue_advance(state,[0,0,3,0]):_kk_}
    function pp_print_if_newline(state,param)
     {var _kj_=state[14] < state[15]?1:0;
      return _kj_?enqueue_advance(state,[0,0,4,0]):_kj_}
    function pp_print_break(state,width,offset)
     {var _ki_=state[14] < state[15]?1:0;
      if(_ki_)
       {var elem=[0,- state[13] | 0,[1,width,offset],width];
        return scan_push(state,1,elem)}
      return _ki_}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _kh_=state[14] < state[15]?1:0;
      if(_kh_)
       {var elem=[0,0,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _kh_}
    function pp_close_tbox(state,param)
     {var _ke_=1 < state[14]?1:0;
      if(_ke_)
       {var _kf_=state[14] < state[15]?1:0;
        if(_kf_)
         {var elem=[0,0,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _kg_=0}
        else
         var _kg_=_kf_}
      else
       var _kg_=_ke_;
      return _kg_}
    function pp_print_tbreak(state,width,offset)
     {var _kd_=state[14] < state[15]?1:0;
      if(_kd_)
       {var elem=[0,- state[13] | 0,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _kd_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kc_=state[14] < state[15]?1:0;
      if(_kc_){var elem=[0,0,0,0];return enqueue_advance(state,elem)}
      return _kc_}
    function pp_set_max_boxes(state,n)
     {var _ka_=1 < n?1:0,_kb_=_ka_?(state[15] = n,0):_ka_;return _kb_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var n$1=state[6] - n$0 | 0,_j$_=1 <= n$1?1:0;
      if(_j$_)
       {var n=pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state)}
      return _j$_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _j__=1 <= n?1:0;
      if(_j__)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _j__}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$66,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _j9_=0 < n$0?1:0;
        if(_j9_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _j9_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_j6_,_j7_,_j8_){return output_substring(oc,_j6_,_j7_,_j8_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_j5_){return display_newline(state,_j5_)};
      state[20] = function(_j4_){return display_indent(state,_j4_)};
      state[21] = function(_j3_){return display_indent(state,_j3_)};
      return 0}
    function default_pp_mark_open_tag(s){return _g_(cst$68,_g_(s,cst$67))}
    function default_pp_mark_close_tag(s){return _g_(cst$70,_g_(s,cst$69))}
    function default_pp_print_open_tag(_j2_){return 0}
    function default_pp_print_close_tag(_j1_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=[0,0,0],sys_tok=[0,-1,_b$_,0];
      add_queue(sys_tok,pp_queue);
      var sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom];
      return [0,
              sys_scan_stack,
              0,
              0,
              0,
              0,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$71,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _jT_(_j0_){return 0}
      function _jU_(_jZ_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_jY_){return 0},_jU_,_jT_);
      ppf[19] = function(_jX_){return display_newline(ppf,_jX_)};
      ppf[20] = function(_jW_){return display_indent(ppf,_jW_)};
      ppf[21] = function(_jV_){return display_indent(ppf,_jV_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _jP_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_jQ_,_jR_,_jS_)
                {return output_substring(oc,_jQ_,_jR_,_jS_)},
               _jP_)}
    function formatter_of_buffer(b)
     {function _jK_(_jO_){return 0}
      return make_formatter
              (function(_jL_,_jM_,_jN_)
                {return add_substring(b,_jL_,_jM_,_jN_)},
               _jK_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(_o_[27]),
     err_formatter=formatter_of_out_channel(_o_[28]),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_jJ_){return add_symbolic_output_item(sob,0)}
      function h(_jI_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_jH_){return pp_open_hbox(std_formatter,_jH_)}
    function open_vbox(_jG_){return pp_open_vbox(std_formatter,_jG_)}
    function open_hvbox(_jF_){return pp_open_hvbox(std_formatter,_jF_)}
    function open_hovbox(_jE_){return pp_open_hovbox(std_formatter,_jE_)}
    function open_box(_jD_){return pp_open_box(std_formatter,_jD_)}
    function close_box(_jC_){return pp_close_box(std_formatter,_jC_)}
    function open_tag(_jB_){return pp_open_tag(std_formatter,_jB_)}
    function close_tag(_jA_){return pp_close_tag(std_formatter,_jA_)}
    function print_as(_jy_,_jz_){return pp_print_as(std_formatter,_jy_,_jz_)}
    function print_string$0(_jx_){return pp_print_string(std_formatter,_jx_)}
    function print_int$0(_jw_){return pp_print_int(std_formatter,_jw_)}
    function print_float$0(_jv_){return pp_print_float(std_formatter,_jv_)}
    function print_char$0(_ju_){return pp_print_char(std_formatter,_ju_)}
    function print_bool(_jt_){return pp_print_bool(std_formatter,_jt_)}
    function print_break(_jr_,_js_)
     {return pp_print_break(std_formatter,_jr_,_js_)}
    function print_cut(_jq_){return pp_print_cut(std_formatter,_jq_)}
    function print_space(_jp_){return pp_print_space(std_formatter,_jp_)}
    function force_newline(_jo_){return pp_force_newline(std_formatter,_jo_)}
    function print_flush(_jn_){return pp_print_flush(std_formatter,_jn_)}
    function print_newline$0(_jm_)
     {return pp_print_newline(std_formatter,_jm_)}
    function print_if_newline(_jl_)
     {return pp_print_if_newline(std_formatter,_jl_)}
    function open_tbox(_jk_){return pp_open_tbox(std_formatter,_jk_)}
    function close_tbox(_jj_){return pp_close_tbox(std_formatter,_jj_)}
    function print_tbreak(_jh_,_ji_)
     {return pp_print_tbreak(std_formatter,_jh_,_ji_)}
    function set_tab(_jg_){return pp_set_tab(std_formatter,_jg_)}
    function print_tab(_jf_){return pp_print_tab(std_formatter,_jf_)}
    function set_margin(_je_){return pp_set_margin(std_formatter,_je_)}
    function get_margin(_jd_){return std_formatter[6]}
    function set_max_indent(_jc_)
     {return pp_set_max_indent(std_formatter,_jc_)}
    function get_max_indent(_jb_){return std_formatter[8]}
    function set_max_boxes(_ja_){return pp_set_max_boxes(std_formatter,_ja_)}
    function get_max_boxes(_i$_){return std_formatter[15]}
    function over_max_boxes(_i__)
     {return pp_over_max_boxes(std_formatter,_i__)}
    function set_ellipsis_text(_i9_)
     {return pp_set_ellipsis_text(std_formatter,_i9_)}
    function get_ellipsis_text(_i8_){return std_formatter[16]}
    function set_formatter_out_channel(_i7_)
     {return pp_set_formatter_out_channel(std_formatter,_i7_)}
    function set_formatter_out_functions(_i6_)
     {return pp_set_formatter_out_functions(std_formatter,_i6_)}
    function get_formatter_out_functions(_i5_)
     {return pp_get_formatter_out_functions(std_formatter,_i5_)}
    function set_formatter_output_functions(_i3_,_i4_)
     {return pp_set_formatter_output_functions(std_formatter,_i3_,_i4_)}
    function get_formatter_output_functions(_i2_)
     {return pp_get_formatter_output_functions(std_formatter,_i2_)}
    function set_formatter_tag_functions(_i1_)
     {return pp_set_formatter_tag_functions(std_formatter,_i1_)}
    function get_formatter_tag_functions(_i0_)
     {return pp_get_formatter_tag_functions(std_formatter,_i0_)}
    function set_print_tags(_iZ_)
     {return pp_set_print_tags(std_formatter,_iZ_)}
    function get_print_tags(_iY_){return std_formatter[22]}
    function set_mark_tags(_iX_){return pp_set_mark_tags(std_formatter,_iX_)}
    function get_mark_tags(_iW_){return std_formatter[23]}
    function set_tags(_iV_){return pp_set_tags(std_formatter,_iV_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _iT_=param$0[2],_iU_=param$0[1];
          if(_iT_)
           {caml_call2(pp_v,ppf,_iU_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_iT_;
            continue}
          return caml_call2(pp_v,ppf,_iU_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _iS_=left[1] !== len?1:0;
        return _iS_?flush(0):_iS_}}
    function compute_tag(output,tag_acc)
     {var buf=create$1(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iI_=acc[2],_iJ_=acc[1];
          if(0 === _iI_[0])
           {var acc$0=_iI_[1];
            output_acc$0(ppf,_iJ_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_iI_[1];
          output_acc$0(ppf,_iJ_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iK_=acc[1];
          if(typeof _iK_ === "number")
           var switch$1=1;
          else
           if(0 === _iK_[0])
            {var _iL_=_iK_[2];
             if(typeof _iL_ === "number")
              var switch$2=1;
             else
              if(1 === _iL_[0])
               var
                s$0=acc[2],
                size=_iL_[2],
                p$1=_iK_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_iK_,switch$0=2;
          break;
         case 3:
          var _iM_=acc[1];
          if(typeof _iM_ === "number")
           var switch$3=1;
          else
           if(0 === _iM_[0])
            {var _iN_=_iM_[2];
             if(typeof _iN_ === "number")
              var switch$4=1;
             else
              if(1 === _iN_[0])
               var
                c$0=acc[2],
                size$0=_iN_[2],
                p$3=_iM_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_iM_,switch$0=3;
          break;
         case 4:
          var _iO_=acc[1];
          if(typeof _iO_ === "number")
           var switch$5=1;
          else
           if(0 === _iO_[0])
            {var _iP_=_iO_[2];
             if(typeof _iP_ === "number")
              var switch$6=1;
             else
              if(1 === _iP_[0])
               var
                s$0=acc[2],
                size=_iP_[2],
                p$1=_iO_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_iO_,switch$0=2;
          break;
         case 5:
          var _iQ_=acc[1];
          if(typeof _iQ_ === "number")
           var switch$7=1;
          else
           if(0 === _iQ_[0])
            {var _iR_=_iQ_[2];
             if(typeof _iR_ === "number")
              var switch$8=1;
             else
              if(1 === _iR_[0])
               var
                c$0=acc[2],
                size$0=_iR_[2],
                p$3=_iQ_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_iQ_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iw_=acc[2],_ix_=acc[1];
          if(0 === _iw_[0])
           {var acc$0=_iw_[1];
            strput_acc$0(ppf,_ix_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_iw_[1];
          strput_acc$0(ppf,_ix_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iy_=acc[1];
          if(typeof _iy_ === "number")
           var switch$1=1;
          else
           if(0 === _iy_[0])
            {var _iz_=_iy_[2];
             if(typeof _iz_ === "number")
              var switch$2=1;
             else
              if(1 === _iz_[0])
               var
                s$0=acc[2],
                size=_iz_[2],
                p$1=_iy_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_iy_,switch$0=2;
          break;
         case 3:
          var _iA_=acc[1];
          if(typeof _iA_ === "number")
           var switch$3=1;
          else
           if(0 === _iA_[0])
            {var _iB_=_iA_[2];
             if(typeof _iB_ === "number")
              var switch$4=1;
             else
              if(1 === _iB_[0])
               var
                c$0=acc[2],
                size$0=_iB_[2],
                p$3=_iA_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_iA_,switch$0=3;
          break;
         case 4:
          var _iC_=acc[1];
          if(typeof _iC_ === "number")
           var switch$5=1;
          else
           if(0 === _iC_[0])
            {var _iD_=_iC_[2];
             if(typeof _iD_ === "number")
              var switch$6=1;
             else
              if(1 === _iD_[0])
               var
                s$0=acc[2],
                size=_iD_[2],
                p$1=_iC_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_iC_,switch$0=2;
          break;
         case 5:
          var _iE_=acc[1];
          if(typeof _iE_ === "number")
           var switch$7=1;
          else
           if(0 === _iE_[0])
            {var _iF_=_iE_[2];
             if(typeof _iF_ === "number")
              var switch$8=1;
             else
              if(1 === _iF_[0])
               var
                c$0=acc[2],
                size$0=_iF_[2],
                p$3=_iE_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_iE_,switch$0=3;
          break;
         case 6:
          var _iG_=acc[1];
          if(typeof _iG_ !== "number" && 0 === _iG_[0])
           {var _iH_=_iG_[2];
            if(typeof _iH_ !== "number" && 1 === _iH_[0])
             {var f$1=acc[2],size$1=_iH_[2],p$4=_iG_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_iG_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iv_=0;
      return make_printf
              (function(ppf,acc)
                {output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               ppf,
               _iv_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function fprintf$0(ppf)
     {function _is_(_iu_){return 0}
      return function(_it_){return kfprintf$0(_is_,ppf,_it_)}}
    function ifprintf$0(ppf)
     {function _ip_(_ir_){return 0}
      return function(_iq_){return ikfprintf$0(_ip_,ppf,_iq_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function ksprintf$0(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf$0(function(s){return s},fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(ppf,acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,ppf,0,fmt)}
    function asprintf(fmt){return kasprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_il_,_im_,_in_,_io_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_il_,_im_,_in_,_io_)}
    function get_all_formatter_output_functions(_ik_)
     {return pp_get_all_formatter_output_functions(std_formatter,_ik_)}
    function bprintf$0(b,param)
     {var fmt=param[1];
      function k(ppf,acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,formatter_of_buffer(b),0,fmt)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       ifprintf$0,
       kfprintf$0,
       ikfprintf$0,
       ksprintf$0,
       kasprintf,
       bprintf$0,
       ksprintf$0,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions];
    caml_register_global(692,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_ij_)
       {_ij_ = caml_wrap_exception(_ij_);
        if(_ij_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _ij_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _ii_=ib[9];
      if(typeof _ii_ === "number")
       return 0 === _ii_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _ii_[0])return cst_unnamed_Pervasives_input_channel;
        var fname=_ii_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$3(1,next)}
    var _ca_=0;
    function from_function$0(_ih_){return create$3(_ca_,_ih_)}
    var len=1024;
    function scan_close_at_end(ic){caml_call1(_o_[81],ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$72,_o_[26]],_o_[26]);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$73))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    var _cb_=_o_[67];
    function from_file(_ig_){return open_in_file(_cb_,_ig_)}
    var _cc_=_o_[68];
    function from_file_bin(_if_){return open_in_file(_cc_,_if_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in(ib)
     {var _ie_=ib[9];
      if(typeof _ie_ === "number")
       return 0;
      else
       {if(0 === _ie_[0]){var ic=_ie_[1];return caml_call1(_o_[81],ic)}
        var ic$0=_ie_[2];
        return caml_call1(_o_[81],ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _ic_=assq(ic,memo[1]);return _ic_}
      catch(_id_)
       {_id_ = caml_wrap_exception(_id_);
        if(_id_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _id_}}
    function memo_from_channel(_ib_)
     {return memo_from_ic(scan_raise_at_end,_ib_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_cd_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_ce_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cg_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_h$_=1 - ib[1];
         if(_h$_)
          {var
            _ia_=c - 9 | 0,
            switch$0=
             4 < _ia_ >>> 0?23 === _ia_?1:0:1 < (_ia_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _h$_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$2)
              ?caml_string_notequal(s,cst_true$2)
                ?bad_input(caml_call1(sprintf(_ch_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_ci_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=_g_(cst_0b,token_string(ib));break;
        case 3:var tok=_g_(cst_0o,token_string(ib));break;
        case 4:var tok=_g_(cst_0u,token_string(ib));break;
        case 5:var tok=_g_(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cj_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ck_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_h9_,_h__)
     {return scan_digit_plus(cst_binary,is_binary_digit,_h9_,_h__)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_h7_,_h8_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_h7_,_h8_)}
    function is_hexa_digit(param)
     {var
       _h6_=param - 48 | 0,
       switch$0=
        22 < _h6_ >>> 0
         ?5 < (_h6_ - 49 | 0) >>> 0?0:1
         :6 < (_h6_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_h4_,_h5_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_h4_,_h5_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _h1_=len - 1 | 0,
       _h0_=0;
      if(! (_h1_ < 0))
       {var i=_h0_;
        for(;;)
         {var c=peek_char(ib),_h2_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _h2_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _h3_=i + 1 | 0;
          if(_h1_ !== i){var i=_h3_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _hN_=0 === width?1:0,_hO_=_hN_ || end_of_input(ib);
      if(_hO_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _hP_=0 === width$0?1:0,
       _hQ_=_hP_ || end_of_input(ib);
      if(_hQ_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _hR_=0 === width$1?1:0,
             _hS_=_hR_ || end_of_input(ib);
            if(_hS_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _hV_=0 === width$3?1:0,
           _hW_=_hV_ || end_of_input(ib);
          if(_hW_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _hX_=match - 46 | 0,
              switch$1=
               34 < _hX_ >>> 0?66 === _hX_?1:0:32 < (_hX_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _hY_=0 === width$9?1:0,
                    _hZ_=_hY_ || end_of_input(ib);
                   if(_hZ_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _hT_=0 === width$2?1:0,
         _hU_=_hT_ || end_of_input(ib);
        if(_hU_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hJ_=0 === width?1:0,_hK_=_hJ_ || end_of_input(ib);
      if(_hK_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _hL_=0 === width$0?1:0,
       _hM_=_hL_ || end_of_input(ib);
      if(_hM_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hv_=0 === width?1:0,_hw_=_hv_ || end_of_input(ib);
      if(_hw_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hx_=0 === width$0?1:0,
       _hy_=_hx_ || end_of_input(ib);
      if(_hy_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hz_=0 === width$1?1:0,
           _hA_=_hz_ || end_of_input(ib);
          if(_hA_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _hB_=0 === width$2?1:0,
          _hC_=_hB_ || end_of_input(ib);
         if(_hC_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hD_=0 === width$3?1:0,
          _hE_=_hD_ || end_of_input(ib);
         if(_hE_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hF_=0 === width$4?1:0,
          _hG_=_hF_ || end_of_input(ib);
         if(_hG_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _hH_=0 === width$9?1:0,
             _hI_=_hH_ || end_of_input(ib);
            if(_hI_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _hu_=c - 9 | 0,
         switch$0=4 < _hu_ >>> 0?23 === _hu_?1:0:1 < (_hu_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cf_),message)):c}
    function check_next_char_for_char(_hs_,_ht_)
     {return check_next_char(cst_a_Char,_hs_,_ht_)}
    function check_next_char_for_string(_hq_,_hr_)
     {return check_next_char(cst_a_String,_hq_,_hr_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _hp_=c - 48 | 0,
                  switch$0=
                   22 < _hp_ >>> 0
                    ?5 < (_hp_ - 49 | 0) >>> 0?0:1
                    :6 < (_hp_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _hl_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _hl_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _hn_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _hn_=bad_input(caml_call2(sprintf(_cm_),c1,c2));
             return store_char(width - 2 | 0,ib,_hn_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _ho_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _ho_=bad_input(caml_call3(sprintf(_cl_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ho_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _hm_=10,switch$3=1;break;
             case 4:var _hm_=13,switch$3=1;break;
             case 6:var _hm_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _hm_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _hm_=c0;
        return store_char(width,ib,_hm_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _hj_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_hj_)}
              return caml_trampoline_return(skip_spaces,[0,_hj_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hk_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hk_)}
                return caml_trampoline_return(skip_spaces,[0,_hk_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_hf_=0 < i$0?1:0;
          if(_hf_)
           {var _hg_=1 - ib[1];
            if(_hg_)
             var _hh_=is_in_char_set(char_set,c),_hi_=_hh_?c !== stp?1:0:_hh_;
            else
             var _hi_=_hg_}
          else
           var _hi_=_hf_;
          if(_hi_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _hi_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _he_=1 - ib[1];
        if(_he_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _he_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_co_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cp_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_hc_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_hc_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_hc_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _hd_=fmt$0[1];
           if(0 === _hd_[0])
            {var
              rest$0=fmt$0[2],
              match=_hd_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_hd_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _hb_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_hb_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_hb_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _gY_=fmt$0[2],_gZ_=fmt$0[1];
           if(typeof _gY_ !== "number")
            switch(_gY_[0])
             {case 17:
               var
                rest$1=_gY_[2],
                fmting_lit=_gY_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_gZ_,0,scan$0,token_string);
              case 18:
               var _g0_=_gY_[1];
               if(0 === _g0_[0])
                {var
                  rest$2=_gY_[2],
                  match$0=_g0_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cq_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _gZ_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_gY_[2],
                match$1=_g0_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cr_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _gZ_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_gY_,readers,_gZ_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _g1_=fmt$0[1];
           if(15 === _g1_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _g1_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_ha_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cn_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$2(function(_g$_){return check_char(ib,_g$_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _g2_=format_of_string_fmtty(s,fmtty),fmt$3=_g2_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _g4_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_g4_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _g3_=bad_input(msg$0),
              fmt$5=_g3_[1],
              fmt$4=_g3_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _g5_=string_of_formatting_lit(formatting_lit);
           iter$2(function(_g__){return check_char(ib,_g__)},_g5_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _g6_=fmt$0[1];
           if(0 === _g6_[0])
            {var rest$19=fmt$0[2],match$4=_g6_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_g6_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _g7_=fmt$0[3],_g8_=fmt$0[2],_g9_=fmt$0[1];
           if(typeof _g7_ !== "number" && 17 === _g7_[0])
            {var
              rest$21=_g7_[2],
              fmting_lit$0=_g7_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_g9_);
             scan_chars_in_char_set(_g8_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_g9_);
           scan_chars_in_char_set(_g8_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_g7_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cs_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _gX_=[0,make_scanf(ib,fmt,readers)],_gW_=_gX_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _gV_=
                invalid_arg
                 (_g_(msg,_g_(cst_in_format,_g_(escaped$1(str),cst$74)))),
               switch$0=1}
          if(! switch$0)var _gV_=[1,exc];
          var _gW_=_gV_}
        if(0 === _gW_[0]){var args=_gW_[1];return apply(f,args)}
        var exc=_gW_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _gU_=format_of_string_format(str,format),fmt=_gU_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {var l=caml_ml_string_length(s);
      function _gT_(x){return x}
      var b=create$1(l + 2 | 0);
      add_char(b,34);
      var _gR_=l - 1 | 0,_gQ_=0;
      if(! (_gR_ < 0))
       {var i=_gQ_;
        for(;;)
         {var c=caml_string_get(s,i);
          if(34 === c)add_char(b,92);
          add_char(b,c);
          var _gS_=i + 1 | 0;
          if(_gR_ !== i){var i=_gS_;continue}
          break}}
      add_char(b,34);
      return sscanf_format(contents(b),fmt,_gT_)}
    function unescaped(s)
     {function _gP_(x){return x}
      return caml_call1(sscanf(_g_(cst$76,_g_(s,cst$75)),_ct_),_gP_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(693,Stdlib_scanf,"Stdlib__scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(694,Stdlib_callback,"Stdlib__callback");
    function copy$6(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_gM_=caml_ml_string_length(s) - 1 | 0,_gL_=0;
      if(! (_gM_ < 0))
       {var i=_gL_;
        for(;;)
         {var _gN_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _gN_ | 0;
          var _gO_=i + 1 | 0;
          if(_gM_ !== i){var i=_gO_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$6=caml_string_compare,
     Vars=caml_call1(Stdlib_map[1],[0,compare$6]),
     compare$7=caml_string_compare,
     Meths=caml_call1(Stdlib_map[1],[0,compare$7]),
     compare$8=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$8]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _gF_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _gF_;
      var _gH_=len - 1 | 0,_gG_=0;
      if(! (_gH_ < 0))
       {var i=_gG_;
        for(;;)
         {var
           _gJ_=(i * 2 | 0) + 3 | 0,
           _gI_=caml_check_bound(pub_labels,i)[i + 1];
          caml_check_bound(methods,_gJ_)[_gJ_ + 1] = _gI_;
          var _gK_=i + 1 | 0;
          if(_gH_ !== i){var i=_gK_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gD_=old_size < new_size?1:0;
      if(_gD_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gE_=0}
      else
       var _gE_=_gD_;
      return _gE_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gB_=caml_call2(Meths[27],name,table[3]);return _gB_}
      catch(_gC_)
       {_gC_ = caml_wrap_exception(_gC_);
        if(_gC_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gC_}}
    function get_method_labels(table,names)
     {return map$3(function(_gA_){return get_method_label(table,_gA_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[label + 1]
                =
                element)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gy_=assoc(label,table[6]);return _gy_}
      catch(_gz_)
       {_gz_ = caml_wrap_exception(_gz_);
        if(_gz_ === Not_found)
         return caml_check_bound(table[2],label)[label + 1];
        throw _gz_}}
    function to_list$0(arr){return arr === 0?0:to_list(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$0(vars),
       virt_meths$0=to_list$0(virt_meths),
       concr_meths$0=to_list$0(concr_meths),
       virt_meth_labs=
        map$0
         (function(_gx_){return get_method_label(table,_gx_)},virt_meths$0),
       concr_meth_labs=
        map$0
         (function(_gw_){return get_method_label(table,_gw_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gn_=Vars[1],_go_=table[7];
      function _gp_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gp_,_go_,_gn_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gs_=by_label[1];
          try
           {var _gu_=caml_call2(Labs[27],label,table[4]),_gt_=_gu_}
          catch(_gv_)
           {_gv_ = caml_wrap_exception(_gv_);
            if(_gv_ !== Not_found)throw _gv_;
            var _gt_=1}
          by_label[1] = caml_call3(Labs[4],label,_gt_,_gs_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _gq_=0,_gr_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gr_,
        _gq_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gm_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_gm_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gl_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gl_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _gj_=caml_call2(Vars[27],name,table[7]);return _gj_}
      catch(_gk_)
       {_gk_ = caml_wrap_exception(_gk_);
        if(_gk_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$77))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gk_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _gb_=nmeths - 1 | 0,
       _ga_=0;
      if(! (_gb_ < 0))
       {var i$0=_ga_;
        for(;;)
         {var
           _gh_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[i$0 + 1]);
          caml_check_bound(res,i$0)[i$0 + 1] = _gh_;
          var _gi_=i$0 + 1 | 0;
          if(_gb_ !== i$0){var i$0=_gi_;continue}
          break}}
      var _gd_=nvals - 1 | 0,_gc_=0;
      if(! (_gd_ < 0))
       {var i=_gc_;
        for(;;)
         {var
           _gf_=i + nmeths | 0,
           _ge_=new_variable(table,caml_check_bound(vals,i)[i + 1]);
          caml_check_bound(res,_gf_)[_gf_ + 1] = _ge_;
          var _gg_=i + 1 | 0;
          if(_gd_ !== i){var i=_gg_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _f__=caml_call2(Vars[27],name,table[7]);return _f__}
      catch(_f$_)
       {_f$_ = caml_wrap_exception(_f$_);
        if(_f$_ === Not_found)throw [0,Assert_failure,_cu_];
        throw _f$_}}
    function get_variables(table,names)
     {return map$3(function(_f9_){return get_variable(table,_f9_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$3(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _f4_=0,
       _f5_=to_array(concr_meths),
       _f6_=
        [0,
         map$3
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_f5_),
         _f4_],
       _f7_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$3(function(_f8_){return get_variable(cla,_f8_)},_f7_),
                 _f6_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_f3_=0 !== inits?1:0;
      return _f3_?iter_f(obj,inits):_f3_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cy_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_fZ_=0;
      if(! (n < 0))
       {var i=_fZ_;
        for(;;)
         {var _f1_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[i + 1],_f1_,0];
          var _f2_=i + 1 | 0;
          if(n !== i){var i=_f2_;continue}
          break}}
      var _f0_=r[1];
      if(tables){tables[2] = _f0_;return res}
      throw [0,Assert_failure,_cv_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[i + 1],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cA_]}
                if(tables$0)
                 {var _fY_=tables$0[3];
                  if(_fY_){var tables$0=_fY_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cw_]}
                throw [0,Assert_failure,_cz_]}
              throw [0,Assert_failure,_cx_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[n$0 + 1] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _fS_=i[1],
           label=caml_check_bound(methods,_fS_)[_fS_ + 1],
           next=
            function(param)
             {i[1]++;
              var _fX_=i[1];
              return caml_check_bound(methods,_fX_)[_fX_ + 1]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[n + 1]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[e + 1][n + 1]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][n + 1],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[n + 1] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[n + 1])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[e + 1][n + 1])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][n + 1],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[n + 1])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[e + 1][n + 1])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][n + 1],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[n + 1],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[e + 1][n + 1],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][n + 1],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[m + 1])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[e + 1][m + 1])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _fV_=caml_call1(obj[1][m + 1],obj);
                     return caml_call2(obj[1][n + 1],obj,_fV_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fU_=obj[n + 1];
                     return caml_call2(caml_get_public_method(_fU_,m,0),_fU_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _fT_=obj[e + 1][n + 1];
                     return caml_call2(caml_get_public_method(_fT_,m,0),_fT_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fW_=caml_call1(obj[1][n + 1],obj);
                     return caml_call2(caml_get_public_method(_fW_,m,0),_fW_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$6,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(695,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$6,public_method_label,public_method_label];
    caml_register_global(696,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(697,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$0
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _fQ_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _fQ_}
        catch(_fR_)
         {_fR_ = caml_wrap_exception(_fR_);
          if(_fR_ === Not_found)return [1,id];
          throw _fR_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _fO_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _fO_}
        catch(_fP_)
         {_fP_ = caml_wrap_exception(_fP_);
          if(_fP_ === Not_found)throw [0,Error,_g_(cst_Illegal_character,s)];
          throw _fP_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fN_=match[1],switcher=_fN_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_fN_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fM_=match[1],switch$0=43 === _fM_?0:45 === _fM_?0:1;
          if(! switch$0)
           {junk(strm);store(_fM_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _fJ_=match[1];
            if(58 <= _fJ_)
             {var switch$0=69 === _fJ_?0:101 === _fJ_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _fJ_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _fK_=match$0[1],_fL_=_fK_ - 69 | 0;
                    if(32 < _fL_ >>> 0)
                     {var switcher=_fL_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_fK_);continue}}
                    else
                     {var switcher$0=_fL_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _fJ_){junk(s);store(_fJ_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fH_=match[1];
            if(94 <= _fH_)
             var
              _fI_=_fH_ - 95 | 0,
              switch$0=30 < _fI_ >>> 0?32 <= _fI_?1:0:29 === _fI_?0:1;
            else
             if(65 <= _fH_)
              var switch$0=92 === _fH_?0:1;
             else
              if(33 <= _fH_)
               switch(_fH_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_fH_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fG_=match[1],switcher=_fG_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fG_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fE_=match[1];
            if(91 <= _fE_)
             var
              _fF_=_fE_ - 95 | 0,
              switch$0=27 < _fF_ >>> 0?97 <= _fF_?0:1:1 === _fF_?1:0;
            else
             var
              switch$0=
               48 <= _fE_?6 < (_fE_ - 58 | 0) >>> 0?0:1:39 === _fE_?0:1;
            if(! switch$0){junk(strm);store(_fE_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fv_=match[1];
            if(124 <= _fv_)
             var switch$0=127 <= _fv_?192 <= _fv_?1:0:125 === _fv_?0:2;
            else
             {var _fw_=_fv_ - 65 | 0;
              if(57 < _fw_ >>> 0)
               if(58 <= _fw_)
                var switch$0=0;
               else
                {var switcher=_fw_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _fy_=match$1[1];
                        if(34 === _fy_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _fy_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_fD_)
                           {_fD_ = caml_wrap_exception(_fD_);
                            if(_fD_ === Failure$0)throw [0,Error,cst$80];
                            throw _fD_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_fy_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _fz_=match$2[1];
                      if(92 === _fz_)
                       {junk(strm);
                        try
                         {var _fA_=escape(strm)}
                        catch(_fC_)
                         {_fC_ = caml_wrap_exception(_fC_);
                          if(_fC_ === Failure$0)throw [0,Error,cst$81];
                          throw _fC_}
                        var c=_fA_}
                      else
                       {junk(strm);var c=_fz_}}
                    catch(_fB_)
                     {_fB_ = caml_wrap_exception(_fB_);
                      if(_fB_ === Failure$0)throw [0,Error,cst$78];
                      throw _fB_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$79];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_fv_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _fx_=_fw_ - 26 | 0;
                if(5 < _fx_ >>> 0)
                 var switch$0=1;
                else
                 switch(_fx_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_fv_)];
              case 1:
               junk(strm);reset_buffer(0);store(_fv_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_fv_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fs_=match[1];
          if(58 <= _fs_)
           {var switcher=_fs_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _fs_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _ft_=match$0[1],switcher$0=_ft_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _fu_=match$1[1],switcher$1=_fu_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_fs_ - 48 | 0) * 100 | 0)
                               +
                               ((_ft_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_fu_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$83]}}
             throw [0,Error,cst$82]}
          junk(strm);
          return _fs_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _fr_=match$1[1];
                    if(41 === _fr_){junk(strm);return 0}
                    if(42 === _fr_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(698,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fq_){return caml_call1(_b6_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fo_=caml_obj_tag(prng),
            _fp_=250 === _fo_?prng[1]:246 === _fo_?force_lazy_block(prng):prng,
            seed=caml_call1(_b6_[4],_fp_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_fm_=len - 1 | 0,_fl_=0;
        if(! (_fm_ < 0))
         {var i=_fl_;
          for(;;)
           {caml_check_bound(h[2],i)[i + 1] = 0;
            var _fn_=i + 1 | 0;
            if(_fm_ !== i){var i=_fn_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fi_=init[4],_fj_=init[3],_fk_=copy$1(init[2]);
        return [0,init[1],_fk_,_fj_,_fi_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_ff_=d.length - 1 - 1 | 0,_fe_=0;
        if(! (_ff_ < 0))
         {var i=_fe_;
          for(;;)
           {var _fg_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _fg_;
            var _fh_=i + 1 | 0;
            if(_ff_ !== i){var i=_fh_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _e__=nsize < max_array_length?1:0,
         _e$_=_e__?(osize >>> 1 | 0) <= h[1]?1:0:_e__;
        if(_e$_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                return ndata[nidx + 1]
                       =
                       [0,hkey,data,caml_check_bound(ndata,nidx)[nidx + 1]]}
              return 0},
           _fb_=osize - 1 | 0,
           _fa_=0;
          if(! (_fb_ < 0))
           {var i=_fa_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[i + 1]);
              var _fd_=i + 1 | 0;
              if(_fb_ !== i){var i=_fd_;continue}
              break}}
          var _fc_=0}
        else
         var _fc_=_e$_;
        return _fc_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _e9_=h[2].length - 1 << 1 < h[1]?1:0;
        return _e9_?resize(h):_e9_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _e8_=remove_bucket(caml_check_bound(h[2],i)[i + 1]);
        return caml_check_bound(h[2],i)[i + 1] = _e8_}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e7_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e7_)[_e7_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e6_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e6_)[_e6_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _e5_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_e5_)[_e5_ + 1])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[i + 1];
        try
         {var _e3_=replace_bucket(l);return _e3_}
        catch(_e4_)
         {_e4_ = caml_wrap_exception(_e4_);
          if(_e4_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[i + 1] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _e2_=h[2].length - 1 << 1 < h[1]?1:0;
            return _e2_?resize(h):_e2_}
          throw _e4_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e1_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e1_)[_e1_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_eZ_=d$0.length - 1 - 1 | 0,_eY_=0;
        if(! (_eZ_ < 0))
         {var i=_eY_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[i + 1],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _e0_=i + 1 | 0;
              if(_eZ_ !== i){var i=_e0_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_eV_=d$0.length - 1 - 1 | 0,_eU_=0;
        if(! (_eV_ < 0))
         {var i=_eU_;
          a:
          for(;;)
           {var
             _eW_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[i + 1],
             b=b$0,
             accu=_eW_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _eX_=i + 1 | 0;
              if(_eV_ !== i){var i=_eX_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eR_=d.length - 1 - 1 | 0,_eQ_=0;
        if(! (_eR_ < 0))
         {var i=_eQ_;
          for(;;)
           {var _eS_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _eS_;
            var _eT_=i + 1 | 0;
            if(_eR_ !== i){var i=_eT_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _eN_=h[2],
         _eO_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_eO_,_eN_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eP_=h[2];
        iter$3
         (function(b)
           {var l=bucket_length(0,b);
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eP_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _eK_=h[2],
         _eL_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_eL_,_eK_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eM_=h[2];
        iter$3
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eM_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var data=match$0[1],key=match[1];
                 return [0,
                         [0,key,data],
                         function(_eJ_){return aux(i$0,next,_eJ_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eG_=0,_eH_=0;
        return function(_eI_){return aux(_eH_,_eG_,_eI_)}}
      function to_seq_keys(m)
       {var _eC_=to_seq(m);
        function _eD_(_eF_){return _eF_[1]}
        return function(_eE_){return map(_eD_,_eC_,_eE_)}}
      function to_seq_values(m)
       {var _ey_=to_seq(m);
        function _ez_(_eB_){return _eB_[2]}
        return function(_eA_){return map(_ez_,_ey_,_eA_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$4(param){return caml_call1(_I_[1],1)}
    function get_key(t){return caml_call2(_I_[3],t,0)}
    function get_key_copy(t){return caml_call2(_I_[4],t,0)}
    function set_key(t,k){return caml_call3(_I_[5],t,0,k)}
    function unset_key(t){return caml_call2(_I_[6],t,0)}
    function check_key(t){return caml_call2(_I_[7],t,0)}
    function blit_key(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_I_[9],t)}
    function get_data_copy(t){return caml_call1(_I_[10],t)}
    function set_data(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data(t){return caml_call1(_I_[12],t)}
    function check_data(t){return caml_call1(_I_[13],t)}
    function blit_data(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$4(0);set_data(c,d);set_key(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$1,get_key,set_key_data,check_key])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _ex_=include[1];
      function create(sz){return caml_call2(_ex_,_cB_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_I_[1],2)}
    function get_key1(t){return caml_call2(_I_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_I_[4],t,0)}
    function set_key1(t,k){return caml_call3(_I_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_I_[6],t,0)}
    function check_key1(t){return caml_call2(_I_[7],t,0)}
    function get_key2(t){return caml_call2(_I_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_I_[4],t,1)}
    function set_key2(t,k){return caml_call3(_I_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_I_[6],t,1)}
    function check_key2(t){return caml_call2(_I_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_I_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_I_[9],t)}
    function get_data_copy$0(t){return caml_call1(_I_[10],t)}
    function set_data$0(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data$0(t){return caml_call1(_I_[12],t)}
    function check_data$0(t){return caml_call1(_I_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$5(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _ew_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _ew_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _ev_=check_key1(c);return _ev_?check_key2(c):_ev_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_et_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_et_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _eu_=include[1];
      function create(sz){return caml_call2(_eu_,_cC_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(n){return caml_call1(_I_[1],n)}
    function length$6(k){return caml_call1(_I_[2],k)}
    function get_key$0(t,n){return caml_call2(_I_[3],t,n)}
    function get_key_copy$0(t,n){return caml_call2(_I_[4],t,n)}
    function set_key$0(t,n,k){return caml_call3(_I_[5],t,n,k)}
    function unset_key$0(t,n){return caml_call2(_I_[6],t,n)}
    function check_key$0(t,n){return caml_call2(_I_[7],t,n)}
    function blit_key$0(t1,o1,t2,o2,l)
     {return caml_call5(_I_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_I_[9],t)}
    function get_data_copy$1(t){return caml_call1(_I_[10],t)}
    function set_data$1(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data$1(t){return caml_call1(_I_[12],t)}
    function check_data$1(t){return caml_call1(_I_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$6(k.length - 1);
        set_data$1(c,d);
        var _er_=k.length - 1 - 1 | 0,_eq_=0;
        if(! (_er_ < 0))
         {var i=_eq_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _es_=i + 1 | 0;
            if(_er_ !== i){var i=_es_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_em_=k.length - 1 - 1 | 0,_el_=0;
        if(! (_em_ < 0))
         {var i=_el_;
          for(;;)
           {var _en_=h[1],_eo_=caml_check_bound(k,i)[i + 1];
            h[1] = (caml_call2(H[2],seed,_eo_) * 65599 | 0) + _en_ | 0;
            var _ep_=i + 1 | 0;
            if(_em_ !== i){var i=_ep_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$0(c,i);
            if(match)
             {var ki=match[1],_ek_=caml_check_bound(k,i)[i + 1];
              if(caml_call2(H[1],_ek_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$0(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$0(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[i + 1] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _ei_=k.length - 1 - 1 | 0,_eh_=0;
        if(! (_ei_ < 0))
         {var i=_eh_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _ej_=i + 1 | 0;
            if(_ei_ !== i){var i=_ej_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _ee_=i < 0?1:0;
          if(_ee_)
           var _ef_=_ee_;
          else
           {var _eg_=check_key$0(c,i);
            if(_eg_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ef_=_eg_}
          return _ef_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _ed_=include[1];
      function create(sz){return caml_call2(_ed_,_cD_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$4,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$5,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$6,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_ec_)
         {return MakeSeeded$0
                  ([0,_ec_[3],_ec_[1],_ec_[2],_ec_[5],_ec_[4],_ec_[6],_ec_[7]])}]];
    caml_register_global(699,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$84))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$85))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _ea_=caml_ml_string_length(n) < 1?1:0,
       _eb_=_ea_ || (47 !== caml_string_get(n,0)?1:0);
      return _eb_}
    function is_implicit(n)
     {var _d7_=is_relative(n);
      if(_d7_)
       {var
         _d8_=caml_ml_string_length(n) < 2?1:0,
         _d9_=_d8_ || caml_string_notequal(sub$0(n,0,2),cst$87);
        if(_d9_)
         var
          _d__=caml_ml_string_length(n) < 3?1:0,
          _d$_=_d__ || caml_string_notequal(sub$0(n,0,3),cst$86);
        else
         var _d$_=_d9_}
      else
       var _d$_=_d7_;
      return _d$_}
    function check_suffix(name,suff)
     {var
       _d5_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _d6_=
        _d5_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_d5_;
      return _d6_}
    try
     {var _cL_=caml_sys_getenv(cst_TMPDIR),_cE_=_cL_}
    catch(_d4_)
     {_d4_ = caml_wrap_exception(_d4_);
      if(_d4_ !== Not_found)throw _d4_;
      var _cE_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,39);
      var _d2_=l - 1 | 0,_d1_=0;
      if(! (_d2_ < 0))
       {var i=_d1_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _d3_=i + 1 | 0;
          if(_d2_ !== i){var i=_d3_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_d0_)
     {return generic_basename(is_dir_sep,current_dir_name,_d0_)}
    function dirname(_dZ_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dZ_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dW_=47 === c?1:0;
      if(_dW_)
       var _dX_=_dW_;
      else
       var _dY_=92 === c?1:0,_dX_=_dY_ || (58 === c?1:0);
      return _dX_}
    function is_relative$0(n)
     {var
       _dQ_=caml_ml_string_length(n) < 1?1:0,
       _dR_=_dQ_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dR_)
       {var
         _dS_=caml_ml_string_length(n) < 1?1:0,
         _dT_=_dS_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dT_)
         var
          _dU_=caml_ml_string_length(n) < 2?1:0,
          _dV_=_dU_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dV_=_dT_}
      else
       var _dV_=_dR_;
      return _dV_}
    function is_implicit$0(n)
     {var _dH_=is_relative$0(n);
      if(_dH_)
       {var
         _dI_=caml_ml_string_length(n) < 2?1:0,
         _dJ_=_dI_ || caml_string_notequal(sub$0(n,0,2),cst$91);
        if(_dJ_)
         {var
           _dK_=caml_ml_string_length(n) < 2?1:0,
           _dL_=_dK_ || caml_string_notequal(sub$0(n,0,2),cst$90);
          if(_dL_)
           {var
             _dM_=caml_ml_string_length(n) < 3?1:0,
             _dN_=_dM_ || caml_string_notequal(sub$0(n,0,3),cst$89);
            if(_dN_)
             var
              _dO_=caml_ml_string_length(n) < 3?1:0,
              _dP_=_dO_ || caml_string_notequal(sub$0(n,0,3),cst$88);
            else
             var _dP_=_dN_}
          else
           var _dP_=_dL_}
        else
         var _dP_=_dJ_}
      else
       var _dP_=_dH_;
      return _dP_}
    function check_suffix$0(name,suff)
     {var _dE_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dE_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dF_=lowercase_ascii$1(suff),
        _dG_=caml_string_equal(lowercase_ascii$1(s),_dF_);
      else
       var _dG_=_dE_;
      return _dG_}
    try
     {var _cK_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cK_}
    catch(_dD_)
     {_dD_ = caml_wrap_exception(_dD_);
      if(_dD_ !== Not_found)throw _dD_;
      var temp_dir_name=cst$92}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _dB_=1;
        if(! (n < 1))
         {var j=_dB_;
          for(;;)
           {add_char(b,92);
            var _dC_=j + 1 | 0;
            if(n !== j){var j=_dC_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _dz_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_dz_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dz_,i$0])}
          if(92 === c)
           {var _dA_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dA_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dA_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dy_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dy_)}
            return caml_trampoline_return(loop$0,[0,_dy_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _du_=2 <= caml_ml_string_length(s)?1:0;
      if(_du_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _dv_=switch$0?1:0,
        _dw_=_dv_?58 === caml_string_get(s,1)?1:0:_dv_;
      else
       var _dw_=_du_;
      if(_dw_)
       {var _dx_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_dx_]}
      return [0,cst$93,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return _g_(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_dt_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_dt_)}
    function dirname$1(_ds_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_ds_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       temp_dir_name$0=_cE_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cJ_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cJ_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        _cE_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cJ_[1],
      parent_dir_name$2=_cJ_[2],
      dir_sep$2=_cJ_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      temp_dir_name$0=_cJ_[8],
      quote$1=_cJ_[9],
      basename$2=_cJ_[10],
      dirname$2=_cJ_[11];
    function concat$2(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return _g_(dirname,_g_(dir_sep$2,filename));
      return _g_(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$94:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_dr_){return caml_call1(_b6_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _dp_=caml_obj_tag(prng$0),
       _dq_=
        250 === _dp_?prng$0[1]:246 === _dp_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b6_[4],_dq_) & 16777215;
      return concat$2(temp_dir,caml_call3(sprintf(_cF_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cG_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_dn_,_dm_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cH_;
      if(_dn_)var sth$0=_dn_[1],perms=sth$0;else var perms=384;
      if(_dm_)
       var sth$1=_dm_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _do_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _do_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$2,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(700,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$3(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$2,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0.)if(x[2] == 0.)return _cI_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dl_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dl_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$2,
       one$2,
       i,
       neg,
       conj,
       add$1,
       sub$3,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(701,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$3,
       map$3,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$2,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(702,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$0,
       iteri,
       map$0,
       mapi,
       rev_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
    caml_register_global(703,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$1,
       iteri$0,
       map$1,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       to_seq$0,
       to_seqi,
       of_seq$0,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(704,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$2,
       iteri$1,
       map$2,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char,
       to_seq$1,
       to_seqi$0,
       of_seq$1];
    caml_register_global(705,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(706,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0,0,0,0,0];
    caml_register_global(707,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$7(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$7,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(708,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_di_=n - 1 | 0,_dh_=0;
      if(! (_di_ < 0))
       {var i=_dh_;
        for(;;)
         {var _dj_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[i + 1] = _dj_;
          var _dk_=i + 1 | 0;
          if(_di_ !== i){var i=_dk_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var
       _dc_=dims(arr),
       _dd_=1,
       _de_=
        fold_left$1(function(_dg_,_df_){return caml_mul(_dg_,_df_)},_dd_,_dc_);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_de_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set(arr)
     {var _da_=[0];
      return function(_db_){return runtime.caml_ba_set_generic(arr,_da_,_db_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _c$_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c$_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return 0 === match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=0 === layout?0:1,
       _c9_=data.length - 1 - 1 | 0,
       _c8_=0;
      if(! (_c9_ < 0))
       {var i=_c8_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[i + 1]);
          var _c__=i + 1 | 0;
          if(_c9_ !== i){var i=_c__;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c6_=caml_ba_dim_2(arr),_c7_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c7_),_c6_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=0 === layout?0:1,
       _c1_=dim1 - 1 | 0,
       _c0_=0;
      if(! (_c1_ < 0))
       {var i=_c0_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_non_rectangular_data);
          var _c3_=dim2 - 1 | 0,_c2_=0;
          if(! (_c3_ < 0))
           {var j=_c2_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[j + 1]);
              var _c5_=j + 1 | 0;
              if(_c3_ !== j){var j=_c5_;continue}
              break}}
          var _c4_=i + 1 | 0;
          if(_c1_ !== i){var i=_c4_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _cX_=runtime.caml_ba_dim_3(arr),
       _cY_=caml_ba_dim_2(arr),
       _cZ_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_cZ_),_cY_),
               _cX_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=0 === layout?0:1,
       _cP_=dim1 - 1 | 0,
       _cO_=0;
      if(! (_cP_ < 0))
       {var i=_cO_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data);
          var _cR_=dim2 - 1 | 0,_cQ_=0;
          if(! (_cR_ < 0))
           {var j=_cQ_;
            for(;;)
             {var col=caml_check_bound(row,j)[j + 1];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data$0);
              var _cU_=dim3 - 1 | 0,_cT_=0;
              if(! (_cU_ < 0))
               {var k=_cT_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[k + 1]);
                  var _cW_=k + 1 | 0;
                  if(_cU_ !== k){var k=_cW_;continue}
                  break}}
              var _cV_=j + 1 | 0;
              if(_cR_ !== j){var j=_cV_;continue}
              break}}
          var _cS_=i + 1 | 0;
          if(_cP_ !== i){var i=_cS_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarray)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarray)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarray)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarray)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$8,caml_ba_change_layout,size_in_bytes$0,get,set,of_value],
       [0,create$9,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$10,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(709,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/gen_js_api/gen_js_api.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_js_get=runtime.caml_js_get,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string(""),
     cst_to_js=caml_new_string("to_js"),
     cst_Ojs_exn_Error=caml_new_string("Ojs_exn.Error"),
     cst_jsError=caml_new_string("jsError"),
     CamlinternalOO=global_data.CamlinternalOO,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_callback=global_data.Stdlib__callback,
     _q_=[0,caml_new_string("to_js")],
     _b_=null,
     _c_=undefined,
     _d_=joo_global_object;
    function _a_(_aA_){return caml_js_to_string(typeof _aA_)}
    function _e_(_az_){return new (_d_.Array)(_az_)}
    var _f_=caml_js_get,_g_=caml_js_set;
    function _h_(_av_,_au_,_at_)
     {var _aw_=_au_.length;
      function _ax_(_ay_){return caml_call1(_av_,_au_[_at_ + _ay_ | 0])}
      return caml_call2(Stdlib_array[2],_aw_ - _at_ | 0,_ax_)}
    function _i_(_as_,_ar_){return _h_(_as_,_ar_,0)}
    function _j_(_ak_,_aj_)
     {var _al_=_aj_.length - 1,_am_=_e_(_al_),_ao_=_al_ - 1 | 0,_an_=0;
      if(! (_ao_ < 0))
       {var _ap_=_an_;
        for(;;)
         {_am_[_ap_]
          =
          caml_call1(_ak_,runtime.caml_check_bound(_aj_,_ap_)[_ap_ + 1]);
          var _aq_=_ap_ + 1 | 0;
          if(_ao_ !== _ap_){var _ap_=_aq_;continue}
          break}}
      return _am_}
    function _k_(_ah_,_ag_,_af_)
     {var _ai_=_h_(_ah_,_ag_,_af_);return caml_call1(Stdlib_array[11],_ai_)}
    function _l_(_ae_,_ad_){return _k_(_ae_,_ad_,0)}
    function _m_(_ac_,_ab_)
     {return _j_(_ac_,caml_call1(Stdlib_array[12],_ab_))}
    function _n_(_aa_,_$_)
     {if(_$_ != _b_)if(_$_ !== _c_)return [0,caml_call1(_aa_,_$_)];return 0}
    function _o_(___,_Z_){return _Z_?caml_call1(___,_Z_[1]):_b_}
    function _p_(_Q_)
     {var
       _R_=caml_call2(CamlinternalOO[3],_Q_,cst),
       _S_=caml_call2(CamlinternalOO[7],_Q_,cst_to_js);
      function _T_(_Y_){return _Y_[_R_ + 1]}
      caml_call3(CamlinternalOO[10],_Q_,_S_,_T_);
      return function(_W_,_V_,_U_)
       {var _X_=caml_call2(CamlinternalOO[24],_V_,_Q_);
        _X_[_R_ + 1] = _U_;
        return _X_}}
    var _r_=caml_call2(CamlinternalOO[19],_q_,_p_);
    function _s_(_P_,_O_){return 1 - (_P_[_O_] === _c_?1:0)}
    function _t_(_N_){return new (_d_.Object)()}
    function _u_(_M_,_L_){return _M_.apply(_b_,_L_)}
    function _v_(_K_,_J_,_I_){return _K_[_J_].apply(_K_,_I_)}
    function _w_(_H_){return _H_ == _b_?1:0}
    var
     Ojs=
      [0,
       _i_,
       _j_,
       _l_,
       _m_,
       _h_,
       _k_,
       _n_,
       _o_,
       _t_,
       _s_,
       _v_,
       _u_,
       _e_,
       _f_,
       _g_,
       _d_,
       _b_,
       _a_,
       _r_,
       _w_,
       function(_G_)
        {return caml_js_to_string(Object.prototype.toString.call(_G_))}];
    caml_register_global(21,Ojs,"Ojs");
    function _x_(_F_){return caml_js_to_string(_F_.name)}
    function _y_(_E_){return caml_js_to_string(_E_.message)}
    function _z_(_D_){return _n_(caml_js_to_string,_D_.stack)}
    function _A_(_C_){return caml_js_to_string(_C_.toString())}
    var _B_=[248,cst_Ojs_exn_Error,runtime.caml_fresh_oo_id(0)];
    caml_call2(Stdlib_callback[2],cst_jsError,[0,_B_,{}]);
    var Ojs_exn=[0,_x_,_y_,_z_,_A_,_B_];
    caml_register_global(23,Ojs_exn,"Ojs_exn");
    return}
  (function(){return this}()));


//# 1 "../.js/ocaml-vdom/vdom.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback_strict=runtime.caml_js_wrap_callback_strict,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_ojs_new_arr=runtime.caml_ojs_new_arr,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_lessthan=runtime.caml_string_lessthan,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_custom=caml_new_string("_custom"),
     cst_memo=caml_new_string("_memo"),
     cst_map=caml_new_string("_map"),
     cst_span=caml_new_string("span"),
     cst_input=caml_new_string("input"),
     cst_div=caml_new_string("div"),
     cst=caml_new_string(""),
     cst_txt=caml_new_string("_txt"),
     cst_className$1=caml_new_string("className"),
     cst_className$2=caml_new_string("className"),
     cst_className$0=caml_new_string("className"),
     cst_disabled=caml_new_string("disabled"),
     cst_value=caml_new_string("value"),
     cst_type=caml_new_string("type"),
     cst_className=caml_new_string("className"),
     cst_Vdom_Cmd_Echo=caml_new_string("Vdom.Cmd.Echo"),
     cst_Vdom_Cmd_Batch=caml_new_string("Vdom.Cmd.Batch"),
     cst_Vdom_Cmd_Map=caml_new_string("Vdom.Cmd.Map"),
     cst_scroll_to_show=caml_new_string("scroll-to-show"),
     cst_autofocus=caml_new_string("autofocus"),
     cst_button=caml_new_string("button"),
     svg_ns=caml_new_string("http://www.w3.org/2000/svg"),
     cst_overflowY=caml_new_string("overflowY"),
     cst_visible=caml_new_string("visible"),
     cst_hidden=caml_new_string("hidden"),
     cst$0=caml_new_string(""),
     cst_blur=caml_new_string("blur"),
     cst_change=caml_new_string("change"),
     cst_click=caml_new_string("click"),
     cst_contextmenu=caml_new_string("contextmenu"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_focus=caml_new_string("focus"),
     cst_input$0=caml_new_string("input"),
     cst_keydown=caml_new_string("keydown"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_checked=caml_new_string("checked"),
     cst_value$1=caml_new_string("value"),
     cst_input$1=caml_new_string("input"),
     cst_blur$0=caml_new_string("blur"),
     cst_div$0=caml_new_string("div"),
     prev_value_attribute=caml_new_string("data-ocaml-vdom-prev-value"),
     cst_click$0=caml_new_string("click"),
     cst_dblclick$0=caml_new_string("dblclick"),
     cst_input$2=caml_new_string("input"),
     cst_change$0=caml_new_string("change"),
     cst_focus$0=caml_new_string("focus"),
     cst_blur$1=caml_new_string("blur"),
     cst_mousemove$0=caml_new_string("mousemove"),
     cst_keydown$0=caml_new_string("keydown"),
     cst_contextmenu$0=caml_new_string("contextmenu"),
     cst_value$0=caml_new_string("value"),
     cst_autofocus$0=caml_new_string("autofocus"),
     cst_scroll_to_show$0=caml_new_string("scroll-to-show"),
     cst_Vdom_blit_no_custom_element_handler_found=
      caml_new_string("Vdom_blit: no custom element handler found"),
     empty=[0,0,0],
     Assert_failure=global_data.Assert_failure,
     Ojs=global_data.Ojs,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib=global_data.Stdlib,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Not_found=global_data.Not_found,
     Stdlib_printexc=global_data.Stdlib__printexc,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_obj=global_data.Stdlib__obj,
     _e_=[0,caml_new_string("js_browser.ml"),1587,15],
     _c_=[0,caml_new_string("js_browser.ml"),1152,15],
     _b_=[0,caml_new_string("js_browser.ml"),1021,15],
     _f_=[0,[2,0,[12,32,[2,0,0]]],caml_new_string("%s %s")],
     _i_=[0,caml_new_string("vdom_blit.ml"),465,13],
     _j_=[0,caml_new_string("vdom_blit.ml"),460,35],
     _l_=
      [0,
       [11,
        caml_new_string("Error in event handler "),
        [3,0,[11,caml_new_string(": "),[2,0,[12,10,[10,0]]]]]],
       caml_new_string("Error in event handler %S: %s\n%!")],
     _k_=[0,caml_new_string("vdom_blit.ml"),521,43],
     _h_=
      [0,
       [11,caml_new_string("scroll: "),[2,0,[12,10,[10,0]]]],
       caml_new_string("scroll: %s\n%!")],
     _g_=
      [0,
       [11,caml_new_string("No command handler found! ("),[2,0,[12,41,0]]],
       caml_new_string("No command handler found! (%s)")];
    function t_of_js(x2){return x2}
    function t_to_js(x1){return x1}
    function length(x5){return x5.length}
    function key(x7,x6)
     {var _cm_=x7.key(x6);return caml_call2(Ojs[7],caml_js_to_string,_cm_)}
    function get_item(x10,x9)
     {var _cl_=x10.getItem(x9.toString());
      return caml_call2(Ojs[7],caml_js_to_string,_cl_)}
    function set_item(x14,x12,x13)
     {x14.setItem(x12.toString(),x13.toString());return 0}
    function remove_item(x16,x15){x16.removeItem(x15.toString());return 0}
    function clear(x17){x17.clear();return 0}
    var
     Storage=
      [0,t_of_js,t_to_js,length,key,get_item,set_item,remove_item,clear];
    function t_of_js$0(x19){return x19}
    function t_to_js$0(x18){return x18}
    function new_reg_exp(x22,x23,param)
     {var x24=new (Ojs[16].Array)();
      x24.push(x22.toString());
      if(x23){var x25=x23[1];x24.push(x25.toString())}
      return caml_ojs_new_arr(Ojs[16].RegExp,x24)}
    var RegExp=[0,t_of_js$0,t_to_js$0,new_reg_exp];
    function t_of_js$1(x27){return x27}
    function t_to_js$1(x26){return x26}
    var of_string=caml_js_from_string,to_string=caml_js_to_string;
    function to_lower_case(x30){return x30.toLowerCase()}
    function to_upper_case(x31){return x31.toUpperCase()}
    function concat(x36,x32)
     {var x33=new (Ojs[16].Array)();
      function _ck_(x34){x33.push(x34);return 0}
      caml_call2(Stdlib_list[15],_ck_,x32);
      return x36.concat.apply(x36,x33)}
    function includes(x38,x37){return x38.includes(x37) | 0}
    function ends_with(x40,x39){return x40.endsWith(x39) | 0}
    function index_of(x42,x41){return x42.indexOf(x41)}
    function repeat(x44,x43){return x44.repeat(x43)}
    function search(x46,x45){return x46.search(caml_call1(RegExp[2],x45))}
    function trim(x47){return x47.trim()}
    var
     JsString=
      [0,
       t_of_js$1,
       t_to_js$1,
       of_string,
       to_string,
       to_lower_case,
       to_upper_case,
       concat,
       includes,
       ends_with,
       index_of,
       repeat,
       search,
       trim];
    function t_of_js$2(x49){return x49}
    function t_to_js$2(x48){return x48}
    function new_date(x52){return new (Ojs[16].Date)(x52)}
    function now(param){return Ojs[16].Date.now()}
    function parse(x53){return Ojs[16].Date.parse(x53.toString())}
    function get_date(x54){return x54.getDate()}
    function get_day(x55){return x55.getDay()}
    function get_full_year(x56){return x56.getFullYear()}
    function get_hours(x57){return x57.getHours()}
    function get_milliseconds(x58){return x58.getMilliseconds()}
    function get_minutes(x59){return x59.getMinutes()}
    function get_month(x60){return x60.getMonth()}
    function get_seconds(x61){return x61.getSeconds()}
    function get_time(x62){return x62.getTime()}
    function get_timezone_offset(x63){return x63.getTimezoneOffset()}
    function get_UTC_date(x64){return x64.getUTCDate()}
    function get_UTC_day(x65){return x65.getUTCDay()}
    function get_UTC_full_year(x66){return x66.getUTCFullYear()}
    function get_UTC_hours(x67){return x67.getUTCHours()}
    function get_UTC_milliseconds(x68){return x68.getUTCMilliseconds()}
    function get_UTC_minutes(x69){return x69.getUTCMinutes()}
    function get_UTC_month(x70){return x70.getUTCMonth()}
    function get_UTC_seconds(x71){return x71.getUTCSeconds()}
    function get_year(x72){return x72.getYear()}
    function set_date(x74,x73){x74.setDate(x73);return 0}
    function set_full_year(x76,x75){x76.setFullYear(x75);return 0}
    function set_hours(x78,x77){x78.setHours(x77);return 0}
    function set_milliseconds(x80,x79){x80.setMilliseconds(x79);return 0}
    function set_minutes(x82,x81){x82.setMinutes(x81);return 0}
    function set_month(x84,x83){x84.setMonth(x83);return 0}
    function set_seconds(x86,x85){x86.setSeconds(x85);return 0}
    function set_time(x88,x87){x88.setTime(x87);return 0}
    function set_UTC_date(x90,x89){x90.setUTCDate(x89);return 0}
    function set_UTC_full_year(x92,x91){x92.setUTCFullYear(x91);return 0}
    function set_UTC_hours(x94,x93){x94.setUTCHours(x93);return 0}
    function set_UTC_milliseconds(x96,x95)
     {x96.setUTCMilliseconds(x95);return 0}
    function set_UTC_minutes(x98,x97){x98.setUTCMinutes(x97);return 0}
    function set_UTC_month(x100,x99){x100.setUTCMonth(x99);return 0}
    function set_UTC_seconds(x102,x101){x102.setUTCSeconds(x101);return 0}
    function set_year(x104,x103){x104.setYear(x103);return 0}
    function to_date_string(x105)
     {return caml_js_to_string(x105.toDateString())}
    function to_GMT_string(x106){return caml_js_to_string(x106.toGMTString())}
    function to_ISO_string(x107){return caml_js_to_string(x107.toISOString())}
    function to_locale_string(x108)
     {return caml_js_to_string(x108.toLocaleString())}
    function to_string$0(x109){return caml_js_to_string(x109.toString())}
    function to_time_string(x110)
     {return caml_js_to_string(x110.toTimeString())}
    function to_UTC_string(x111){return caml_js_to_string(x111.toUTCString())}
    var
     Date=
      [0,
       t_of_js$2,
       t_to_js$2,
       new_date,
       now,
       parse,
       get_date,
       get_day,
       get_full_year,
       get_hours,
       get_milliseconds,
       get_minutes,
       get_month,
       get_seconds,
       get_time,
       get_timezone_offset,
       get_UTC_date,
       get_UTC_day,
       get_UTC_full_year,
       get_UTC_hours,
       get_UTC_milliseconds,
       get_UTC_minutes,
       get_UTC_month,
       get_UTC_seconds,
       get_year,
       set_date,
       set_full_year,
       set_hours,
       set_milliseconds,
       set_minutes,
       set_month,
       set_seconds,
       set_time,
       set_UTC_date,
       set_UTC_full_year,
       set_UTC_hours,
       set_UTC_milliseconds,
       set_UTC_minutes,
       set_UTC_month,
       set_UTC_seconds,
       set_year,
       to_date_string,
       to_GMT_string,
       to_ISO_string,
       to_locale_string,
       to_string$0,
       to_time_string,
       to_UTC_string];
    function t_of_js$3(x113){return x113}
    function t_to_js$3(x112){return x112}
    function name(x116){return caml_js_to_string(x116.name)}
    function type(x117){return caml_js_to_string(x117.type)}
    var File=[0,t_of_js$3,t_to_js$3,name,type];
    function t_of_js$4(x119){return x119}
    function t_to_js$4(x118){return x118}
    function files(x122){return caml_call2(Ojs[3],File[1],x122.files)}
    var DataTransfer=[0,t_of_js$4,t_to_js$4,files];
    function t_of_js$5(x125){return x125}
    function t_to_js$5(x124){return x124}
    function target(x128){return x128.target}
    function prevent_default(x129){x129.preventDefault();return 0}
    function type$0(x130){return caml_js_to_string(x130.type)}
    function init_event(x134,x131,x132,x133)
     {x134.initEvent(x131.toString(),! ! x132,! ! x133);return 0}
    function client_x(x135){return x135.clientX}
    function client_y(x136){return x136.clientY}
    function page_x(x137){return x137.pageX}
    function page_y(x138){return x138.pageY}
    function screen_x(x139){return x139.screenX}
    function screen_y(x140){return x140.screenY}
    function movement_x(x141){return x141.movementX}
    function movement_y(x142){return x142.movementY}
    function buttons(x143){return x143.buttons}
    function alt_key(x144){return x144.altKey | 0}
    function ctrl_key(x145){return x145.ctrlKey | 0}
    function shift_key(x146){return x146.shiftKey | 0}
    function which(x147){return x147.which}
    function code(x148){return caml_js_to_string(x148.code)}
    function key$0(x149){return caml_js_to_string(x149.key)}
    function delta_y(x150){return x150.deltaY}
    function delta_x(x151){return x151.deltaX}
    function data_transfer(x152)
     {return caml_call1(DataTransfer[1],x152.dataTransfer)}
    function data(x153){return x153.data}
    function origin(x154){return caml_js_to_string(x154.origin)}
    var
     Event=
      [0,
       t_of_js$5,
       t_to_js$5,
       target,
       prevent_default,
       type$0,
       init_event,
       client_x,
       client_y,
       page_x,
       page_y,
       screen_x,
       screen_y,
       movement_x,
       movement_y,
       buttons,
       alt_key,
       ctrl_key,
       shift_key,
       which,
       code,
       key$0,
       delta_y,
       delta_x,
       data_transfer,
       data,
       origin];
    function t_of_js$6(x156){return x156}
    function t_to_js$6(x155){return x155}
    function height(x159){return x159.height}
    function width(x160){return x160.width}
    function left(x161){return x161.left}
    function right(x162){return x162.right}
    function top(x163){return x163.top}
    function bottom(x164){return x164.bottom}
    var Rect=[0,t_of_js$6,t_to_js$6,height,width,left,right,top,bottom];
    function t_of_js$7(x166){return x166}
    function t_to_js$7(x165){return x165}
    function x(x169){return x169.x}
    function y(x170){return x170.y}
    function height$0(x171){return x171.height}
    function width$0(x172){return x172.width}
    var SVGRect=[0,t_of_js$7,t_to_js$7,x,y,height$0,width$0];
    function t_of_js$8(x174){return x174}
    function t_to_js$8(x173){return x173}
    function set(style,prop,value){return style[prop] = value.toString()}
    function set_color(x177,x178){return x177.color = x178.toString()}
    function set_border(x179,x180){return x179.border = x180.toString()}
    function set_background(x181,x182)
     {return x181.background = x182.toString()}
    function set_background_color(x183,x184)
     {return x183.backgroundColor = x184.toString()}
    function set_height(x185,x186){return x185.height = x186.toString()}
    function set_width(x187,x188){return x187.width = x188.toString()}
    function set_bottom(x189,x190){return x189.bottom = x190.toString()}
    function set_left(x191,x192){return x191.left = x192.toString()}
    function set_top(x193,x194){return x193.top = x194.toString()}
    function set_right(x195,x196){return x195.right = x196.toString()}
    function set_cursor(x197,x198){return x197.cursor = x198.toString()}
    function get(style,prop){return caml_js_to_string(style[prop])}
    var
     Style=
      [0,
       t_of_js$8,
       t_to_js$8,
       set,
       set_color,
       set_border,
       set_background,
       set_background_color,
       set_height,
       set_width,
       set_bottom,
       set_left,
       set_top,
       set_right,
       set_cursor,
       get];
    function t_of_js$9(x200){return x200}
    function t_to_js$9(x199){return x199}
    var _a_=Ojs[17];
    function clone_node(x204,x203){return x204.cloneNode(! ! x203)}
    function contains(x206,x205){return x206.contains(x205) | 0}
    function append_child(x208,x207){x208.appendChild(x207);return 0}
    function insert_before(x211,x209,x210)
     {x211.insertBefore(x209,x210);return 0}
    function replace_child(x214,x212,x213)
     {x214.replaceChild(x212,x213);return 0}
    function remove_child(x216,x215){x216.removeChild(x215);return 0}
    function first_child(x217){return x217.firstChild}
    function last_child(x218){return x218.lastChild}
    function next_sibling(x219){return x219.nextSibling}
    function remove_all_children(x)
     {var child$1=x.firstChild,child=child$1;
      for(;;)
       {if(caml_equal(child,_a_))return 0;
        remove_child(x,child);
        var child$0=x.firstChild,child=child$0;
        continue}}
    function has_child_nodes(x220){return x220.hasChildNodes() | 0}
    function add_event_listener(x225,x221,x222,x224)
     {var
       _ci_=! ! x224,
       _cj_=
        caml_js_wrap_callback_strict
         (1,function(x223){return caml_call1(x222,caml_call1(Event[1],x223))});
      x225.addEventListener(x221.toString(),_cj_,_ci_);
      return 0}
    function inner_text(x226){return caml_js_to_string(x226.innerText)}
    function get_elements_by_tag_name(x228,x227)
     {var _ch_=x228.getElementsByTagName(x227.toString());
      return caml_call2(Ojs[1],t_of_js$9,_ch_)}
    function has_attribute(x231,x230)
     {return x231.hasAttribute(x230.toString()) | 0}
    function get_attribute(x233,x232)
     {return caml_js_to_string(x233.getAttribute(x232.toString()))}
    function remove_attribute(x235,x234)
     {x235.removeAttribute(x234.toString());return 0}
    function set_attribute(x238,x236,x237)
     {x238.setAttribute(x236.toString(),x237.toString());return 0}
    function get_bounding_client_rect(x239)
     {var _cg_=x239.getBoundingClientRect();return caml_call1(Rect[1],_cg_)}
    function get_bounding_box(x240)
     {var _cf_=x240.getBBox();return caml_call1(SVGRect[1],_cf_)}
    function normalize(x241){x241.normalize();return 0}
    function value(x242){return caml_js_to_string(x242.value)}
    function set_value(x243,x244){return x243.value = x244.toString()}
    function select(x245){x245.select();return 0}
    function files$0(x246){return caml_call2(Ojs[3],File[1],x246.files)}
    function selected_index(x248){return x248.selectedIndex}
    function checked(x249){return x249.checked | 0}
    function set_checked(x250,x251){return x250.checked = ! ! x251}
    function node_value(x252){return caml_js_to_string(x252.nodeValue)}
    function set_node_value(x253,x254)
     {return x253.nodeValue = x254.toString()}
    function parent_node(x255){return x255.parentNode}
    function node_name(x256){return caml_js_to_string(x256.nodeName)}
    function dispatch_event(x258,x257)
     {return x258.dispatchEvent(caml_call1(Event[2],x257)) | 0}
    function style(x259){return caml_call1(Style[1],x259.style)}
    function set_inner_HTML(x260,x261)
     {return x260.innerHTML = x261.toString()}
    function set_text_content(x262,x263)
     {return x262.textContent = x263.toString()}
    function set_class_name(x264,x265)
     {return x264.className = x265.toString()}
    function class_name(x266){return caml_js_to_string(x266.className)}
    function client_width(x267){return x267.clientWidth}
    function client_height(x268){return x268.clientHeight}
    function scroll_width(x269){return x269.scrollWidth}
    function scroll_height(x270){return x270.scrollHeight}
    function width$1(x271){return x271.width}
    function height$1(x272){return x272.height}
    function scroll_top(x273){return x273.scrollTop}
    function set_scroll_top(x274,x275){return x274.scrollTop = x275}
    function focus(x276){x276.focus();return 0}
    function selection_start(x277){return x277.selectionStart}
    function selection_end(x278){return x278.selectionEnd}
    function set_selection_start(x279,x280){return x279.selectionStart = x280}
    function set_selection_end(x281,x282){return x281.selectionEnd = x282}
    var
     Element=
      [0,
       t_of_js$9,
       t_to_js$9,
       _a_,
       clone_node,
       contains,
       append_child,
       insert_before,
       replace_child,
       remove_child,
       first_child,
       last_child,
       next_sibling,
       remove_all_children,
       has_child_nodes,
       add_event_listener,
       inner_text,
       get_elements_by_tag_name,
       has_attribute,
       get_attribute,
       remove_attribute,
       set_attribute,
       get_bounding_client_rect,
       get_bounding_box,
       normalize,
       value,
       set_value,
       select,
       files$0,
       selected_index,
       checked,
       set_checked,
       node_value,
       set_node_value,
       parent_node,
       node_name,
       dispatch_event,
       style,
       set_inner_HTML,
       set_text_content,
       set_class_name,
       class_name,
       client_width,
       client_height,
       scroll_width,
       scroll_height,
       width$1,
       height$1,
       scroll_top,
       set_scroll_top,
       focus,
       selection_start,
       selection_end,
       set_selection_start,
       set_selection_end];
    function t_of_js$10(x284){return x284}
    function t_to_js$10(x283){return x283}
    function create_element(x288,x287)
     {var _ce_=x288.createElement(x287.toString());
      return caml_call1(Element[1],_ce_)}
    function create_element_ns(x291,x289,x290)
     {var _cd_=x291.createElementNS(x289.toString(),x290.toString());
      return caml_call1(Element[1],_cd_)}
    function create_text_node(x293,x292)
     {var _cc_=x293.createTextNode(x292.toString());
      return caml_call1(Element[1],_cc_)}
    function create_event(x295,x294)
     {var _cb_=x295.createEvent(x294.toString());
      return caml_call1(Event[1],_cb_)}
    function get_element_by_id(x297,x296)
     {var _ca_=x297.getElementById(x296.toString());
      return caml_call2(Ojs[7],Element[1],_ca_)}
    function get_elements_by_class_name(x300,x299)
     {var _b$_=x300.getElementsByClassName(x299.toString());
      return caml_call2(Ojs[1],Element[1],_b$_)}
    function body(x302){return caml_call1(Element[1],x302.body)}
    function cookie(x303){return caml_js_to_string(x303.cookie)}
    function set_cookie(x304,x305){return x304.cookie = x305.toString()}
    function set_title(x306,x307){return x306.title = x307.toString()}
    function open(x314,x308,x309,param)
     {var x310=new (Ojs[16].Array)();
      if(x308){var x312=x308[1];x310.push(x312.toString())}
      if(x309){var x311=x309[1];x310.push(x311.toString())}
      x314.open.apply(x314,x310);
      return 0}
    function write(x316,x315){x316.write(x315.toString());return 0}
    function writeln(x318,x317){x318.writeln(x317.toString());return 0}
    function close(x319){x319.close();return 0}
    function exec_command(x321,x320)
     {return x321.execCommand(x320.toString()) | 0}
    function query_selector(x323,x322)
     {var _b__=x323.querySelector(x322.toString());
      return caml_call1(Element[1],_b__)}
    var
     Document=
      [0,
       t_of_js$10,
       t_to_js$10,
       create_element,
       create_element_ns,
       create_text_node,
       create_event,
       get_element_by_id,
       get_elements_by_class_name,
       body,
       cookie,
       set_cookie,
       set_title,
       open,
       write,
       writeln,
       close,
       exec_command,
       query_selector];
    function t_of_js$11(x325){return x325}
    function t_to_js$11(x324){return x324}
    function length$0(x328){return x328.length}
    function back(x329){x329.back();return 0}
    function forward(x330){x330.forward();return 0}
    function go(x334,x331)
     {if(349440947 <= x331[1])
       var x332=x331[2],x332$0=x332;
      else
       var x333=x331[2],x332$0=x333.toString();
      x334.go(x332$0);
      return 0}
    function replace_state(x338,x335,x336,x337)
     {x338.replaceState(x335,x336.toString(),x337.toString());return 0}
    function push_state(x342,x339,x340,x341)
     {x342.pushState(x339,x340.toString(),x341.toString());return 0}
    var
     History=
      [0,
       t_of_js$11,
       t_to_js$11,
       length$0,
       back,
       forward,
       go,
       replace_state,
       push_state];
    function t_of_js$12(x344){return x344}
    function t_to_js$12(x343){return x343}
    function get_hash(param){return caml_js_to_string(Ojs[16].location.hash)}
    function set_hash(x347){return Ojs[16].location.hash = x347.toString()}
    function host(x348){return caml_js_to_string(x348.host)}
    function set_host(x349,x350){return x349.host = x350.toString()}
    function hostname(x351){return caml_js_to_string(x351.hostname)}
    function set_hostname(x352,x353){return x352.hostname = x353.toString()}
    function href(param){return caml_js_to_string(Ojs[16].location.href)}
    function set_href(x354){return Ojs[16].location.href = x354.toString()}
    function pathname(x355){return caml_js_to_string(x355.pathname)}
    function set_pathname(x356,x357){return x356.pathname = x357.toString()}
    function port(x358){return caml_js_to_string(x358.port)}
    function set_port(x359,x360){return x359.port = x360.toString()}
    function protocol(x361){return caml_js_to_string(x361.protocol)}
    function set_protocol(x362,x363){return x362.protocol = x363.toString()}
    function search$0(x364){return caml_js_to_string(x364.search)}
    function set_search(x365,x366){return x365.search = x366.toString()}
    function assign(x368,x367){x368.assign(x367.toString());return 0}
    function reload(x373,x369,param)
     {var x370=new (Ojs[16].Array)();
      if(x369){var x371=x369[1];x370.push(! ! x371)}
      x373.reload.apply(x373,x370);
      return 0}
    function replace(x375,x374){x375.replace(x374.toString());return 0}
    var
     Location=
      [0,
       t_of_js$12,
       t_to_js$12,
       get_hash,
       set_hash,
       host,
       set_host,
       hostname,
       set_hostname,
       href,
       set_href,
       pathname,
       set_pathname,
       port,
       set_port,
       protocol,
       set_protocol,
       search$0,
       set_search,
       assign,
       reload,
       replace];
    function t_of_js$13(x377){return x377}
    function t_to_js$13(x376){return x376}
    function timeout_id_of_js(x381){return x381}
    function timeout_id_to_js(x380){return x380}
    function add_event_listener$0(x388,x384,x385,x387)
     {var
       _b8_=! ! x387,
       _b9_=
        caml_js_wrap_callback_strict
         (1,function(x386){return caml_call1(x385,caml_call1(Event[1],x386))});
      x388.addEventListener(x384.toString(),_b9_,_b8_);
      return 0}
    function document(x389){return caml_call1(Document[1],x389.document)}
    function set_onload(x390,x391)
     {return x390.onload
             =
             caml_js_wrap_callback_strict
              (1,function(param){return caml_call1(x391,0)})}
    function set_interval(x394,x392,x393)
     {return x394.setInterval
              (caml_js_wrap_callback_strict
                (1,function(param){return caml_call1(x392,0)}),
               x393)}
    function set_timeout(x397,x395,x396)
     {return x397.setTimeout
              (caml_js_wrap_callback_strict
                (1,function(param){return caml_call1(x395,0)}),
               x396)}
    function clear_timeout(x399,x398){x399.clearTimeout(x398);return 0}
    function request_animation_frame(x402,x400)
     {x402.requestAnimationFrame
       (caml_js_wrap_callback_strict
         (1,function(x401){return caml_call1(x400,x401)}));
      return 0}
    function open$0(x413,x403,x404,x405,x406,param)
     {var x407=new (Ojs[16].Array)();
      if(x403){var x411=x403[1];x407.push(x411.toString())}
      if(x404){var x410=x404[1];x407.push(x410.toString())}
      if(x405){var x409=x405[1];x407.push(x409.toString())}
      if(x406){var x408=x406[1];x407.push(! ! x408)}
      return x413.open.apply(x413,x407)}
    function alert(x415,x414){x415.alert(x414.toString());return 0}
    function session_storage(x416)
     {return caml_call2(Ojs[7],Storage[1],x416.sessionStorage)}
    function local_storage(x418)
     {return caml_call2(Ojs[7],Storage[1],x418.localStorage)}
    function inner_width(x420){return x420.innerWidth}
    function inner_height(x421){return x421.innerHeight}
    function page_x_offset(x422){return x422.pageXOffset}
    function page_y_offset(x423){return x423.pageYOffset}
    function scroll_by(x426,x424,x425){x426.scrollBy(x424,x425);return 0}
    function scroll_to(x429,x427,x428){x429.scrollTo(x427,x428);return 0}
    function history(x430){return caml_call1(History[1],x430.history)}
    function location(x431){return caml_call1(Location[1],x431.location)}
    function get_computed_style(x433,x432)
     {var _b7_=x433.getComputedStyle(caml_call1(Element[2],x432));
      return caml_call1(Style[1],_b7_)}
    var
     Window=
      [0,
       t_of_js$13,
       t_to_js$13,
       timeout_id_of_js,
       timeout_id_to_js,
       add_event_listener$0,
       document,
       set_onload,
       set_interval,
       set_timeout,
       clear_timeout,
       request_animation_frame,
       open$0,
       alert,
       session_storage,
       local_storage,
       inner_width,
       inner_height,
       page_x_offset,
       page_y_offset,
       scroll_by,
       scroll_to,
       history,
       location,
       get_computed_style];
    function content_window(x434)
     {var _b6_=caml_call1(Element[2],x434).contentWindow;
      return caml_call2(Ojs[7],Window[1],_b6_)}
    function content_document(x436)
     {var _b5_=caml_call1(Element[2],x436).contentDocument;
      return caml_call2(Ojs[7],Document[1],_b5_)}
    var IFrame=[0,content_window,content_document];
    function parse$0(x438){return Ojs[16].JSON.parse(x438.toString())}
    function stringify(x439)
     {return caml_js_to_string(Ojs[16].JSON.stringify(x439))}
    var JSON=[0,parse$0,stringify];
    function t_of_js$14(x444){return x444}
    function t_to_js$14(x443){return x443}
    function new_file_reader(param){return new (Ojs[16].FileReader)()}
    function ready_state(x447)
     {var x441=x447.readyState;
      if(2 < x441 >>> 0)throw [0,Assert_failure,_b_];
      switch(x441){case 0:return 0;case 1:return 1;default:return 2}}
    function result(x448){return caml_js_to_string(x448.result)}
    function set_onload$0(x449,x450)
     {return x449.onload
             =
             caml_js_wrap_callback_strict
              (1,function(param){return caml_call1(x450,0)})}
    function read_as_text(x452,x451)
     {x452.readAsText(caml_call1(File[2],x451));return 0}
    function t_of_js$15(x454){return x454}
    function t_to_js$15(x453){return x453}
    function create(param){return new (Ojs[16].XMLHttpRequest)()}
    function open$1(x459,x457,x458)
     {x459.open(x457.toString(),x458.toString());return 0}
    function send(x461,x460){x461.send(x460.toString());return 0}
    function set_request_header(x464,x462,x463)
     {x464.setRequestHeader(x462.toString(),x463.toString());return 0}
    function get_response_header(x466,x465)
     {var _b4_=x466.getResponseHeader(x465.toString());
      return caml_call2(Ojs[7],caml_js_to_string,_b4_)}
    function override_mime_type(x469,x468)
     {x469.overrideMimeType(x468.toString());return 0}
    function set_with_credentials(x470,x471)
     {return x470.withCredentials = ! ! x471}
    function status(x477){return x477.status}
    function ready_state$0(x478)
     {var x474=x478.readyState;
      if(4 < x474 >>> 0)return [0,x474];
      switch(x474)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        case 3:return 3;
        default:return 4}}
    function response_text(x479){return caml_js_to_string(x479.responseText)}
    function set_onreadystatechange(x480,x481)
     {return x480.onreadystatechange
             =
             caml_js_wrap_callback_strict
              (1,function(param){return caml_call1(x481,0)})}
    function t_of_js$16(x483){return x483}
    function t_to_js$16(x482){return x482}
    function create$0(x489,x490,param)
     {var x491=new (Ojs[16].Array)();
      x491.push(x489.toString());
      if(x490)
       {var x492=x490[1];
        x491.push(caml_call2(Ojs[4],caml_js_from_string,x492))}
      return caml_ojs_new_arr(Ojs[16].WebSocket,x491)}
    function send$0(x495,x494){x495.send(x494.toString());return 0}
    function close$0(x502,x496,x497,param)
     {var x498=new (Ojs[16].Array)();
      if(x496){var x500=x496[1];x498.push(x500)}
      if(x497){var x499=x497[1];x498.push(x499.toString())}
      x502.close.apply(x502,x498);
      return 0}
    function binary_type(x503){return caml_js_to_string(x503.binaryType)}
    function set_binary_type(x504,x505)
     {return x504.binaryType = x505.toString()}
    function ready_state$1(x506)
     {var x487=x506.readyState;
      if(3 < x487 >>> 0)throw [0,Assert_failure,_c_];
      switch(x487)
       {case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}}
    function add_event_listener$1(x511,x507,x508,x510)
     {var
       _b2_=! ! x510,
       _b3_=
        caml_js_wrap_callback_strict
         (1,function(x509){return caml_call1(x508,caml_call1(Event[1],x509))});
      x511.addEventListener(x507.toString(),_b3_,_b2_);
      return 0}
    var _d_=Event[2];
    function code$0(x514){return caml_call1(_d_,x514).code}
    var
     window=caml_call1(Window[1],Ojs[16].window),
     document$0=caml_call1(Document[1],Ojs[16].document);
    function context_of_js(x516){return x516}
    function context_to_js(x515){return x515}
    function gradient_of_js(x520){return x520}
    function gradient_to_js(x519){return x519}
    function get_context(opt,canvas)
     {if(opt)var sth=opt[1],alpha=sth;else var alpha=1;
      var
       _b1_=
        caml_call1(Element[2],canvas).getContext("2d",{"alpha":! ! alpha});
      return caml_call2(Ojs[7],context_of_js,_b1_)}
    function to_data_URL(x531)
     {return caml_js_to_string(caml_call1(Element[2],x531).toDataURL())}
    function set_fill_style(x532,x533)
     {if(66123280 <= x533[1])
       var x535=x533[2],_b0_=x535;
      else
       var x534=x533[2],_b0_=x534.toString();
      return x532.fillStyle = _b0_}
    function set_stroke_style(x536,x537)
     {if(66123280 <= x537[1])
       var x539=x537[2],_bZ_=x539;
      else
       var x538=x537[2],_bZ_=x538.toString();
      return x536.strokeStyle = _bZ_}
    function set_line_width(x540,x541){return x540.lineWidth = x541}
    function create_linear_gradient(x546,x542,x543,x544,x545)
     {return x546.createLinearGradient(x542,x543,x544,x545)}
    function add_color_stop(x549,x547,x548)
     {x549.addColorStop(x547,x548.toString());return 0}
    function begin_path(x550){x550.beginPath();return 0}
    function close_path(x551){x551.closePath();return 0}
    function arc(x557,x552,x553,x554,x555,x556)
     {x557.arc(x552,x553,x554,x555,x556);return 0}
    function move_to(x560,x558,x559){x560.moveTo(x558,x559);return 0}
    function line_to(x563,x561,x562){x563.lineTo(x561,x562);return 0}
    function fill(x564){x564.fill();return 0}
    function stroke(x565){x565.stroke();return 0}
    function stroke_rect(x570,x566,x567,x568,x569)
     {x570.strokeRect(x566,x567,x568,x569);return 0}
    function fill_rect(x575,x571,x572,x573,x574)
     {x575.fillRect(x571,x572,x573,x574);return 0}
    function set_font(x576,x577){return x576.font = x577.toString()}
    function fill_text(x581,x578,x579,x580)
     {x581.fillText(x578.toString(),x579,x580);return 0}
    function stroke_text(x585,x582,x583,x584)
     {x585.strokeText(x582.toString(),x583,x584);return 0}
    function t_of_js$17(x587){return x587}
    function t_to_js$17(x586){return x586}
    function width$2(x590){return x590.width}
    var TextMetrics=[0,t_of_js$17,t_to_js$17,width$2];
    function measure_text(x592,x591)
     {var _bY_=x592.measureText(x591.toString());
      return caml_call1(TextMetrics[1],_bY_)}
    function rotate(x594,x593){x594.rotate(x593);return 0}
    function translate(x597,x595,x596){x597.translate(x595,x596);return 0}
    function scale(x600,x598,x599){x600.scale(x598,x599);return 0}
    function clear_rect(x605,x601,x602,x603,x604)
     {x605.clearRect(x601,x602,x603,x604);return 0}
    function now$0(param){return Ojs[16].performance.now()}
    var Performance=[0,now$0];
    function log(x609,x608){x609.log(x608);return 0}
    var console=Ojs[16].console;
    function create$1(x612){return new (Ojs[16].ArrayBuffer)(x612)}
    function from_buffer(x615){return new (Ojs[16].Uint8Array)(x615)}
    function set$0(x619,x616,x618)
     {function _bW_(_bX_){return _bX_}
      x619.set(caml_call2(Ojs[2],_bW_,x616),x618);
      return 0}
    function options(x622,x623,param)
     {var x624=caml_call1(Ojs[9],0);
      if(x622){var x626=x622[1];x624.type = x626.toString()}
      if(x623){var x625=x623[1];x624.endings = x625.toString()}
      return x624}
    function create$2(x629,x630,param)
     {var x631=new (Ojs[16].Array)();
      function _bV_(x633){var x634=x633[2];return x634}
      x631.push(caml_call2(Ojs[4],_bV_,x629));
      if(x630){var x632=x630[1];x631.push(x632)}
      return caml_ojs_new_arr(Ojs[16].Blob,x631)}
    function of_blob(x635)
     {return caml_js_to_string(Ojs[16].URL.createObjectURL(x635))}
    function revoke(x636)
     {Ojs[16].URL.revokeObjectURL(x636.toString());return 0}
    var ObjectURL=[0,of_blob,revoke];
    function t_of_js$18(x638){return x638}
    function t_to_js$18(x637){return x637}
    function unit_type(x641){return x641.unitType}
    function value$0(x642){return x642.value}
    function value_as_string(x643)
     {return caml_js_to_string(x643.valueAsString)}
    function value_in_specified_units(x644){return x644.valueInSpecifiedUnits}
    var
     Length=
      [0,
       t_of_js$18,
       t_to_js$18,
       unit_type,
       value$0,
       value_as_string,
       value_in_specified_units];
    function t_of_js$19(x646){return x646}
    function t_to_js$19(x645){return x645}
    function anim_val(x649){return caml_call1(Length[1],x649.animVal)}
    function base_val(x650){return caml_call1(Length[1],x650.baseVal)}
    var AnimatedLength=[0,t_of_js$19,t_to_js$19,anim_val,base_val];
    function t_of_js$20(x655){return x655}
    function t_to_js$20(x654){return x654}
    function x$0(x658){return x658.x}
    function y$0(x659){return x659.y}
    function x1(x660){return x660.x1}
    function y1(x661){return x661.y1}
    function x2(x662){return x662.x2}
    function y2(x663){return x663.y2}
    function path_seg_type(x664)
     {var x652=x664.pathSegType;
      if(9 < x652 >>> 0)throw [0,Assert_failure,_e_];
      switch(x652)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        case 3:return 3;
        case 4:return 4;
        case 5:return 5;
        case 6:return 6;
        case 7:return 7;
        case 8:return 8;
        default:return 9}}
    function path_seg_type_as_letter(x665)
     {return caml_js_to_string(x665.pathSegTypeAsLetter)}
    var
     PathSeg=
      [0,
       t_of_js$20,
       t_to_js$20,
       x$0,
       y$0,
       x1,
       y1,
       x2,
       y2,
       path_seg_type,
       path_seg_type_as_letter];
    function t_of_js$21(x667){return x667}
    function t_to_js$21(x666){return x666}
    function number_of_items(x670){return x670.numberOfItems}
    function get_item$0(x672,x671)
     {var _bU_=x672.getItem(x671);return caml_call1(PathSeg[1],_bU_)}
    function insert_item_before(x675,x673,x674)
     {x675.insertItemBefore(caml_call1(PathSeg[2],x673),x674);return 0}
    function replace_item(x678,x676,x677)
     {x678.replaceItem(caml_call1(PathSeg[2],x676),x677);return 0}
    function remove_item$0(x680,x679){x680.removeItem(x679);return 0}
    function append_item(x682,x681)
     {x682.appendItem(caml_call1(PathSeg[2],x681));return 0}
    var
     PathSegList=
      [0,
       t_of_js$21,
       t_to_js$21,
       number_of_items,
       get_item$0,
       insert_item_before,
       replace_item,
       remove_item$0,
       append_item];
    function t_of_js$22(x684){return x684}
    function t_to_js$22(x683){return x683}
    function path_seg_list(x687)
     {return caml_call1(PathSegList[1],x687.pathSegList)}
    function normalized_path_seg_list(x688)
     {return caml_call1(PathSegList[1],x688.normalizedPathSegList)}
    function animated_path_seg_list(x689)
     {return caml_call1(PathSegList[1],x689.animatedPathSegList)}
    function animated_normalized_path_seg_list(x690)
     {return caml_call1(PathSegList[1],x690.animatedNormalizedPathSegList)}
    function create_close_path(x691,param)
     {var _bT_=x691.createSVGPathSegClosePath();
      return caml_call1(PathSeg[1],_bT_)}
    function create_moveto_abs(x694,x692,x693)
     {var _bS_=x694.createSVGPathSegMovetoAbs(x692,x693);
      return caml_call1(PathSeg[1],_bS_)}
    function create_moveto_rel(x697,x695,x696)
     {var _bR_=x697.createSVGPathSegMovetoRel(x695,x696);
      return caml_call1(PathSeg[1],_bR_)}
    function create_lineto_abs(x700,x698,x699)
     {var _bQ_=x700.createSVGPathSegLinetoAbs(x698,x699);
      return caml_call1(PathSeg[1],_bQ_)}
    function create_lineto_rel(x703,x701,x702)
     {var _bP_=x703.createSVGPathSegLinetoRel(x701,x702);
      return caml_call1(PathSeg[1],_bP_)}
    var
     PathElement=
      [0,
       t_of_js$22,
       t_to_js$22,
       path_seg_list,
       normalized_path_seg_list,
       animated_path_seg_list,
       animated_normalized_path_seg_list,
       create_close_path,
       create_moveto_abs,
       create_moveto_rel,
       create_lineto_abs,
       create_lineto_rel],
     Js_browser=
      [0,
       Storage,
       RegExp,
       JsString,
       Date,
       File,
       DataTransfer,
       Event,
       Rect,
       SVGRect,
       Style,
       Element,
       Document,
       History,
       Location,
       Window,
       IFrame,
       JSON,
       [0,
        t_of_js$14,
        t_to_js$14,
        new_file_reader,
        ready_state,
        result,
        set_onload$0,
        read_as_text],
       [0,
        t_of_js$15,
        t_to_js$15,
        create,
        open$1,
        send,
        set_request_header,
        get_response_header,
        override_mime_type,
        set_with_credentials,
        status,
        ready_state$0,
        response_text,
        set_onreadystatechange],
       [0,
        t_of_js$16,
        t_to_js$16,
        create$0,
        send$0,
        close$0,
        binary_type,
        set_binary_type,
        ready_state$1,
        add_event_listener$1,
        [0,code$0]],
       window,
       document$0,
       [0,
        context_of_js,
        context_to_js,
        gradient_of_js,
        gradient_to_js,
        get_context,
        to_data_URL,
        set_fill_style,
        set_stroke_style,
        set_line_width,
        create_linear_gradient,
        add_color_stop,
        begin_path,
        close_path,
        arc,
        move_to,
        line_to,
        fill,
        stroke,
        stroke_rect,
        fill_rect,
        set_font,
        fill_text,
        stroke_text,
        TextMetrics,
        measure_text,
        rotate,
        translate,
        scale,
        clear_rect],
       Performance,
       [0,log],
       console,
       [0,create$1],
       [0,from_buffer,set$0],
       [0,options,create$2],
       ObjectURL,
       [0,Length,AnimatedLength,PathSeg,PathSegList,PathElement]];
    caml_register_global(441,Js_browser,"Js_browser");
    var
     Echo=[248,cst_Vdom_Cmd_Echo,caml_fresh_oo_id(0)],
     Batch=[248,cst_Vdom_Cmd_Batch,caml_fresh_oo_id(0)],
     Map=[248,cst_Vdom_Cmd_Map,caml_fresh_oo_id(0)];
    function echo(msg){return [0,Echo,msg]}
    function batch(l){return [0,Batch,l]}
    function map(f,x){return [0,Map,f,x]}
    var Cmd=[0,Echo,Batch,Map,echo,batch,map],Custom=[0];
    function onclick(msg){return [2,[0,msg]]}
    function ondblclick(msg){return [2,[1,msg]]}
    function oncontextmenu(msg){return [2,[10,msg]]}
    function onfocus(msg){return [2,[2,msg]]}
    function oninput(msg){return [2,[4,msg]]}
    function onchange(msg){return [2,[5,msg]]}
    function onchange_index(msg){return [2,[6,msg]]}
    function onchange_checked(msg){return [2,[7,msg]]}
    function onblur(msg){return [2,[3,msg]]}
    function onmousemove(msg){return [2,[8,msg]]}
    function onkeydown(msg){return [2,[9,msg]]}
    function str_prop(k,v){return [0,k,[0,v]]}
    function int_prop(k,v){return [0,k,[1,v]]}
    function bool_prop(k,v){return [0,k,[3,v]]}
    function float_prop(k,v){return [0,k,[2,v]]}
    function style$0(k,v){return [1,k,v]}
    function attr(k,v){return [3,k,v]}
    function int_attr(k,v){return [3,k,caml_call1(Stdlib[22],v)]}
    function float_attr(k,v){return [3,k,caml_call1(Stdlib[24],v)]}
    var
     scroll_to_show=bool_prop(cst_scroll_to_show,1),
     autofocus=bool_prop(cst_autofocus,1);
    function class$0(x){return [0,cst_className,[0,x]]}
    function type$1(x){return [0,cst_type,[0,x]]}
    var type_button=type$1(cst_button);
    function value$1(x){return [0,cst_value,[0,x]]}
    function disabled(x){return [0,cst_disabled,[3,x]]}
    function add_class(x,attrs)
     {function _bM_(param)
       {if(0 === param[0])
         if(! caml_string_notequal(param[1],cst_className$0))return 1;
        return 0}
      var has_className=caml_call2(Stdlib_list[28],_bM_,attrs);
      if(has_className)
       {var
         _bN_=
          function(a)
           {if(0 === a[0])
             if(! caml_string_notequal(a[1],cst_className$1))
              {var _bO_=a[2];
               if(0 === _bO_[0])
                {var s=_bO_[1];
                 return [0,
                         cst_className$2,
                         [0,caml_call3(Stdlib_printf[4],_f_,s,x)]]}}
            return a};
        return caml_call2(Stdlib_list[17],_bN_,attrs)}
      return [0,class$0(x),attrs]}
    function text(opt,txt)
     {if(opt)var sth=opt[1],key=sth;else var key=cst_txt;return [0,key,txt]}
    function elt(opt,tag,key,_bL_,l)
     {if(opt)var sth=opt[1],ns=sth;else var ns=cst;
      if(_bL_)var sth$0=_bL_[1],a=sth$0;else var a=0;
      if(key)var k=key[1],k$0=k;else var k$0=tag;
      return [1,k$0,ns,tag,a,l]}
    function svg_elt(tag,key,a,l){return elt([0,svg_ns],tag,key,a,l)}
    function div(key,a,l){return elt(0,cst_div,key,a,l)}
    function input(key,a,l){return elt(0,cst_input,key,a,l)}
    function txt_span(key,a,s){return elt(0,cst_span,key,a,[0,text(0,s),0])}
    function map_attr(f,init)
     {switch(init[0])
       {case 1:
         var attributes=init[4],_bI_=init[5],_bJ_=caml_call1(f,attributes);
         return [1,init[1],init[2],init[3],_bJ_,_bI_];
        case 4:
         var attributes$0=init[3],_bK_=caml_call1(f,attributes$0);
         return [4,init[1],init[2],_bK_];
        default:return init}}
    function map$0(opt,f,child)
     {if(opt)var sth=opt[1],key=sth;else var key=cst_map;
      return [2,key,f,child]}
    function memo(opt,f,arg)
     {if(opt)var sth=opt[1],key=sth;else var key=cst_memo;
      return [3,key,f,arg]}
    function custom(opt,_bH_,elt)
     {if(opt)var sth=opt[1],key=sth;else var key=cst_custom;
      if(_bH_)var sth$0=_bH_[1],a=sth$0;else var a=0;
      return [4,key,elt,a]}
    function return$0(opt,model)
     {if(opt)var sth=opt[1],c=sth;else var c=0;
      return [0,model,caml_call1(Cmd[5],c)]}
    function app(init,update,view,param){return [0,init,update,view]}
    function simple_app(init,update,view,param)
     {function _bG_(model,msg)
       {return return$0(0,caml_call2(update,model,msg))}
      return [0,return$0(0,init),_bG_,view]}
    function input_event(s)
     {return [0,
              function(param)
               {if(4 === param[0]){var f=param[1];return [0,caml_call1(f,s)]}
                return 0}]}
    function checked_event(b)
     {return [0,
              function(param)
               {if(7 === param[0]){var f=param[1];return [0,caml_call1(f,b)]}
                return 0}]}
    function change_event(s)
     {return [0,
              function(param)
               {if(5 === param[0]){var f=param[1];return [0,caml_call1(f,s)]}
                return 0}]}
    var
     Vdom=
      [0,
       Cmd,
       Custom,
       onclick,
       ondblclick,
       oncontextmenu,
       onfocus,
       onblur,
       oninput,
       onchange_checked,
       onchange,
       onchange_index,
       onmousemove,
       onkeydown,
       str_prop,
       int_prop,
       bool_prop,
       float_prop,
       style$0,
       attr,
       int_attr,
       float_attr,
       class$0,
       type$1,
       type_button,
       value$1,
       disabled,
       add_class,
       scroll_to_show,
       autofocus,
       input_event,
       checked_event,
       change_event,
       elt,
       svg_elt,
       text,
       map_attr,
       map$0,
       memo,
       custom,
       div,
       input,
       txt_span,
       return$0,
       app,
       simple_app];
    caml_register_global(444,Vdom,"Vdom");
    function send_msg(ctx){return ctx[1]}
    function run(param,p,x)
     {var p$0=p,x$0=x;
      for(;;)
       {if(x$0[1] === Cmd[1]){var msg=x$0[2];return caml_call1(p$0,msg)}
        if(x$0[1] === Cmd[2])
         {var l=x$0[2],_bB_=function(_bF_){return run(param,p$0,_bF_)};
          return caml_call2(Stdlib_list[15],_bB_,l)}
        if(x$0[1] === Cmd[3])
         {var
           x$1=x$0[3],
           f=x$0[2],
           p$2=
            function(p,f)
             {function p$0(x){return caml_call1(p,caml_call1(f,x))}return p$0},
           p$1=p$2(p$0,f),
           p$0=p$1,
           x$0=x$1;
          continue}
        var ctx=[0,p$0],param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            if(caml_call2(hd[1],ctx,x$0))return 0;
            var param$0=tl;
            continue}
          var
           _bC_=caml_call1(Stdlib_obj[21],x$0),
           _bD_=caml_call1(Stdlib_obj[22],_bC_),
           _bE_=caml_call2(Stdlib_printf[4],_g_,_bD_);
          return caml_call1(Stdlib[3],_bE_)}}}
    function make(sync,dom){return [0,dom,sync]}
    function send_event(ctx){return ctx[1]}
    function scroll_to_make_visible(child)
     {var node=child;
      for(;;)
       {if(caml_equal(node,Element[3]))
         var parent=caml_call1(Document[9],document$0);
        else
         {var
           _bv_=caml_call2(Window[24],window,node),
           overflow_y=caml_call2(Style[15],_bv_,cst_overflowY),
           _bw_=caml_string_notequal(overflow_y,cst_visible),
           is_scrollable=_bw_?caml_string_notequal(overflow_y,cst_hidden):_bw_;
          if(is_scrollable)
           {var _bx_=caml_call1(Element[43],node);
            if(_bx_ <= caml_call1(Element[45],node))
             var parent=node,switch$0=1;
            else
             var switch$0=0}
          else
           var switch$0=0;
          if(! switch$0)
           {var node$0=caml_call1(Element[34],node),node=node$0;continue}}
        var
         r_parent=caml_call1(Element[22],parent),
         r_child=caml_call1(Element[22],child),
         y1=caml_call1(Rect[8],r_parent),
         y2=caml_call1(Rect[8],r_child);
        if(y1 < y2)
         {var _by_=caml_call1(Element[48],parent) + y2 - y1;
          return caml_call2(Element[49],parent,_by_)}
        var
         y1$0=caml_call1(Rect[7],r_parent),
         y2$0=caml_call1(Rect[7],r_child),
         _bz_=y2$0 < y1$0?1:0;
        if(_bz_)
         {var _bA_=caml_call1(Element[48],parent) + y2$0 - y1$0;
          return caml_call2(Element[49],parent,_bA_)}
        return _bz_}}
    function get_dom(param)
     {switch(param[0])
       {case 0:return param[2];
        case 1:return param[2];
        case 2:return param[2];
        case 3:return param[2];
        default:return param[2][1]}}
    function get_vdom(param)
     {switch(param[0])
       {case 0:return param[1];
        case 1:return param[1];
        case 2:return param[1];
        case 3:return param[1];
        default:return param[1]}}
    function eval_prop(param)
     {switch(param[0])
       {case 0:var x=param[1];return x.toString();
        case 1:var x$0=param[1];return x$0;
        case 2:var x$1=param[1];return x$1;
        default:var x$2=param[1];return ! ! x$2}}
    function string_of_prop(param)
     {switch(param[0])
       {case 0:var s=param[1];return s;
        case 1:var x=param[1];return caml_call1(Stdlib[22],x);
        case 2:var x$0=param[1];return caml_call1(Stdlib[24],x$0);
        default:var x$1=param[1];return caml_call1(Stdlib[19],x$1)}}
    function same_prop(v1,match)
     {var _bt_=v1 === match?1:0;
      if(_bt_)
       var _bu_=_bt_;
      else
       {switch(v1[0])
         {case 0:
           if(0 === match[0])
            {var x2=match[1],x1=v1[1];return caml_string_equal(x1,x2)}
           break;
          case 1:
           if(1 === match[0])
            {var x2$0=match[1],x1$0=v1[1];return x1$0 === x2$0?1:0}
           break;
          case 2:
           if(2 === match[0])
            {var x2$1=match[1],x1$1=v1[1];return x1$1 == x2$1?1:0}
           break;
          default:
           if(3 === match[0])
            {var x2$2=match[1],x1$2=v1[1];return x1$2 === x2$2?1:0}}
        var _bu_=0}
      return _bu_}
    function bmemo(vdom,child){return [3,vdom,get_dom(child),child]}
    function async(f){caml_call3(Window[9],window,f,0);return 0}
    function custom_attribute(dom,param)
     {return caml_string_notequal(param,cst_autofocus$0)
              ?caml_string_notequal(param,cst_scroll_to_show$0)
                ?0
                :(async
                   (function(param)
                     {try
                       {var _bs_=scroll_to_make_visible(dom);return _bs_}
                      catch(exn)
                       {exn = caml_wrap_exception(exn);
                        var _br_=caml_call1(Stdlib_printexc[1],exn);
                        return caml_call2(Stdlib_printf[2],_h_,_br_)}}),
                  1)
              :(async(function(param){return caml_call1(Element[50],dom)}),1)}
    function apply_attributes(dom,attributes)
     {function _bm_(param)
       {switch(param[0])
         {case 0:
           var v=param[2],k=param[1],_bn_=1 - custom_attribute(dom,k);
           if(_bn_)
            var _bo_=eval_prop(v),_bp_=caml_call1(Element[2],dom)[k] = _bo_;
           else
            var _bp_=_bn_;
           return _bp_;
          case 1:
           var v$0=param[2],k$0=param[1],_bq_=v$0.toString();
           return caml_call1(Element[2],dom).style[k$0] = _bq_;
          case 2:return 0;
          default:
           var v$1=param[2],k$1=param[1];
           return caml_call3(Element[21],dom,k$1,v$1)}}
      return caml_call2(Stdlib_list[15],_bm_,attributes)}
    function blit(ctx,vdom)
     {switch(vdom[0])
       {case 0:
         var txt=vdom[2];
         return [0,vdom,caml_call2(Document[5],document$0,txt)];
        case 1:
         var
          children=vdom[5],
          attributes=vdom[4],
          tag=vdom[3],
          ns=vdom[2],
          dom$0=
           caml_string_equal(ns,cst$0)
            ?caml_call2(Document[3],document$0,tag)
            :caml_call3(Document[4],document$0,ns,tag),
          _a__=function(_bd_){return blit(ctx,_bd_)},
          children$0=caml_call2(Stdlib_list[17],_a__,children),
          _a$_=
           function(c)
            {var _bc_=get_dom(c);return caml_call2(Element[6],dom$0,_bc_)};
         caml_call2(Stdlib_list[15],_a$_,children$0);
         apply_attributes(dom$0,attributes);
         return [1,vdom,dom$0,children$0];
        case 2:
         var child=vdom[3],f=vdom[2],child$0=blit(ctx,child);
         return [2,vdom,get_dom(child$0),f,child$0];
        case 3:
         var arg=vdom[3],f$0=vdom[2];
         return bmemo(vdom,blit(ctx,caml_call1(f$0,arg)));
        default:
         var
          attributes$0=vdom[3],
          elt=vdom[2],
          dom=[],
          send_event=function _bl_(_bk_){return _bl_.fun(_bk_)},
          el=[],
          _ba_=ctx[2],
          _bb_=ctx[1];
         caml_update_dummy
          (dom,
           [246,
            function(_bh_)
             {var
               _bi_=caml_obj_tag(el),
               _bj_=
                250 === _bi_
                 ?el[1]
                 :246 === _bi_?caml_call1(CamlinternalLazy[2],el):el;
              return _bj_[1]}]);
         caml_update_dummy
          (send_event,
           function(e)
            {var
              _bf_=caml_obj_tag(dom),
              _bg_=
               250 === _bf_
                ?dom[1]
                :246 === _bf_?caml_call1(CamlinternalLazy[2],dom):dom;
             return caml_call2(_bb_,_bg_,e)});
         caml_update_dummy
          (el,
           [246,
            function(_be_)
             {var ctx=[0,send_event],param=_ba_;
              for(;;)
               {if(param)
                 {var tl=param[2],hd=param[1],match=caml_call2(hd,ctx,elt);
                  if(match){var f=match[1];return f}
                  var param=tl;
                  continue}
                return caml_call1
                        (Stdlib[3],cst_Vdom_blit_no_custom_element_handler_found)}}]);
         var
          _a9_=caml_obj_tag(el),
          elt$0=
           250 === _a9_
            ?el[1]
            :246 === _a9_?caml_call1(CamlinternalLazy[2],el):el;
         apply_attributes(elt$0[1],attributes$0);
         return [4,vdom,elt$0]}}
    function sync_props(to_string,same,set,clear,l1,l2)
     {function _a3_(param,_a8_)
       {var k2=_a8_[1],k1=param[1];return runtime.caml_string_compare(k1,k2)}
      var
       sort=caml_call1(Stdlib_list[48],_a3_),
       l1$0=caml_call1(sort,l1),
       l2$0=caml_call1(sort,l2),
       l1$1=l1$0,
       l2$1=l2$0;
      for(;;)
       {if(l1$1)
         {var _a4_=l1$1[2],_a5_=l1$1[1],_a7_=_a5_[1],_a6_=_a5_[2];
          if(l2$1)
           {var tl2=l2$1[2],match=l2$1[1],v2=match[2],k2=match[1];
            if(caml_string_lessthan(_a7_,k2))
             {caml_call1(clear,_a7_);var l1$1=_a4_;continue}
            if(caml_string_lessthan(k2,_a7_))
             {caml_call2(set,k2,v2);var l2$1=tl2;continue}
            if(1 - caml_call2(same,_a6_,v2))caml_call2(set,k2,v2);
            var l1$1=_a4_,l2$1=tl2;
            continue}
          caml_call1(clear,_a7_);
          var l1$1=_a4_,l2$1=0;
          continue}
        if(l2$1)
         {var tl2$0=l2$1[2],match$0=l2$1[1],v2$0=match$0[2],k2$0=match$0[1];
          caml_call2(set,k2$0,v2$0);
          var l1$1=0,l2$1=tl2$0;
          continue}
        return 0}}
    function choose(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var tl=param$0[2],hd=param$0[1],match=caml_call1(f,hd);
          if(match){var x=match[1];return [0,x,choose(f,tl)]}
          var param$0=tl;
          continue}
        return 0}}
    var js_empty_string="";
    function sync_attributes(dom,a1,a2)
     {function props(param)
       {if(0 === param[0]){var v=param[2],k=param[1];return [0,[0,k,v]]}
        return 0}
      function set(k,v)
       {if(! caml_string_notequal(k,cst_value$0))
         if(0 === v[0])
          {var s=v[1];
           if(caml_string_equal(s,caml_call1(Element[25],dom)))return 0}
        var _a0_=1 - custom_attribute(dom,k);
        if(_a0_)
         var _a1_=eval_prop(v),_a2_=caml_call1(Element[2],dom)[k] = _a1_;
        else
         var _a2_=_a0_;
        return _a2_}
      function clear(k)
       {var _aZ_=Ojs[17];return caml_call1(Element[2],dom)[k] = _aZ_}
      var _aT_=choose(props,a2);
      sync_props(string_of_prop,same_prop,set,clear,choose(props,a1),_aT_);
      function styles(param)
       {if(1 === param[0]){var v=param[2],k=param[1];return [0,[0,k,[0,v]]]}
        return 0}
      function set$0(k,v)
       {var _aY_=eval_prop(v);
        return caml_call1(Element[2],dom).style[k] = _aY_}
      function clear$0(k)
       {return caml_call1(Element[2],dom).style[k] = js_empty_string}
      var _aU_=choose(styles,a2);
      sync_props
       (string_of_prop,same_prop,set$0,clear$0,choose(styles,a1),_aU_);
      function attrs(param)
       {if(3 === param[0]){var v=param[2],k=param[1];return [0,[0,k,v]]}
        return 0}
      function set$1(k,v){return caml_call3(Element[21],dom,k,v)}
      function clear$1(k){return caml_call2(Element[20],dom,k)}
      var _aV_=choose(attrs,a2),_aW_=choose(attrs,a1),_aX_=caml_string_equal;
      return sync_props(function(s){return s},_aX_,set$1,clear$1,_aW_,_aV_)}
    function sync(ctx,parent,old,vdom)
     {if(vdom === get_vdom(old))return old;
      switch(old[0])
       {case 0:
         var _aw_=old[1];
         if(0 === _aw_[0])
          if(0 === vdom[0])
           {var s2=vdom[2],dom=old[2],s1=_aw_[2];
            if(caml_string_notequal(s1,s2))caml_call2(Element[33],dom,s2);
            return [0,vdom,dom]}
         break;
        case 1:
         var _az_=old[1];
         if(1 === _az_[0])
          if(1 === vdom[0])
           {var children=old[3],dom$0=old[2];
            if(caml_string_equal(_az_[3],vdom[3]))
             if(caml_string_equal(_az_[2],vdom[2]))
              {var
                old_children=caml_call1(Stdlib_array[12],children),
                new_children=caml_call1(Stdlib_array[12],vdom[5]),
                by_key=caml_call2(Stdlib_hashtbl[1],0,8),
                _aA_=old_children.length - 1 - 1 | 0;
               if(! (_aA_ < 0))
                {var i$1=_aA_;
                 for(;;)
                  {var
                    k$0=
                     get_vdom(caml_check_bound(old_children,i$1)[i$1 + 1])[1];
                   caml_call3(Stdlib_hashtbl[5],by_key,k$0,i$1);
                   var _aO_=i$1 - 1 | 0;
                   if(0 !== i$1){var i$1=_aO_;continue}
                   break}}
               var
                indices=runtime.caml_make_vect(new_children.length - 1,-1),
                _aC_=indices.length - 1 - 1 | 0,
                _aB_=0;
               if(! (_aC_ < 0))
                {var i$0=_aB_;
                 for(;;)
                  {var k=caml_check_bound(new_children,i$0)[i$0 + 1][1];
                   try
                    {var idx$0=caml_call2(Stdlib_hashtbl[6],by_key,k),switch$0=0}
                   catch(_aS_)
                    {_aS_ = caml_wrap_exception(_aS_);
                     if(_aS_ !== Not_found)throw _aS_;
                     var switch$0=1}
                   if(! switch$0)
                    {caml_check_bound(indices,i$0)[i$0 + 1] = idx$0;
                     caml_call2(Stdlib_hashtbl[10],by_key,k)}
                   var _aN_=i$0 + 1 | 0;
                   if(_aC_ !== i$0){var i$0=_aN_;continue}
                   break}}
               var
                _aD_=
                 function(param,i)
                  {var _aR_=get_dom(caml_check_bound(old_children,i)[i + 1]);
                   return caml_call2(Element[9],dom$0,_aR_)};
               caml_call2(Stdlib_hashtbl[12],_aD_,by_key);
               var
                ctrls=[0,0],
                next=[0,caml_call1(Element[1],Ojs[17])],
                _aE_=new_children.length - 1 - 1 | 0;
               if(! (_aE_ < 0))
                {var i=_aE_;
                 for(;;)
                  {var idx=caml_check_bound(indices,i)[i + 1];
                   if(0 <= idx)
                    var
                     _aF_=caml_check_bound(new_children,i)[i + 1],
                     c=
                      sync
                       (ctx,dom$0,caml_check_bound(old_children,idx)[idx + 1],_aF_);
                   else
                    var c=blit(ctx,caml_check_bound(new_children,i)[i + 1]);
                   if(0 <= idx)
                    {if(i === (new_children.length - 1 - 1 | 0))
                      var _aG_=idx !== (old_children.length - 1 - 1 | 0)?1:0;
                     else
                      var
                       _aM_=i + 1 | 0,
                       _aG_=
                        caml_check_bound(indices,_aM_)[_aM_ + 1] !== (idx + 1 | 0)
                         ?1
                         :0;
                     if(_aG_)
                      var
                       _aH_=next[1],
                       _aI_=get_dom(c),
                       move=caml_call1(Element[12],_aI_) !== _aH_?1:0;
                     else
                      var move=_aG_}
                   else
                    var move=1;
                   if(move)
                    {var _aJ_=next[1],_aK_=get_dom(c);
                     caml_call3(Element[7],dom$0,_aK_,_aJ_)}
                   next[1] = get_dom(c);
                   ctrls[1] = [0,c,ctrls[1]];
                   var _aL_=i - 1 | 0;
                   if(0 !== i){var i=_aL_;continue}
                   break}}
               var children$0=ctrls[1];
               sync_attributes(dom$0,_az_[4],vdom[4]);
               return [1,vdom,dom$0,children$0]}}
         break;
        case 2:
         if(2 === vdom[0])
          {var c2=vdom[3],f=vdom[2],c1=old[4],child=sync(ctx,parent,c1,c2);
           return [2,vdom,get_dom(child),f,child]}
         break;
        case 3:
         var _aP_=old[1];
         if(3 === _aP_[0])
          if(3 === vdom[0])
           {var a2=vdom[3],f2=vdom[2],c1$0=old[3],a1=_aP_[3],f1=_aP_[2];
            if(f1 === f2)if(a1 === a2)return bmemo(vdom,c1$0);
            return bmemo(vdom,sync(ctx,parent,c1$0,caml_call1(f2,a2)))}
         break;
        default:
         var _aQ_=old[1];
         if(4 === _aQ_[0])
          if(4 === vdom[0])
           {var
             a2$0=vdom[3],
             arg2=vdom[2],
             key2=vdom[1],
             elt=old[2],
             a1$0=_aQ_[3],
             arg1=_aQ_[2],
             key1=_aQ_[1];
            if(caml_string_equal(key1,key2))
             {var switch$1=arg1 === arg2?0:caml_call1(elt[2],arg2)?0:1;
              if(! switch$1)
               {sync_attributes(elt[1],a1$0,a2$0);return [4,vdom,elt]}}}}
      var x=blit(ctx,vdom),_ax_=get_dom(old),_ay_=get_dom(x);
      caml_call3(Element[8],parent,_ay_,_ax_);
      return x}
    function found(mapper,parent,inner)
     {var mapper$0=mapper,inner$0=inner;
      for(;;)
       switch(inner$0[0])
        {case 2:
          var
           inner$1=inner$0[4],
           f=inner$0[3],
           mapper$2=
            function(mapper,f)
             {function mapper$0(x){return caml_call1(mapper,caml_call1(f,x))}
              return mapper$0},
           mapper$1=mapper$2(mapper$0,f),
           mapper$0=mapper$1,
           inner$0=inner$1;
          continue;
         case 3:var inner$2=inner$0[3],inner$0=inner$2;continue;
         default:return [0,mapper$0,inner$0,parent]}}
    function vdom_of_dom(root,dom)
     {var
       _aq_=caml_call1(Element[2],dom),
       match=caml_call2(Ojs[7],Element[1],_aq_);
      if(match)
       {var dom$0=match[1];
        if(dom$0 === get_dom(root))
         {var _ar_=0;return found(function(x){return x},_ar_,root)}
        var parent=vdom_of_dom(root,caml_call1(Element[34],dom$0));
        if(parent)
         {var _as_=parent[2],_at_=parent[1];
          switch(_as_[0])
           {case 1:
             var children=_as_[3];
             try
              {var
                _au_=function(c){return get_dom(c) === dom$0?1:0},
                c=caml_call2(Stdlib_list[33],_au_,children)}
             catch(_av_)
              {_av_ = caml_wrap_exception(_av_);
               if(_av_ === Not_found)throw [0,Assert_failure,_j_];
               throw _av_}
             return found(_at_,parent,c);
            case 4:return 0;
            default:throw [0,Assert_failure,_i_]}}
        return 0}
      return 0}
    function mouse_event(e)
     {var
       _aj_=caml_call1(Event[18],e),
       _ak_=caml_call1(Event[17],e),
       _al_=caml_call1(Event[16],e),
       _am_=caml_call1(Event[15],e),
       _an_=caml_call1(Event[10],e),
       _ao_=caml_call1(Event[9],e),
       _ap_=caml_call1(Event[8],e);
      return [0,caml_call1(Event[7],e),_ap_,_ao_,_an_,_am_,_al_,_ak_,_aj_]}
    function dom(x){return x[1]}
    function process(x){return x[2]}
    function cmd(h){return [0,[0,h,0],empty[2]]}
    function custom$0(h){return [0,empty[1],[0,h,0]]}
    function merge(envs)
     {function _ae_(e){return e[2]}
      var
       _af_=caml_call2(Stdlib_list[17],_ae_,envs),
       _ag_=caml_call1(Stdlib_list[13],_af_);
      function _ah_(e){return e[1]}
      var _ai_=caml_call2(Stdlib_list[17],_ah_,envs);
      return [0,caml_call1(Stdlib_list[13],_ai_),_ag_]}
    var global=[0,empty];
    function register(e){global[1] = merge([0,e,[0,global[1],0]]);return 0}
    function run$0(opt,param)
     {var
       view=param[3],
       update=param[2],
       match=param[1],
       cmd0=match[2],
       model0=match[1];
      if(opt)var sth=opt[1],env=sth;else var env=empty;
      var
       env$0=merge([0,env,[0,global[1],0]]),
       container=caml_call2(Document[3],document$0,cst_div$0),
       process_custom_fwd=
        [0,function(param,_ad_){throw [0,Assert_failure,_k_]}],
       _m_=env$0[2],
       ctx=
        [0,
         function(dom,evt){return caml_call2(process_custom_fwd[1],dom,evt)},
         _m_],
       x=blit(ctx,caml_call1(view,model0)),
       model=[0,model0],
       current=[0,x],
       pending_redraw=[0,0],
       post_redraw=[0,0];
      function after_redraw(f){post_redraw[1] = [0,f,post_redraw[1]];return 0}
      function redraw(param)
       {pending_redraw[1] = 0;
        var
         new_vdom=caml_call1(view,model[1]),
         x=sync(ctx,container,current[1],new_vdom);
        current[1] = x;
        var l=caml_call1(Stdlib_list[9],post_redraw[1]);
        post_redraw[1] = 0;
        function _ac_(f){return caml_call1(f,0)}
        return caml_call2(Stdlib_list[15],_ac_,l)}
      function process(msg)
       {var
         match=caml_call2(update,model[1],msg),
         cmd=match[2],
         new_model=match[1];
        model[1] = new_model;
        run(env$0[1],process,cmd);
        var _ab_=1 - pending_redraw[1];
        return _ab_
                ?(pending_redraw[1] = 1,caml_call2(Window[11],window,redraw))
                :_ab_}
      var _n_=get_dom(x);
      caml_call2(Element[6],container,_n_);
      function onevent(evt)
       {var ty=caml_call1(Event[5],evt);
        try
         {var
           _s_=caml_call1(Event[3],evt),
           tgt=caml_call1(Element[1],_s_),
           propagate=
            function(param)
             {var param$0=param;
              a:
              for(;;)
               {if(param$0)
                 {var _Z_=param$0[2],___=param$0[1];
                  switch(_Z_[0])
                   {case 1:
                     var _$_=_Z_[1];
                     if(1 === _$_[0])
                      var attributes=_$_[4],switch$0=0;
                     else
                      var switch$0=1;
                     break;
                    case 4:
                     var _aa_=_Z_[1];
                     if(4 === _aa_[0])
                      var attributes=_aa_[3],switch$0=0;
                     else
                      var switch$0=1;
                     break;
                    default:var switch$0=1}
                  if(! switch$0)
                   {var parent=param$0[3],l=attributes;
                    for(;;)
                     {if(caml_string_notequal(ty,cst_blur))
                       if(caml_string_notequal(ty,cst_change))
                        if(caml_string_notequal(ty,cst_click))
                         if(caml_string_notequal(ty,cst_contextmenu))
                          if(caml_string_notequal(ty,cst_dblclick))
                           if(caml_string_notequal(ty,cst_focus))
                            if(caml_string_notequal(ty,cst_input$0))
                             if(caml_string_notequal(ty,cst_keydown))
                              if(caml_string_notequal(ty,cst_mousemove))
                               var switch$1=0;
                              else
                               if(l)
                                {var _G_=l[1];
                                 if(2 === _G_[0])
                                  {var _H_=_G_[1];
                                   if(8 === _H_[0])
                                    var
                                     f=_H_[1],
                                     match=[0,caml_call1(f,mouse_event(evt))],
                                     switch$1=1;
                                   else
                                    var switch$1=0}
                                 else
                                  var switch$1=0}
                               else
                                var switch$1=0;
                             else
                              if(l)
                               {var _I_=l[1];
                                if(2 === _I_[0])
                                 {var _J_=_I_[1];
                                  if(9 === _J_[0])
                                   var
                                    f$0=_J_[1],
                                    _D_=caml_call1(Event[18],evt),
                                    _E_=caml_call1(Event[17],evt),
                                    _F_=caml_call1(Event[16],evt),
                                    match=
                                     [0,
                                      caml_call1(f$0,[0,caml_call1(Event[19],evt),_F_,_E_,_D_])],
                                    switch$1=1;
                                  else
                                   var switch$1=0}
                                else
                                 var switch$1=0}
                              else
                               var switch$1=0;
                            else
                             if(l)
                              {var _K_=l[1];
                               if(2 === _K_[0])
                                {var _L_=_K_[1];
                                 if(4 === _L_[0])
                                  var
                                   f$1=_L_[1],
                                   match=[0,caml_call1(f$1,caml_call1(Element[25],tgt))],
                                   switch$1=1;
                                 else
                                  var switch$1=0}
                               else
                                var switch$1=0}
                             else
                              var switch$1=0;
                           else
                            if(l)
                             {var _M_=l[1];
                              if(2 === _M_[0])
                               {var _N_=_M_[1];
                                switch(_N_[0])
                                 {case 2:var msg=_N_[1],match=[0,msg],switch$1=1;break;
                                  case 5:
                                   var tl=l[2],curr_value=caml_call1(Element[25],tgt);
                                   caml_call3(Element[21],tgt,prev_value_attribute,curr_value);
                                   var l=tl;
                                   continue;
                                  default:var switch$1=0}}
                              else
                               var switch$1=0}
                            else
                             var switch$1=0;
                          else
                           if(l)
                            {var _O_=l[1];
                             if(2 === _O_[0])
                              {var _P_=_O_[1];
                               if(1 === _P_[0])
                                var
                                 f$2=_P_[1],
                                 match=[0,caml_call1(f$2,mouse_event(evt))],
                                 switch$1=1;
                               else
                                var switch$1=0}
                             else
                              var switch$1=0}
                           else
                            var switch$1=0;
                         else
                          if(l)
                           {var _Q_=l[1];
                            if(2 === _Q_[0])
                             {var _R_=_Q_[1];
                              if(10 === _R_[0])
                               {var f$3=_R_[1];
                                caml_call1(Event[4],evt);
                                var match=[0,caml_call1(f$3,mouse_event(evt))],switch$1=1}
                              else
                               var switch$1=0}
                            else
                             var switch$1=0}
                          else
                           var switch$1=0;
                        else
                         if(l)
                          {var _S_=l[1];
                           if(2 === _S_[0])
                            {var _T_=_S_[1];
                             if(0 === _T_[0])
                              var
                               f$4=_T_[1],
                               match=[0,caml_call1(f$4,mouse_event(evt))],
                               switch$1=1;
                             else
                              var switch$1=0}
                           else
                            var switch$1=0}
                         else
                          var switch$1=0;
                       else
                        if(l)
                         {var _U_=l[1];
                          if(2 === _U_[0])
                           {var _V_=_U_[1];
                            switch(_V_[0])
                             {case 6:
                               var
                                f$5=_V_[1],
                                match=[0,caml_call1(f$5,caml_call1(Element[29],tgt))],
                                switch$1=1;
                               break;
                              case 7:
                               var
                                f$6=_V_[1],
                                match=[0,caml_call1(f$6,caml_call1(Element[30],tgt))],
                                switch$1=1;
                               break;
                              default:var switch$1=0}}
                          else
                           var switch$1=0}
                        else
                         var switch$1=0;
                      else
                       if(l)
                        {var _W_=l[1];
                         if(2 === _W_[0])
                          {var _X_=_W_[1];
                           switch(_X_[0])
                            {case 3:var msg$0=_X_[1],match=[0,msg$0],switch$1=1;break;
                             case 5:
                              var
                               f$7=_X_[1],
                               curr_value$0=caml_call1(Element[25],tgt),
                               _Y_=1 - caml_call2(Element[18],tgt,prev_value_attribute),
                               changed=
                                _Y_
                                ||
                                caml_string_notequal
                                 (caml_call2(Element[19],tgt,prev_value_attribute),
                                  curr_value$0);
                              if(changed)
                               var match=[0,caml_call1(f$7,curr_value$0)],switch$1=1;
                              else
                               var match=0,switch$1=1;
                              break;
                             default:var switch$1=0}}
                         else
                          var switch$1=0}
                       else
                        var switch$1=0;
                      if(! switch$1)
                       {if(l){var l$0=l[2],l=l$0;continue}var match=0}
                      if(match)
                       {var msg$1=match[1];return process(caml_call1(___,msg$1))}
                      var param$0=parent;
                      continue a}}}
                return 0}};
          propagate(vdom_of_dom(current[1],tgt));
          var
           _t_=caml_string_equal(ty,cst_input$1),
           _u_=_t_ || caml_string_equal(ty,cst_blur$0);
          if(_u_)
           var
            f=
             function(param)
              {var match=vdom_of_dom(current[1],tgt);
               if(match)
                {var _x_=match[2];
                 if(1 === _x_[0])
                  {var _y_=_x_[1];
                   if(1 === _y_[0])
                    {var
                      attributes=_y_[4],
                      _z_=
                       function(param)
                        {if(0 === param[0])
                          {var _A_=param[1];
                           if(caml_string_notequal(_A_,cst_checked))
                            {if(! caml_string_notequal(_A_,cst_value$1))
                              {var _B_=param[2];
                               if(0 === _B_[0])
                                {var s2=_B_[1];
                                 if(caml_string_notequal(s2,caml_call1(Element[25],tgt)))
                                  return caml_call2(Element[26],tgt,s2)}}}
                           else
                            {var _C_=param[2];
                             if(3 === _C_[0])
                              {var s2$0=_C_[1];return caml_call2(Element[31],tgt,s2$0)}}}
                         return 0};
                     return caml_call2(Stdlib_list[15],_z_,attributes)}}}
               return 0},
            _v_=pending_redraw[1]?after_redraw(f):f(0),
            _w_=_v_;
          else
           var _w_=_u_;
          return _w_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          var _r_=caml_call1(Stdlib_printexc[1],exn);
          return caml_call3(Stdlib_printf[2],_l_,ty,_r_)}}
      function process_custom(tgt,event)
       {var match=vdom_of_dom(current[1],tgt);
        if(match)
         {var _o_=match[2];
          if(4 === _o_[0])
           {var _p_=_o_[1];
            if(4 === _p_[0])
             {var attributes=_p_[3],mapper=match[1],param=attributes;
              for(;;)
               {if(param)
                 {var _q_=param[1];
                  if(2 !== _q_[0])
                   {var param$0=param[2],param=param$0;continue}
                  var rest=param[2],h=_q_[1],r=caml_call1(event[1],h);
                  if(! r){var param=rest;continue}
                  var match$0=r}
                else
                 var match$0=0;
                if(match$0)
                 {var msg=match$0[1];return process(caml_call1(mapper,msg))}
                return 0}}}}
        return 0}
      process_custom_fwd[1] = process_custom;
      caml_call4(Element[15],container,cst_click$0,onevent,0);
      caml_call4(Element[15],container,cst_dblclick$0,onevent,0);
      caml_call4(Element[15],container,cst_input$2,onevent,0);
      caml_call4(Element[15],container,cst_change$0,onevent,0);
      caml_call4(Element[15],container,cst_focus$0,onevent,1);
      caml_call4(Element[15],container,cst_blur$1,onevent,1);
      caml_call4(Element[15],container,cst_mousemove$0,onevent,1);
      caml_call4(Element[15],container,cst_keydown$0,onevent,1);
      caml_call4(Element[15],container,cst_contextmenu$0,onevent,1);
      run(env$0[1],process,cmd0);
      return [0,container,process]}
    var
     Vdom_blit=
      [0,
       [0,send_msg],
       [0,make,send_event],
       cmd,
       custom$0,
       merge,
       empty,
       register,
       run$0,
       dom,
       process];
    caml_register_global(451,Vdom_blit,"Vdom_blit");
    return}
  (function(){return this}()));


//# 1 ".code.eobjs/byte/kbdlayout.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_FFA0A0=caml_new_string("#FFA0A0"),
     cst_white=caml_new_string("white"),
     cst_fill=caml_new_string("fill"),
     cst_height=caml_new_string("height"),
     cst_width=caml_new_string("width"),
     cst_y=caml_new_string("y"),
     cst_x=caml_new_string("x"),
     cst_rect=caml_new_string("rect"),
     cst_y$0=caml_new_string("y"),
     cst_x$0=caml_new_string("x"),
     cst_text=caml_new_string("text"),
     cst_remove=caml_new_string("remove"),
     cst_interactive=caml_new_string("interactive"),
     cst_a=caml_new_string("a"),
     cst_content_curtain=caml_new_string("content curtain"),
     cst_height$0=caml_new_string("height"),
     cst_width$0=caml_new_string("width"),
     cst_svg=caml_new_string("svg"),
     cst_title=caml_new_string("title"),
     cst_in_edit=caml_new_string("in-edit"),
     cst$0=caml_new_string(""),
     cst_keyboard=caml_new_string("keyboard"),
     cst_home_positionns_now=caml_new_string("home positionns now."),
     cst=caml_new_string(", "),
     cst_pinky=caml_new_string("pinky"),
     cst_ring=caml_new_string("ring"),
     cst_middle=caml_new_string("middle"),
     cst_index=caml_new_string("index"),
     cst_thumb=caml_new_string("thumb"),
     cst_right=caml_new_string("right"),
     cst_left=caml_new_string("left"),
     sample_dvorak_data=
      [0,
       caml_list_of_js_array
        ([[0,96],
          [0,49],
          [0,50],
          [0,51],
          [0,52],
          [0,53],
          [0,54],
          [0,55],
          [0,56],
          [0,57],
          [0,48],
          [0,91],
          [0,93]]),
       [0,
        caml_list_of_js_array
         ([0,
           [0,39],
           [0,44],
           [0,46],
           [0,80],
           [0,89],
           [0,70],
           [0,71],
           [0,67],
           [0,82],
           [0,76],
           [0,47],
           [0,61]]),
        [0,
         caml_list_of_js_array
          ([0,
            [1,65,0,0],
            [1,79,0,1],
            [1,69,0,2],
            [1,85,0,3],
            [0,73],
            [0,68],
            [1,72,1,3],
            [1,84,1,2],
            [1,78,1,1],
            [1,83,1,0],
            [0,45],
            [0,92]]),
         [0,
          caml_list_of_js_array
           ([[0,60],
             [0,59],
             [0,81],
             [0,74],
             [0,75],
             [0,88],
             [0,66],
             [0,77],
             [0,87],
             [0,86],
             [0,90],
             0,
             0]),
          0]]]],
     sample_colemak_data=
      [0,
       caml_list_of_js_array
        ([[0,96],
          [0,49],
          [0,50],
          [0,51],
          [0,52],
          [0,53],
          [0,54],
          [0,55],
          [0,56],
          [0,57],
          [0,48],
          [0,45],
          [0,61],
          0]),
       [0,
        caml_list_of_js_array
         ([0,
           [0,81],
           [0,87],
           [0,70],
           [0,80],
           [0,71],
           [0,74],
           [0,76],
           [0,85],
           [0,89],
           [0,59],
           [0,91],
           [0,93],
           [0,92]]),
        [0,
         caml_list_of_js_array
          ([0,
            [1,65,0,0],
            [1,82,0,1],
            [1,83,0,2],
            [1,84,0,3],
            [0,68],
            [0,72],
            [1,78,1,3],
            [1,69,1,2],
            [1,73,1,1],
            [1,79,1,0],
            [0,39],
            0,
            0]),
         [0,
          caml_list_of_js_array
           ([0,
             [0,90],
             [0,88],
             [0,67],
             [0,86],
             [0,66],
             [0,75],
             [0,77],
             [0,44],
             [0,46],
             [0,47],
             0,
             0,
             0]),
          0]]]],
     sample_qwerty_data=
      [0,
       caml_list_of_js_array
        ([[0,34],
          [0,49],
          [0,50],
          [0,51],
          [0,52],
          [0,53],
          [0,54],
          [0,55],
          [0,56],
          [0,57],
          [0,48],
          [0,42],
          [0,45]]),
       [0,
        caml_list_of_js_array
         ([0,
           [0,81],
           [0,87],
           [0,69],
           [0,82],
           [0,84],
           [0,89],
           [0,85],
           [0,73],
           [0,79],
           [0,80],
           [0,71],
           [0,85]]),
        [0,
         caml_list_of_js_array
          ([0,
            [1,65,0,0],
            [1,83,0,1],
            [1,68,0,2],
            [1,70,0,3],
            [0,71],
            [0,72],
            [1,74,1,3],
            [1,75,1,2],
            [1,76,1,1],
            [1,83,1,0],
            [0,73],
            [0,59]]),
         [0,
          caml_list_of_js_array
           ([[0,60],
             [0,90],
             [0,88],
             [0,67],
             [0,86],
             [0,66],
             [0,78],
             [0,77],
             [0,44],
             [0,46],
             [0,47],
             0,
             0]),
          0]]]],
     Stdlib_list=global_data.Stdlib__list,
     Stdlib=global_data.Stdlib,
     Vdom=global_data.Vdom,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_queue=global_data.Stdlib__queue,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     _d_=[0,0,0],
     _a_=
      [0,
       [12,40,[4,0,0,0,[11,caml_new_string(", "),[4,0,0,0,[12,41,0]]]]],
       caml_new_string("(%d, %d)")],
     _b_=
      [0,
       [11,caml_new_string("home_positions: "),[2,0,[12,10,0]]],
       caml_new_string("home_positions: %s\n")],
     _c_=
      [0,
       [0,
        [11,
         caml_new_string(" with "),
         [2,0,[12,32,[2,0,[11,caml_new_string(" at "),[4,0,0,0,[12,10,0]]]]]]]],
       caml_new_string("%c with %s %s at %d\n")];
    function string_of_hand(param){return 0 === param?cst_left:cst_right}
    function string_of_finger(param)
     {switch(param)
       {case 0:return cst_pinky;
        case 1:return cst_ring;
        case 2:return cst_middle;
        case 3:return cst_index;
        default:return cst_thumb}}
    function lookup_of_data(layout)
     {caml_call1(Stdlib[35],cst_home_positionns_now);
      var results=0,y=0,x=0,param=layout;
      for(;;)
       {if(param)
         {var _K_=param[1];
          if(_K_)
           {var rows=param[2],t=_K_[2],h=_K_[1];
            if(typeof h === "number")
             var switch$0=0;
            else
             if(1 === h[0])
              var results$0=[0,[0,x,y],results],switch$0=1;
             else
              var switch$0=0;
            if(! switch$0)var results$0=results;
            var
             param$0=[0,t,rows],
             x$0=x + 1 | 0,
             results=results$0,
             x=x$0,
             param=param$0;
            continue}
          var param$1=param[2],y$0=y + 1 | 0,y=y$0,x=0,param=param$1;
          continue}
        var
         _L_=
          function(param)
           {var y=param[2],x=param[1];
            return caml_call3(Stdlib_printf[4],_a_,x,y)},
         _M_=caml_call2(Stdlib_list[17],_L_,results),
         _N_=caml_call2(Stdlib_string[7],cst,_M_);
        caml_call2(Stdlib_printf[2],_b_,_N_);
        var
         _O_=
          function(y,cols)
           {function _al_(x,k)
             {if(typeof k === "number")
               return [0,0,x,y,0,4,0,0,0];
              else
               {if(0 === k[0]){var c=k[1];return [0,[0,c],x,y,0,4,0,0,0]}
                var finger=k[3],hand=k[2],c$0=k[1];
                return [0,[0,c$0],x,y,hand,finger,0,0,0]}}
            return caml_call2(Stdlib_list[18],_al_,cols)},
         _P_=caml_call2(Stdlib_list[18],_O_,layout),
         _Q_=caml_call2(Stdlib_list[17],Stdlib_array[12],_P_),
         matrix=caml_call1(Stdlib_array[12],_Q_),
         width=caml_check_bound(matrix,0)[1].length - 1,
         height=matrix.length - 1,
         q=caml_call1(Stdlib_queue[2],0),
         map=caml_call2(Stdlib_hashtbl[1],0,runtime.caml_mul(width,height)),
         _ac_=
          function(it)
           {var y=it[2],x=it[1];
            caml_check_bound(caml_check_bound(matrix,y)[y + 1],x)[x + 1][8]
            =
            1;
            return caml_call2(Stdlib_queue[4],it,q)};
        caml_call2(Stdlib_list[15],_ac_,results);
        for(;;)
         {if(caml_call1(Stdlib_queue[11],q))return map;
          var
           match=caml_call1(Stdlib_queue[6],q),
           node_y=match[2],
           node_x=match[1],
           node=
            caml_check_bound
              (caml_check_bound(matrix,node_y)[node_y + 1],node_x)
             [node_x + 1],
           my_dist=node[6] + 1 | 0,
           _ad_=node[1];
          if(_ad_)
           {var
             c=_ad_[1],
             _ae_=node[6],
             _af_=string_of_finger(node[5]),
             _ag_=string_of_hand(node[4]);
            caml_call5(Stdlib_printf[2],_c_,c,_ag_,_af_,_ae_);
            caml_call3(Stdlib_hashtbl[5],map,c,[0,node[4],node[5],node[6]])}
          var _R_=0;
          if((node_y + 1 | 0) < height)
           var
            _S_=node_y + 1 | 0,
            _T_=
             [0,
              caml_check_bound(caml_check_bound(matrix,_S_)[_S_ + 1],node_x)
               [node_x + 1],
              0];
          else
           var _T_=0;
          var _U_=[0,_T_,_R_];
          if((node_x + 1 | 0) < width)
           var
            _V_=node_x + 1 | 0,
            _W_=
             [0,
              caml_check_bound
                (caml_check_bound(matrix,node_y)[node_y + 1],_V_)
               [_V_ + 1],
              0];
          else
           var _W_=0;
          var _X_=[0,_W_,_U_];
          if(0 < node_y)
           var
            _Y_=node_y - 1 | 0,
            _Z_=
             [0,
              caml_check_bound(caml_check_bound(matrix,_Y_)[_Y_ + 1],node_x)
               [node_x + 1],
              0];
          else
           var _Z_=0;
          var ___=[0,_Z_,_X_];
          if(0 < node_x)
           var
            _$_=node_x - 1 | 0,
            _aa_=
             [0,
              caml_check_bound
                (caml_check_bound(matrix,node_y)[node_y + 1],_$_)
               [_$_ + 1],
              0];
          else
           var _aa_=0;
          var
           _ab_=caml_call1(Stdlib_list[14],[0,_aa_,___]),
           _ah_=
            function(node,my_dist)
              {return function(n)
                {var _ai_=n[3],_aj_=n[2],_ak_=n[6];
                 return 0 === n[7]
                         ?0 === n[8]
                           ?(n[4]
                             =
                             node[4],
                             n[5]
                             =
                             node[5],
                             n[6]
                             =
                             my_dist,
                             n[8]
                             =
                             1,
                             caml_call2(Stdlib_queue[4],[0,_aj_,_ai_],q))
                           :my_dist < _ak_
                             ?(n[4] = node[4],n[5] = node[5],n[6] = my_dist,0)
                             :0
                         :0}}
             (node,my_dist);
          caml_call2(Stdlib_list[15],_ah_,_ab_);
          continue}}}
    function view(opt,_e_,onremove,label,layout)
     {if(opt)var sth=opt[1],highlit_key=sth;else var highlit_key=0;
      if(_e_)var sth$0=_e_[1],in_edit=sth$0;else var in_edit=0;
      var l=40;
      function _f_(row,cols)
       {function _z_(param,key)
         {var rects=param[2],col=param[1];
          if(typeof key === "number")return [0,col + 1 | 0,rects];
          var c=key[1];
          if(highlit_key)
           {var c$0=highlit_key[1];
            if(c === c$0)var fill=cst_FFA0A0,switch$0=1;else var switch$0=0}
          else
           var switch$0=0;
          if(! switch$0)var fill=cst_white;
          var
           pos_x=col * 40 | 0,
           pos_y=row * 40 | 0,
           _B_=[0,caml_call2(Vdom[19],cst_fill,fill),0],
           _C_=[0,caml_call2(Vdom[20],cst_height,l),_B_],
           _D_=[0,caml_call2(Vdom[20],cst_width,l),_C_],
           _E_=[0,caml_call2(Vdom[20],cst_y,pos_y),_D_],
           _F_=[0,[0,caml_call2(Vdom[20],cst_x,pos_x),_E_]],
           rect=caml_call4(Vdom[34],cst_rect,0,_F_,0),
           _G_=caml_call2(Stdlib_string[1],1,c),
           _H_=[0,caml_call2(Vdom[35],0,_G_),0],
           _I_=[0,caml_call2(Vdom[20],cst_y$0,pos_y + 15 | 0),0],
           _J_=[0,[0,caml_call2(Vdom[20],cst_x$0,pos_x + 5 | 0),_I_]],
           text=caml_call4(Vdom[34],cst_text,0,_J_,_H_);
          return [0,col + 1 | 0,[0,text,[0,rect,rects]]]}
        var _A_=caml_call3(Stdlib_list[20],_z_,_d_,cols)[2];
        return caml_call1(Stdlib_list[9],_A_)}
      var
       _g_=caml_call2(Stdlib_list[18],_f_,layout),
       key_buttons=caml_call1(Stdlib_list[14],_g_),
       _h_=0;
      function _i_(acc,l)
       {var _y_=caml_call1(Stdlib_list[1],l);
        return caml_call2(Stdlib[6],acc,_y_)}
      var
       max_row_len=caml_call3(Stdlib_list[20],_i_,_h_,layout),
       _j_=[0,caml_call2(Vdom[35],0,cst_remove),0],
       _k_=[0,caml_call1(Vdom[22],cst_interactive),0],
       _l_=[0,[0,caml_call1(Vdom[3],onremove),_k_]],
       _m_=[0,caml_call5(Vdom[33],0,cst_a,0,_l_,_j_),0],
       _n_=[0,[0,caml_call1(Vdom[22],cst_content_curtain),0]],
       _o_=[0,caml_call3(Vdom[40],0,_n_,_m_),0],
       _p_=[0,caml_call2(Vdom[20],cst_height$0,160),0],
       _q_=[0,[0,caml_call2(Vdom[20],cst_width$0,max_row_len * 40 | 0),_p_]],
       _r_=[0,caml_call4(Vdom[34],cst_svg,0,_q_,key_buttons),_o_],
       _s_=[0,caml_call2(Vdom[35],0,label),0],
       _t_=[0,[0,caml_call1(Vdom[22],cst_title),0]],
       _u_=[0,caml_call3(Vdom[40],0,_t_,_s_),_r_],
       _v_=0,
       _w_=in_edit?cst_in_edit:cst$0,
       _x_=[0,[0,caml_call1(Vdom[22],_w_),_v_]];
      return caml_call5(Vdom[33],0,cst_keyboard,0,_x_,_u_)}
    var
     Kbdlayout=
      [0,
       string_of_hand,
       string_of_finger,
       sample_colemak_data,
       sample_dvorak_data,
       sample_qwerty_data,
       lookup_of_data,
       view];
    runtime.caml_register_global(46,Kbdlayout,"Kbdlayout");
    return}
  (function(){return this}()));


//# 1 ".code.eobjs/byte/sampletexts.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string,
     sentence=
      caml_new_string
       ("A wet brown dog came running and did not bark, lifting a wet feather of a tail. The man followed in a wet black oilskin jacket, like a chauffeur, and face flushed a little. She felt him recoil in his quick walk, when he saw her. She stood up in the handbreadth of dryness under the rustic porch. He saluted without speaking, coming slowly near. She began to withdraw."),
     sherlock=
      caml_new_string
       (" In the year 1878 I took my degree of Doctor of Medicine of the University of London, and proceeded to Netley to go through the course prescribed for surgeons in the army. Having completed my studies there, I was duly attached to the Fifth Northumberland Fusiliers as Assistant Surgeon. The regiment was stationed in India at the time, and before I could join it, the second Afghan war had broken out. On landing at Bombay, I learned that my corps had advanced through the passes, and was already deep in the enemy's country. I followed, however, with many other officers who were in the same situation as myself, and succeeded in reaching Candahar in safety, where I found my regiment, and at once entered upon my new duties.\n\nThe campaign brought honours and promotion to many, but for me it had nothing but misfortune and disaster. I was removed from my brigade and attached to the Berkshires, with whom I served at the fatal battle of Maiwand. There I was struck on the shoulder by a Jezail bullet, which shattered the bone and grazed the subclavian artery. I should have fallen into the hands of the murderous Ghazis had it not been for the devotion and courage shown by Murray, my orderly, who threw me across a pack-horse, and succeeded in bringing me safely to the British lines."),
     Sampletexts=[0,sentence,sherlock];
    runtime.caml_register_global(2,Sampletexts,"Sampletexts");
    return}
  (function(){return this}()));


//# 1 ".code.eobjs/byte/code.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_container=caml_new_string("container"),
     cst_Colemak=caml_new_string("Colemak"),
     cst_Dvorak$0=caml_new_string("Dvorak"),
     cst_Qwerty$0=caml_new_string("Qwerty"),
     cst_Qwerty$1=caml_new_string("Qwerty"),
     cst_Dvorak$1=caml_new_string("Dvorak"),
     cst_Colemak$0=caml_new_string("Colemak"),
     cst_option$2=caml_new_string("option"),
     cst_select$0=caml_new_string("select"),
     cst$3=caml_new_string(""),
     cst_selected$0=caml_new_string("selected"),
     cst_option$3=caml_new_string("option"),
     cst_interactive$1=caml_new_string("interactive"),
     cst_select$1=caml_new_string("select"),
     cst_content=caml_new_string("content"),
     cst_create_keyboard_button=caml_new_string("create-keyboard-button"),
     cst_id$1=caml_new_string("id"),
     cst_Add_New=caml_new_string("Add New"),
     cst_title=caml_new_string("title"),
     cst_in_edit=caml_new_string("in-edit"),
     cst_hidden$0=caml_new_string("hidden"),
     cst_keyboard=caml_new_string("keyboard"),
     cst_best_stat=caml_new_string(" best-stat"),
     cst$2=caml_new_string(""),
     cst_numerical=caml_new_string("numerical"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_hidden=caml_new_string("hidden"),
     cst$1=caml_new_string(""),
     cst_br$0=caml_new_string("br"),
     cst_distance=caml_new_string("distance"),
     cst_numerical$0=caml_new_string("numerical"),
     cst_th$0=caml_new_string("th"),
     cst_same_finger=caml_new_string("same finger"),
     cst_numerical$1=caml_new_string("numerical"),
     cst_th$1=caml_new_string("th"),
     cst_same_hand=caml_new_string("same hand"),
     cst_numerical$2=caml_new_string("numerical"),
     cst_th$2=caml_new_string("th"),
     cst_th$3=caml_new_string("th"),
     cst_tr$0=caml_new_string("tr"),
     cst_stats=caml_new_string("stats"),
     cst_id$0=caml_new_string("id"),
     cst_table=caml_new_string("table"),
     cst_one_sentence$0=caml_new_string("one sentence"),
     cst_sherlock_holmes$0=caml_new_string("sherlock holmes"),
     cst_cols=caml_new_string("cols"),
     cst_rows=caml_new_string("rows"),
     cst_textarea=caml_new_string("textarea"),
     cst_br=caml_new_string("br"),
     cst_sherlock_holmes=caml_new_string("sherlock holmes"),
     cst_option=caml_new_string("option"),
     cst_one_sentence=caml_new_string("one sentence"),
     cst_option$0=caml_new_string("option"),
     cst_Sample_Texts=caml_new_string("Sample Texts"),
     cst$0=caml_new_string(""),
     cst_selected=caml_new_string("selected"),
     cst_option$1=caml_new_string("option"),
     cst_select=caml_new_string("select"),
     cst_passage=caml_new_string("passage"),
     cst_id=caml_new_string("id"),
     cst_save=caml_new_string("\xe2\x9c\x93 save"),
     cst_edit=caml_new_string("\xe2\x9c\x8e edit"),
     cst_interactive$0=caml_new_string("interactive"),
     cst_play=caml_new_string("\xe2\x96\xb6 play"),
     cst_reset=caml_new_string("\xe2\x97\x80\xe2\x97\x80 reset"),
     cst_play$0=caml_new_string("\xe2\x96\xb7 play"),
     cst_end=caml_new_string("\xe2\x96\xb6\xe2\x96\xb6 end"),
     cst_stop=caml_new_string("\xe2\x97\xbc stop"),
     cst_inline_block=caml_new_string("inline-block"),
     cst_display=caml_new_string("display"),
     cst_keyboards=caml_new_string("keyboards"),
     cst_id$2=caml_new_string("id"),
     cst_center=caml_new_string("center"),
     cst_text_align=caml_new_string("text-align"),
     cst_height=caml_new_string("height"),
     cst_width=caml_new_string("width"),
     cst_y$0=caml_new_string("y"),
     cst_x=caml_new_string("x"),
     cst_rect=caml_new_string("rect"),
     cst_y$1=caml_new_string("y"),
     cst_x$0=caml_new_string("x"),
     cst_text$0=caml_new_string("text"),
     cst_y=caml_new_string("y"),
     cst_text=caml_new_string("text"),
     cst_height$0=caml_new_string("height"),
     cst_svg=caml_new_string("svg"),
     cst_interactive=caml_new_string("interactive"),
     param=[0,0],
     cst_Same_Hand=caml_new_string("Same Hand"),
     cst_Same_Finger=caml_new_string("Same Finger"),
     cst_Distance=caml_new_string("Distance"),
     cst_list_can_t_be_empty=caml_new_string("list can't be empty"),
     cst=caml_new_string(""),
     cst_Qwerty=caml_new_string("Qwerty"),
     cst_Dvorak=caml_new_string("Dvorak"),
     Vdom_blit=global_data.Vdom_blit,
     Js_browser=global_data.Js_browser,
     Kbdlayout=global_data.Kbdlayout,
     Vdom=global_data.Vdom,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Sampletexts=global_data.Sampletexts,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     _k_=
      [0,
       caml_new_string("Colemak"),
       [0,caml_new_string("Dvorak"),[0,caml_new_string("Qwerty"),0]]],
     _i_=[0,0,[0,1,[0,2,0]]],
     _j_=[0,5,0],
     _g_=[0,0,0,0],
     _h_=[0,0];
    function chars_of_string(s)
     {function aux(i)
       {if(i < caml_ml_string_length(s))
         {var _cI_=aux(i + 1 | 0);return [0,caml_string_get(s,i),_cI_]}
        return 0}
      return aux(0)}
    function string_of_chars(chars)
     {var
       _cG_=caml_call1(Stdlib_string[1],1),
       _cH_=caml_call2(Stdlib_list[17],_cG_,chars);
      return caml_call2(Stdlib_string[7],cst,_cH_)}
    function find_best_in_list(cmp,l)
     {if(l){var t=l[2],h=l[1];return caml_call3(Stdlib_list[20],cmp,h,t)}
      return caml_call1(Stdlib[3],cst_list_can_t_be_empty)}
    function get(x,param)
     {switch(param){case 0:return x[1];case 1:return x[2];default:return x[3]}}
    function map(f,x)
     {var _cE_=caml_call1(f,x[3]),_cF_=caml_call1(f,x[2]);
      return [0,caml_call1(f,x[1]),_cF_,_cE_]}
    function map2(f,x,y)
     {var _cC_=caml_call2(f,x[3],y[3]),_cD_=caml_call2(f,x[2],y[2]);
      return [0,caml_call2(f,x[1],y[1]),_cD_,_cC_]}
    function init(x){return [0,x,x,x]}
    function string_of_key(param)
     {switch(param)
       {case 0:return cst_Same_Hand;
        case 1:return cst_Same_Finger;
        default:return cst_Distance}}
    var Stats=[0,get,map,map2,init,string_of_key];
    function update_analysis(letter,analysis)
     {var match=caml_call2(Stdlib_hashtbl[7],analysis[3],letter);
      if(match)
       {var
         match$0=match[1],
         dist=match$0[3],
         finger=match$0[2],
         hand=match$0[1],
         last_finger=analysis[6],
         last_hand=analysis[5],
         stats=analysis[4],
         _cy_=stats[3] + dist | 0,
         _cz_=finger === last_finger?1:0,
         _cA_=stats[2] + _cz_ | 0,
         _cB_=hand === last_hand?1:0;
        return [0,
                analysis[1],
                analysis[2],
                analysis[3],
                [0,stats[1] + _cB_ | 0,_cA_,_cy_],
                hand,
                finger]}
      return analysis}
    function finish_analyses(model)
     {var analyses=model[2],param$0=model[1],_cw_=model[3];
      for(;;)
       {if(typeof param$0 === "number")
         {if(0 === param$0){var param$0=param;continue}}
        else
         {var i=param$0[1];
          if((i + 1 | 0) < caml_ml_string_length(model[3]))
           {var
             _cu_=caml_string_get(model[3],i),
             c=caml_call1(Stdlib_char[6],_cu_),
             param$1=[0,i + 1 | 0],
             _cv_=
              function(c)
                {return function(_cx_){return update_analysis(c,_cx_)}}
               (c),
             analyses$0=caml_call2(Stdlib_list[17],_cv_,analyses),
             analyses=analyses$0,
             param$0=param$1;
            continue}}
        return [0,1,analyses,_cw_]}}
    function group_typing_analyses(analyses)
     {var _cp_=caml_call1(Stats[4],0);
      function _cq_(acc,it)
       {var _cs_=it[4];
        function _ct_(a,b){return [0,[0,it[1],b],a]}
        return caml_call3(Stats[3],_ct_,acc,_cs_)}
      var _cr_=caml_call3(Stdlib_list[20],_cq_,_cp_,analyses);
      return caml_call2(Stats[2],Stdlib_list[9],_cr_)}
    function find_best_stats(l)
     {function cmp(a,b)
       {var b_val=b[2],a_val=a[2];
        return runtime.caml_lessthan(a_val,b_val)?a:b}
      var _cn_=group_typing_analyses(l);
      function _co_(a){return find_best_in_list(cmp,a)[1]}
      return caml_call2(Stats[2],_co_,_cn_)}
    var
     _a_=Sampletexts[1],
     _b_=caml_call1(Stats[4],0),
     _c_=caml_call1(Kbdlayout[6],Kbdlayout[5]),
     _d_=[0,[0,cst_Qwerty,Kbdlayout[5],_c_,_b_,0,4],0],
     _e_=caml_call1(Stats[4],0),
     _f_=caml_call1(Kbdlayout[6],Kbdlayout[4]),
     init$0=[0,0,[0,[0,cst_Dvorak,Kbdlayout[4],_f_,_e_,0,4],_d_],_a_];
    function update(init,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var
           _bZ_=init[3],
           _b0_=init[2],
           _b1_=
            function(analysis)
             {return [0,analysis[1],analysis[2],analysis[3],_g_,0,4]};
          return [0,_h_,caml_call2(Stdlib_list[17],_b1_,_b0_),_bZ_];
         case 1:return finish_analyses(init);
         case 2:
          var _b2_=init[1];
          if(typeof _b2_ === "number")return [0,_b2_,init[2],init[3]];
          var i=_b2_[1];
          if((i + 1 | 0) < caml_ml_string_length(init[3]))
           {var
             _b3_=caml_string_get(init[3],i),
             c=caml_call1(Stdlib_char[6],_b3_),
             _b4_=init[3],
             _b5_=init[2],
             _b6_=function(_cl_){return update_analysis(c,_cl_)};
            return [0,
                    [0,i + 1 | 0],
                    caml_call2(Stdlib_list[17],_b6_,_b5_),
                    _b4_]}
          return [0,1,init[2],init[3]];
         case 3:
          var
           _b9_=init[1],
           _b7_=init[3],
           _b8_=init[2],
           _b__=typeof _b9_ === "number"?1 === _b9_?0:_b9_:0;
          return [0,_b__,_b8_,_b7_];
         case 4:
          var
           _cb_=init[1],
           _b$_=init[3],
           _ca_=init[2],
           _cc_=typeof _cb_ === "number"?2 <= _cb_?0:2:_cb_;
          return [0,_cc_,_ca_,_b$_];
         default:return init}
      else
       switch(param[0])
        {case 0:var passage=param[1];return [0,init[1],init[2],passage];
         case 1:
          var
           analysis=param[1],
           _cd_=init[3],
           _ce_=init[2],
           _cf_=function(_cm_){return runtime.caml_notequal(analysis,_cm_)},
           _cg_=caml_call2(Stdlib_list[35],_cf_,_ce_);
          return [0,init[1],_cg_,_cd_];
         default:
          var
           layout_data=param[2],
           name=param[1],
           _ch_=init[3],
           _ci_=init[2],
           _cj_=caml_call1(Stats[4],0),
           _ck_=
            [0,
             [0,
              name,
              layout_data,
              caml_call1(Kbdlayout[6],layout_data),
              _cj_,
              0,
              4],
             _ci_];
          return [0,init[1],_ck_,_ch_]}}
    function button(txt,msg)
     {var
       _bU_=[0,caml_call1(Vdom[25],txt),0],
       _bV_=[0,caml_call1(Vdom[22],cst_interactive),_bU_],
       _bT_=0,
       _bW_=[0,Vdom[24],_bV_];
      function _bX_(param){return msg}
      var _bY_=[0,[0,caml_call1(Vdom[3],_bX_),_bW_]];
      return caml_call3(Vdom[41],0,_bY_,_bT_)}
    function stats_chart(analyses)
     {var stats_by_names=group_typing_analyses(analyses);
      function _bt_(_bS_){return _bS_[2]}
      var
       _bu_=caml_call1(Stdlib_list[17],_bt_),
       _bv_=caml_call2(Stats[2],_bu_,stats_by_names),
       _bw_=Stdlib[6];
      function _bx_(_bR_){return find_best_in_list(_bw_,_bR_)}
      var _by_=caml_call2(Stats[2],_bx_,_bv_);
      function _bz_(x){return 200. / x}
      var factors=caml_call2(Stats[2],_bz_,_by_);
      function _bA_(param,k)
       {var
         acc=param[2],
         y0=param[1],
         factor=caml_call2(Stats[1],factors,k),
         stats_by_names$0=caml_call2(Stats[1],stats_by_names,k),
         _bE_=caml_call1(Stats[5],k),
         _bF_=[0,caml_call2(Vdom[35],0,_bE_),0],
         _bG_=[0,[0,caml_call2(Vdom[20],cst_y,y0 + 15 | 0),0]],
         legend=caml_call4(Vdom[34],cst_text,0,_bG_,_bF_),
         _bH_=[0,y0 + 20 | 0,[0,legend,acc]];
        function _bI_(param,_bJ_)
         {var
           v=_bJ_[2],
           name=_bJ_[1],
           acc=param[2],
           y0=param[1],
           w=factor * v | 0,
           _bK_=[0,caml_call2(Vdom[20],cst_height,20),0],
           _bL_=[0,caml_call2(Vdom[20],cst_width,w),_bK_],
           _bM_=[0,caml_call2(Vdom[20],cst_y$0,y0),_bL_],
           _bN_=[0,[0,caml_call2(Vdom[20],cst_x,0),_bM_]],
           r=caml_call4(Vdom[34],cst_rect,0,_bN_,0),
           _bO_=[0,caml_call2(Vdom[35],0,name),0],
           _bP_=[0,caml_call2(Vdom[20],cst_y$1,y0 + 14 | 0),0],
           _bQ_=[0,[0,caml_call2(Vdom[20],cst_x$0,w + 25 | 0),_bP_]],
           t=caml_call4(Vdom[34],cst_text$0,0,_bQ_,_bO_);
          return [0,y0 + 22 | 0,[0,r,[0,t,acc]]]}
        return caml_call3(Stdlib_list[20],_bI_,_bH_,stats_by_names$0)}
      var
       _bB_=caml_call3(Stdlib_list[20],_bA_,_j_,_i_)[2],
       _bC_=30 + (85 * caml_call1(Stdlib_list[1],analyses) | 0) | 0,
       _bD_=[0,[0,caml_call2(Vdom[20],cst_height$0,_bC_),0]];
      return caml_call4(Vdom[34],cst_svg,0,_bD_,_bB_)}
    function view(model)
     {var _aN_=model[2],_aO_=model[1],best_stats=find_best_stats(_aN_),_aM_=0;
      if(typeof _aO_ === "number")
       if(1 === _aO_)var switch$0=0;else var classes=cst_hidden,switch$0=1;
      else
       var switch$0=0;
      if(! switch$0)var classes=cst$1;
      var
       _$_=[0,stats_chart(_aN_),0],
       _aa_=[0,caml_call5(Vdom[33],0,cst_br$0,0,0,0),_$_];
      function _ab_(param)
       {var stats=param[4],name=param[1];
        function stat_cell(k)
         {var
           _bm_=caml_call2(Stats[1],stats,k),
           _bn_=caml_call1(Stdlib[22],_bm_),
           _bo_=[0,caml_call2(Vdom[35],0,_bn_),0],
           _bp_=0,
           _bq_=
            caml_string_equal(name,caml_call2(Stats[1],best_stats,k))
             ?cst_best_stat
             :cst$2,
           _br_=caml_call2(Stdlib[17],cst_numerical,_bq_),
           _bs_=[0,[0,caml_call1(Vdom[22],_br_),_bp_]];
          return caml_call5(Vdom[33],0,cst_td,0,_bs_,_bo_)}
        var
         _bh_=[0,stat_cell(2),0],
         _bi_=[0,stat_cell(1),_bh_],
         _bj_=[0,stat_cell(0),_bi_],
         _bk_=[0,caml_call2(Vdom[35],0,name),0],
         _bl_=[0,caml_call5(Vdom[33],0,cst_th,0,0,_bk_),_bj_];
        return caml_call5(Vdom[33],0,cst_tr,0,0,_bl_)}
      var
       _ac_=caml_call2(Stdlib_list[17],_ab_,_aN_),
       _ad_=[0,caml_call2(Vdom[35],0,cst_distance),0],
       _ae_=[0,[0,caml_call1(Vdom[22],cst_numerical$0),0]],
       _af_=[0,caml_call5(Vdom[33],0,cst_th$0,0,_ae_,_ad_),0],
       _ag_=[0,caml_call2(Vdom[35],0,cst_same_finger),0],
       _ah_=[0,[0,caml_call1(Vdom[22],cst_numerical$1),0]],
       _ai_=[0,caml_call5(Vdom[33],0,cst_th$1,0,_ah_,_ag_),_af_],
       _aj_=[0,caml_call2(Vdom[35],0,cst_same_hand),0],
       _ak_=[0,[0,caml_call1(Vdom[22],cst_numerical$2),0]],
       _al_=[0,caml_call5(Vdom[33],0,cst_th$2,0,_ak_,_aj_),_ai_],
       _am_=[0,caml_call5(Vdom[33],0,cst_th$3,0,0,0),_al_],
       _an_=[0,caml_call5(Vdom[33],0,cst_tr$0,0,0,_am_),_ac_],
       _ao_=[0,[0,caml_call2(Vdom[19],cst_id$0,cst_stats),0]],
       _ap_=[0,caml_call5(Vdom[33],0,cst_table,0,_ao_,_an_),_aa_],
       _aq_=[0,[0,caml_call1(Vdom[22],classes),0]],
       _aP_=[0,caml_call3(Vdom[40],0,_aq_,_ap_),_aM_],
       _aQ_=model[3],
       _aR_=model[1];
      if(typeof _aR_ === "number")var i=0;else var i$0=_aR_[1],i=i$0;
      var _C_=0;
      if(typeof _aR_ === "number")
       if(2 <= _aR_)
        var
         _D_=0,
         _E_=[0,caml_call2(Vdom[35],0,_aQ_),0],
         _F_=0,
         _G_=function(s){return [0,s]},
         _H_=[0,caml_call1(Vdom[8],_G_),_F_],
         _I_=[0,caml_call2(Vdom[20],cst_cols,80),_H_],
         _J_=[0,[0,caml_call2(Vdom[20],cst_rows,10),_I_]],
         _K_=[0,caml_call5(Vdom[33],0,cst_textarea,0,_J_,_E_),_D_],
         _L_=[0,caml_call5(Vdom[33],0,cst_br,0,0,0),_K_],
         _M_=[0,caml_call2(Vdom[35],0,cst_sherlock_holmes),0],
         _N_=[0,caml_call5(Vdom[33],0,cst_option,0,0,_M_),0],
         _O_=[0,caml_call2(Vdom[35],0,cst_one_sentence),0],
         _P_=[0,caml_call5(Vdom[33],0,cst_option$0,0,0,_O_),_N_],
         _Q_=[0,caml_call2(Vdom[35],0,cst_Sample_Texts),0],
         _R_=[0,caml_call1(Vdom[26],1),0],
         _S_=[0,[0,caml_call2(Vdom[19],cst_selected,cst$0),_R_]],
         _T_=[0,caml_call5(Vdom[33],0,cst_option$1,0,_S_,_Q_),_P_],
         _U_=0,
         _V_=
          function(param)
           {return caml_string_notequal(param,cst_one_sentence$0)
                    ?caml_string_notequal(param,cst_sherlock_holmes$0)
                      ?5
                      :[0,Sampletexts[2]]
                    :[0,Sampletexts[1]]},
         _W_=[0,[0,caml_call1(Vdom[8],_V_),_U_]],
         _X_=[0,caml_call5(Vdom[33],0,cst_select,0,_W_,_T_),_L_],
         switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)
       var
        ___=
         caml_call3
          (Stdlib_string[4],_aQ_,i,caml_ml_string_length(_aQ_) - i | 0),
        _X_=[0,caml_call2(Vdom[35],0,___),0];
      var
       _Y_=[0,[0,caml_call2(Vdom[19],cst_id,cst_passage),0]],
       _Z_=[0,caml_call3(Vdom[40],0,_Y_,_X_),_C_],
       _aS_=[0,caml_call3(Vdom[40],0,0,_Z_),_aP_],
       _aU_=model[1],
       _aT_=0,
       _t_=0,
       _u_=0;
      if(typeof _aU_ === "number")
       if(2 <= _aU_)var _v_=cst_save,switch$2=1;else var switch$2=0;
      else
       var switch$2=0;
      if(! switch$2)var _v_=cst_edit;
      var
       _w_=[0,caml_call1(Vdom[25],_v_),_u_],
       _x_=typeof _aU_ === "number"?0:1,
       _y_=[0,caml_call1(Vdom[26],_x_),_w_],
       _z_=[0,caml_call1(Vdom[22],cst_interactive$0),_y_];
      function _A_(param){return 4}
      var
       _B_=[0,caml_call1(Vdom[3],_A_),_z_],
       _aV_=[0,caml_call3(Vdom[41],0,[0,[0,Vdom[24],_B_]],_t_),_aT_],
       _aW_=model[1];
      if(typeof _aW_ === "number")
       switch(_aW_)
        {case 0:var _o_=[0,button(cst_play,0),0];break;
         case 1:var _o_=[0,button(cst_reset,3),0];break;
         default:
          var
           _q_=[0,caml_call1(Vdom[25],cst_play$0),0],
           _r_=[0,caml_call1(Vdom[26],1),_q_],
           _o_=[0,caml_call3(Vdom[41],0,[0,[0,Vdom[24],_r_]],0),0]}
      else
       var _s_=[0,button(cst_end,1),0],_o_=[0,button(cst_stop,3),_s_];
      var
       _p_=[0,[0,caml_call2(Vdom[18],cst_display,cst_inline_block),0]],
       _aX_=[0,caml_call3(Vdom[40],0,_p_,_o_),_aV_],
       _aY_=[0,caml_call3(Vdom[40],0,0,_aX_),_aS_],
       _a0_=model[1],
       _aZ_=model[2],
       _a1_=model[3];
      function _a2_(analysis)
       {if(typeof _a0_ === "number")
         var highlit_key=0;
        else
         var
          i=_a0_[1],
          _bg_=caml_string_get(_a1_,i),
          highlit_key=[0,caml_call1(Stdlib_char[6],_bg_)];
        if(typeof _a0_ === "number")
         if(2 <= _a0_)
          if(1 < caml_call1(Stdlib_list[1],model[2]))
           var in_edit=1,switch$0=1;
          else
           var switch$0=0;
         else
          var switch$0=0;
        else
         var switch$0=0;
        if(! switch$0)var in_edit=0;
        var _bd_=analysis[2],_be_=analysis[1];
        function _bf_(param){return [1,analysis]}
        return caml_call5
                (Kbdlayout[7],[0,highlit_key],[0,in_edit],_bf_,_be_,_bd_)}
      var _a3_=caml_call2(Stdlib_list[17],_a2_,_aZ_),_a4_=model[1];
      if(typeof _a4_ === "number")
       if(2 <= _a4_)var in_edit=1,switch$3=1;else var switch$3=0;
      else
       var switch$3=0;
      if(! switch$3)var in_edit=0;
      var _ar_=0,_as_=0;
      function _at_(name)
       {var _ba_=[0,caml_call2(Vdom[35],0,name),0],_bb_=0,_a9_=model[2];
        function _a__(a){return caml_string_equal(a[1],name)}
        var
         _a$_=caml_call2(Stdlib_list[28],_a__,_a9_),
         _bc_=[0,[0,caml_call1(Vdom[26],_a$_),_bb_]];
        return caml_call5(Vdom[33],0,cst_option$2,0,_bc_,_ba_)}
      var
       _au_=caml_call2(Stdlib_list[17],_at_,_k_),
       _av_=[0,caml_call2(Vdom[35],0,cst_select$0),0],
       _aw_=[0,caml_call1(Vdom[26],1),0],
       _ax_=[0,[0,caml_call2(Vdom[19],cst_selected$0,cst$3),_aw_]],
       _ay_=[0,caml_call5(Vdom[33],0,cst_option$3,0,_ax_,_av_),_au_],
       _az_=[0,caml_call1(Vdom[22],cst_interactive$1),0];
      function _aA_(param)
       {return caml_string_notequal(param,cst_Colemak)
                ?caml_string_notequal(param,cst_Dvorak$0)
                  ?caml_string_notequal(param,cst_Qwerty$0)
                    ?5
                    :[2,cst_Qwerty$1,Kbdlayout[5]]
                  :[2,cst_Dvorak$1,Kbdlayout[4]]
                :[2,cst_Colemak$0,Kbdlayout[3]]}
      var
       _aB_=[0,[0,caml_call1(Vdom[8],_aA_),_az_]],
       _aC_=[0,caml_call5(Vdom[33],0,cst_select$1,0,_aB_,_ay_),_as_],
       _aD_=[0,caml_call1(Vdom[22],cst_content),0],
       _aE_=
        [0,[0,caml_call2(Vdom[19],cst_id$1,cst_create_keyboard_button),_aD_]],
       _aF_=[0,caml_call3(Vdom[40],0,_aE_,_aC_),_ar_],
       _aG_=[0,caml_call2(Vdom[35],0,cst_Add_New),0],
       _aH_=[0,[0,caml_call1(Vdom[22],cst_title),0]],
       _aI_=[0,caml_call3(Vdom[40],0,_aH_,_aG_),_aF_],
       _aJ_=0,
       _aK_=in_edit?cst_in_edit:cst_hidden$0,
       _aL_=[0,[0,caml_call1(Vdom[22],_aK_),_aJ_]],
       _a5_=[0,caml_call5(Vdom[33],0,cst_keyboard,0,_aL_,_aI_),_a3_],
       _a6_=[0,[0,caml_call2(Vdom[19],cst_id$2,cst_keyboards),0]],
       _a7_=[0,caml_call3(Vdom[40],0,_a6_,_a5_),_aY_],
       _a8_=[0,[0,caml_call2(Vdom[18],cst_text_align,cst_center),0]];
      return caml_call3(Vdom[40],0,_a8_,_a7_)}
    var app=caml_call4(Vdom[45],init$0,update,view,0);
    function run(param)
     {var app$0=caml_call2(Vdom_blit[8],0,app),_l_=50;
      function _m_(param){return caml_call2(Vdom_blit[10],app$0,2)}
      caml_call3(Js_browser[15][8],Js_browser[21],_m_,_l_);
      var
       _n_=caml_call1(Vdom_blit[9],app$0),
       match=caml_call2(Js_browser[12][7],Js_browser[22],cst_container);
      if(match)
       var container=match[1],container$0=container;
      else
       var container$0=caml_call1(Js_browser[12][9],Js_browser[22]);
      return caml_call2(Js_browser[11][6],container$0,_n_)}
    caml_call2(Js_browser[15][7],Js_browser[21],run);
    var
     Code=
      [0,
       chars_of_string,
       string_of_chars,
       find_best_in_list,
       Stats,
       update_analysis,
       finish_analyses,
       group_typing_analyses,
       find_best_stats,
       init$0,
       update,
       button,
       stats_chart,
       view,
       app];
    runtime.caml_register_global(113,Code,"Code");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjb2RlLmJjLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVycl9ub19wcmVkIiwiZXJyX25vX3N1Y2MiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwibWluX2ludCQxIiwibWF4X2ludCQxIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQyIiwib25lJDIiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJtaW4iLCJ4IiwieSIsIm1heCIsImFicyIsImxub3QiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJtYXhfaW50IiwibWluX2ludCIsIl9nXyIsInMxIiwiczIiLCJsMSIsImwyIiwiY2hhcl9vZl9pbnQiLCJuIiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsInYiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsInIiLCJsZW4kMSIsIm9mcyQxIiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2xpbmUiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsIl9uXyIsInN0cjIiLCJzdHIxIiwiZXhpdF9mdW5jdGlvbiIsImF0X2V4aXQiLCJnIiwiZl9hbHJlYWR5X3JhbiIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsImVtcHR5IiwicmV0dXJuJDAiLCJtYXAiLCJzZXEiLCJuZXh0IiwiZmlsdGVyX21hcCIsInNlcSQwIiwiZmlsdGVyIiwiZmxhdF9tYXAkMCIsImZsYXRfbWFwX2FwcCQwIiwidGFpbCIsImZsYXRfbWFwX2FwcCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiYWNjJDAiLCJhY2MkMSIsImVzY2FwZWQiLCJzJDAiLCJsb3dlcmNhc2UiLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2VfYXNjaWkiLCJ1cHBlcmNhc2VfYXNjaWkiLCJjb21wYXJlIiwiYzEiLCJjMiIsImVxdWFsIiwibWluJDAiLCJtYXgkMCIsImxvX2JvdW5kIiwiaGlfYm91bmQiLCJib20iLCJyZXAiLCJzdWNjIiwidSIsInByZWQiLCJpc192YWxpZCIsIm9mX2ludCIsImlzX2NoYXIiLCJvZl9jaGFyIiwidG9fY2hhciIsInVuc2FmZV90b19jaGFyIiwiZXF1YWwkMCIsImNvbXBhcmUkMCIsImhhc2giLCJzaXplIiwibGVuZ3RoIiwicGFyYW0kMCIsImNvbnMiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicnkiLCJyeCIsImNtcCIsIm1hdGNoIiwidDIiLCJoMiIsInQxIiwiaDEiLCJjaG9wIiwiayIsImskMCIsImskMSIsInNvcnQiLCJ4MiIsIngxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwiX3ZfIiwibGVmdCIsInJpZ2h0Iiwic3Jjb2ZmIiwiZHN0b2ZmIiwiY3B5bGVuIiwib2ZzMSIsIm9mczIiLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJpc19zcGFjZSIsImoiLCJhcHBseTEiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleF9yZWNfb3B0IiwicmluZGV4X3JlYyIsInJpbmRleF9yZWNfb3B0IiwibmV3X2xlbiIsIm5ld19idWYiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwibWVyZ2UkMCIsIm9yZGVyIiwibGlzdCIsImluaXRsaXN0IiwiZTIiLCJtZXJnZTIiLCJzd2FwIiwiYXJyIiwidG1wIiwiYXJyYXkiLCJxc29ydCIsImxvIiwiaGkiLCJsbyQwIiwiaGkkMCIsIm1pZCIsInBpdm90IiwibG8kMSIsImhpJDEiLCJ2YWxfaSIsInRvX2J1ZmZlciIsImJ1ZmYiLCJmbGFncyIsImhlYWRlcl9zaXplIiwiZGF0YV9zaXplIiwidG90YWxfc2l6ZSIsImZyb21fYnl0ZXMiLCJmcm9tX3N0cmluZyIsImlzX2Jsb2NrIiwiZG91YmxlX2ZpZWxkIiwic2V0X2RvdWJsZV9maWVsZCIsIm1hcnNoYWwiLCJvYmoiLCJ1bm1hcnNoYWwiLCJwb3MiLCJmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2xvdCIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibGVuZ3RoJDAiLCJpbmZpbml0eSQwIiwibmVnX2luZmluaXR5JDAiLCJuYW4kMCIsIm1heF9mbG9hdCQwIiwibWluX2Zsb2F0JDAiLCJlcHNpbG9uIiwib2Zfc3RyaW5nX29wdCIsInRvX3N0cmluZyQwIiwicGkiLCJlcXVhbCQzIiwiaGFzaCQwIiwic3giLCJzeSIsImluaXQiLCJsYSIsImxiIiwicmVzJDAiLCJsaXN0X2xlbmd0aCIsInBhcmFtJDEiLCJ0bCQwIiwiaGQkMCIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwiZSIsInRyaWNrbGUiLCJidWJibGVkb3duIiwiYnViYmxlIiwiaSQyIiwiZSQwIiwiZmF0aGVyIiwibWVyZ2UiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJkIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsInN1Y2MkMCIsInByZWQkMCIsImFicyQwIiwibWluX2ludCQwIiwibWF4X2ludCQwIiwibG9nbm90IiwidG9fc3RyaW5nJDEiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDMiLCJlcXVhbCQ0Iiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJsb2dub3QkMCIsInRvX3N0cmluZyQyIiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQ0IiwiZXF1YWwkNSIsInplcm8kMSIsIm9uZSQxIiwibWludXNfb25lJDEiLCJzdWNjJDIiLCJwcmVkJDIiLCJhYnMkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImxvZ25vdCQxIiwidG9fc3RyaW5nJDMiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDUiLCJlcXVhbCQ2IiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJyZXN1bHQiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJjbWQkMCIsImFyZyQxIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaCIsImNyZWF0ZSIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJqb2luIiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwiY29uY2F0Iiwic3BsaXQiLCJwcmVzIiwicHJlcyQwIiwiaXNfZW1wdHkiLCJtZW0iLCJyZW1vdmUiLCJ1bmlvbiIsInIyIiwidjIiLCJyMSIsInYxIiwicjIkMCIsInIxJDAiLCJpbnRlciIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUxIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsImZvbGQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsInYkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0Iiwib2ZfbGlzdCIsInN1YiIsImwkMyIsIngwIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsImwkMiIsIng0IiwiYWRkX3NlcSIsIm0iLCJvZl9zZXEiLCJzZXFfb2ZfZW51bSIsInRvX3NlcSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsImNvcHkkMiIsInB1c2giLCJwb3AiLCJ0b3AiLCJsZW5ndGgkMSIsIml0ZXIkNCIsInRvX3NlcSQzIiwicSIsIm9mX3NlcSQzIiwiY3JlYXRlJDAiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwidGFrZSIsImNvcHkkMyIsInFfcmVzIiwicHJldiIsImlzX2VtcHR5JDAiLCJsZW5ndGgkMiIsIml0ZXIkNSIsImZvbGQkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsInRvX3NlcSQ0IiwiYWRkX3NlcSQwIiwib2Zfc2VxJDQiLCJyYWlzZV91bmRlZmluZWQiLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsImZvcmNlX3ZhbF9sYXp5X2Jsb2NrIiwiZm9yY2UiLCJsenYiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwiY291bnQiLCJmaWxsX2J1ZmYiLCJnZXRfZGF0YSIsImQxMSIsImEkMCIsImEkMSIsInBlZWtfZGF0YSIsInBlZWskMCIsImp1bmtfZGF0YSIsImp1bmsiLCJuZ2V0X2RhdGEiLCJhbCIsIm5wZWVrIiwiZW1wdHkkMSIsIml0ZXIkNiIsInN0cm0iLCJmcm9tIiwib2ZfbGlzdCQwIiwib2Zfc3RyaW5nJDAiLCJvZl9ieXRlcyIsIm9mX2NoYW5uZWwiLCJpYXBwIiwiaWNvbnMiLCJpc2luZyIsImxhcHAiLCJsY29ucyIsImxzaW5nIiwic2VtcHR5Iiwic2xhenkiLCJkdW1wIiwiZHVtcF9kYXRhIiwiY3JlYXRlJDEiLCJjb250ZW50cyIsInRvX2J5dGVzIiwic3ViJDIiLCJibGl0JDIiLCJzcmMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwidG9fc2VxJDUiLCJ0b19zZXFpJDIiLCJhZGRfc2VxJDEiLCJvZl9zZXEkNSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZHR5JDAiLCJicHJpbnRfcHJlY2lzaW9uIiwiYnByaW50X2ljb252X2ZsYWciLCJicHJpbnRfYWx0aW50X2ZtdCIsImJwcmludF9mY29udl9mbGFnIiwic3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0Iiwic3RyJDAiLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4iLCJmb3JtYXR0aW5nX2dlbiIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsImlzX2Fsb25lJDAiLCJpc19hbG9uZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5JDUiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJmbXR0eSQ2IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwiZm10dHlfcmVzdCQ2IiwiZm10dHkkNyIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsImZtdHR5X3Jlc3QkNyIsImZtdHR5JDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJmbXR0eV9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmbXR0eTMiLCJmbXQzIiwic3RyJDEiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDciLCJzdWJfZm10dHlfcmVzdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkOSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJzdWJfZm10dHlfcmVzdCQxMiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwic3ViX2ZtdHR5X3Jlc3QkMTQiLCJzdWIyX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTUiLCJzdWIyX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxNiIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE4Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJzdWJfZm10dHlfcmVzdCQyMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJzdWJfZm10dHlfcmVzdCQyMyIsInN1Yl9mbXR0eV9yZXN0JDI0Iiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJzdWJfZm10dHlfcmVzdCQyNiIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJzaWduIiwic3ltYiIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwibyIsIm1ha2VfcHJpbnRmIiwicCQwIiwicCQxIiwibWFrZV9wYWRkaW5nIiwibmV3X2FjYyIsIm1ha2VfcHJpbnRmJDAiLCJhY2MkMiIsImFjYyQzIiwiYWNjJDQiLCJrJDMiLCJrb2MiLCJrYWNjIiwiayQ0IiwibWFrZV9pZ25vcmVkX3BhcmFtJDAiLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiIsIm1ha2VfaXByaW50ZiIsIm1ha2VfaXByaW50ZiQwIiwicmVzdCQyNCIsInJlc3QkMjUiLCJmbl9vZl9jdXN0b21fYXJpdHkkMCIsImZuX29mX2N1c3RvbV9hcml0eSIsIm91dHB1dF9hY2MiLCJwJDIiLCJwJDMiLCJtc2ciLCJwJDQiLCJidWZwdXRfYWNjIiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsInBhcnNlX2x3b3JkIiwicGFyc2VfaW50Iiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJ1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJlbmRfaW5kIiwiaW52YWxpZF9mb3JtYXRfd2l0aG91dCIsImV4cGVjdGVkX2NoYXJhY3RlciIsImV4cGVjdGVkIiwiYWRkX2xpdGVyYWwiLCJsaXRfc3RhcnQiLCJwYXJzZSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwicGFyc2VfZ29vZF9icmVhayIsInBhcnNlX21hZ2ljX3NpemUiLCJzdHJfaW5kJDEiLCJwYXJzZV9jb252ZXJzaW9uIiwicGN0X2luZCIsInBsdXMiLCJzcGFjZSIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImluY29tcGF0aWJsZV9mbGFnIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQwIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwibmV4dF9pbmQiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2VuZCQwIiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwic3ltYiQwIiwiaWdub3JlZCQ1IiwiY29tcHV0ZV9pbnRfY29udiIsImlnbm9yZWQkOCIsInByZWMkNCIsInNwYWNlJDEiLCJwbHVzJDIiLCJwbHVzJDMiLCJzcGFjZSQyIiwiaWdub3JlZCQ0IiwiaWdub3JlZCIsImlnbm9yZWQkMCIsImlnbm9yZWQkMSIsInBsdXMkMCIsInNwYWNlJDAiLCJwbHVzJDEiLCJpZ24kMCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsIm1pbnVzIiwicGFyc2VfY29udiIsInBhcnNlX2FmdGVyX3BhZGRpbmciLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwibWludXMkMCIsInNldF9mbGFnIiwic3RyX2luZCQzIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1IiwiaXNfb3Blbl90YWciLCJpbmQiLCJzdWJfc3RyIiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInN0cl9pbmRfMSIsInBhcnNlX2ludGVnZXIiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJmb3JtYXR0aW5nX2xpdCQwIiwic3RyX2luZF80Iiwic3RyX2luZF81Iiwic3ViX2VuZCQxIiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3Iiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJwcmludGYiLCJlcHJpbnRmIiwia3NwcmludGYiLCJzcHJpbnRmIiwiYXNzb2MzIiwieTIiLCJ5MSIsInNwbGl0JDAiLCJtYWtlX3N5bWxpc3QiLCJwcmVmaXgiLCJzdWZmaXgiLCJoZWxwX2FjdGlvbiIsImFkZF9oZWxwIiwic3BlY2xpc3QiLCJhZGQyIiwidXNhZ2VfYiIsImVycm1zZyIsImRvYyIsInNwZWMiLCJrZXkiLCJ1c2FnZV9zdHJpbmciLCJ1c2FnZSIsImJvb2xfb2Zfc3RyaW5nX29wdCQwIiwiaW50X29mX3N0cmluZ19vcHQkMCIsImZsb2F0X29mX3N0cmluZ19vcHQkMCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJlcnJvciIsInByb2duYW1lIiwib3B0IiwiYWN0aW9uIiwiZm9sbG93JDAiLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsIngkMCIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiYXJnJDYiLCJuZXdhcmciLCJiZWZvcmUiLCJhZnRlciIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIiwicGFyc2VfYXJndl9keW5hbWljIiwic3RoIiwiY3VycmVudCQwIiwicGFyc2VfYXJndiIsIm1zZyQwIiwibXNnJDEiLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibWF4X2FyZ19sZW4iLCJjdXIiLCJrd2QiLCJyZXBsYWNlX2xlYWRpbmdfdGFiIiwic2VlbiIsImFsaWduIiwibGltaXQiLCJjb21wbGV0ZWQiLCJrc2QiLCJjdXRjb2wkMCIsInNwYWNlcyQwIiwiY3V0Y29sIiwia3dkX2xlbiIsInNwYWNlcyIsInJlYWRfYXV4IiwidHJpbSIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwiZmllbGRzIiwidG9fc3RyaW5nJDQiLCJjb252IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiYnQiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpbmZvIiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdHMiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInByaW50X3N0YXQiLCJhbGxvY2F0ZWRfYnl0ZXMiLCJtYSIsInBybyIsIm1pIiwiY3JlYXRlX2FsYXJtIiwiZGVsZXRlX2FsYXJtIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwib3V0cHV0JDAiLCJkaWdlc3QiLCJpbnB1dCQwIiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2UkMSIsIm1ha2Vfc2VsZl9pbml0IiwiY29weSQ0IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50JDAiLCJib3VuZCIsImludDMyIiwiYjEiLCJiMiIsImludDY0IiwiYjMiLCJuYXRpdmVpbnQiLCJmbG9hdCQwIiwiYm9vbCIsImRlZmF1bHQkMCIsImJpdHMkMCIsImludCQxIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJzY2FsZSIsImJvb2wkMCIsImZ1bGxfaW5pdCQwIiwiaW5pdCQzIiwic2VsZl9pbml0IiwiZ2V0X3N0YXRlIiwic2V0X3N0YXRlIiwiaGFzaCQxIiwiaGFzaF9wYXJhbSIsInNlZWRlZF9oYXNoIiwib25nb2luZ190cmF2ZXJzYWwiLCJmbGlwX29uZ29pbmdfdHJhdmVyc2FsIiwicGFyYW1zIiwicmFuZG9taXplZF9kZWZhdWx0IiwicmFuZG9taXplZCIsInJhbmRvbWl6ZSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nIiwiY3JlYXRlJDIiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ1IiwibGVuZ3RoJDQiLCJyZXNpemUkMCIsImluZGV4ZnVuIiwib2RhdGEiLCJvc2l6ZSIsIm5zaXplIiwibmRhdGEiLCJuZGF0YV90YWlsIiwiaW5wbGFjZSIsImNlbGwkMCIsIm5pZHgiLCJtYXRjaCQwIiwia2V5X2luZGV4IiwiYWRkJDAiLCJidWNrZXQiLCJmaW5kJDAiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwibWVtJDEiLCJpdGVyJDciLCJkb19idWNrZXQiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJmb2xkJDEiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRvX3NlcSQ2IiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwiYWRkX3NlcSQyIiwicmVwbGFjZV9zZXEiLCJvZl9zZXEkNiIsImZpbmRfYWxsIiwiY29weSIsInN6IiwibGVuZ3RoJDUiLCJmaWxsJDEiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0IiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld3QiLCJvYiIsIm9oIiwic2V0dGVyJDAiLCJuYiIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwiYWRkX3F1ZXVlIiwidGFrZV9xdWV1ZSIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX2xpbmUiLCJicmVha19zYW1lX2xpbmUiLCJwcF9mb3JjZV9icmVha19saW5lIiwiYmxfdHkiLCJwcF9za2lwX3Rva2VuIiwiZm9ybWF0X3BwX3Rva2VuIiwidGFicyIsImFkZF90YWIiLCJscyIsImxzJDAiLCJ0YWdzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJvZmYiLCJvZmYkMCIsImluc2VydGlvbl9wb2ludCIsInRhYnMkMCIsInRhYiIsIm9mZiQxIiwiaW5zZXJ0aW9uX3BvaW50JDAiLCJvZmZzZXQkMCIsImJsX3R5cGUiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiYWR2YW5jZV9sb29wIiwic2l6ZSQwIiwiYWR2YW5jZV9sZWZ0IiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJxX2VsZW0iLCJzY2FuX3N0YWNrX2JvdHRvbSIsImNsZWFyX3NjYW5fc3RhY2siLCJzZXRfc2l6ZSIsInF1ZXVlX2VsZW0iLCJsZWZ0X3RvdCIsInNjYW5fcHVzaCIsInBwX29wZW5fYm94X2dlbiIsImJyX3R5IiwiZWxlbSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fdGFnIiwicHBfY2xvc2VfdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2luZGVudCIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzeXNfc2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsImZsdXNoIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJwcmludF9hcyIsInByaW50X3N0cmluZyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfbWF4X2JveGVzIiwiZ2V0X21heF9ib3hlcyIsIm92ZXJfbWF4X2JveGVzIiwic2V0X2VsbGlwc2lzX3RleHQiLCJnZXRfZWxsaXBzaXNfdGV4dCIsInNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3RleHQiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJvdXRwdXRfYWNjJDAiLCJidHkiLCJwJDUiLCJwJDYiLCJzdHJwdXRfYWNjJDAiLCJzaXplJDEiLCJrZnByaW50ZiQwIiwiaWtmcHJpbnRmJDAiLCJmcHJpbnRmJDAiLCJpZnByaW50ZiQwIiwicHJpbnRmJDAiLCJlcHJpbnRmJDAiLCJrc3ByaW50ZiQwIiwic3ByaW50ZiQwIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiYnByaW50ZiQwIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJmbmFtZSIsImNoYXJfY291bnQiLCJyZXNldF90b2tlbiIsImludmFsaWRhdGVfY3VycmVudF9jaGFyIiwidG9rZW5fc3RyaW5nIiwidG9rZW5fYnVmZmVyIiwic2tpcF9jaGFyIiwiaWdub3JlX2NoYXIiLCJzdG9yZV9jaGFyIiwiZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSIsImNyZWF0ZSQzIiwiaW5hbWUiLCJmcm9tX3N0cmluZyQxIiwiZnJvbV9mdW5jdGlvbiQwIiwic2Nhbl9jbG9zZV9hdF9lbmQiLCJzY2FuX3JhaXNlX2F0X2VuZCIsImZyb21faWMiLCJzY2FuX2Nsb3NlX2ljIiwiZW9mIiwic3RkaWIiLCJvcGVuX2luX2ZpbGUiLCJmcm9tX2ZpbGUiLCJmcm9tX2ZpbGVfYmluIiwiZnJvbV9jaGFubmVsJDAiLCJjbG9zZV9pbiIsImljJDAiLCJtZW1vIiwibWVtb19mcm9tX2ljIiwibWVtb19mcm9tX2NoYW5uZWwiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZmxvYXQiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja190aGlzX2NoYXIiLCJjaGVja19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwidG9rZW5fZmxvYXQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsIndpZHRoJDIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsInNjYW5fY2hhciIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJzY2FuX2NhbWxfY2hhciIsImZpbmRfc3RvcCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNraXBfc3BhY2VzIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsInNjYW5faW5kaWMiLCJzY2FuX2NoYXJzIiwic2NhbmZfYmFkX2lucHV0IiwiZ2V0X2NvdW50ZXIiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsImZtdCQyMyIsImZtdCQyNCIsImZtdCQyNSIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJwYWRfcHJlY19zY2FuZiIsInJlYWRlcnMiLCJzY2FuIiwibWFrZV9zY2FuZiIsInNjYW4kMCIsInN0cl9yZXN0Iiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiQzIiwic2NhbiQ0IiwiY29udiQwIiwic2NhbiQ1IiwiY29udiQxIiwic2NhbiQ2IiwiY29udiQyIiwic2NhbiQ3IiwicHJlYyQ1Iiwic2NhbiQ4IiwiZm10aW5nX2xpdCQwIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQ2IiwiY29tcGFyZSQ3IiwiY29tcGFyZSQ4IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsInRvX2xpc3QkMCIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3Nsb3QiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyIsImdldF9kYXRhJDAiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290IiwidGFibGVzJDIiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJjbG8kMCIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIngkMyIsIm4kNyIsIngkNCIsIm4kOCIsImYkNyIsIm4kOSIsIngkNSIsImYkOCIsImUkMiIsIm4kMTAiLCJ4JDYiLCJmJDkiLCJuJDExIiwieCQ3IiwibiQxMiIsIngkOCIsIm4kMTMiLCJuJDE0IiwiZSQzIiwibiQxNSIsIm0kMiIsIngkOSIsIm0kMyIsIm4kMTYiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ1IiwibiQxOCIsInN0YXRzJDAiLCJpbml0aWFsX2J1ZmZlciIsImJ1ZmZlciIsImJ1ZnBvcyIsInJlc2V0X2J1ZmZlciIsInN0b3JlIiwibmV3YnVmZmVyIiwiZ2V0X3N0cmluZyIsIm1ha2VfbGV4ZXIiLCJrZXl3b3JkcyIsImt3ZF90YWJsZSIsImlkZW50X29yX2tleXdvcmQiLCJpZCIsImtleXdvcmRfb3JfZXJyb3IiLCJlbmRfZXhwb25lbnRfcGFydCIsImV4cG9uZW50X3BhcnQiLCJudW1iZXIiLCJpZGVudDIiLCJuZWdfbnVtYmVyIiwibmV4dF90b2tlbiQwIiwiZXNjYXBlIiwibWF5YmVfY29tbWVudCIsImNvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwiaXRlciQwIiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNCIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNSIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ2IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDAiLCJnZXRfa2V5X2NvcHkkMCIsInNldF9rZXkkMCIsInVuc2V0X2tleSQwIiwiY2hlY2tfa2V5JDAiLCJibGl0X2tleSQwIiwibzEiLCJvMiIsImdldF9kYXRhJDMiLCJnZXRfZGF0YV9jb3B5JDEiLCJzZXRfZGF0YSQxIiwidW5zZXRfZGF0YSQxIiwiY2hlY2tfZGF0YSQxIiwiYmxpdF9kYXRhJDEiLCJraSIsImswIiwiZ2VuZXJpY19iYXNlbmFtZSIsImlzX2Rpcl9zZXAiLCJnZW5lcmljX2Rpcm5hbWUiLCJpc19yZWxhdGl2ZSIsImlzX2ltcGxpY2l0IiwiY2hlY2tfc3VmZml4Iiwic3VmZiIsInF1b3RlIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNvbmNhdCQyIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwicHJuZyQwIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJ0cnlfbmFtZSIsImNvdW50ZXIkMSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwiYWRkJDEiLCJzdWIkMyIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJlbmFibGVkIiwiaWZfc3BhY2V0aW1lX2VuYWJsZWQiLCJjcmVhdGUkNyIsImNoYW5uZWwiLCJzYXZlX2V2ZW50IiwidGltZSIsImV2ZW50X25hbWUiLCJzYXZlX2FuZF9jbG9zZSIsInRha2UkMCIsImNsb3NlZCIsInNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMiLCJmbG9hdDMyIiwiZmxvYXQ2NCIsImludDhfc2lnbmVkIiwiaW50OF91bnNpZ25lZCIsImludDE2X3NpZ25lZCIsImludDE2X3Vuc2lnbmVkIiwiaW50MzIkMSIsImludDY0JDEiLCJpbnQkMiIsIm5hdGl2ZWludCQxIiwiY29tcGxleDMyIiwiY29tcGxleDY0Iiwia2luZF9zaXplX2luX2J5dGVzIiwiY19sYXlvdXQiLCJmb3J0cmFuX2xheW91dCIsImRpbXMiLCJzaXplX2luX2J5dGVzIiwiY3JlYXRlJDgiLCJraW5kIiwibGF5b3V0IiwiZ2V0Iiwic2V0Iiwic2l6ZV9pbl9ieXRlcyQwIiwib2ZfdmFsdWUiLCJjcmVhdGUkOSIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwib2ZfYXJyYXkiLCJiYSIsImNyZWF0ZSQxMCIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQxMSIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsIm9mX2FycmF5JDEiLCJjb2wiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJzdmdfbnMiLCJwcmV2X3ZhbHVlX2F0dHJpYnV0ZSIsImVtcHR5IiwidF9vZl9qcyIsIngyIiwidF90b19qcyIsIngxIiwibGVuZ3RoIiwieDUiLCJrZXkiLCJ4NyIsIng2IiwiZ2V0X2l0ZW0iLCJ4MTAiLCJ4OSIsInNldF9pdGVtIiwieDE0IiwieDEyIiwieDEzIiwicmVtb3ZlX2l0ZW0iLCJ4MTYiLCJ4MTUiLCJjbGVhciIsIngxNyIsInRfb2ZfanMkMCIsIngxOSIsInRfdG9fanMkMCIsIngxOCIsIm5ld19yZWdfZXhwIiwieDIyIiwieDIzIiwieDI0IiwieDI1IiwidF9vZl9qcyQxIiwieDI3IiwidF90b19qcyQxIiwieDI2Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwidG9fbG93ZXJfY2FzZSIsIngzMCIsInRvX3VwcGVyX2Nhc2UiLCJ4MzEiLCJjb25jYXQiLCJ4MzYiLCJ4MzIiLCJ4MzMiLCJ4MzQiLCJpbmNsdWRlcyIsIngzOCIsIngzNyIsImVuZHNfd2l0aCIsIng0MCIsIngzOSIsImluZGV4X29mIiwieDQyIiwieDQxIiwicmVwZWF0IiwieDQ0IiwieDQzIiwic2VhcmNoIiwieDQ2IiwieDQ1IiwidHJpbSIsIng0NyIsInRfb2ZfanMkMiIsIng0OSIsInRfdG9fanMkMiIsIng0OCIsIm5ld19kYXRlIiwieDUyIiwibm93IiwicGFyc2UiLCJ4NTMiLCJnZXRfZGF0ZSIsIng1NCIsImdldF9kYXkiLCJ4NTUiLCJnZXRfZnVsbF95ZWFyIiwieDU2IiwiZ2V0X2hvdXJzIiwieDU3IiwiZ2V0X21pbGxpc2Vjb25kcyIsIng1OCIsImdldF9taW51dGVzIiwieDU5IiwiZ2V0X21vbnRoIiwieDYwIiwiZ2V0X3NlY29uZHMiLCJ4NjEiLCJnZXRfdGltZSIsIng2MiIsImdldF90aW1lem9uZV9vZmZzZXQiLCJ4NjMiLCJnZXRfVVRDX2RhdGUiLCJ4NjQiLCJnZXRfVVRDX2RheSIsIng2NSIsImdldF9VVENfZnVsbF95ZWFyIiwieDY2IiwiZ2V0X1VUQ19ob3VycyIsIng2NyIsImdldF9VVENfbWlsbGlzZWNvbmRzIiwieDY4IiwiZ2V0X1VUQ19taW51dGVzIiwieDY5IiwiZ2V0X1VUQ19tb250aCIsIng3MCIsImdldF9VVENfc2Vjb25kcyIsIng3MSIsImdldF95ZWFyIiwieDcyIiwic2V0X2RhdGUiLCJ4NzQiLCJ4NzMiLCJzZXRfZnVsbF95ZWFyIiwieDc2IiwieDc1Iiwic2V0X2hvdXJzIiwieDc4IiwieDc3Iiwic2V0X21pbGxpc2Vjb25kcyIsIng4MCIsIng3OSIsInNldF9taW51dGVzIiwieDgyIiwieDgxIiwic2V0X21vbnRoIiwieDg0IiwieDgzIiwic2V0X3NlY29uZHMiLCJ4ODYiLCJ4ODUiLCJzZXRfdGltZSIsIng4OCIsIng4NyIsInNldF9VVENfZGF0ZSIsIng5MCIsIng4OSIsInNldF9VVENfZnVsbF95ZWFyIiwieDkyIiwieDkxIiwic2V0X1VUQ19ob3VycyIsIng5NCIsIng5MyIsInNldF9VVENfbWlsbGlzZWNvbmRzIiwieDk2IiwieDk1Iiwic2V0X1VUQ19taW51dGVzIiwieDk4IiwieDk3Iiwic2V0X1VUQ19tb250aCIsIngxMDAiLCJ4OTkiLCJzZXRfVVRDX3NlY29uZHMiLCJ4MTAyIiwieDEwMSIsInNldF95ZWFyIiwieDEwNCIsIngxMDMiLCJ0b19kYXRlX3N0cmluZyIsIngxMDUiLCJ0b19HTVRfc3RyaW5nIiwieDEwNiIsInRvX0lTT19zdHJpbmciLCJ4MTA3IiwidG9fbG9jYWxlX3N0cmluZyIsIngxMDgiLCJ0b19zdHJpbmckMCIsIngxMDkiLCJ0b190aW1lX3N0cmluZyIsIngxMTAiLCJ0b19VVENfc3RyaW5nIiwieDExMSIsInRfb2ZfanMkMyIsIngxMTMiLCJ0X3RvX2pzJDMiLCJ4MTEyIiwibmFtZSIsIngxMTYiLCJ0eXBlIiwieDExNyIsInRfb2ZfanMkNCIsIngxMTkiLCJ0X3RvX2pzJDQiLCJ4MTE4IiwiZmlsZXMiLCJ4MTIyIiwidF9vZl9qcyQ1IiwieDEyNSIsInRfdG9fanMkNSIsIngxMjQiLCJ0YXJnZXQiLCJ4MTI4IiwicHJldmVudF9kZWZhdWx0IiwieDEyOSIsInR5cGUkMCIsIngxMzAiLCJpbml0X2V2ZW50IiwieDEzNCIsIngxMzEiLCJ4MTMyIiwieDEzMyIsImNsaWVudF94IiwieDEzNSIsImNsaWVudF95IiwieDEzNiIsInBhZ2VfeCIsIngxMzciLCJwYWdlX3kiLCJ4MTM4Iiwic2NyZWVuX3giLCJ4MTM5Iiwic2NyZWVuX3kiLCJ4MTQwIiwibW92ZW1lbnRfeCIsIngxNDEiLCJtb3ZlbWVudF95IiwieDE0MiIsImJ1dHRvbnMiLCJ4MTQzIiwiYWx0X2tleSIsIngxNDQiLCJjdHJsX2tleSIsIngxNDUiLCJzaGlmdF9rZXkiLCJ4MTQ2Iiwid2hpY2giLCJ4MTQ3IiwiY29kZSIsIngxNDgiLCJrZXkkMCIsIngxNDkiLCJkZWx0YV95IiwieDE1MCIsImRlbHRhX3giLCJ4MTUxIiwiZGF0YV90cmFuc2ZlciIsIngxNTIiLCJkYXRhIiwieDE1MyIsIm9yaWdpbiIsIngxNTQiLCJ0X29mX2pzJDYiLCJ4MTU2IiwidF90b19qcyQ2IiwieDE1NSIsImhlaWdodCIsIngxNTkiLCJ3aWR0aCIsIngxNjAiLCJsZWZ0IiwieDE2MSIsInJpZ2h0IiwieDE2MiIsInRvcCIsIngxNjMiLCJib3R0b20iLCJ4MTY0IiwidF9vZl9qcyQ3IiwieDE2NiIsInRfdG9fanMkNyIsIngxNjUiLCJ4IiwieDE2OSIsInkiLCJ4MTcwIiwiaGVpZ2h0JDAiLCJ4MTcxIiwid2lkdGgkMCIsIngxNzIiLCJ0X29mX2pzJDgiLCJ4MTc0IiwidF90b19qcyQ4IiwieDE3MyIsInNldCIsInN0eWxlIiwicHJvcCIsInZhbHVlIiwic2V0X2NvbG9yIiwieDE3NyIsIngxNzgiLCJzZXRfYm9yZGVyIiwieDE3OSIsIngxODAiLCJzZXRfYmFja2dyb3VuZCIsIngxODEiLCJ4MTgyIiwic2V0X2JhY2tncm91bmRfY29sb3IiLCJ4MTgzIiwieDE4NCIsInNldF9oZWlnaHQiLCJ4MTg1IiwieDE4NiIsInNldF93aWR0aCIsIngxODciLCJ4MTg4Iiwic2V0X2JvdHRvbSIsIngxODkiLCJ4MTkwIiwic2V0X2xlZnQiLCJ4MTkxIiwieDE5MiIsInNldF90b3AiLCJ4MTkzIiwieDE5NCIsInNldF9yaWdodCIsIngxOTUiLCJ4MTk2Iiwic2V0X2N1cnNvciIsIngxOTciLCJ4MTk4IiwiZ2V0IiwidF9vZl9qcyQ5IiwieDIwMCIsInRfdG9fanMkOSIsIngxOTkiLCJjbG9uZV9ub2RlIiwieDIwNCIsIngyMDMiLCJjb250YWlucyIsIngyMDYiLCJ4MjA1IiwiYXBwZW5kX2NoaWxkIiwieDIwOCIsIngyMDciLCJpbnNlcnRfYmVmb3JlIiwieDIxMSIsIngyMDkiLCJ4MjEwIiwicmVwbGFjZV9jaGlsZCIsIngyMTQiLCJ4MjEyIiwieDIxMyIsInJlbW92ZV9jaGlsZCIsIngyMTYiLCJ4MjE1IiwiZmlyc3RfY2hpbGQiLCJ4MjE3IiwibGFzdF9jaGlsZCIsIngyMTgiLCJuZXh0X3NpYmxpbmciLCJ4MjE5IiwicmVtb3ZlX2FsbF9jaGlsZHJlbiIsImNoaWxkJDEiLCJjaGlsZCIsImNoaWxkJDAiLCJoYXNfY2hpbGRfbm9kZXMiLCJ4MjIwIiwiYWRkX2V2ZW50X2xpc3RlbmVyIiwieDIyNSIsIngyMjEiLCJ4MjIyIiwieDIyNCIsIngyMjMiLCJpbm5lcl90ZXh0IiwieDIyNiIsImdldF9lbGVtZW50c19ieV90YWdfbmFtZSIsIngyMjgiLCJ4MjI3IiwiaGFzX2F0dHJpYnV0ZSIsIngyMzEiLCJ4MjMwIiwiZ2V0X2F0dHJpYnV0ZSIsIngyMzMiLCJ4MjMyIiwicmVtb3ZlX2F0dHJpYnV0ZSIsIngyMzUiLCJ4MjM0Iiwic2V0X2F0dHJpYnV0ZSIsIngyMzgiLCJ4MjM2IiwieDIzNyIsImdldF9ib3VuZGluZ19jbGllbnRfcmVjdCIsIngyMzkiLCJnZXRfYm91bmRpbmdfYm94IiwieDI0MCIsIm5vcm1hbGl6ZSIsIngyNDEiLCJ4MjQyIiwic2V0X3ZhbHVlIiwieDI0MyIsIngyNDQiLCJzZWxlY3QiLCJ4MjQ1IiwiZmlsZXMkMCIsIngyNDYiLCJzZWxlY3RlZF9pbmRleCIsIngyNDgiLCJjaGVja2VkIiwieDI0OSIsInNldF9jaGVja2VkIiwieDI1MCIsIngyNTEiLCJub2RlX3ZhbHVlIiwieDI1MiIsInNldF9ub2RlX3ZhbHVlIiwieDI1MyIsIngyNTQiLCJwYXJlbnRfbm9kZSIsIngyNTUiLCJub2RlX25hbWUiLCJ4MjU2IiwiZGlzcGF0Y2hfZXZlbnQiLCJ4MjU4IiwieDI1NyIsIngyNTkiLCJzZXRfaW5uZXJfSFRNTCIsIngyNjAiLCJ4MjYxIiwic2V0X3RleHRfY29udGVudCIsIngyNjIiLCJ4MjYzIiwic2V0X2NsYXNzX25hbWUiLCJ4MjY0IiwieDI2NSIsImNsYXNzX25hbWUiLCJ4MjY2IiwiY2xpZW50X3dpZHRoIiwieDI2NyIsImNsaWVudF9oZWlnaHQiLCJ4MjY4Iiwic2Nyb2xsX3dpZHRoIiwieDI2OSIsInNjcm9sbF9oZWlnaHQiLCJ4MjcwIiwid2lkdGgkMSIsIngyNzEiLCJoZWlnaHQkMSIsIngyNzIiLCJzY3JvbGxfdG9wIiwieDI3MyIsInNldF9zY3JvbGxfdG9wIiwieDI3NCIsIngyNzUiLCJmb2N1cyIsIngyNzYiLCJzZWxlY3Rpb25fc3RhcnQiLCJ4Mjc3Iiwic2VsZWN0aW9uX2VuZCIsIngyNzgiLCJzZXRfc2VsZWN0aW9uX3N0YXJ0IiwieDI3OSIsIngyODAiLCJzZXRfc2VsZWN0aW9uX2VuZCIsIngyODEiLCJ4MjgyIiwidF9vZl9qcyQxMCIsIngyODQiLCJ0X3RvX2pzJDEwIiwieDI4MyIsImNyZWF0ZV9lbGVtZW50IiwieDI4OCIsIngyODciLCJjcmVhdGVfZWxlbWVudF9ucyIsIngyOTEiLCJ4Mjg5IiwieDI5MCIsImNyZWF0ZV90ZXh0X25vZGUiLCJ4MjkzIiwieDI5MiIsImNyZWF0ZV9ldmVudCIsIngyOTUiLCJ4Mjk0IiwiZ2V0X2VsZW1lbnRfYnlfaWQiLCJ4Mjk3IiwieDI5NiIsImdldF9lbGVtZW50c19ieV9jbGFzc19uYW1lIiwieDMwMCIsIngyOTkiLCJib2R5IiwieDMwMiIsImNvb2tpZSIsIngzMDMiLCJzZXRfY29va2llIiwieDMwNCIsIngzMDUiLCJzZXRfdGl0bGUiLCJ4MzA2IiwieDMwNyIsIm9wZW4iLCJ4MzE0IiwieDMwOCIsIngzMDkiLCJ4MzEwIiwieDMxMiIsIngzMTEiLCJ3cml0ZSIsIngzMTYiLCJ4MzE1Iiwid3JpdGVsbiIsIngzMTgiLCJ4MzE3IiwiY2xvc2UiLCJ4MzE5IiwiZXhlY19jb21tYW5kIiwieDMyMSIsIngzMjAiLCJxdWVyeV9zZWxlY3RvciIsIngzMjMiLCJ4MzIyIiwidF9vZl9qcyQxMSIsIngzMjUiLCJ0X3RvX2pzJDExIiwieDMyNCIsImxlbmd0aCQwIiwieDMyOCIsImJhY2siLCJ4MzI5IiwiZm9yd2FyZCIsIngzMzAiLCJnbyIsIngzMzQiLCJ4MzMxIiwieDMzMiIsIngzMzIkMCIsIngzMzMiLCJyZXBsYWNlX3N0YXRlIiwieDMzOCIsIngzMzUiLCJ4MzM2IiwieDMzNyIsInB1c2hfc3RhdGUiLCJ4MzQyIiwieDMzOSIsIngzNDAiLCJ4MzQxIiwidF9vZl9qcyQxMiIsIngzNDQiLCJ0X3RvX2pzJDEyIiwieDM0MyIsImdldF9oYXNoIiwic2V0X2hhc2giLCJ4MzQ3IiwiaG9zdCIsIngzNDgiLCJzZXRfaG9zdCIsIngzNDkiLCJ4MzUwIiwiaG9zdG5hbWUiLCJ4MzUxIiwic2V0X2hvc3RuYW1lIiwieDM1MiIsIngzNTMiLCJocmVmIiwic2V0X2hyZWYiLCJ4MzU0IiwicGF0aG5hbWUiLCJ4MzU1Iiwic2V0X3BhdGhuYW1lIiwieDM1NiIsIngzNTciLCJwb3J0IiwieDM1OCIsInNldF9wb3J0IiwieDM1OSIsIngzNjAiLCJwcm90b2NvbCIsIngzNjEiLCJzZXRfcHJvdG9jb2wiLCJ4MzYyIiwieDM2MyIsInNlYXJjaCQwIiwieDM2NCIsInNldF9zZWFyY2giLCJ4MzY1IiwieDM2NiIsImFzc2lnbiIsIngzNjgiLCJ4MzY3IiwicmVsb2FkIiwieDM3MyIsIngzNjkiLCJ4MzcwIiwieDM3MSIsInJlcGxhY2UiLCJ4Mzc1IiwieDM3NCIsInRfb2ZfanMkMTMiLCJ4Mzc3IiwidF90b19qcyQxMyIsIngzNzYiLCJ0aW1lb3V0X2lkX29mX2pzIiwieDM4MSIsInRpbWVvdXRfaWRfdG9fanMiLCJ4MzgwIiwiYWRkX2V2ZW50X2xpc3RlbmVyJDAiLCJ4Mzg4IiwieDM4NCIsIngzODUiLCJ4Mzg3IiwieDM4NiIsImRvY3VtZW50IiwieDM4OSIsInNldF9vbmxvYWQiLCJ4MzkwIiwieDM5MSIsInNldF9pbnRlcnZhbCIsIngzOTQiLCJ4MzkyIiwieDM5MyIsInNldF90aW1lb3V0IiwieDM5NyIsIngzOTUiLCJ4Mzk2IiwiY2xlYXJfdGltZW91dCIsIngzOTkiLCJ4Mzk4IiwicmVxdWVzdF9hbmltYXRpb25fZnJhbWUiLCJ4NDAyIiwieDQwMCIsIng0MDEiLCJvcGVuJDAiLCJ4NDEzIiwieDQwMyIsIng0MDQiLCJ4NDA1IiwieDQwNiIsIng0MDciLCJ4NDExIiwieDQxMCIsIng0MDkiLCJ4NDA4IiwiYWxlcnQiLCJ4NDE1IiwieDQxNCIsInNlc3Npb25fc3RvcmFnZSIsIng0MTYiLCJsb2NhbF9zdG9yYWdlIiwieDQxOCIsImlubmVyX3dpZHRoIiwieDQyMCIsImlubmVyX2hlaWdodCIsIng0MjEiLCJwYWdlX3hfb2Zmc2V0IiwieDQyMiIsInBhZ2VfeV9vZmZzZXQiLCJ4NDIzIiwic2Nyb2xsX2J5IiwieDQyNiIsIng0MjQiLCJ4NDI1Iiwic2Nyb2xsX3RvIiwieDQyOSIsIng0MjciLCJ4NDI4IiwiaGlzdG9yeSIsIng0MzAiLCJsb2NhdGlvbiIsIng0MzEiLCJnZXRfY29tcHV0ZWRfc3R5bGUiLCJ4NDMzIiwieDQzMiIsImNvbnRlbnRfd2luZG93IiwieDQzNCIsImNvbnRlbnRfZG9jdW1lbnQiLCJ4NDM2IiwicGFyc2UkMCIsIng0MzgiLCJzdHJpbmdpZnkiLCJ4NDM5IiwidF9vZl9qcyQxNCIsIng0NDQiLCJ0X3RvX2pzJDE0IiwieDQ0MyIsIm5ld19maWxlX3JlYWRlciIsInJlYWR5X3N0YXRlIiwieDQ0NyIsIng0NDEiLCJyZXN1bHQiLCJ4NDQ4Iiwic2V0X29ubG9hZCQwIiwieDQ0OSIsIng0NTAiLCJyZWFkX2FzX3RleHQiLCJ4NDUyIiwieDQ1MSIsInRfb2ZfanMkMTUiLCJ4NDU0IiwidF90b19qcyQxNSIsIng0NTMiLCJjcmVhdGUiLCJvcGVuJDEiLCJ4NDU5IiwieDQ1NyIsIng0NTgiLCJzZW5kIiwieDQ2MSIsIng0NjAiLCJzZXRfcmVxdWVzdF9oZWFkZXIiLCJ4NDY0IiwieDQ2MiIsIng0NjMiLCJnZXRfcmVzcG9uc2VfaGVhZGVyIiwieDQ2NiIsIng0NjUiLCJvdmVycmlkZV9taW1lX3R5cGUiLCJ4NDY5IiwieDQ2OCIsInNldF93aXRoX2NyZWRlbnRpYWxzIiwieDQ3MCIsIng0NzEiLCJzdGF0dXMiLCJ4NDc3IiwicmVhZHlfc3RhdGUkMCIsIng0NzgiLCJ4NDc0IiwicmVzcG9uc2VfdGV4dCIsIng0NzkiLCJzZXRfb25yZWFkeXN0YXRlY2hhbmdlIiwieDQ4MCIsIng0ODEiLCJ0X29mX2pzJDE2IiwieDQ4MyIsInRfdG9fanMkMTYiLCJ4NDgyIiwiY3JlYXRlJDAiLCJ4NDg5IiwieDQ5MCIsIng0OTEiLCJ4NDkyIiwic2VuZCQwIiwieDQ5NSIsIng0OTQiLCJjbG9zZSQwIiwieDUwMiIsIng0OTYiLCJ4NDk3IiwieDQ5OCIsIng1MDAiLCJ4NDk5IiwiYmluYXJ5X3R5cGUiLCJ4NTAzIiwic2V0X2JpbmFyeV90eXBlIiwieDUwNCIsIng1MDUiLCJyZWFkeV9zdGF0ZSQxIiwieDUwNiIsIng0ODciLCJhZGRfZXZlbnRfbGlzdGVuZXIkMSIsIng1MTEiLCJ4NTA3IiwieDUwOCIsIng1MTAiLCJ4NTA5IiwiY29kZSQwIiwieDUxNCIsIndpbmRvdyIsImRvY3VtZW50JDAiLCJjb250ZXh0X29mX2pzIiwieDUxNiIsImNvbnRleHRfdG9fanMiLCJ4NTE1IiwiZ3JhZGllbnRfb2ZfanMiLCJ4NTIwIiwiZ3JhZGllbnRfdG9fanMiLCJ4NTE5IiwiZ2V0X2NvbnRleHQiLCJvcHQiLCJjYW52YXMiLCJzdGgiLCJhbHBoYSIsInRvX2RhdGFfVVJMIiwieDUzMSIsInNldF9maWxsX3N0eWxlIiwieDUzMiIsIng1MzMiLCJ4NTM1IiwieDUzNCIsInNldF9zdHJva2Vfc3R5bGUiLCJ4NTM2IiwieDUzNyIsIng1MzkiLCJ4NTM4Iiwic2V0X2xpbmVfd2lkdGgiLCJ4NTQwIiwieDU0MSIsImNyZWF0ZV9saW5lYXJfZ3JhZGllbnQiLCJ4NTQ2IiwieDU0MiIsIng1NDMiLCJ4NTQ0IiwieDU0NSIsImFkZF9jb2xvcl9zdG9wIiwieDU0OSIsIng1NDciLCJ4NTQ4IiwiYmVnaW5fcGF0aCIsIng1NTAiLCJjbG9zZV9wYXRoIiwieDU1MSIsImFyYyIsIng1NTciLCJ4NTUyIiwieDU1MyIsIng1NTQiLCJ4NTU1IiwieDU1NiIsIm1vdmVfdG8iLCJ4NTYwIiwieDU1OCIsIng1NTkiLCJsaW5lX3RvIiwieDU2MyIsIng1NjEiLCJ4NTYyIiwiZmlsbCIsIng1NjQiLCJzdHJva2UiLCJ4NTY1Iiwic3Ryb2tlX3JlY3QiLCJ4NTcwIiwieDU2NiIsIng1NjciLCJ4NTY4IiwieDU2OSIsImZpbGxfcmVjdCIsIng1NzUiLCJ4NTcxIiwieDU3MiIsIng1NzMiLCJ4NTc0Iiwic2V0X2ZvbnQiLCJ4NTc2IiwieDU3NyIsImZpbGxfdGV4dCIsIng1ODEiLCJ4NTc4IiwieDU3OSIsIng1ODAiLCJzdHJva2VfdGV4dCIsIng1ODUiLCJ4NTgyIiwieDU4MyIsIng1ODQiLCJ0X29mX2pzJDE3IiwieDU4NyIsInRfdG9fanMkMTciLCJ4NTg2Iiwid2lkdGgkMiIsIng1OTAiLCJtZWFzdXJlX3RleHQiLCJ4NTkyIiwieDU5MSIsInJvdGF0ZSIsIng1OTQiLCJ4NTkzIiwidHJhbnNsYXRlIiwieDU5NyIsIng1OTUiLCJ4NTk2Iiwic2NhbGUiLCJ4NjAwIiwieDU5OCIsIng1OTkiLCJjbGVhcl9yZWN0IiwieDYwNSIsIng2MDEiLCJ4NjAyIiwieDYwMyIsIng2MDQiLCJub3ckMCIsImxvZyIsIng2MDkiLCJ4NjA4IiwiY29uc29sZSIsImNyZWF0ZSQxIiwieDYxMiIsImZyb21fYnVmZmVyIiwieDYxNSIsInNldCQwIiwieDYxOSIsIng2MTYiLCJ4NjE4Iiwib3B0aW9ucyIsIng2MjIiLCJ4NjIzIiwieDYyNCIsIng2MjYiLCJ4NjI1IiwiY3JlYXRlJDIiLCJ4NjI5IiwieDYzMCIsIng2MzEiLCJ4NjMzIiwieDYzNCIsIng2MzIiLCJvZl9ibG9iIiwieDYzNSIsInJldm9rZSIsIng2MzYiLCJ0X29mX2pzJDE4IiwieDYzOCIsInRfdG9fanMkMTgiLCJ4NjM3IiwidW5pdF90eXBlIiwieDY0MSIsInZhbHVlJDAiLCJ4NjQyIiwidmFsdWVfYXNfc3RyaW5nIiwieDY0MyIsInZhbHVlX2luX3NwZWNpZmllZF91bml0cyIsIng2NDQiLCJ0X29mX2pzJDE5IiwieDY0NiIsInRfdG9fanMkMTkiLCJ4NjQ1IiwiYW5pbV92YWwiLCJ4NjQ5IiwiYmFzZV92YWwiLCJ4NjUwIiwidF9vZl9qcyQyMCIsIng2NTUiLCJ0X3RvX2pzJDIwIiwieDY1NCIsIngkMCIsIng2NTgiLCJ5JDAiLCJ4NjU5IiwieDY2MCIsInkxIiwieDY2MSIsIng2NjIiLCJ5MiIsIng2NjMiLCJwYXRoX3NlZ190eXBlIiwieDY2NCIsIng2NTIiLCJwYXRoX3NlZ190eXBlX2FzX2xldHRlciIsIng2NjUiLCJ0X29mX2pzJDIxIiwieDY2NyIsInRfdG9fanMkMjEiLCJ4NjY2IiwibnVtYmVyX29mX2l0ZW1zIiwieDY3MCIsImdldF9pdGVtJDAiLCJ4NjcyIiwieDY3MSIsImluc2VydF9pdGVtX2JlZm9yZSIsIng2NzUiLCJ4NjczIiwieDY3NCIsInJlcGxhY2VfaXRlbSIsIng2NzgiLCJ4Njc2IiwieDY3NyIsInJlbW92ZV9pdGVtJDAiLCJ4NjgwIiwieDY3OSIsImFwcGVuZF9pdGVtIiwieDY4MiIsIng2ODEiLCJ0X29mX2pzJDIyIiwieDY4NCIsInRfdG9fanMkMjIiLCJ4NjgzIiwicGF0aF9zZWdfbGlzdCIsIng2ODciLCJub3JtYWxpemVkX3BhdGhfc2VnX2xpc3QiLCJ4Njg4IiwiYW5pbWF0ZWRfcGF0aF9zZWdfbGlzdCIsIng2ODkiLCJhbmltYXRlZF9ub3JtYWxpemVkX3BhdGhfc2VnX2xpc3QiLCJ4NjkwIiwiY3JlYXRlX2Nsb3NlX3BhdGgiLCJ4NjkxIiwiY3JlYXRlX21vdmV0b19hYnMiLCJ4Njk0IiwieDY5MiIsIng2OTMiLCJjcmVhdGVfbW92ZXRvX3JlbCIsIng2OTciLCJ4Njk1IiwieDY5NiIsImNyZWF0ZV9saW5ldG9fYWJzIiwieDcwMCIsIng2OTgiLCJ4Njk5IiwiY3JlYXRlX2xpbmV0b19yZWwiLCJ4NzAzIiwieDcwMSIsIng3MDIiLCJlY2hvIiwibXNnIiwiYmF0Y2giLCJsIiwibWFwIiwiZiIsIm9uY2xpY2siLCJvbmRibGNsaWNrIiwib25jb250ZXh0bWVudSIsIm9uZm9jdXMiLCJvbmlucHV0Iiwib25jaGFuZ2UiLCJvbmNoYW5nZV9pbmRleCIsIm9uY2hhbmdlX2NoZWNrZWQiLCJvbmJsdXIiLCJvbm1vdXNlbW92ZSIsIm9ua2V5ZG93biIsInN0cl9wcm9wIiwiayIsInYiLCJpbnRfcHJvcCIsImJvb2xfcHJvcCIsImZsb2F0X3Byb3AiLCJzdHlsZSQwIiwiYXR0ciIsImludF9hdHRyIiwiZmxvYXRfYXR0ciIsInNjcm9sbF90b19zaG93IiwiYXV0b2ZvY3VzIiwiY2xhc3MkMCIsInR5cGUkMSIsInR5cGVfYnV0dG9uIiwidmFsdWUkMSIsImRpc2FibGVkIiwiYWRkX2NsYXNzIiwiYXR0cnMiLCJoYXNfY2xhc3NOYW1lIiwiYSIsInMiLCJ0ZXh0IiwidHh0IiwiZWx0IiwidGFnIiwibnMiLCJzdGgkMCIsImskMCIsInN2Z19lbHQiLCJkaXYiLCJpbnB1dCIsInR4dF9zcGFuIiwibWFwX2F0dHIiLCJpbml0IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZXMkMCIsIm1hcCQwIiwibWVtbyIsImFyZyIsImN1c3RvbSIsInJldHVybiQwIiwibW9kZWwiLCJjIiwiYXBwIiwidXBkYXRlIiwidmlldyIsInNpbXBsZV9hcHAiLCJpbnB1dF9ldmVudCIsImNoZWNrZWRfZXZlbnQiLCJiIiwiY2hhbmdlX2V2ZW50Iiwic2VuZF9tc2ciLCJjdHgiLCJydW4iLCJwYXJhbSIsIngkMSIsInRsIiwiaGQiLCJtYWtlIiwic3luYyIsImRvbSIsInNlbmRfZXZlbnQiLCJzY3JvbGxfdG9fbWFrZV92aXNpYmxlIiwibm9kZSIsInBhcmVudCIsIm92ZXJmbG93X3kiLCJpc19zY3JvbGxhYmxlIiwibm9kZSQwIiwicl9wYXJlbnQiLCJyX2NoaWxkIiwieTEkMCIsInkyJDAiLCJnZXRfZG9tIiwiZ2V0X3Zkb20iLCJldmFsX3Byb3AiLCJ4JDIiLCJzdHJpbmdfb2ZfcHJvcCIsInNhbWVfcHJvcCIsInYxIiwibWF0Y2giLCJ4MiQwIiwieDEkMCIsIngyJDEiLCJ4MSQxIiwieDIkMiIsIngxJDIiLCJibWVtbyIsInZkb20iLCJhc3luYyIsImN1c3RvbV9hdHRyaWJ1dGUiLCJleG4iLCJhcHBseV9hdHRyaWJ1dGVzIiwidiQwIiwidiQxIiwiayQxIiwiYmxpdCIsImNoaWxkcmVuIiwiZG9tJDAiLCJjaGlsZHJlbiQwIiwiZiQwIiwiZWwiLCJlIiwiZWx0JDAiLCJzeW5jX3Byb3BzIiwic2FtZSIsImwxIiwibDIiLCJrMiIsImsxIiwic29ydCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJ0bDIkMCIsInYyJDAiLCJrMiQwIiwiY2hvb3NlIiwianNfZW1wdHlfc3RyaW5nIiwic3luY19hdHRyaWJ1dGVzIiwiYTEiLCJhMiIsInByb3BzIiwic3R5bGVzIiwiY2xlYXIkMCIsInNldCQxIiwiY2xlYXIkMSIsIm9sZCIsInMyIiwiczEiLCJvbGRfY2hpbGRyZW4iLCJuZXdfY2hpbGRyZW4iLCJieV9rZXkiLCJpJDEiLCJpbmRpY2VzIiwiaSQwIiwiaWR4JDAiLCJpIiwiY3RybHMiLCJuZXh0IiwiaWR4IiwibW92ZSIsImMyIiwiYzEiLCJmMiIsImMxJDAiLCJmMSIsImEyJDAiLCJhcmcyIiwia2V5MiIsImExJDAiLCJhcmcxIiwia2V5MSIsImZvdW5kIiwiaW5uZXIkMSIsImlubmVyJDIiLCJ2ZG9tX29mX2RvbSIsInJvb3QiLCJtb3VzZV9ldmVudCIsInByb2Nlc3MiLCJjbWQiLCJoIiwiY3VzdG9tJDAiLCJtZXJnZSIsImVudnMiLCJnbG9iYWwiLCJyZWdpc3RlciIsInJ1biQwIiwiY21kMCIsIm1vZGVsMCIsImVudiIsImVudiQwIiwiY29udGFpbmVyIiwicHJvY2Vzc19jdXN0b21fZndkIiwiZXZ0IiwiY3VycmVudCIsInBlbmRpbmdfcmVkcmF3IiwicG9zdF9yZWRyYXciLCJhZnRlcl9yZWRyYXciLCJyZWRyYXciLCJuZXdfdmRvbSIsIm5ld19tb2RlbCIsIm9uZXZlbnQiLCJ0eSIsInRndCIsInByb3BhZ2F0ZSIsImYkMSIsImN1cnJfdmFsdWUiLCJmJDIiLCJmJDMiLCJmJDQiLCJmJDUiLCJmJDYiLCJtc2ckMCIsImYkNyIsImN1cnJfdmFsdWUkMCIsImNoYW5nZWQiLCJsJDAiLCJtc2ckMSIsInMyJDAiLCJwcm9jZXNzX2N1c3RvbSIsImV2ZW50IiwibWFwcGVyIiwicGFyYW0kMCIsInJlc3QiLCJyIiwic2FtcGxlX2R2b3Jha19kYXRhIiwic2FtcGxlX2NvbGVtYWtfZGF0YSIsInNhbXBsZV9xd2VydHlfZGF0YSIsInN0cmluZ19vZl9oYW5kIiwic3RyaW5nX29mX2ZpbmdlciIsImxvb2t1cF9vZl9kYXRhIiwibGF5b3V0Iiwicm93cyIsInQiLCJoIiwicmVzdWx0cyQwIiwicGFyYW0kMSIsInkiLCJ4IiwiY29scyIsImsiLCJjIiwiZmluZ2VyIiwiaGFuZCIsImMkMCIsIm1hdHJpeCIsIndpZHRoIiwiaGVpZ2h0IiwicSIsIm1hcCIsIml0Iiwibm9kZV95Iiwibm9kZV94Iiwibm9kZSIsIm15X2Rpc3QiLCJuIiwidmlldyIsIm9wdCIsIm9ucmVtb3ZlIiwibGFiZWwiLCJzdGgiLCJoaWdobGl0X2tleSIsInN0aCQwIiwiaW5fZWRpdCIsImwiLCJyb3ciLCJrZXkiLCJyZWN0cyIsImNvbCIsImZpbGwiLCJwb3NfeCIsInBvc195IiwicmVjdCIsInRleHQiLCJrZXlfYnV0dG9ucyIsImFjYyIsIm1heF9yb3dfbGVuIiwiY2hhcnNfb2Zfc3RyaW5nIiwicyIsImF1eCIsImkiLCJzdHJpbmdfb2ZfY2hhcnMiLCJjaGFycyIsImZpbmRfYmVzdF9pbl9saXN0IiwiY21wIiwibCIsInQiLCJoIiwiZ2V0IiwieCIsIm1hcCIsImYiLCJtYXAyIiwieSIsImluaXQiLCJzdHJpbmdfb2Zfa2V5IiwidXBkYXRlX2FuYWx5c2lzIiwibGV0dGVyIiwiYW5hbHlzaXMiLCJkaXN0IiwiZmluZ2VyIiwiaGFuZCIsImxhc3RfZmluZ2VyIiwibGFzdF9oYW5kIiwic3RhdHMiLCJmaW5pc2hfYW5hbHlzZXMiLCJtb2RlbCIsImMiLCJncm91cF90eXBpbmdfYW5hbHlzZXMiLCJhbmFseXNlcyIsImFjYyIsIml0IiwiYSIsImIiLCJmaW5kX2Jlc3Rfc3RhdHMiLCJiX3ZhbCIsImFfdmFsIiwiaW5pdCQwIiwidXBkYXRlIiwicGFzc2FnZSIsImxheW91dF9kYXRhIiwibmFtZSIsImJ1dHRvbiIsInR4dCIsIm1zZyIsInN0YXRzX2NoYXJ0Iiwic3RhdHNfYnlfbmFtZXMiLCJmYWN0b3JzIiwiayIsInkwIiwiZmFjdG9yIiwic3RhdHNfYnlfbmFtZXMkMCIsImxlZ2VuZCIsInYiLCJ3IiwiciIsInZpZXciLCJiZXN0X3N0YXRzIiwiY2xhc3NlcyIsInN0YXRfY2VsbCIsImkkMCIsImhpZ2hsaXRfa2V5IiwiaW5fZWRpdCIsImFwcCIsInJ1biIsImFwcCQwIiwiY29udGFpbmVyIiwiY29udGFpbmVyJDAiXSwibWFwcGluZ3MiOiI7Ozs7SUE4bENBO0lDOWRBLGtDQUFvQyxVQUFXO0lBN2IvQztNQUNFO2dCQUVFLG1CQUFxQixnQkFFckIsT0FBTztlQUVQO1NBRUo7SUNqSkE7TUFDRTtPQUFPO09BQ0E7T0FDQTtNQUNQLG9EQUNGO0lBNUNBLHNCQUF3QjtJQXdEeEI7TUFDRTtPQUFPO09BQ0E7T0FDQTs7Ozs7Ozs7Ozs7Ozs7TUFDUCxvREFDRjtJQTlCQTtNQUNFLElBQU8sVUFDQSx1QkFDQTtNQUNQLG9EQUNGO0lBd0xBO01BQ0UsNkRBQ0Y7SUZoQkE7TUFDRSxJQUFNLFdBQ0E7TUFDTixJQUFVO01BQ1YsUUFDRjtJRXBLQTtNQUNFO09BQU87T0FDQTtPQUNBO01BQ1Asb0RBQ0Y7SUFqREE7TUFDRSxlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixRQUNGO0lBOElBOzs7aUNBSUE7SUFHQTs7O3VCQUlBO0lBTUE7TUFDRTtPQUFXO09BQ0MsUUFBRTtPQUNGLFFBQUU7T0FDRDtNQUNiLE1B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Ozs7Ozs7Ozs7OztVOzs7Ozs7O0lheGVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDa0JLQTtLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N3QkFDO0tBQ0FDO0tBQ0FDO0tBSUFDO0tBQ0FDOzs7O0tDekJBQztLQW9IQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3k3RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0MxakZkQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3FERUM7S0FDQUM7S0FDQUM7OztLQTNEWUM7S0E4RVpDO0tBQ0FDO0tBQ0FDOzs7S0ErREFDO0tBQ0FDO0tBQ0FDOzs7S0M3SUZDO0tBQ0FDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQ21mSUM7O09Ba0NZOztPQWxDWjtnQkFLSixJQURRQyxjQUNBLG9CQURBQTtnQkFHUixJQURVQyxnQkFDQSxvQkFEQUE7Z0JBR1YsSUFET0MsZ0JBQ0Esb0JBREFBO2dCQUdQLElBRFNDLGdCQUNBLG9CQURBQTtnQkFLVCxJQURhQyxnQkFDQSxvQkFEQUE7Z0JBRGIsSUFEU0MsZ0JBQ0Esb0JBREFBO2dCQUtULElBRFNDLGdCQUNBLG9CQURBQTtnQkFHVCxJQURRQyxnQkFDQSxvQkFEQUE7O2NBRVdDLGdCQUFKQyxZQUNJLFVBREpBLEdBQ0ksVUFEQUQ7O2NBRVNFLGdCQUFYQztVQUNVLFVBRFZBLFFBQ1UsVUFEQ0Q7aUJBRzVCLElBRFNFLGdCQUNBLHFCQURBQTtpQkFHVCxJQURTQyxpQkFDQSxxQkFEQUE7aUJBR1QsSUFET0MsaUJBQ0EscUJBREFBO2lCQUdQLElBRFVDLGlCQUNBLHFCQURBQTtpQkFHVixJQURrQkMsaUJBQ0EscUJBREFBLFVBRVU7YUFpQnhCQyxhQVdKQyxPQUFPQztNQUFVLFVBQWpCRDtPQStCZ0IsT0EvQlRDOztPQUFVLE9BQWpCRDtnQkFFQSxJQURRbEIsS0FEUmtCLFVBRVEsdUJBREFsQixLQUREbUI7Z0JBSVAsSUFEVWxCLE9BSFZpQixVQUlVLHVCQURBakIsT0FISGtCO2dCQU1QLElBRE9qQixPQUxQZ0IsVUFNTyx1QkFEQWhCLE9BTEFpQjtnQkFRUCxJQURTaEIsT0FQVGUsVUFRUyx1QkFEQWYsT0FQRmdCO2dCQVVQLElBRGFmLE9BVGJjLFVBVWEsdUJBREFkLE9BVE5lO2dCQVlQLElBRFNkLE9BWFRhLFVBWVMsdUJBREFiLE9BWEZjO2dCQWNQLElBRFNiLE9BYlRZLFVBY1MsdUJBREFaLE9BYkZhO2dCQWdCUCxJQURRWixPQWZSVyxVQWdCUSx1QkFEQVgsT0FmRFk7O2NBMkJZWCxPQTNCbkJVLFVBMkJlVCxHQTNCZlM7VUE0Qm1CLFVBREpULEdBQ0ksYUFEQUQsT0EzQlpXOztjQTZCb0JULE9BN0IzQlEsVUE2QnNCRSxJQTdCdEJGLFVBNkJpQlAsSUE3QmpCTztVQThCMkIsVUFEVlAsSUFBS1MsSUFDSyxhQURBVixPQTdCcEJTO2lCQWtCUCxJQURTUCxPQWpCVE0sVUFrQlMsd0JBREFOLE9BakJGTzs7VUFvQlAsSUFEU04sUUFuQlRLLFVBb0JTLHdCQURBTCxRQW5CRk07O1VBc0JQLElBRE9MLFFBckJQSSxVQXNCTyx3QkFEQUosUUFyQkFLOztVQXdCUCxJQURVSixRQXZCVkcsVUF3QlUsd0JBREFILFFBdkJISTs7VUEwQlAsSUFEa0JILFFBekJsQkUsVUEwQmtCLHdCQURBRixRQXpCWEcsU0ErQmU7YUFNbEJFLFdBSUpDLEtBQUtDO01BQVEsVUFBYkQ7T0EyREEsT0EzREtDOztPQUFRLE9BQWJEO2dCQWtCQSxJQURLdEIsS0FqQkxzQixRQWtCSyxxQkFEQXRCLEtBakJBdUI7Z0JBb0JMLElBRFV0QixPQW5CVnFCLFFBb0JVLHFCQURBckIsT0FuQkxzQjs7Y0FDUXJCLE9BRGJvQixRQUNRRSxJQURSRjtVQUVhLFVBRExFLElBQ0ssV0FEQXRCLE9BRFJxQjs7Y0FHYXBCLE9BSGxCbUIsUUFHYUcsTUFIYkg7VUFJa0IsVUFETEcsTUFDSyxXQURBdEIsT0FIYm9COztjQU1rQm5CLE9BTnZCa0IsUUFNaUJJLEtBTmpCSixRQU1ZSyxNQU5aTCxRQU1LTSxNQU5MTjtVQU91QixVQURsQk0sTUFBT0QsTUFBS0QsS0FDTSxXQURBdEIsT0FObEJtQjs7Y0FRb0JsQixPQVJ6QmlCLFFBUW1CTyxPQVJuQlAsUUFRY1EsTUFSZFIsUUFRT1MsUUFSUFQ7VUFTeUIsVUFEbEJTLFFBQU9ELE1BQUtELE9BQ00sV0FEQXhCLE9BUnBCa0I7O2NBVXdCakIsT0FWN0JnQixRQVV1QlUsT0FWdkJWLFFBVWtCVyxNQVZsQlgsUUFVV1ksUUFWWFo7VUFXNkIsVUFEbEJZLFFBQU9ELE1BQUtELE9BQ00sV0FEQTFCLE9BVnhCaUI7O2NBWW9CaEIsT0FaekJlLFFBWW1CYSxPQVpuQmIsUUFZY2MsTUFaZGQsUUFZT2UsUUFaUGY7VUFheUIsVUFEbEJlLFFBQU9ELE1BQUtELE9BQ00sV0FEQTVCLE9BWnBCZ0I7O2NBY29CZixPQWR6QmMsUUFjbUJnQixPQWRuQmhCLFFBY2NpQixNQWRkakIsUUFjT2tCLE1BZFBsQjtVQWV5QixVQURsQmtCLE1BQU9ELE1BQUtELE9BQ00sV0FEQTlCLE9BZHBCZTs7Y0FxQk1iLE9BckJYWSxRQXFCTW1CLE1BckJObkI7VUFzQlcsVUFETG1CLE1BQ0ssV0FEQS9CLE9BckJOYTtpQkFnQ0wsSUFETVgsT0EvQk5VLFFBZ0NNLHNCQURBVixPQS9CRFc7O2NBa0NnQlYsUUFsQ3JCUyxRQWtDZ0JvQixJQWxDaEJwQjtVQW1DcUIsV0FETG9CLElBQ0ssV0FEQTdCLFFBbENoQlU7O2NBb0NjVCxRQXBDbkJRLFFBb0NjcUIsSUFwQ2RyQjtVQXFDcUIsV0FEUHFCLElBQ08sV0FERjdCLFFBcENkUzs7Y0F1Q21CUixRQXZDeEJPLFFBdUNpQnNCLE1BdkNqQnRCLFFBdUNZdUIsTUF2Q1p2QjtVQXdDMEIsV0FEZHVCLE1BQUtELE1BQ1MsV0FERjdCLFFBdkNuQlE7O2NBeUNxQlAsUUF6QzFCTSxRQXlDbUJ3QixRQXpDbkJ4QixRQXlDY3lCLE1BekNkekI7VUEwQzBCLFdBRFp5QixNQUFLRCxRQUNPLFdBREE5QixRQXpDckJPO2lCQXdCTCxJQURNeUIsUUF2Qk4xQixRQXdCTSxzQkFEQTBCLFFBdkJEekI7aUJBMEJMLElBRE0wQixRQXpCTjNCLFFBMEJNLHNCQURBMkIsUUF6QkQxQjs7Y0FxRHVCMkIsUUFyRDVCNUIsUUFxRGdCNkIsV0FyRGhCN0I7VUFzRDRCLFdBRFo2QixXQUNZLFdBREFELFFBckR2QjNCOztjQXVEdUI2QixRQXZENUI5QixRQXVEZ0IrQixXQXZEaEIvQjtVQXdENEIsV0FEWitCLFdBQ1ksV0FEQUQsUUF2RHZCN0I7aUJBOEJMLElBRE8rQixRQTdCUGhDLFFBOEJPLHNCQURBZ0MsUUE3QkYvQjs7Y0E0QytCZ0MsUUE1Q3BDakMsUUE0QzBCa0MsU0E1QzFCbEMsUUE0Q2VtQyxVQTVDZm5DO1VBNkNvQyxXQURyQm1DLFVBQVdELFNBQ1UsV0FEQUQsUUE1Qy9CaEM7O2NBOENzQm1DLFFBOUMzQnBDLFFBOENrQnFDLFFBOUNsQnJDO1VBK0MyQixXQURUcUMsUUFDUyxXQURBRCxRQTlDdEJuQztpQkFpREwsSUFEZXFDLFFBaERmdEMsUUFpRGUsc0JBREFzQyxRQWhEVnJDOztjQWtEZXNDLFFBbERwQnZDLFFBa0Rld0MsSUFsRGZ4QztVQW1Eb0IsV0FETHdDLElBQ0ssV0FEQUQsUUFsRGZ0Qzs7Y0EyQmF3QyxRQTNCbEJ6QyxRQTJCZTBDLEVBM0JmMUMsUUEyQlEyQyxNQTNCUjNDO1VBNEJrQixXQURWMkMsTUFBT0QsRUFDRyxXQURBRCxRQTNCYnhDLE9BMkREO29DQS9HQU4sYUFuREFsQixVQW1HQXNCOzs7SUNsbEJOLFNBT0U2QyxTQUFTQyxHQUFJLGlCQUFKQSxFQUFvQjtJQVAvQixTQVFFQyxZQUFZRCxHQUFJLDBCQUFKQSxFQUE2QjtJQVIzQzthQXVDRUUsSUFBSUMsRUFBRUMsR0FBTyxzQkFBVEQsRUFBRUMsR0FBRkQsRUFBRUMsQ0FBMkI7SUF2Q25DLFNBd0NFQyxJQUFJRixFQUFFQyxHQUFPLHlCQUFURCxFQUFFQyxHQUFGRCxFQUFFQyxDQUEyQjtJQXhDbkMsU0FpRUVFLElBQUlILEdBQUksWUFBSkEsV0FBNEI7SUFqRWxDLFNBdUVFSSxLQUFLSixHQUFJLE9BQUpBLE1BQWU7SUFzRXRCOztLQUVBO0tBRUE7S0FFQTtLQUVBO0tBRUE7S0F2SkE7O0lBdUpBLFNBc0JFYSxJQUFNQyxHQUFHQztNQUNYO2dDQURRRDtPQUNSLHlCQURXQztPQUNYLG9CQUFJQyxLQUEwQkM7TUFFOUIsaUJBSFFILEtBRUpqQixJQURBbUI7TUFHSixpQkFKV0QsS0FFUGxCLEVBREFtQixHQUEwQkM7TUFHOUIsNEJBRklwQixFQUdvQjtJQTNCeEIsU0FpQ0VxQixZQUFZQztNQUNkLFFBRGNBLDBCQUNXLG1DQUFtRDtJQWxDNUUsU0ErREVDLGVBQWVDLEdBQ2pCLE9BRGlCQSxvQkFDWTtJQWhFN0IsU0FpRUVDO01BQWlCOztpQkFHWjs7Z0JBQTRCO0lBcEVuQyxTQXNFRUM7TUFBcUI7O2tCQUdaO0lBekVYLFNBMkVFQyxjQUFjTCxHQUNoQiw0QkFEZ0JBLEVBQ0M7SUE1RWpCLFNBZ0ZFTSxrQkFBa0I1QjtNQUVwQjtRQUFTLCtCQUZXQTs7OztRQUpwQixXQU9zQjtJQW5GdEIsU0F1RkU2QixrQkFBa0I3QjtNQUNwQiw0QkFEb0JBLEdBRVByRTtNQUNYO1dBRkVtRyxLQUNTbkcsU0FDSSxJQUhHcUU7UUFJWjsrQkFKWUEsRUFFUHJFO1NBRUw7UUQ2UEYsYUM1UGtCLFFBSFhBO1FBSUosT0FOV3FFLEVBUWQ7SUEvRk4sU0FpR0VnQyxnQkFBZ0JuQztNQUFzQixtREFBdEJBLEdBQThDO0lBakdoRSxTQXFHRW9DLG9CQUFvQmpDO01BRXRCO1FBQVMsaUNBRmFBOzs7O1FBSkEsV0FPQTtJQXhHdEIsU0MvSEVrQyxPRDJPVWYsR0FBR0M7TUFDZixHQURZRCxRQUdKZ0IsR0FISWhCLE1BR1ZpQixHQUhVakIsTUFHUSxVQUFsQmlCLEdBQWtCLE9BQVpELEdBSE9mLEtBRVAsT0FGT0EsRUFHYztJQVduQjs7S0FDQztLQUNBO2FBY1RvQixhQUFhQyxLQUFLQyxLQUFLQztNQUNFLElBQXZCQyxFQUF1QiwwQ0FERkQsS0FBVkYsS0FBS0M7TUFFcEIseUJBRElFLEVBRHFCRDtNQUV6QixPQURJQyxDQUVIO0lBakJVLFNBbUJUQyxTQUFTRixNQUNYLDRCQURXQSxLQUM2RDtJQXBCN0QsU0FzQlRHLGFBQWFILE1BQ2YsNEJBRGVBLEtBQzJEO0lBdkIvRCxTQThCVEk7TUFDRixTQUFRQztRVDVVWDtRUzRVa0I7O2dCQUVSbEIsYUFBSG1COztjQUVNLGNBRk5BOzs7O3dCQUFHbkI7O1VBREcsU0FPRTtNQUNKLGlEQUFzQjtJQXhDbkIsU0FpRFRvQixhQUFhQyxHQUFHbkQ7TUFDbEIsNEJBRGVtRCxHQUFHbkQsSUFDbEIscUJBRGtCQSxHQUNtQjtJQWxEMUIsU0FvRFRvRCxjQUFjRCxHQUFHbkQ7TUFDbkIsc0JBRGdCbUQsR0FBR25ELElBQ25CLHNCQURtQkEsR0FDMEI7SUFyRGxDLFNBdURUcUQsT0FBT0YsR0FBR25ELEVBQUVzRCxJQUFJQztNQUNsQixRQURjRDtlQUFJQztvQ0FBTnZELEtBQU11RCxXQUFKRDtnQkFHVCxxQkFISUgsR0FBR25ELEVBQUVzRCxJQUFJQztNQUViLDhCQUMwQjtJQTFEcEIsU0E0RFRDLGlCQUFpQkwsR0FBR25ELEVBQUVzRCxJQUFJQztNQUM1QixRQUR3QkQ7ZUFBSUM7cUNBQU52RCxLQUFNdUQsV0FBSkQ7Z0JBR25CLGVBSGNILEdBQUduRCxFQUFFc0QsSUFBSUM7TUFFdkIsd0NBQ2lDO0lBL0QzQixTQXNFVEUsYUFBYUMsS0FBS0MsR0FBSSx5QkFBVEQsS0FBS0MsSUFBZ0M7SUF0RXpDLFNBNEVUQyxVQUFVVCxJQUFLLGNBQUxBLElBQUssNkJBQUxBLEdBQW1DO0lBNUVwQyxTQTZFVFUsZ0JBQWdCVjtNQUNsQixLQUFLLGNBRGFBO01BRWxCO1FBQUssK0JBRmFBLElBRWtCOzJCQUFHO0lBL0U1QixTQXdGVFcsWUFBWXJCLEtBQUtDLEtBQUtDO01BQ0UsSUFBdEJDLEVBQXNCLHlDQURGRCxLQUFWRixLQUFLQztNQUVuQix5QkFESUUsRUFEb0JEO01BRXhCLE9BRElDLENBRUg7SUEzRlUsU0E2RlRtQixRQUFRcEIsTUFDVix5QkFEVUEsS0FDaUM7SUE5RmhDLFNBZ0dUcUIsWUFBWXJCLE1BQ2QseUJBRGNBLEtBQytCO0lBakdsQyxTQXdHVHNCLE1BQU1DLEdBQUdsRSxFQUFFc0QsSUFBSUM7TUFDakIsUUFEYUQ7ZUFBSUM7b0NBQU52RCxLQUFNdUQsV0FBSkQ7Z0JBR1IsY0FIR1ksR0FBR2xFLEVBQUVzRCxJQUFJQztNQUVaLDZCQUN5QjtJQTNHbkIsU0E2R0xZLG9CQUFvQkQsR0FBR2xFLEVBQUVzRCxJQUFJQztVQUFKYSxVQUFJQztNQUNuQztlQURtQ0E7VUFDVixJQUNuQkMsRUFEbUIsY0FEQ0osR0FBR2xFLEVBQUVvRSxNQUFJQztVQUNWLFNBQ25CQztVQURtQixJQUlsQixNQUw0QkQsUUFFN0JDLE1BR0MsTUFMd0JGLFFBRXpCRSxNQUZ5QkYsWUFBSUM7O1FBQ2xCLFNBS2Q7SUFuSFEsU0FxSFRJLGFBQWFQLEdBQUdsRSxFQUFFc0QsSUFBSUM7TUFDeEIsUUFEb0JEO2VBQUlDO29DQUFOdkQsS0FBTXVELFdBQUpEO2dCQUdmLG9CQUhVWSxHQUFHbEUsRUFBRXNELElBQUlDO01BRW5CLG9DQUNnQztJQXhIMUIsU0EwSFRtQixvQkFBb0JSLEdBQUdYO01BQ3pCLElBQUl2RCxFQUFKLGtCQUR5QnVEO01BRXpCLGFBRnNCVyxHQUNsQmxFLElBRHFCdUQ7TUFFekIsNEJBREl2RCxFQUVvQjtJQTdIYixTQWlJVDJFLFdBQVdqQjtNQUNiLFNBQVFrQixhQUFhQzs7OztnQkFFYjFDLGNBQU5DLGNBQ01tQix5QkFETm5CO1lBRUUsZ0JBRkZBLEtBRm1CeUMsWUFHYnRCO1lBQ0osa0JBRElBLDRCQURBcEI7O1VBREEsT0FEYTBDO1VBTVJDLE9BQUt2QjtNQUNoQjtZQUFJakMsRUFBSixnQ0FSV29DO1FBUVgsU0FBSXBDO1VBQ1UsS0FGSHdEO21CQUtZLCtCQUxQdkIsU0FBTHVCOztVQU1GLFVBTEx4RDtZQWFLLElBQ0h5RCxJQURHLG9CQWJMekQ7WUFlSSxjQXZCR29DLEtBc0JMcUIsUUFkRnpEO1lBYUssSUFFRCxNQWhCUWlDLE1BQ1pqQyxNQWVJLFVBREZ5RCxJQWZLRCxrQkFBS3ZCOztVQU1PLElBQ2pCMEIsSUFEaUIsa0JBTG5CM0Q7VUFPSyxjQWZFb0MsS0FjTHVCLE1BTkYzRDtVQVFLLG1CQWhCRW9DO1VBZ0JGLEdBVEVvQjtXQVlEO21CQVpNdkIsTUFDWmpDO2lCQVltQiwrQkFEVCtDLGdCQUxSWSxJQVBLSDs7b0JBT0xHOzBDQVk2QjtJQTNKMUIsU0FvS1RDLGVBQWVoQjtNQUFLO1FBQUssK0JBQVZBLElBQWdDOzJCQUFHO0lBcEt6QyxTQTBLVGlCLFdBQVd2QyxHQUFJLDJCQTNLZk4sT0EyS1dNLEVBQXdCO0lBMUsxQixTQTJLVHdDLGFBQWFwRixHQUFJLHFCQTVLakJzQyxPQTRLYXRDLEVBQTBCO0lBM0s5QixTQTRLVHFGLFlBQVlyRixHQUFJLG9CQTdLaEJzQyxPQTZLWXRDLEVBQXlCO0lBNUs1QixTQTZLVHNGLFVBQVUzSjtNQUF5QixxQkE5S25DMkcsT0E4S21DLHFCQUF6QjNHLEdBQTBDO0lBN0szQyxTQThLVDRKLFlBQVkxRixHQUF5QixxQkEvS3JDeUMsT0ErS3FDLGdCQUF6QnpDLEdBQTRDO0lBOUsvQyxTQStLVDJGLGNBQWN4RjtNQUNoQixjQWpMRXNDLE9BZ0xjdEM7TUFDUSxvQkFqTHRCc0M7TUFpTHNCLHFCQWpMdEJBLE9BaUwyRDtJQWhMbEQsU0FpTFRtRDtNQUFtQixvQkFsTG5CbkQsV0FrTG1CLHFCQWxMbkJBLE9Ba0x3RDtJQWpML0MsU0FxTFRvRCxXQUFXOUMsR0FBSSwyQkFyTGZMLE9BcUxXSyxFQUF3QjtJQXJMMUIsU0FzTFQrQyxhQUFhM0YsR0FBSSxxQkF0TGpCdUMsT0FzTGF2QyxFQUEwQjtJQXRMOUIsU0F1TFQ0RixZQUFZNUYsR0FBSSxvQkF2TGhCdUMsT0F1TFl2QyxFQUF5QjtJQXZMNUIsU0F3TFQ2RixVQUFVbEs7TUFBeUIscUJBeExuQzRHLE9Bd0xtQyxxQkFBekI1RyxHQUEwQztJQXhMM0MsU0F5TFRtSyxZQUFZakcsR0FBeUIscUJBekxyQzBDLE9BeUxxQyxnQkFBekIxQyxHQUE0QztJQXpML0MsU0EwTFRrRyxjQUFjL0Y7TUFDaEIsY0EzTEV1QyxPQTBMY3ZDO01BQ1Esb0JBM0x0QnVDO01BMkxzQixxQkEzTHRCQSxPQTJMMkQ7SUEzTGxELFNBNExUeUQ7TUFBbUIsb0JBNUxuQnpELFdBNExtQixxQkE1TG5CQSxPQTRMd0Q7SUE1TC9DLFNBZ01UMEQsaUJBQWUsY0FqTWYzRCxRQWlNZSxrQkFsTWZELE1Ba002QztJQWhNcEMsU0FpTVQ2RCxnQkFBMkIsdUNBQWE7SUFqTS9CLFNBa01UQyxvQkFBbUMsc0NBQWE7SUFsTXZDLFNBbU1UQyxrQkFBK0IseUNBQWE7SUFuTW5DLFNBb01UQyxzQkFBdUMsd0NBQWE7SUFwTTNDO2FBOE5UQyx3QlQzZ0JMLElTMmdCcUMvSDtJQTlOdkIsU0FvT1RnSTtNQUVNO09BRnNDQztPQUFOcEo7T0FBaEJxSjtPQUFOdEo7T0FFVixTQUZnQnNKLEtBRVQsVUFGK0JEO01BQ3RDLHFCQURVckosS0FBc0JDO0lBcE83QixJQTRPVHNKLGlCQTlNQTNEO0lBOUJTLFNBOE9UNEQsUUFBUTlHO01BQ1YsTUFIRTZHLGlCQUdGOzs7O1FBS0ksT0FIQUcsa0JBRzJCLHFCQUE2QixXQU5sRGhIO1FBTXFELGtCQUwzRCtHLElBTUc7TUFOUCxRQU1RO0lBclBHLFNBdVBURSxrQkFBZ0Isa0JBWGhCSixtQkFXbUM7SUF2UDFCLFNBeVBUSyxLQUFLQztNQUNQLDJDQURPQSxRQUVTO0lBRVY7OztPQXhnQkovRztPQURBRjs7T0FnQ0FHO09BQ0FHO09BeUJBQztPQVlBUTtPQUNBQztPQVBBUjtPQXFFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0F1QkFHO09BV0FLO09BOEJBRTtPQUVBRTtPQUtBQztPQUtBQztPQUtBQztPQWlCQUk7T0FJQUM7T0NwT0FDO09EeVBBRztPQUNBQztPQUNBQztPQTBLQTRDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BSUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BSUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BakxBeEQ7T0FHQUM7T0FSQU47O09BZ0JBTzs7T0FzQkFLO09BSEFGO09BTUFHO09BS0FHOzs7T0FVQUM7Ozs7T0FNQUc7T0FDQUM7O09BZ0JBRTtPQUdBQztPQVJBRjs7T0F5Q0FhO09BekJBVjtPQWFBUTtPQUtBQzs7Ozs7Ozs7T0EwQ0FROzs7Ozs7Ozs7T0EwREFvQjtPQU1BQztPQXFCQVE7T0FYQUo7T0FuUkE5RTtPQWtKSXNDO09BMElKMkM7S0FNSTs7O09BeGdCSjdHO09BREFGOztPQWdDQUc7T0FDQUc7T0F5QkFDO09BWUFRO09BQ0FDO09BUEFSO09BcUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQXVCQUc7T0FXQUs7T0E4QkFFO09BRUFFO09BS0FDO09BS0FDO09BS0FDO09BaUJBSTtPQUlBQztPQ3BPQUM7T0R5UEFHO09BQ0FDO09BQ0FDO09BMEtBNEM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FqTEF4RDtPQUdBQztPQVJBTjs7T0FnQkFPOztPQXNCQUs7T0FIQUY7T0FNQUc7T0FLQUc7OztPQVVBQzs7OztPQU1BRztPQUNBQzs7T0FnQkFFO09BR0FDO09BUkFGOztPQXlDQWE7T0F6QkFWO09BYUFRO09BS0FDOzs7Ozs7OztPQTBDQVE7OztPQTBEQW9CO09BTUFDO09BcUJBUTtPQVhBSjtPQW5SQTlFO09Ba0pJc0M7T0EwSUoyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1JO2FFbGhCSkcsYUFBVyxRQUFHO2FBRWRDLFNBQU8vRyxTQUFPLFVBQVBBLEVBRlA4RyxNQUU2QjthQUV6QkUsSUFBSXRILEVBQUV1SDtNQUFlLHFCQUFmQTtNQUFlO1FBRUk7U0FBcEJDO1NBQUhsSDtTQUF1QixvQlg5QmxDLE9XNEJTZ0gsSUFBSXRILEVBRUN3SDtRQUFlLHFCQUZoQnhILEVBRUZNO01BREMsUUFDaUM7YUFFcENtSCxXQUFXekgsRUFBRXVIO01YaEN0QixJV2dDc0JHO01BQVM7UUFBTSxxQkFBZkE7UUFBZTtVQUd4QixJQURDRixjQUFIbEgsV0FDRSxtQkFIT04sRUFFVE07VUFDRTtZQUVRLElBQUxDO1lBQWMsVUFBZEEsaUJYckNoQixPV2dDU2tILFdBQVd6SCxFQUVOd0g7VUFDRCxJQUhTRSxNQUVSRjs7UUFERixTQUlvQzthQUV2Q0csT0FBTzNILEVBQUV1SDtNWHZDbEIsSVd1Q2tCRztNQUFTO1FBQU0scUJBQWZBO1FBQWU7Y0FFbkJGLGNBQUhsSDtVQUNELGNBSE1OLEVBRUxNO3NDWHpDWCxPV3VDU3FILE9BQU8zSCxFQUVGd0g7Y0FGSUUsTUFFSkY7O1FBREYsU0FJZ0I7YUFFbkJJLG1CQUFTNUgsRUFBRXVIO01BQWUscUJBQWZBO01BQWU7UUFHZixJQUROQyxjQUFIbEgsV0FDUyxnQkFIRk4sRUFFUE07UUFDUzs7aUJBR2Z1SCx5QkFOYTdILE9BRUp3SDtzQ0FJVEssa0JBTmE3SCxPQUVKd0g7TUFERixRQUVxQjthQUc1QkssdUJBQWE3SCxFQUFFdUgsSUFBSU87TUFBZ0IscUJBQXBCUDtNQUFvQjtZQUUxQkMsY0FBSGxIO1FBQ0csVUFESEEsaUJYdERYLE9Xb0RLeUgsYUFBYS9ILEVBRUp3SCxLQUZVTTtNQUFnQjtNQUM1Qjs7ZUFQSEYscUJBTVM1SCxFQUFNOEg7b0NBTmZGLGNBTVM1SCxFQUFNOEgsV0FHZTthQVQ5QkUsU0FBU2hJLEVBQUV1SDtNWDlDcEIsdUJXOENTSyxhQUFTNUgsRUFBRXVIO2FBTWZRLGFBQWEvSCxFQUFFdUgsSUFBSU87TVhwRHhCLHVCV29ES0QsaUJBQWE3SCxFQUFFdUgsSUFBSU87YUFLbkJHLFVBQ1VqSSxFQUFFa0ksSUFBSVg7VUFBSlksVUFBSVQ7TUFBTTtRQUFNLHFCQUFaQTtRQUFZO1VBR2Q7V0FESEY7V0FBSGxIO1dBQ00saUJBSEpOLEVBQUVtSSxNQUVKN0g7V0FGSTZIO1dBQUlULE1BRUxGOztRQURGLE9BREdXLE1BTUQ7YUFFWGhGLEtBQUtuRCxFQUNLdUg7TVhuRWYsSVdtRWVHO01BQU07UUFBTSxxQkFBWkE7UUFBWTtjQUVYRixjQUFIbEg7VUFDSixXQUpDTixFQUdHTTtjQUZFb0gsTUFFQ0Y7O1FBREYsU0FLSjs7O1NBakRMSixNQUVBQyxTQUVJQyxJQVdBSyxPQVBBRixXQWNBTyxTQVdKQyxVQVNBOUU7O2FDN0NBeEUsSUFBSThDO01BQ04sUUFETUEsMEJBQ21CLGdDQUF3QzthQU8vRDRHLFFBT0F0RjtNQVBVLFNBT1ZBOzs7Ozs7Ozs7O2tCQURRO2tCQUZBO21CQURBO21CQUVBOztNSnVlSjtRSXBlRixJQUFJdUYsSUFBSjs4QkFBSUEsTUFETnZGO1FBQ0UsNEJBQUl1RjtNQUlKLElBQ0luSSxFQURKOzRCQUNJQTtNQURKLHNCQUNJQSxVQU5ONEM7TUFLRSxzQkFDSTVDLFdBTk40QztNQUtFLHNCQUNJNUMsVUFOTjRDO01BS0UsNEJBQ0k1QyxFQUtjO2FBRXBCb0ksVUFBVXhGO01BQ1osbUJBRFlBO01Kd2ROOzRCSXhkTUE7OztNQUlQLE9BSk9BLFVBS047YUFFSnlGLFVBQVV6RjtNQUNaLG1CQURZQTtNSmlkTjs0QklqZE1BOzs7TUFJUCxPQUpPQSxVQUtOO2FBRUowRixnQkFBZ0IxRjtNQUNsQixTQURrQkEsa0NBR2IsT0FIYUEsQ0FHWjthQUVKMkYsZ0JBQWdCM0Y7TUFDbEIsU0FEa0JBLG1DQUdiLE9BSGFBLENBR1o7YUFJSjRGLFFBQVFDLEdBQUdDLElBQUssT0FBUkQsS0FBR0MsTUFBc0I7YUFDakNDLE1BQU9GLEdBQVFDLElBQVMsY0FBakJELEtBQVFDLFdBQTBCOzs7O09BdkR6Q2xLO09BUUEwSjtPQW9CQUU7T0FPQUM7T0FPQUM7T0FLQUM7T0FPQUM7T0FDQUc7OztLWG5EQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7YUFFQUMsS0FBS0M7TUFDUCxPQURPQTtlQUxMSjtlQUtLSSxjQUVTLFlBaEJkL08sYUFjSytPLFNBR0Y7YUFFSEMsS0FBS0Q7TUFDUCxPQURPQSxZQVhMTCxTQVdLSyxRQUVTLFlBdEJkaFAsYUFvQktnUCxTQUdGO2FBRUhFLFNBQVMxTjtNQUFJLGNBQUpBLE1BQUksVUFBSkE7Ozs7O01BSlgsV0FJeUU7YUFDdkUyTixPQUFPM047TUFBTyxnQkFBUEE7O2VRVlBzRTtpQlJkZTt5Q0F3QlJ0RTt1REFBd0Q7YUFJL0Q0TixRQUFRSixHQUFJLE9BQUpBLFdBQVc7YUFDbkJLLFFBQVE1RyxHQUFJLE9BQUpBLENBQWU7YUFDdkI2RyxRQUFRTjtNQUNWLGFBRFVBO2VRaEJSbEo7aUJSYjBCOzs7NkNBNkJsQmtKO2dCQUVPO2FBRWZPLHFCQUhGLFdBQ2lCO2FBSWZDLG1CRHhETDtRQ3lES0M7YUFDQUMsV0QxREw7Ozs7O09DeUJLakI7T0FDQUM7T0FJQUc7T0FDQUM7T0FFQUM7T0FLQUU7T0FLQUM7T0FDQUM7c0JENUNMOztPQ2dES0M7T0FDQUM7T0FDQUM7T0FJQUM7T0FFQUM7T0FDQUM7T0FDQUM7O0lEMURMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09hK0NLQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0liL0NMO2FVc0JLQyxPQUFPakk7Ozs7VUFGQyx1REFBTGtJOztRQURHLFdBR21CO2FBRXpCQyxLQUFLaEgsRUFBRW5CLEdBQUksVUFBTm1CLEVBQUVuQixFQUFRO2FBRWZNO01BQUssVUFFRyxJQUFSYSxXQUFRLE9BQVJBLEVBRE0sdUJBQ0c7YUFFVGQ7TUFBSyxVQUVHLElBQUxMLFdBQUssT0FBTEEsRUFERyx1QkFDRzthQUVUb0ksSUFFY3BJLEVBQUVSO01BRGxCLFFBQ2tCQTtZQUFGNkksTUFBRUM7UUFDaEI7YUFEY0Q7Z0JBR1RFLElBSFNGLE9BR1psSCxFQUhZa0g7cUJBQUVDLFdBR2RuSDtZQUE2QixRQUhmbUgsWUFBRkQsSUFHVEUsSUFIV0Q7O1VBRVI7TUFISSxnQ0FLQTthQUVaRyxRQUVjekksRUFBRVI7TUFEbEIsUUFDa0JBO1lBQUY2SSxNQUFFQztRQUNoQjthQURjRDtnQkFHVEUsSUFIU0YsT0FHWmxILEVBSFlrSDtxQkFBRUMsY0FHZG5IO1lBQWtDLFFBSHBCbUgsWUFBRkQsSUFHVEUsSUFIV0Q7O1VBRVI7TUFISSxrQ0FLQTthQUlSSSxXQUFXckosR0FBR0M7VUFBSHFKLFFBQUdDO01BQ3BCO1dBRGlCRDsyQkFHZnhILEVBSGV3SCxRQUFHRyxRQUdsQjNILEVBSGtCeUgsTUFBSEQsVUFBR0M7O1FBRVosT0FGWUEsS0FHYzthQUVoQ0csSUFBSS9JLEdBQUksa0JBQUpBLElBQW1CO2FBTW5CZ0osU0FBU25QLEVBQUUyRixFQUFFekI7TUFDbkIsR0FEaUJ5QixLQUFGM0Y7TUFHTCxJQUFKMkksRUFBSSxXQUhTekUsRUFBSmxFO01BSVIsVUFERDJJLEVBQ0MsU0FKUTNJLFVBQUUyRixFQUFFekIsR0FJTTtRQUV2QmtMO2tCQU1LeEgsSUFBSTFEO01BQ1gsUUFETzBEO1FBRVAsR0FSRXdILHFCQU1LeEg7Y0FoQmdCd0UsTUFBSXBNO1VBQzNCO2VBZU80SCxPQWhCb0I1SCxTQUZ6QmtQLElBRXFCOUM7WUFFbEIsUUFGc0JwTSxVQUVKLG9CQWNaa0UsRUFoQmdCbEUsR0FBSm9NLGVBQUlwTTs7UUFtQnRCLGtCQUhFNEgsSUFBSTFEO01BQ0ssaUNBRUs7O01BRUwsY0FFWHlFLFdBQUh4QyxXQUFZLGNBQVpBLEVBQVksUUFBVHdDO01BREcsUUFDZTttQkFJYnpFO01WdEZiO1FVd0ZxQixJQUFiaUMsV0FBSG1CLFdBQWdCLGFBRlJwRCxFQUVSb0QsR0FBNEIsVUFBaEJxQixFQUFnQixNQUZwQnpFLEVBRUxpQztNQURHO2lCQUdHbkcsRUFBRWtFO01WMUZoQjtRVTRGcUIsSUFBYmlDLFdBQUhtQixXQUFnQixhQUZMcEQsRUFBRmxFLEVBRVRzSDtRQUE4QixVQUFsQnFCLEVBQWtCLElBRnJCM0ksVUFBRWtFLEVBRVJpQztNQURHO2tCQUdEakMsRUFBRWlDLEdBQUksYUFBTmpDLEVBQUVpQyxFQUFjO3FCQUViakMsRUFBRW1MOzs7O1VBR1E7V0FBYmxKO1dBQUhtQjtXQUFnQixxQkFIVnBELEVBR05vRDs7bUJBQUduQjs7UUFERyxZQUdDO29CQUdBakM7TVZ4R2Q7OztjVTBHUWlDLGFBQUhtQjtVQUFRLFdBRkNwRCxFQUVUb0Q7c0JBQUduQjs7UUFERzttQkFPQWpDLEVBQUVzSzs7OztjQUZMckksV0FBSG1CO1VBQVEsV0FFRnBELElBRk5vRDtVQUFRLDhCQUFMbkI7O1FBREcsU0FHaUI7eUJBRVRqQyxFQUFFaUYsS0FBS2hEO1VBQUxrRCxZQUFLbUY7TUFDdkI7V0FEdUJBO1VBR0Q7V0FBakJFLElBSGtCRjtXQUdyQmxILEVBSHFCa0g7V0FHRCxrQkFITnRLLEVBQUVtRixPQUdoQi9CO1dBSGdCK0I7V0FBS21GLElBR2xCRTs7UUFERyxPQUZVckYsT0FHZ0I7d0JBRWpCbkYsRUFBRWlDLEVBQUVnRDtNQUNyQixHQURtQmhELE9BR2RxSSxJQUhjckksS0FHakJtQixFQUhpQm5CLEtBR0wsa0JBSEdqQyxFQUdmb0QsRUFBWSxXQUhHcEQsRUFHWnNLLElBSGdCckY7TUFFYixPQUZhQSxJQUdjO2tCQUV4QmpGLEVBQUVzQixHQUFHQztNQUNoQixHQURhRDtXQUFHQztVQUdjLElBQWZzSixLQUhDdEosTUFHTDhKLEdBSEs5SixNQUdUcUosS0FITXRKLE1BR1ZnSyxHQUhVaEssTUFHaUIsYUFIbkJ0QixFQUdSc0wsR0FBUUQ7VUFBbUMsVUFBcEI1RyxFQUFvQixLQUhuQ3pFLEVBR0o0SyxLQUFRQzs7WUFIQ3RKO01BSUosaUNBQXVCO3NCQUV4QnZCLEVBQ1VzQixHQUFHQztVQUFSMEQsT0FBSzJGLFFBQUdDO01BQ3RCO1dBRG1CRDthQUFHQztZQUdTO2FBQWhCRSxLQUhPRjthQUdYUSxHQUhXUjthQUdmQyxLQUhZRjthQUdoQlUsR0FIZ0JWO2FBR1kscUJBSnRCNUssRUFJTnNMLEdBQVFELElBSEdwRzs7YUFBSzJGLEtBR1pFO2FBSGVELEtBR1BFOzs7Y0FIT0YsWUFBUjVGO1FBSUYsc0NBRUU7bUJBR0pqRixFQUFFc0IsR0FBR0M7VUFBSHFKLFFBQUdDO01BQ2pCO1dBRGNEO2FBQUdDO2dCQUdGRSxLQUhFRixRQUdOUSxHQUhNUixRQUdWQyxLQUhPRixRQUdYVSxHQUhXVjtZQUdRLFdBSFY1SyxFQUdUc0wsR0FBUUQ7Z0JBSEdULEtBR1BFLEtBSFVELEtBR0ZFOzs7Y0FIRUY7UUFJTCxtQ0FBd0I7d0JBRW5CN0ssRUFBRWlGLEtBQUszRCxHQUFHQztVQUFSNEQsWUFBS3lGLFFBQUdDO01BQzNCO1dBRHdCRDthQUFHQztZQUdRO2FBQXBCRSxLQUhZRjthQUdoQlEsR0FIZ0JSO2FBR3BCQyxLQUhpQkY7YUFHckJVLEdBSHFCVjthQUdXLGtCQUhsQjVLLEVBQUVtRixPQUdoQm1HLEdBQVFEO2FBSFFsRzthQUFLeUYsS0FHakJFO2FBSG9CRCxLQUdaRTs7O2NBSFlGLFlBQVIxRjtRQUlQLHdDQUE2Qjt5QkFFdkJuRixFQUFFc0IsR0FBR0MsR0FBRzBEO01BQzFCLEdBRG9CM0Q7V0FBR0M7Y0FHUnNKLEtBSFF0SixNQUdaOEosR0FIWTlKLE1BR2hCcUosS0FIYXRKLE1BR2pCZ0ssR0FIaUJoSztVQUdVLGtCQUhadEIsRUFHZnNMLEdBQVFELEdBQW1CLFlBSFpyTCxFQUdYNEssS0FBUUMsS0FIVzVGOztZQUFIMUQsVUFBRzBEO01BSWQsd0NBQThCO3FCQUU1QnNHO01WOUpqQjs7O1VVZ0thLElBQUx0SixhQUFIbUIsYUFBUSxnQkFGSW1JLEVBRVpuSTtVQUFRLHFCQUFMbkI7VUFERzs7b0JBR0tzSjtNVmxLaEI7OztVVW9LYSxJQUFMdEosYUFBSG1CLGFBQVEsZ0JBRkdtSSxFQUVYbkk7VUFBUTtzQkFBTG5COztRQURHO3NCQUdPc0osRUFBRWpLLEdBQUdDO1VBQUhxSixRQUFHQztNQUNwQjtXQURpQkQ7YUFBR0M7WUFHRTthQUFQRSxLQUhLRjthQUdUUSxHQUhTUjthQUdiQyxLQUhVRjthQUdkVSxHQUhjVjthQUdLLGdCQUhQVyxFQUdaRCxHQUFRRDtZQUFXLGFBSExULEtBR1ZFLEtBSGFELEtBR0xFOzs7Y0FIS0Y7UUFJUixzQ0FBMkI7cUJBRXpCVSxFQUFFakssR0FBR0M7VUFBSHFKLFFBQUdDO01BQ25CO1dBRGdCRDthQUFHQztZQUdHO2FBQVBFLEtBSElGO2FBR1JRLEdBSFFSO2FBR1pDLEtBSFNGO2FBR2JVLEdBSGFWO2FBR00sZ0JBSFJXLEVBR1hELEdBQVFEO1lBQVc7Z0JBSE5ULEtBR1RFLEtBSFlELEtBR0pFOzs7Y0FISUY7UUFJUCxxQ0FBMEI7aUJBRTVCdks7TVZsTGI7OztVVW9MYSxJQUFMMkIsYUFBSG1CLGFBQVEsd0JBQVJBLEVBRlE5QztVQUVBO3NCQUFMMkI7O1FBREc7a0JBR0czQjtNVnRMZDs7O2NVd0xRMkIsYUFBSG1CLHdCQUZTOUM7O3NCQUVOMkI7O1FBREc7bUJBR0kzQjtNVjFMZjs7O2NVNExZMkIsOEJBQUpOLFdBQUZ5QjtVQUFjLHNCQUFkQSxFQUZTOUMsVUFFUHFCO3NCQUFJTTs7UUFERDt1QkFHUTNCO01WOUxuQjs7O2NVZ01ZMkIsOEJBQUpOLFdBQUZ5QjtVQUFjLHNCQUFkQSxFQUZhOUMsYUFFWHFCO3NCQUFJTTs7UUFERDtrQkFHRzNCO01WbE1kOzs7Y1VvTVkyQiw4QkFBSk4sV0FBRnlCO21CQUZROUMsU0FFTnFCO3NCQUFJTTs7UUFERDtzQkFHTzNCO01WdE1sQjs7O2NVd01ZMkIsOEJBQUpOLFdBQUZ5QjttQkFGWTlDLFlBRVZxQjtzQkFBSU07O1FBREQ7dUJBR1EzQjtNVjFNbkI7OztVVTRNb0I7V0FBTDJCOztXQUFUbUI7V0FBYyx3QkFBZEEsRUFGYTlDO1VBRUM7c0JBQUwyQjs7UUFESjtzQkFHTzNCO01WOU1sQjs7O2NVZ05lMkIsOEJBQVRtQixzQkFGWTlDOztzQkFFSDJCOztRQURKOzBCQUdXM0I7TVZsTnRCO1lVb051QjJCLFdBQWxCdUosY0FBQ3BJLEVBQURvSTtRQUNLLDBCQURKcEksRUFGZ0I5QyxHQUVDMkIsS0FBbEJ1SixLQUN5QyxhQUh4QmxMLEVBRUMyQjtNQURaO3lCQUlVM0I7TVZ2TnJCO1lVeU51QjJCLFdBQWxCdUosY0FBQ3BJLEVBQURvSTtlQUFDcEksTUFGZTlDLEVBRUUyQixLQUFsQnVKLEtBQXFELFlBRnJDbEwsRUFFRTJCO01BRFo7a0JBR0dzSjtNVjNOZDs7O2NVNk5VdEosYUFBTDNCO1VBQWEsY0FGSmlMLEVBRVRqTDtzQkFBSzJCOztRQURDO3NCQUdPc0o7TVYvTmxCOzs7Y1VpT1V0SixhQUFMM0I7VUFBYSxjQUZBaUwsRUFFYmpMO3NCQUFLMkI7O1FBREM7c0JBR0dzSjtNQUNYOzs7OztnQkFFT3RKLFdBQUwzQjtZQUFhLGNBSEppTCxFQUdUakw7Y0FBc0IsY0FBdEJBLDhCQUFLMkI7OztVQURDLG9CQUVEO3VCQUlLc0osRUFBRUo7Ozs7Y0FHUGxKLGFBQUwzQjtVQUFhLGNBSEhpTCxFQUdWakw7WUFBc0IsYUFBdEJBLHlCQUFLMkI7VUFBMkMsWUFBaEQzQixzQkFBSzJCOztRQURXO1FBQVQseUJBRUc7O01BRUU7UUFHSztTQURWQTs7U0FBSjFCO1NBQUZEO1NBQ2dCLGNBRFYyQjtTQUNVOztxQkFEaEIzQixFQUNNb0wsT0FESm5MLEVBQ1FrTDtNQUZMLFVBRW9DO3FCQUU5Qm5LLEdBQUdDO01BQ2pCLEdBRGNEO1dBQUdDO2NBR0ZzSixLQUhFdEosTUFHTjhKLEdBSE05SixNQUdWcUosS0FIT3RKLE1BR1hnSyxHQUhXaEs7VUFHb0IsYUFBL0JnSyxHQUFRRCxJQUF1QixRQUEzQlQsS0FBUUM7O1lBSEV0SjtNQUlMLG9DQUEwQjttQkFJMUJvSyxJQUdWckssR0FESXNLO01BRE4sR0FFRXRLO1dBRElzSztjQUVZQyxHQUZaRCxTQUVNRSxHQUZORixTQUVFRyxHQUROekssTUFDQTBLLEdBREExSztVQUVLLHNCQUxLcUssSUFJVkssR0FBVUY7eUJBR0csTUFQSEgsSUFHVnJLLEdBQ2dCdUs7c0JBQWhCRyxHQUVhLE1BTkhMLElBSUpJLEdBRkZIO1FBQ00sT0FBVnRLO01BRFUsT0FBTnNLLEtBS3dCO2FBR3hCSyxLQUFLQyxFQUFFaks7VUFBRmtLLE1BQUU3QjtNQUNiO2lCQURXNkIsV0FBRTdCO1FBQ1EsR0FEUkEsS0FHRCxRQUhDQSxPQUdELElBSEQ2QixvQkFBRTdCO1FBSUosNkJBQ047dUJBR1dxQixJQUFJMUo7TUFDbEIsU0FrQlFvSyxLQUFLNUssRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2tCQUVGcUssV0FBTkMsR0FGUXRLO2NBR1Asc0JBdEJNMEosSUFxQlBZLEdBQU1ELGFBQU5DLGdCQUFNRDs7a0JBRkE3SzthQUFFUTs7Ozs7b0JBSUl1SyxXQUFOQyxhQUFOQyxLQUpReks7Z0JBS1Asc0JBeEJNMEosSUF1QlBlLEtBQU1EOzZCQU1ILFdBN0JJZCxJQXVCUGUsS0FBWUY7K0JBT0osV0E5QkRiLElBdUJEYyxLQUFNRDtzQ0FBTkMsUUFBTkM7Z0NBQU1ELFFBQU1ELE1BQVpFOzhCQUFNRCxRQUFOQyxRQUFZRjs2QkFFVCxXQXpCSWIsSUF1QkRjLEtBQU1EOytCQUdKLFdBMUJEYixJQXVCUGUsS0FBWUY7c0NBQVpFLFFBQU1EO2dDQUFOQyxRQUFZRixNQUFOQzs4QkFBTkMsUUFBTUQsUUFBTUQ7UUFXZDtZQWZRL0s7U0FlUixHQWZRQSxJQWVKa0w7U0FFSyxVQUZMQSxHQWZNMUs7U0FrQkQsY0FITDBLLEdBZk0xSztTQW1CRCxjQUhMMkssR0FDQS9CO1NBMUJhdko7U0FBR0M7U0FBRzBEO1FBQzFCO2FBRG9CM0Q7ZUFBR0M7a0JBSVRzSyxHQUpTdEssTUFJYnVLLEdBSmF2SyxNQUlqQndLLEdBSmN6SyxNQUlsQjBLLEdBSmtCMUs7Y0FLYixrQkFmS3FLLElBY1ZLLEdBQVFGO2dCQUVELGNBRlBFLEdBSndCL0csTUFBTjNELEdBSWR5SyxHQUpvQjlHO2NBT2pCLGNBSEM2RyxHQUpnQjdHLE1BQUgxRCxHQUlUc0ssR0FKWTVHOztZQUdkLGtCQUhRM0QsR0FBTTJEO1VBRWQsa0JBRlcxRCxHQUFHMEQsTUE2QkQ7TUF0QzNCLFNBdUNJNEgsU0FBU3BMLEVBQUVRO1FBQ2IsU0FEV1I7YUFBRVE7OztrQkFFRnFLLFdBQU5DLEdBRlF0SztjQUdQLHNCQTNDTTBKLElBMENQWSxHQUFNRCxPQUFOQyxNQUFNRCxnQkFBTkM7O2tCQUZNOUs7YUFBRVE7Ozs7O29CQUlJdUssV0FBTkMsYUFBTkMsS0FKUXpLO2dCQUtQLHNCQTdDTTBKLElBNENQZSxLQUFNRDs2QkFFSCxXQTlDSWQsSUE0Q0RjLEtBQU1EOzhCQUFaRSxRQUFNRCxRQUFNRDsrQkFHSixXQS9DRGIsSUE0Q1BlLEtBQVlGO2dDQUFaRSxRQUFZRixNQUFOQztnQ0FBTUQsTUFBWkUsUUFBTUQ7NkJBTUgsV0FsRElkLElBNENQZSxLQUFZRjs4QkFBTkMsUUFBTkMsUUFBWUY7K0JBT0osV0FuRERiLElBNENEYyxLQUFNRDtnQ0FBTkMsUUFBTUQsTUFBWkU7Z0NBQVlGLE1BQU5DLFFBQU5DO1FBV0Y7WUFmUWpMO1NBZVIsR0FmUUEsSUFlSmtMO1NBRUssVUFGTEEsR0FmTTFLO1NBa0JELFVBSEwwSyxHQWZNMUs7U0FtQkQsVUFITDJLLEdBQ0EvQjtTQXhEU3ZKO1NBQUdDO1NBQUcwRDtRQUN0QjthQURnQjNEO2VBQUdDO2tCQUlMc0ssR0FKS3RLLE1BSVR1SyxHQUpTdkssTUFJYndLLEdBSlV6SyxNQUlkMEssR0FKYzFLO2NBS1Qsa0JBTktxSyxJQUtWSyxHQUFRRjtnQkFHRCxjQUhDQSxHQUpZN0csTUFBSDFELEdBSUxzSyxHQUpRNUc7Y0FNYixjQUZQK0csR0FKb0IvRyxNQUFOM0QsR0FJVnlLLEdBSmdCOUc7O1lBR1Ysa0JBSEkzRCxHQUFNMkQ7VUFFVixrQkFGTzFELEdBQUcwRCxNQTJERDtNQUViLElBQU52QixJQUFNLE9BOURRekI7TUE4RFIsWUFBTnlCLElBQ21CLEtBRG5CQSxJQTlEY3pCLElBK0RlO3VCQXlDckIwSixJQUFJMUo7TUFDaEIsU0FzQlFvSyxLQUFLNUssRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2NBR0YsSUFEQXFLLFdBQU5DLEdBRlF0SyxLQUdGLGVBMUJEMEosSUF5QkxZLEdBQU1EO2NBQ0EsYUFBSlE7MEJBREZQOzRCQUNFTyxPQURJUixNQUFOQyxnQkFBTUQ7O2tCQUZBN0s7YUFBRVE7Ozs7O2dCQU9GO2lCQURNdUs7aUJBQU5DO2lCQUFOQyxLQU5Reks7aUJBT0YsZUE5QkQwSixJQTZCTGUsS0FBTUQ7Z0JBQ0EsU0FBSk07a0JBRU0sSUFBSkMsSUFBSSxXQWhDSHJCLElBNkJDYyxLQUFNRDtrQkFHSixhQUFKUTs4QkFIRVA7Z0NBR0ZPLE9BSFFSLE1BQU5DLG9CQUFNRDtnQkFNTCxRQUxMTztrQkFjTSxJQUFKRSxJQUFJLFdBNUNIdEIsSUE2QkxlLEtBQVlGO2tCQWVKLFNBQUpTLGNBZkVSLFFBQU5DO2tCQWlCSyxRQUZETztvQkFHUyxJQUFKQyxJQUFJLFdBL0NSdkIsSUE2QkNjLEtBQU1EO29CQWtCQyxhQUFKVTtnQ0FsQkhULFFBQU5DO2tDQWtCU1E7a0NBbEJHVixNQUFOQyxRQUFOQztrQ0FBTUQsUUFBTUQsTUFBWkU7a0JBaUJtQixVQWpCYkQsUUFBTkMsUUFBWUY7Z0JBQ04sSUFNRlcsSUFBSSxXQXBDSHhCLElBNkJDYyxLQUFNRDtnQkFPSixTQUFKVyxjQVBKVCxRQUFNRDtnQkFTRCxRQUZEVTtrQkFHUyxJQUFKQyxJQUFJLFdBdkNSekIsSUE2QkxlLEtBQVlGO2tCQVVDLGFBQUpZOzhCQVZUVixRQUFNRDtnQ0FVR1c7Z0NBVkdaLE1BQVpFLFFBQU1EO2dDQUFOQyxRQUFZRixNQUFOQztnQkFTYSxVQVRuQkMsUUFBTUQsUUFBTUQ7UUF3QmQ7WUE5QlEvSztTQThCUixHQTlCUUEsSUE4QkprTDtTQUVLLFVBRkxBLEdBOUJNMUs7U0FpQ0QsY0FITDBLLEdBOUJNMUs7U0FrQ0QsY0FITDJLLEdBQ0EvQjtTQTNDYXZKO1NBQUdDO1NBQUcwRDtRQUMxQjthQURvQjNEO2VBQUdDO2NBS1gsSUFERXNLLEdBSlN0SyxNQUlidUssR0FKYXZLLE1BSWpCd0ssR0FKY3pLLE1BSWxCMEssR0FKa0IxSyxNQUtSLGFBakJGcUssSUFnQlJLLEdBQVFGO2NBQ0UsU0FBSi9JO2dCQUNVLGNBRmhCaUosR0FKd0IvRyxNQUFOM0QsR0FJZHlLLEdBSmlCeEssR0FJVHNLLEdBSlk1RztjQU9qQixPQUZEbEMsR0FHQyxjQUpQaUosR0FKd0IvRyxNQUFOM0QsR0FJZHlLLEdBSm9COUc7Y0FLZCxJQUlILFVBTEM2RyxHQUpnQjdHLE1BQUgxRCxHQUlUc0ssR0FKWTVHOztZQUdkLGtCQUhRM0QsR0FBTTJEO1VBRWQsa0JBRlcxRCxHQUFHMEQsTUE4Q0Q7TUF6RDNCLFNBMERJNEgsU0FBU3BMLEVBQUVRO1FBQ2IsU0FEV1I7YUFBRVE7OztjQUdGLElBREFxSyxXQUFOQyxHQUZRdEssS0FHRixlQTlERDBKLElBNkRMWSxHQUFNRDtjQUNBLGFBQUpROzBCQURGUDsyQkFDRU8sT0FERlAsTUFBTUQsZ0JBQU5DOztrQkFGTTlLO2FBQUVROzs7OztnQkFPRjtpQkFETXVLO2lCQUFOQztpQkFBTkMsS0FOUXpLO2lCQU9GLGVBbEVEMEosSUFpRUxlLEtBQU1EO2dCQUNBLFNBQUpNO2tCQUVNLElBQUpDLElBQUksV0FwRUhyQixJQWlFQ2MsS0FBTUQ7a0JBR0osYUFBSlE7OEJBSEVQOytCQUdGTyxPQUhFUCxRQUFNRCxnQkFBTkM7Z0JBTUMsT0FMTE07a0JBTU0sSUFBSkUsSUFBSSxXQXhFSHRCLElBaUVDYyxLQUFNRDtrQkFPSixTQUFKUyxjQVBKUCxRQUFNRDtrQkFTRCxPQUZEUSxjQVBKUCxRQUFNRCxRQUFNRDtrQkFPSixJQUdDVSxJQUFJLFdBM0VSdkIsSUFpRUxlLEtBQVlGO2tCQVVDLGFBQUpVOzhCQVZUUixRQUFNRDsrQkFVR1M7Z0NBVlRSLFFBQVlGLE1BQU5DO2dDQUFNRCxNQUFaRSxRQUFNRDtnQkFDQSxJQWNGVSxJQUFJLFdBaEZIeEIsSUFpRUxlLEtBQVlGO2dCQWVKLFNBQUpXLGNBZkVWLFFBQU5DO2dCQWlCSyxPQUZEUyxjQWZFVixRQUFOQyxRQUFZRjtnQkFDTixJQWlCR1ksSUFBSSxXQW5GUnpCLElBaUVDYyxLQUFNRDtnQkFrQkMsYUFBSlk7NEJBbEJIWCxRQUFOQzs2QkFrQlNVOzhCQWxCSFgsUUFBTUQsTUFBWkU7OEJBQVlGLE1BQU5DLFFBQU5DO1FBd0JGO1lBOUJRakw7U0E4QlIsR0E5QlFBLElBOEJKa0w7U0FFSyxVQUZMQSxHQTlCTTFLO1NBaUNELFVBSEwwSyxHQTlCTTFLO1NBa0NELFVBSEwySyxHQUNBL0I7U0ExRlN2SjtTQUFHQztTQUFHMEQ7UUFDdEI7YUFEZ0IzRDtlQUFHQztjQUtQLElBREVzSyxHQUpLdEssTUFJVHVLLEdBSlN2SyxNQUlid0ssR0FKVXpLLE1BSWQwSyxHQUpjMUssTUFLSixhQU5GcUssSUFLUkssR0FBUUY7Y0FDRSxTQUFKL0k7Z0JBQ1UsY0FGaEJpSixHQUpvQi9HLE1BQU4zRCxHQUlWeUssR0FKYXhLLEdBSUxzSyxHQUpRNUc7Y0FPYixRQUZEbEMsR0FJQyxjQUxDK0ksR0FKWTdHLE1BQUgxRCxHQUlMc0ssR0FKUTVHO2NBS1YsSUFHSCxVQUpQK0csR0FKb0IvRyxNQUFOM0QsR0FJVnlLLEdBSmdCOUc7O1lBR1Ysa0JBSEkzRCxHQUFNMkQ7VUFFVixrQkFGTzFELEdBQUcwRCxNQTZGRDtNQUViLElBQU52QixJQUFNLE9BaEdNekI7TUFnR04sWUFBTnlCLElBQ21CLEtBRG5CQSxJQWhHWXpCLElBaUdpQjs2QkFFWFgsR0FBR0M7VUFBSHFKLFFBQUdDO01BQ3pCO1dBRHNCRDthQUFHQyx1QkFBSEMsdUJBQUdEO1VBSWQ7UUFEQSxPQUhjQSxVQUtrQjtpQ0FHakI1SSxFQUFFUjtVQUFGNkksTUFBRUM7TUFDNUI7V0FEMEJEO1VBTXhCLElBREtFLElBTG1CRjtVQU14QixPQU4wQkMsS0FPeEIsUUFQd0JBLFlBQUZELElBS25CRSxJQUxxQkQ7VUFNWDtRQUhmLGFBSDBCQSxtQkFPRztvQkFLdEJ0STtNQUNULFNBQVFxTCxJQUFJckw7UUFBTyxHQUFQQTtjQUVINkYsS0FGRzdGLEtBRVIzQixFQUZRMkI7VUFFa0IsVUFBMUIzQixpQlZsZlAsT1VnZldnTixJQUVDeEY7UUFEQyxRQUM2QjtNQUZ2QyxzQlZoZkgsT1VnZld3RixJQURDckwsUUFLSjtvQkFFSXNGO01BQ1QsU0FBUWdHLE9BQU9DLE1BQU1qRztRQUNuQixTQURhaUc7VUFHWDt3Q0FBbUJ0RixJQUFJNUgsR0FBSyxVQUFMQSxFQUFKNEgsSUFBZSxPQUhqQlg7UUFLUixxQkFMUUE7UUFLUjtjQUVNQyxjQUFIbEg7VUFBaUIsVUFBakJBLEVBQWlCLE9BUGxCa04sY0FPSWhHO1FBREYsUUFDcUM7TUFQdEQsa0JBRFNELElBVUs7Ozs7T0ExZVoyQzs7O09BRUFFO09BRUE3SDtPQUlBRDtPQUlBK0g7T0FRQUs7T0FlQU07O09BUEEzSTtPQUVJc0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCSVhDbEosRUFBRXNCO01BQ1QsSUFBSTVDLEVBQUosa0JBRE9zQixHQUVQLGdCQURJdEIsSUFER3NCLEVBQUVzQixHQUVULE9BREk1QyxDQUVIO29CQUVNc0IsRUFBRXpCO01BQ1Qsd0JBRE95QixHQUNQLEtBRE9BLFVBQ1A7O1lBQ0EzRjtRQUNFO1VBQWUsc0JBRmJxRSxFQUNKckUsRUFDaUIsV0FIUmtFLEVBRVRsRTtVQUNpQixTQURqQkE7OztNQUdBLE9BSklxRSxDQUlIO0lBRVM7a0JBRUhBO01BQ1AsNkJBRE9BLEdBQ1Asb0JBQUl1RDtNQUVKLGdCQUhPdkQsSUFFSHNFLElBREFmO01BRUosT0FESWUsQ0FFSDtJQU5TLG1CQVFFOUMsR0FBcUIsaUNBQXJCQSxHQUE2QjtJQVIvQixtQkFTRXhCLEdBQUksaUNBQUpBLEdBQTZCO0lBVC9CLGFBV0pBLEVBQUVzRCxJQUFJQztNQUNaLFFBRFFEO2VBQUlDO29DQUFOdkQsS0FBTXVELFdBQUpEO1VBR0gsSUFDQ2dCLEVBREQsa0JBSE9mO1VBS1YsZ0JBTEl2RCxFQUFFc0QsSUFJRmdCLElBSk1mO1VBS1YsT0FESWU7TUFGRCw0Q0FLRjtJQWxCTyxvQkFvQkc5QyxFQUFFOEIsSUFBSUM7TUFBdUIsZ0NBQTdCL0IsRUFBRThCLElBQUlDLEtBQXNDO0lBcEIvQyxTQXVCUitKLElBQUtySyxFQUFFekI7TUFDVDtTQURPeUIsSUFBRXpCO09BQ1QsS0FEU0E7T0FDVCxNQUFJb0I7T0FBSjtlQURPSzs7O01ONmJELGdCTXpibUIsOEJBSHJCTCxDQUlJO0lBNUJFLGdCQThCRDVDLEVBQUV1TixLQUFLQztNQUNOO21CQUFWLHFCQURTeE4sR0FBRXVOLE1BQUtDO09BQ04sb0JBQU5qSztNQUFNLFFBRENnSztXQUdORSxTQUFRQyxPQUhGSDs7V0FHTkUsU0FITUYsU0FHRUc7TUFGSCxJQUdOQyxPQUFTLElBQWIscUJBSlMzTixLQUdKeU4sV0FGRGxLLE1BRVNtSztNQUNBLE9BQVRDLE9BQ2UsZ0JBTFYzTixFQUdKeU4sT0FERG5KLEVBQ1NvSixPQUNUQztNQUNtRCxPQUhuRHJKLENBSUg7SUFwQ1MsY0FzQ0h0RSxFQUFFc0QsSUFBSUMsSUFBSVg7TUFDakIsUUFEU1U7ZUFBSUM7b0NBQU52RCxLQUFNdUQsV0FBSkQ7Z0JBR0osZ0JBSEV0RCxFQUFFc0QsSUFBSUMsSUFBSVg7TUFFWiw4Q0FDdUI7SUF6Q2xCLGNBMkNIM0IsR0FBRzJNLEtBQUsxTSxHQUFHMk0sS0FBS3RLO01BQ3ZCLFFBRHVCQTtlQUFicUs7b0NBQUgzTSxNQUFnQnNDLFdBQWJxSztpQkFBUUM7c0NBQUgzTSxNQUFRcUMsV0FBTHNLO2tCQUliLGdCQUpFNU0sR0FBRzJNLEtBQUsxTSxHQUFHMk0sS0FBS3RLO01BR2xCLGtDQUMrQjtJQS9DMUIsZ0JBaURJdEMsR0FBRzJNLEtBQUsxTSxHQUFHMk0sS0FBS3RLO01BQzlCLFFBRDhCQTtlQUFicUs7cUNBQUgzTSxNQUFnQnNDLFdBQWJxSztpQkFBUUM7c0NBQUgzTSxNQUFRcUMsV0FBTHNLO2tCQUlwQixpQkFKUzVNLEdBQUcyTSxLQUFLMU0sR0FBRzJNLEtBQUt0SztNQUd6QixxREFDc0M7SUFyRGpDLGdCQXdESDFELEVBQUVvRDtNQUNULDhCQURTQSxXQUNUOzs7UUFBNkI7cUJBRHRCcEQsRUFDc0Isc0JBRHBCb0QsRUFDVHRIO1VBQTZCLFNBQTdCQTs7O2NBQW1EO0lBekR6QyxpQkE0REZrRSxFQUFFb0Q7TUFDViw4QkFEVUEsV0FDVjs7O1FBQTZCO3FCQURyQnBELEVBQ1JsRSxFQUE2QixzQkFEbkJzSCxFQUNWdEg7VUFBNkIsU0FBN0JBOzs7Y0FBc0Q7SUE3RDVDLGdCQStFRG1TLElBRVBoTTtNZHRJTCxHY3NJS0E7UUFBSyxnQ0FGRWdNLGlCQUVQaE0sRUFBSzs7Ozs7Y0FiTzsrQ0FFaUJpTTtlQVBQLGFBQVg1TixJQUFpQzs7OztxQkFJaEM7OztVQWdCNEIsa0RBRnhDMkI7Ozs7O2dCQU5BLHVCQUxpQmtNLFFBS2pCO2dCQUNBO2tCQUdPRixNQVRVRSxVQUtqQiwrQkFMNkJEO2dCQU03QjtnRUFONkJBOzs7O2NBRzdCLHVCQUhpQkMsUUFHakI7cUJBSGlCQTtZQUNYLE9BRFdBO01BVVg7SUFoRkUsYUFzRkovTSxHQUFHQztNQUNUOytCQURNRDtPQUNOLHdCQURTQztPQUNULG9CQUFJQyxLQUNBQztNQUVKLGdCQUpNSCxLQUdGcUQsSUFGQW5EO01BSUosZ0JBTFNELEtBR0xvRCxFQUZBbkQsR0FDQUM7TUFHSixPQUZJa0QsQ0FHSDtJQTVGUyxTQWtHUjJKO01BQVc7OztNTmtYUCxtQk1oWE07SUFwR0YsY0FzR0hqTztNQUNQLDZCQURPQSxHQUNQOztXQUNJckUsT0FEQTRIO1lBRWMsK0JBSFh2RCxFQUVIckUsUUFFRjtRQUVGLElBQUl1UyxLQUxBM0s7O2FBQ0E1SCxRQUlBdVM7Y0FDYywrQkFQWGxPLEVBTUhrTyxRQUVGO1VBRUYsT0FSSXZTLFFBSUF1UyxLQUtGLElBWEtsTyxFQUVIckUsTUFJQXVTLE9BSkF2Uyw0QkFXRztJQW5IRyxtQkFxSEFxRTtNQUNWLHNDQURVQSxXQUNWOztZQUNBK0I7UUFDRTswQ0FIUS9CLEVBRVYrQjtVQUNFOzs7Ozs7Ozs7Ozs7VU40Vkk7VU05VkZUO1VBRUYsU0FERlM7OztNQU9BLEdBUklULFNBUUoscUJBVFV0QixVQVNZLEtBVFpBO01BQ1YsSUFTTW1JLElBRDRCLGtCQVI5QjdHO01BUThCO01BUmxDLElBUWtDLDBCQVR4QnRCLFdBU3dCOztZQUdoQ3JFO1FBQ0U7Y0FXRWlILEVBWEYsc0JBYk01QyxFQVlSckU7VUFDRSxTQVdFaUg7Ozs7Ozs7Ozs7O2dCQURFLHNCQWJGdUYsSUFURjdHO2dCQXNCSTtzQ0FiRjZHLElBVEY3Rzs7OztnQkFrQkksc0JBVEY2RyxJQVRGN0c7Z0JBa0JJO3NDQVRGNkcsSUFURjdHOzs7O2dCQWdCSSxzQkFQRjZHLElBVEY3RztnQkFnQkk7c0NBUEY2RyxJQVRGN0c7Ozs7Z0JBb0JJLHNCQVhGNkcsSUFURjdHO2dCQW9CSTtzQ0FYRjZHLElBVEY3Rzs7Ozs7O2FBeUJJLHNCQWhCRjZHLElBVEY3RzthQXlCSTttQ0FoQkY2RyxJQVRGN0csV0F1QkVzQjthQUVFO21DQWhCRnVGLElBVEY3RyxZQXVCRXNCO2FBRUU7bUNBaEJGdUYsSUFURjdHLFdBdUJFc0I7OzthQVRFLHNCQUxGdUYsSUFURjdHO2FBY0k7bUNBTEY2RyxJQVRGN0csS0F1QkVzQjs7bUJBQXFCLHNCQWRyQnVGLElBVEY3RyxLQXVCRXNCOztVQVdGO1VBdEJBLFNBREZqSDs7O01BeUJBLE9BM0JJd00sR0E0Qkg7SUEzSk8sZUE2Skp0SSxFQUFFRztNQUNSLElBQUk4QixFQUFKLHFCQURROUI7TUFDUixTQUFJOEIsU0FESTlCO01BQ1IsSUFDcUIsb0JBRGpCOEIsR0FDaUIsS0FEakJBLFVBQ2lCOztZQUVuQm5HO1FBQXNCO1VBQWUsc0JBRGpDMkksRUFDSjNJLEVBQXFDLFdBSmpDa0UsRUFJa0Isc0JBSmhCRyxFQUlOckU7VUFBcUMsU0FBckNBOzs7TUFDQSxPQUZJMkksQ0FHSDtJQW5LTyxnQkFxS0h6RSxFQUFFRztNQUNULElBQUk4QixFQUFKLHFCQURTOUI7TUFDVCxTQUFJOEIsU0FESzlCO01BQ1QsSUFDcUIsb0JBRGpCOEIsR0FDaUIsS0FEakJBLFVBQ2lCOztZQUVuQm5HO1FBQXNCO1VBQWU7WUFEakMySSxFQUNKM0ksRUFBcUMsV0FKaENrRSxFQUlMbEUsRUFBc0Isc0JBSmZxRSxFQUlQckU7VUFBcUMsU0FBckNBOzs7TUFDQSxPQUZJMkksQ0FHSDtJQTNLTywyQkE2S1F0RSxHQUFJLGFGOUpwQnVJLGdCRThKZ0J2SSxFQUE4QjtJQTdLdEMsMkJBOEtRQSxHQUFJLGFGcEtwQnNJLGdCRW9LZ0J0SSxFQUE4QjtJQTlLdEMsU0FnTFJtTyxPQUFPdE8sRUFBRUc7TUFDWCw4QkFEV0E7TUFFRCxJQUFKc0UsRUFBSSxLQUZDdEU7TUFHTSxzQkFEWHNFLElBQ1csV0FIUnpFLEVBRUMsc0JBRkNHO01BR00sT0FEWHNFLENBR0g7SUFyTE8sMEJBdUxTdEUsR0FBSSxjRnhLckJ1SSxnQkV3S2lCdkksRUFBaUM7SUF2TDFDLDRCQXdMV0EsR0FBSSxjRjlLdkJzSSxnQkU4S21CdEksRUFBaUM7SUF4TDVDLFNBMkxKb08sVUFBVXBPLEVBQUVxTyxJQUFJMVMsRUFBRWlIO01kaFAzQixJY2dQeUJiO01BQ3RCO1dBRGtCc00sT0FBSXRNO1FBRXRCLHlCQUZnQi9CLEVBQU0rQixTQUFFYSxTQUFGYjtRQUVZLFFBRlpBO2lCQUVxQztJQTdMakQsZUFnTUYvQixFQUFFNEMsR0FBSSxpQkFBTjVDLEVBQU0scUJBQU5BLEtBQUU0QyxFQUE4QjtJQWhNOUIsU0FtTUoyTCxjQUFjdk8sRUFBRXFPLElBQUkxUyxFQUFFaUg7TWR4UC9CLEljd1A2QmI7TUFDMUI7V0FEc0JzTSxPQUFJdE07UUFFMUIseUJBRm9CL0IsRUFBTStCLFNBQUVhLFlBQUZiO1FBRWEsUUFGYkE7aUJBRTBDO0lBck0xRCxtQkF3TUUvQixFQUFFNEM7TUFBSSxxQkFBTjVDLEVBQU0scUJBQU5BLEtBQUU0QyxFQUFrQztJQXhNdEMsb0JBMk1HNUMsRUFBRXJFLEVBQUVpSDtNQUNqQixJQUFJZCxFQUFKLHFCQURhOUI7TUFDYixRQURlckUsUUFDWG1HLElBRFduRyxVQUdmLFVBSGFxRSxFQUNUOEIsRUFEV25HLEVBQUVpSDtNQUVNLDBEQUNOO0lBOU1QLHdCQWlOTzVDLEVBQUVyRSxFQUFFaUg7TUFDckIsSUFBSWQsRUFBSixxQkFEaUI5QjtNQUNqQixRQURtQnJFLFFBQ2ZtRyxJQURlbkcsVUFHbkIsY0FIaUJxRSxFQUNiOEIsRUFEZW5HLEVBQUVpSDtNQUVFLGtFQUNGO0lBcE5YLFNBdU5KNEwsV0FBV3hPLEVBQUVyRSxFQUFFaUg7TWQ1UXhCLEljNFFzQmI7TUFDbkI7Z0JBRG1CQTtVQUVuQix5QkFGaUIvQixFQUFFK0IsU0FBRWEsU0FBRmI7VUFFZSxRQUZmQTs7UUFDTCxnQkFDMEM7SUF6TjlDLGdCQTRORC9CLEVBQUU0QztNQUFJLGtCQUFONUMsRUFBTSxxQkFBTkEsV0FBRTRDLEVBQWlDO0lBNU5sQyxxQkErTkk1QyxFQUFFckUsRUFBRWlIO01BQ2xCLFNBRGdCakgsNkJBQUZxRSxNQUFFckUsVUFJZCxXQUpZcUUsRUFBRXJFLEVBQUVpSDtNQUVoQiw0REFFZ0I7SUFuT1IsU0FzT0o2TCxlQUFlek8sRUFBRXJFLEVBQUVpSDtNZDNSNUIsSWMyUjBCYjtNQUN2QjtnQkFEdUJBO1VBRXZCLHlCQUZxQi9CLEVBQUUrQixTQUFFYSxZQUFGYjtVQUVnQixRQUZoQkE7O1FBQ1QsU0FDbUQ7SUF4T3ZELG9CQTJPRy9CLEVBQUU0QztNQUFJLHNCQUFONUMsRUFBTSxxQkFBTkEsV0FBRTRDLEVBQXFDO0lBM08xQyx5QkE4T1E1QyxFQUFFckUsRUFBRWlIO01BQ3RCLFNBRG9Cakg7a0NBQUZxRSxNQUFFckUsVUFJbEIsZUFKZ0JxRSxFQUFFckUsRUFBRWlIO01BRXBCLG9FQUVvQjtJQWxQWix1QkFzUE01QyxFQUFFckUsRUFBRWlIO01BQ3BCLElBQUlkLEVBQUoscUJBRGdCOUI7TUFDaEIsUUFEa0JyRTthQUNkbUcsSUFEY25HOztVQUtMLFVBTEdxRSxFQUNaOEIsRUFEY25HLEVBQUVpSCxHQUtQOzs7OztNQUZYLGdFQUU0RDtJQTNQcEQsa0JBK1BDNUMsRUFBRTRDLEdBQUkscUJBQU41QyxJQUFFNEMsRUFBdUI7SUEvUDFCLHdCQWtRTzVDLEVBQUVyRSxFQUFFaUg7TUFDckIsUUFEbUJqSDtrQ0FBRnFFLE1BQUVyRTs7VUFJTixXQUpJcUUsRUFBRXJFLEVBQUVpSCxHQUlSOzs7OztNQUZYLGtFQUUyRDtJQXRRbkQ7eUJBZ1JFNUMsR0FBSSxhRjdRZHFJLFVFNlFVckksRUFBd0I7SUFoUjFCLHFCQWlSRUEsR0FBSSxhRnJSZG9JLFVFcVJVcEksRUFBd0I7SUFqUjFCLG9CQW1SR0EsR0FBSSxjRmhSZnFJLFVFZ1JXckksRUFBMkI7SUFuUjlCLHNCQW9SS0EsR0FBSSxjRnhSakJvSSxVRXdSYXBJLEVBQTJCO0lBcFJoQyxrQkF3UkRBO01BQ1QsU0FBUW1OLElBQUl4UjtRQUNWLEdBRFVBLE1BQ1YscUJBRk9xRTtRQUlMLHFCQUpLQSxFQUNHckUsR0FHUixLQUhRQTtRQUlLLFVBRFR3RSxpQmRqVlgsT2M4VVdnTixnQkFJbUI7TUFKM0I7NEJkOVVILE9jOFVXQSxlQU1IO0lBL1JLLGlCQWlTQW5OO01BQ1YsU0FBUW1OLElBQUl4UjtRQUNWLEdBRFVBLE1BQ1YscUJBRlFxRTtRQUlOLHFCQUpNQSxFQUNFckUsR0FHUixLQUhRQTtRQUlTLGFBSlRBLEVBR0p3RSxrQmQxVlgsT2N1VldnTixnQkFJdUI7TUFKL0I7NEJkdlZILE9jdVZXQSxlQU1IO0lBeFNLLGtCQTBTRHhSO01BQ1QsWUFDYztNQVNkO2lCQUNPaUg7VUFDRixHQVpEdEIsU0FZQyxxQkFYRHVEO1lBR1k7YUFBVjZKO2NBQVUsUUFBZCxxQkFIRTdKO1lBR1ksd0JBSFpBLFlBR0U2SjthQUMwQjtZQURoQixJQUVWQyxRQUFVLEtBRlZEO1lBR0osS0FORTdKLFNBS0U4SixVQU5Gck47WUFPRixTQURJcU47VUFPRCxlQVpEOUosT0FEQXZELEtBV0dzQjtVQUVGO2tCQUNNO1FBZkZqSDtNQVdULFdBVElrSixTQURBdkQsS0FnQlM7SUEzVEg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQ2JIQSxFQUFFc0IsR0FDVCxpQ0FET3RCLEVBQUVzQixHQUNRO29CQUNWdEIsRUFBRXpCLEdBQ1QsbUNBRE95QixFQUFFekIsR0FDUTtvQkFDVkc7TUFDUCxpQ0FBTyxxQkFEQUEsSUFDYzttQkFDZkEsRUFBRXNELElBQUlDO01BQ1osZ0NBQU0scUJBREF2RCxHQUFFc0QsSUFBSUMsS0FDZ0I7c0JBc0JuQnVLLElBRVBoTTtNZnZFTCxHZXVFS0E7UUFBSyxpQ0FGRWdNLGlCQUVQaE0sRUFBSzs7Ozs7Y0FiTztnREFFaUJpTTtlQVBQLGFBQVg1TixJQUFpQzs7OztxQkFJaEM7OztVQWdCOEIsa0RBRjFDMkI7Ozs7O2dCQU5BLHdCQUxpQmtNLFFBS2pCO2dCQUNBO2tCQUdPRixNQVRVRSxVQUtqQixnQ0FMNkJEO2dCQU03QjtpRUFONkJBOzs7O2NBRzdCLHdCQUhpQkMsUUFHakI7d0NBSGlCQTtNQVVYO29CQU9Ebk8sRUFBRUc7TUFDVCwrQkFEU0EsV0FDVDs7O1FBQTZCO3FCQUR0QkgsRUFDc0IsdUJBRHBCRyxFQUNUckU7VUFBNkIsU0FBN0JBOzs7Y0FBb0Q7cUJBRzVDa0UsRUFBRUc7TUFDViwrQkFEVUEsV0FDVjs7O1FBQTZCO3FCQURyQkgsRUFDUmxFLEVBQTZCLHVCQURuQnFFLEVBQ1ZyRTtVQUE2QixTQUE3QkE7OztjQUFzRDttQkFFaERrRSxFQUFFRztNQUNSLGtDQURNSCxFQUNFLHFCQURBRyxJQUNjO29CQUNmSCxFQUFFRztNQUNULG1DQURPSCxFQUNFLHFCQURBRyxJQUNjO2FBTXJCNE87TUFBVzs7O01QNGFQLG1CTzFhTTtvQkFFTDVPO01BQ0oscUJBRElBO01BRUMsZ0JBQUgsdUJBRkVBOzs7U0FFOEI7a0NBRjlCQTs7TUFHSSxpQ0FBUSxxQkFIWkEsSUFJRDt1QkFHbUJBO01BQXpCLDRCQUF5QkEsR0FBSXJFO01BQzNCO1dBRHlCMkYsS0FBRTNGLFNBQUpxRTtRQUVyQjtzQ0FGcUJBLEVBQUlyRTtTQUV6Qjs7O1FQK1pFO2dCTzlac0QsK0JBQVcscUJBSDlDcUU7UUFFckIsSUFFTyxJQUprQnJFO2lCQU1FO2FBR3pCa1QsWUFBVTdPLEVBQUVxTyxJQUFJMVMsRUFBRWlIO01makgzQixJZWlIeUJiO01BQ3RCO1dBRGtCc00sT0FBSXRNO1FBRXRCLDBCQUZnQi9CLEVBQU0rQixTQUFFYSxTQUFGYjtRQUVZLFFBRlpBO2lCQUVxQztxQkFHbkQvQixFQUFFNEMsR0FBSSxtQkFBTjVDLEVBQU0sc0JBQU5BLEtBQUU0QyxFQUE4QjthQUdsQ2tNLGdCQUFjOU8sRUFBRXFPLElBQUkxUyxFQUFFaUg7TWZ6SC9CLElleUg2QmI7TUFDMUI7V0FEc0JzTSxPQUFJdE07UUFFMUIsMEJBRm9CL0IsRUFBTStCLFNBQUVhLFlBQUZiO1FBRWEsUUFGYkE7aUJBRTBDO3lCQUd4RC9CLEVBQUU0QztNQUFJLHVCQUFONUMsRUFBTSxzQkFBTkEsS0FBRTRDLEVBQWtDOzBCQUduQzVDLEVBQUVyRSxFQUFFaUg7TUFDakIsSUFBSWQsRUFBSixzQkFEYTlCO01BQ2IsUUFEZXJFLFFBQ1htRyxJQURXbkcsVUFHYixZQUhXcUUsRUFDVDhCLEVBRFduRyxFQUFFaUg7TUFFTSw0REFDSjs4QkFHRjVDLEVBQUVyRSxFQUFFaUg7TUFDckIsSUFBSWQsRUFBSixzQkFEaUI5QjtNQUNqQixRQURtQnJFLFFBQ2ZtRyxJQURlbkcsVUFHbkIsZ0JBSGlCcUUsRUFDYjhCLEVBRGVuRyxFQUFFaUg7TUFFRSxvRUFDRjthQUdmbU0sYUFBVy9PLEVBQUVyRSxFQUFFaUg7TWY3SXhCLEllNklzQmI7TUFDbkI7Z0JBRG1CQTtVQUVuQiwwQkFGaUIvQixFQUFFK0IsU0FBRWEsU0FBRmI7VUFFZSxRQUZmQTs7UUFDTCxnQkFDMEM7c0JBRy9DL0IsRUFBRTRDO01BQUksb0JBQU41QyxFQUFNLHNCQUFOQSxXQUFFNEMsRUFBaUM7MkJBRzlCNUMsRUFBRXJFLEVBQUVpSDtNQUNsQixTQURnQmpIO21DQUFGcUUsTUFBRXJFLFVBSWQsYUFKWXFFLEVBQUVyRSxFQUFFaUg7TUFFaEIsOERBRWdCO2FBR1pvTSxpQkFBZWhQLEVBQUVyRSxFQUFFaUg7TWY1SjVCLEllNEowQmI7TUFDdkI7Z0JBRHVCQTtVQUV2QiwwQkFGcUIvQixFQUFFK0IsU0FBRWEsWUFBRmI7VUFFZ0IsUUFGaEJBOztRQUNULFNBQ21EOzBCQUdwRC9CLEVBQUU0QztNQUFJLHdCQUFONUMsRUFBTSxzQkFBTkEsV0FBRTRDLEVBQXFDOytCQUdsQzVDLEVBQUVyRSxFQUFFaUg7TUFDdEIsU0FEb0JqSDttQ0FBRnFFLE1BQUVyRSxVQUlsQixpQkFKZ0JxRSxFQUFFckUsRUFBRWlIO01BRXBCLHNFQUVvQjs2QkFHTjVDLEVBQUVyRSxFQUFFaUg7TUFDcEIsSUFBSWQsRUFBSixzQkFEZ0I5QjtNQUNoQixRQURrQnJFO2FBQ2RtRyxJQURjbkc7O1VBS0wsWUFMR3FFLEVBQ1o4QixFQURjbkcsRUFBRWlILEdBS1A7Ozs7O01BRlgsa0VBRTREO3dCQUduRDVDLEVBQUU0QyxHQUFJLHVCQUFONUMsSUFBRTRDLEVBQXVCOzhCQUduQjVDLEVBQUVyRSxFQUFFaUg7TUFDckIsUUFEbUJqSDttQ0FBRnFFLE1BQUVyRTs7VUFJTixhQUpJcUUsRUFBRXJFLEVBQUVpSCxHQUlSOzs7OztNQUZYLG9FQUUyRDsrQkFFM0M1QztNQUNsQiw4Q0FBa0IscUJBREFBLElBQ2M7K0JBQ2RBO01BQ2xCLDhDQUFrQixxQkFEQUEsSUFDYztnQ0FDYkE7TUFDbkIsNkNBQW1CLHFCQURBQSxJQUNjO2tDQUNaQTtNQUNyQiwrQ0FBcUIscUJBREFBLElBQ2M7OzJCQU9uQjhOLElBQUk5TjtNQUNwQjs7a0NBRG9CQTtPQUNwQiwyQkFEb0JBO01BQ3BCO1lBRUFyRTtRQUNFO29DQUprQnFFLEVBR3BCckUsT0FIZ0JtUztZQUllLFNBSDNCeEo7WUFJSyxnQkFMV3RFLEVBR3BCckUsV0FESXVTLE9BQ0p2UztZQUVTLE9BRlRBOzs7O01BRkEsU0FBSTJJO01BUUosZ0JBVG9CdEUsSUFFaEJrTyxXQU9ZO3lCQUlKbE87TUFDWix3Q0FBWSxxQkFEQUEsSUFDYzt5QkFDZEE7TUFDWix3Q0FBWSxxQkFEQUEsSUFDYzswQkFDYkE7TUFDYix1Q0FBYSxxQkFEQUEsSUFDYzs0QkFDWkE7TUFDZix5Q0FBZSxxQkFEQUEsSUFDYztzQkFJcEJBLEdBQUkscUNBQUpBLEdBQXFCO3VCQUVwQkEsR0FBSSxvQ0FBSkEsR0FBc0I7c0JBRXZCNEcsR0FBSSxxQ0FBSkEsR0FBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FDbE54QnFJLFFBQU1DLE1BQU0vTixHQUFHQztNQUNyQixHQURrQkQ7WUFHVnlLLEdBSFV6SyxNQUdoQjBLLEdBSGdCMUs7V0FBR0M7Y0FNVHNLLEdBTlN0SyxNQU1mdUssR0FOZXZLO1VBT1Ysa0JBUEM4TixNQUdWckQsR0FHSUY7c0JBSEpFLEdBS2lCLFFBUlBxRCxNQUdKdEQsR0FIYXhLO3NCQU1mdUssR0FHYSxRQVRQdUQsTUFBTS9OLEdBTU51SztRQURBLE9BTE12SztNQUVWLE9BRmFDLEVBU2U7YUFFbEMrTixLQUFLRCxNQUFNcE47TUFDYixTQUFRc047UUFBVzs7O1lBSWlDO2FBRHhDdlQ7YUFBSndUO2FBQzRDLGNBRHhDeFQ7YUFDRjt5QkFMSHFULFdBSUNHOztVQURHO1FBREQsUUFHdUQ7TUFKakUsU0FLUUMsT0FFSm5QO1FBRmEsR0FFYkE7OztZQURxQyxJQUE3QnRFLGFBQUp1RixXQUFKRCxHQUNBaEIsS0FEcUMsWUFBN0J0RTtZQUFRLGtCQVBicVQsTUFPSC9OLEdBQUlDO1FBQ0MsT0FBTGpCLENBQU07TUFLRixxQkFiSzJCO01BU007O3VCQUdHO1VBRFgsSUFBTnFJO1VBQU0sT0FBTkE7UUFESyxTQUdVO2FBRWxCb0YsS0FBS0MsSUFBSTdULEVBQUV1UztNQUNiLElBQUl1QixJQURHRCxJQUFJN1QsT0FHWCxJQUhXQSxTQUFKNlQsSUFBTXRCLE9BR2IsT0FIT3NCLElBQU10QixTQUNUdUIsR0FFZ0I7YUFLbEJDLE1BQU1sRSxJQUFJZ0U7TUFDWixTQUFRRyxNQUFNQyxHQUFHQztZQUFIQyxRQUFHQzs7UUFDZjt5QkFEZUEsT0FBSEQ7VUFDWjtZQUFxQixJQUNmRSxLQUZNRixPQUFHQztZQVFWLGNBVEN2RSxJQUFJZ0UsSUFHSlEsU0FISVIsSUFDRU0sV0FRMkMsS0FUN0NOLElBR0pRLElBRk1GO1lBU1AsY0FWQ3RFLElBQUlnRSxJQUNLTyxVQURMUCxJQUdKUTtjQVFGLEtBWE1SLElBR0pRLElBRlNEO2NBV1IsY0FaRHZFLElBQUlnRSxJQUdKUSxTQUhJUixJQUNFTSxXQVc2QyxLQVovQ04sSUFHSlEsSUFGTUY7WUFDUzthQVVtRCxNQVo5RE4sSUFHSlE7YUFTa0UsS0FYNURGO2FBVzRELEtBWHpEQzthQWVOLG9CQWhCSHZFLElBY0F5RSxNQWRJVCxJQUNLTzthQWVOLGlCQUNHLFdBakJOdkUsSUFBSWdFLElBQ0VNLFVBYU5HO1lBSUM7OztpQkFIRHRVLE9BQXFCdVM7O2lCQUtiLGNBcEJSMUMsSUFjQXlFLE1BZElULElBZUo3VDs7b0JBTVEsY0FyQlI2UCxJQUFJZ0UsSUFlaUJ0QixVQURyQitCO3NCQVFGLEdBUEV0VSxPQUFxQnVTLEtBT1AsS0F0QlZzQixJQWVKN1QsS0FBcUJ1UztzQkFPTzs7O29CQURlOztpQkFEQTs7Y0FNL0MsSUFYeUJBLE9BZGY0QixjQUFHQyxPQWNUcFU7Z0JBWUYsTUExQlFtVSxLQWNlNUIsTUFZdkIsU0FaRXZTLEtBZE1tVTtjQTRCUixNQWRFblUsS0FkU29VO2NBNEJYLFNBZHVCN0IsS0FkWjZCOztzQkE4Qlo7TUFDTCxRQWhDWVA7TUFnQ1osU0FoQ1lBLHVCQWdDWjs7WUFFQTdUO1FBQ0U7Y0FBSXlVLE1BbkNNWixJQWtDWjdUO1VBRVMsa0JBcENENlAsSUFBSWdFLEtBa0NaN1QsZ0JBQ015VTtZQUdGLElBSkp6VSxTQWxDWTZULEtBa0NaN1Q7WUFJSSxJQUFJdVMsS0FKUnZTOztzQkFJUXVTO29CQUNpQixXQXZDakIxQyxJQUFJZ0UsS0FzQ0p0QixtQkFIRmtDO2lCQU1BLElBSEVsQyxZQXRDSXNCLEtBc0NKdEIsbUJBR0Y7Y0FFRixJQUxJQSxZQUhGa0M7O1VBQUosU0FERnpVOzs7Y0FXSTt1QkFwRUZ3VCxLQXVCQU8sTUFsQ0lUOzthQ1lKb0IsVUFBVUMsS0FBS2hOLElBQUlDLElBQUlJLEVBQUU0TTtNQUMzQixRQURpQmpOO2VBQUlDO29DQUFUK00sUUFBUy9NLFdBQUpEO2dCQUdaLG9DQUhPZ04sS0FBS2hOLElBQUlDLElBQUlJLEVBQUU0TTtNQUV0QixpRUFDcUM7UUFZeENDO2FBQ0FDLFVBQVVILEtBQUtoTjtNQUNqQixRQURpQkE7bUNBQUxnTixrQkFBS2hOO2VBR1osdUJBSE9nTixLQUFLaE47TUFFWix5Q0FDeUI7YUFDNUJvTixXQUFXSixLQUFLaE4sS0FBb0Isc0JBQXpCZ04sS0FBS2hOLFFBQXNDO2FBRXREcU4sV0FBV0wsS0FBS2hOO01BQ2xCLFFBRGtCQTttQ0FBTGdOLGtCQUFLaE47U0FHYixJQUNDQyxJQURELHVCQUhRK00sS0FBS2hOO1NBR2IsNkJBSFFnTixjQUlQL00sZ0JBSllEO2tCQU1YO2tCQUNBLG9DQVBNZ04sS0FBS2hOO01BRWIsMENBTUY7YUFFRHNOLFlBQVlOLEtBQUtoTjtNQUdSLHVDQUhHZ04sTUFBS2hOLElBR3lCOzs7OztPQW5DMUMrTTs7T0FzQkFNO09BVUFDO09BakJBSjtPQUNBQztPQUlBQzs7YUM1QmlCRyxTQUFTNU4sR0FBSSxtQkFBSkEsbUJBQWtCOztLQVUzQjZOO0tBQ0FDO2FBT2pCQyxRQUFTQyxLQUNYLDBDQURXQSxNQUNZO2FBQ3JCQyxVQUFVM1MsSUFBSTRTO01BQ21CLFNBRG5CQSxNQUNtQixXQUR2QjVTLElBQUk0UztNQUNmLHFCQURXNVMsSUFBSTRTLFVBQzhDOztLQUU1REM7S0FDQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7S0FDQUM7YUFFQUMsc0JBQ0VqUztNQUVDLFlBRkRBO1VBRWlCLGFBRmpCQTtpQ0FDQWtTLEtBREFsUzs7Ozs7TVZrY0Usa0JVamNGa1MsS0FEQWxTO01BTUMsWUFMRGtTO1VBS29CLGFBTHBCQTtZQUlBMVAsS0FKQTBQOzs7Ozt3QkFJQTFQLEtBRUc7TUFFRixvQkFKREE7ZUFKQTBQO2VBU0csMENBQXVDO2FBRTNCQyxlQUFnQkQsTUFDbEMsT0FEa0NBLE9BQ1Q7YUFFUEUsYUFBY0YsTUFDaEMsT0FEZ0NBLE9BQ1A7YUFTdEJHLFNBQU9yUyxHQUFJLE9BQUpBLG9CQUFvQjs7dUJsQmhHbEM7Ozs7Ozs7Ozs7Ozs7OztPa0JnR09xUzs7Ozs7Ozs7Ozs7Ozs7O09BeEVlM0I7T0FVQUM7T0FDQUM7T0FZakJLO09BQ0FDO09BRUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BRUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDOztPQUlBQztPQUNBQztPQUNBQztPQUVBQztPQWFpQkU7T0FHQUM7T0E1Q2pCdkI7T0FFQUU7Ozs7S0NuQkF1QjtLQUNBQztLQUNBQztLQUVBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQztLQVJBQzthQTZEQUMsUUFBTS9TLEVBQUVDLEdBQUksZ0NBQU5ELEVBQUVDLE1BQW1CO2FBRTNCK1MsT0FBS2hULEdBQUksMEJBQUpBLEVBQWdDOzs7OztPQWxFckNzUztPQUNBQztPQUNBQztPQUNBTTtPQUNBTDtPQUNBQztPQUNBQztPQUlBQztPQUNBQzs7T0FxREFFO09BRUFDOzs7O29CQ2hES3JSLEVBQUVqQztNQUNULFNBRE9pQztNQUVQLFFBRk9BO1FBTWEsdUJBTmJBLEVBTWEsV0FOWGpDLE1BTVcsS0FOYmlDLFVBTWE7O2NBQ25Cbkc7VUFDRTtZQUFpQixJQURuQkEsU0FDbUIsV0FSWGtFLEVBT1JsRTtZQUNtQixTQURuQkE7OztRQUdBLE9BSklzSjtNQUpTLGtDQVFWOzJCQUVVbU8sR0FBR0MsR0FBR0M7TUFDcEIsdUJBRGNGLFFBQ2QsS0FEY0EsV0FDZDs7WUFDQWpUO1FBQ0U7VUFBaUIsSUFEbkJBLFNBQ21CLGVBSEZrVCxHQUFHQztVQUdELFNBRG5CblQ7OztNQUdBLE9BSkk4RSxHQUlEO29CQUlJaEM7TUFDUCxJQUFJbkIsRUFER21CLGFBQ1AsYUFBSW5CLE1BQXdDLGVBRHJDbUIsSUFDSG5CLEVBQXdEO3NCQUVuRHFKLEdBQUdEO01BQ1osSUFBSS9KLEdBREtnSztNQUNULGFBQUloSztlQUNXLE9BRkgrSjs7aUJBR2UsZUFIbEJDLEtBQ0xoSztpQkFHQywwQkFKSWdLLEdBQUdELEdBSVU7bUJBRWhCakksRUFBRUssSUFBSUM7TUFDWixRQURRRDtlQUFJQztlQUFOTixlQUFNTSxXQUFKRDtnQkFHSCxlQUhDTCxFQUFFSyxJQUFJQztNQUVQLGlDQUNvQjtvQkFFbEJOLEVBQUVLLElBQUlDLElBQUlJO01BQ2pCLFFBRFNMO2VBQUlDO2VBQU5OLGVBQU1NLFdBQUpEO1VBR0osVUFISUEsTUFBSUM7VUFHUixhQUhJRDtnQkFHSjNILEVBSEkySDtZQUc0QjtnQkFBaEMzSCxTQUhZZ0k7Y0FHb0IsU0FBaENoSTs7OztNQURBLGtDQUNxRDtvQkFFbkR3UCxHQUFHeUMsS0FBSzFDLEdBQUcyQyxLQUFLdEs7TUFDdkIsUUFEdUJBO2VBQWJxSztlQUFIekMsZ0JBQWdCNUgsV0FBYnFLO2lCQUFRQztpQkFBSDNDLGdCQUFRM0gsV0FBTHNLO2tCQUliLHdCQUpFMUMsR0FBR3lDLEtBQUsxQyxHQUFHMkMsS0FBS3RLO01BR2xCLGtDQUMrQjtvQkFFN0IxRCxFQUFFb0Q7TUFDVCxTQURTQSxxQkFDVDs7O1FBQTZCO3FCQUR0QnBELEVBQUVvRCxFQUNUdEg7VUFBNkIsU0FBN0JBOzs7Y0FBbUQ7cUJBRTNDa0UsRUFBRW9ELEVBQUV6QjtNQUNaLEdBRFV5QixpQkFBRXpCO2NBRVY7TUFFQSxTQUpReUIscUJBSVI7OztRQUE2QjtxQkFKdkJwRCxFQUFFb0QsRUFJUnRILE9BSlU2RixFQUlWN0Y7VUFBNkIsU0FBN0JBOzs7Y0FBcUU7bUJBRWpFa0UsRUFBRW9EO01BQ1IsSUFBSW5CLEVBREltQjtNQUNSLFNBQUluQjtNQUFKLElBRW1CLGlCQUZmQSxFQUVlLFdBSGJqQyxFQUFFb0QsT0FHVyxLQUZmbkIsVUFFZTs7WUFDakJuRztRQUNFO1VBQWUsRUFEakJBLFNBQ2lCLFdBTGJrRSxFQUFFb0QsRUFJTnRIO1VBQ2lCLFNBRGpCQTs7O01BR0EsT0FKSTJJLENBS0g7b0JBRUl6RSxFQUFFb0QsRUFBRXpCO01BQ1gsT0FEU3lCLGFBQ1QsR0FEV3pCO01BQ1gsR0FBSStSLE9BQ0FDO2NBRUY7TUFDRyxTQUpERDtNQUFKLElBTXNCLGlCQU5sQkEsR0FNa0IsV0FQZjFULEVBQUVvRCxLQUFFekIsT0FPVyxLQU5sQitSLFdBTWtCOztZQUNsQjVYO1FBQ0U7VUFBZSxFQURqQkEsU0FDaUIsV0FUZGtFLEVBQUVvRCxFQVFMdEgsT0FSTzZGLEVBUVA3RjtVQUNpQixTQURqQkE7OztNQUdBLE9BSkkySSxDQU1MO3FCQUVLekUsRUFBRW9EO01BQ1YsU0FEVUEscUJBQ1Y7OztRQUE2QjtxQkFEckJwRCxFQUNSbEUsRUFEVXNILEVBQ1Z0SDtVQUE2QixTQUE3QkE7OztjQUFzRDtvQkFFL0NrRSxFQUFFb0Q7TUFDVCxJQUFJbkIsRUFES21CO01BQ1QsU0FBSW5CO01BQUosSUFFbUIsaUJBRmZBLEVBRWUsV0FIWmpDLElBQUVvRCxPQUdVLEtBRmZuQixVQUVlOztZQUNqQm5HO1FBQ0U7VUFBZSxFQURqQkEsU0FDaUIsV0FMWmtFLEVBSUxsRSxFQUpPc0gsRUFJUHRIO1VBQ2lCLFNBRGpCQTs7O01BR0EsT0FKSTJJLENBS0g7cUJBRU9yQjtNQUNWLFFBRFVBLHFCQUNLdEgsTUFBRXNKO01BQ2Y7Z0JBRGF0SjtVQUNVLGFBRmZzSCxFQUNLdEgsT0FBRXNKLEtBQ1EsSUFEVnRKLGdCQUFFc0o7UUFDRCxPQURDQSxJQUVPO2FBR2xCeU87Ozs7VUFFSTs7OzttQkFBTEM7O1FBREc7cUJBS043UjtNQUZVLEdBRVZBO1FBQ2lCO1NBRGJLLEdBQUpMOztTQUNpQiwrQkFEakJBOztlQUFJSzs7O2dCQUlNeVIsY0FBSkM7WUFBNkIsV0FBN0JBO1lBQTZCLDhCQUF6QkQ7O1VBREUsT0FGTjNRO01BRkEsVUFNSzt5QkFFRHBELEVBQUVNLEVBQUU4QztNQUNoQixTQURjOUMsR0FDZCxLQURnQjhDLHFCQUNoQjs7WUFDQXRIO1FBQ0U7VUFBSyxrQkFIS2tFLEVBQ1J5RSxLQURZckIsRUFFaEJ0SDtVQUNPLFNBRFBBOzs7TUFHQSxPQUpJMkksSUFJRjswQkFFV3pFLEVBQUVvRCxFQUFFOUM7TUFDakIsU0FEaUJBLEdBQ2pCLEtBRGU4QztNQUNmO1lBQ0F0SDtRQUNFO1VBQUssa0JBSE1rRSxFQUFFb0QsRUFFZnRILE9BREkySTtVQUVHLFNBRFAzSTs7O01BR0EsT0FKSTJJLElBSUY7c0JBRU84RyxFQUFFbkk7TUFDWCxNQURXQSxhQUVFdEg7TUFDWDtXQURXQSxNQURUMkY7UUFHTSxjQUpEOEosRUFBRW5JLEVBRUV0SDtRQUdOLFFBSE1BO2lCQUlQO3VCQUVJeVAsRUFBRW5JO01BQ1osTUFEWUEsYUFFQ3RIO01BQ1g7V0FEV0EsTUFEVDJGO1FBR00sY0FKQThKLEVBQUVuSSxFQUVDdEgsU0FFcUIsUUFGckJBO1FBR04sU0FDRDttQkFFQXdFLEVBQUU4QztNQUNSLE1BRFFBLGFBRUt0SDtNQUNYO1dBRFdBLE1BRFQyRjtRQUdNLHNCQUpGMkIsRUFFS3RILE9BRlB3RTtRQUtDLFFBSE14RTtpQkFJUDtvQkFFQ3dFLEVBQUU4QztNQUNULE1BRFNBLGFBRUl0SDtNQUNYO1dBRFdBLE1BRFQyRjtRQUdHLEdBSkFuQixNQUFFOEMsRUFFSXRIO1FBR04sUUFITUE7aUJBSVA7O2tCQUdDNlAsSUFBSXZJO01BQ1gsU0FBSTZRLE9BQU9oUyxFQUFFbkc7UUFDWCxVQURXQSw0QkFDWCxLQUFJb1k7UUFBSixJQUFJQSxlQURLalM7VUFHUyxTQUZkaVMsWUFHaUIsc0JBTFo5UTtVQUtKLGNBTEF1SSxJQUtJLGlCQUxBdkksRUFFTDhRO1dBQ0E1VCxPQURBNFQ7VUFFYztXQUVoQixLQUpFQTtXQUlnQixzQkFOWDlRO1dBTVcsS0FIaEI5QztVQUdDLGNBTkFxTCxJQU1JLGlCQU5Bdkk7V0FHTDlDLE9BREE0VDtVQUtGLE9BSkU1VDtRQU1GLElBUEU0VCxlQURLalM7VUFReUIsU0FQOUJpUyxZQU84QixzQkFUekI5UTtVQVNTLHNCQVRidUksSUFTaUIsaUJBVGJ2SSxFQUVMOFE7O1FBU0csR0FUSEEsTUFES2pTLFNBQ0xpUztRQVM0QixnQkFWckJwWSxFQVVxQztNQVZsRCxTQVlRcVksWUFBWWxTLEVBQUVuRyxFQUFFc1k7UXBCdk4zQixJb0J1TnlCbFM7UUFDcEI7VUFBUSxJQUFKbU0sRUFBSSxPQURVcE0sRUFBRUM7VUFFakIsa0JBZkV5SixJQWVFLGlCQWZFdkksRUFjTGlMLFVBRGtCK0Y7WUFHWiwwQkFoQkRoUixFQWNMaUw7WUFFRixpQkFoQk9qTCxFQWFXbEI7WUFHVixJQUhVQSxJQUNoQm1NOztVQUlLLHdCQWxCQWpMLEVBYVdsQixnQkFBRWtTLEVBT2xCO01BbkJOLFNBcUJJQyxRQUFRcFMsRUFBRW5HLEVBQUVzWTtRQUFJO1VBQUkscUJBQVpuUyxFQUFFbkcsRUFBRXNZOzs7O1lBQTJDLElBQUxsUyxXQUFLLHdCQXRCaERrQixFQXNCMkNsQixnQkFBdENrUztvQkFBb0Q7TUFyQnBFLFNBc0JRRSxXQUFXclMsRUFBRW5HO1FwQmpPeEIsSW9CaU93Qm9HO1FBQ25CO1VBQVEsZUFEU0QsRUFBRUMsS0FFWCxzQkF6QkNrQixFQXVCVXFMO1VBRW5CLGlCQXpCU3JMLEVBdUJVbEI7VUFDWCxJQURXQTttQkFHTDtNQXpCaEIsU0EyQklxUyxPQUFPdFMsRUFBRW5HO1FBQUk7VUFBSSxvQkFBVm1HLEVBQUVuRzs7O2dDQUF3QyxJQUFMb0csV0FBSyxPQUFMQTtvQkFBTTtNQTNCdEQsTUFEV2tCLGFBQ1gsT0FzQ0luQjtNQXRDSjtZQXVDQXVTO1FBQW9DO2tCQURoQ3ZTLEVBQ0p1UyxJQUFnRCxpQkF4Q3JDcFIsRUF3Q1hvUjtVQUFvQyxTQUFwQ0E7OztNQXZDQSxTQXNDSXZTO01BRUo7OztRQUNFOztnQ0ExQ1NtQixFQXlDWGxCO1dBRVUsc0JBM0NDa0I7VUEyQ1QsaUJBM0NTQSxFQXlDWGxCO1VBQ0UsSUFFVSxXQUhaQSxPQVprQnBHO1VBQ2hCO2dCQUFJNFksUUFEWTVZO1lBQ2hCLEdBRGdCQSxNQUNaNFk7WUFFRDs4QkFoQ0UvSSxJQWdDRSxpQkFoQ0V2SSxFQThCTHNSLG9CQURjRDthQU1ULGlCQW5DQXJSLEVBNkJPdEgsWUFBRTJZOztjQUlSLDBCQWpDRHJSLEVBOEJMc1I7Y0FHRixpQkFqQ090UixFQTZCT3RIO2NBSWQsT0FIRTRZLFlBRFk1WSxFQUNaNFk7Y0FJeUMsaUJBbENwQ3RSLFVBNkJTcVI7WUFDbEIsU0FXRnZTOzs7O01BeENBLGFBc0NJRDtNQU9KO1FBQWMsdUJBOUNIbUIsUUE4Q2lDLHNCQTlDakNBO1FBOEN5QixpQkE5Q3pCQTtRQThDRyxTQUFzQixpQkE5Q3pCQSxVQThDUWdSOzs7TUFwRGpCLFdBb0QrRDt5QkFJbkR6SSxJQUFJdkk7TUFDbEIsU0FBSXVSLE1BQU1DLFFBQVFDLFFBQVFDLEtBQUtDLFFBQVFDLFFBQVE3RyxJQUFJOEc7UUFDakQ7ZUFEUUwsVUFBUUM7U0FDaEIsTUFENkJFLFVBQVFDO1NBa0JHLHNCQWxCaEJGLEtBQUtDO1NBa0JiLHNCQW5CQTNSLEVBQ1J3UjtTQUVLVSxHQUZMVjtTQUVReFQ7U0FBR21VLEdBRlVSO1NBRVAxVDtTQUFHbVUsRUFGd0JQO1FBRy9DO1VBQUcsa0JBSk90SixJQUdJdkssR0FBTUM7WUFTbEIsaUJBWHlDOE0sSUFFcEJxSCxZQUFIblU7WUFTbEIsSUFDSW9VLEtBVldGO1lBU2YsR0FDSUUsT0FYMEJOO2NBYTVCO21CQVptQks7ZUFZTCxzQkFkSVYsS0FZaEJXO2VBVldGLEdBVVhFO2VBVmNwVTtlQUFHbVU7O1lBY25CLGNBakJVcFMsRUFHSGtTLEdBRmdDbkgsSUFFcEJxSCxVQURyQk4sUUFDU0k7VUFFVCxpQkFKeUNuSCxJQUVwQnFILFlBQVRwVTtVQUVaLElBQ0l3VSxLQUhLTjtVQUVULEdBQ0lNLE9BSkpWO1lBTUU7aUJBTG1CTTthQUtYLHNCQVJFcFMsRUFNUndTO2FBSEtOLEdBR0xNO2FBSFF4VTthQUFTb1U7O1VBT25CLGNBVGtCVixLQUVMUyxHQUYwQnBILElBRXBCcUgsVUFEU0wsUUFDZkksUUFnQitDO01BbEJwRSxTQW9CSVEsUUFBUUMsT0FBTzdILElBQUk4RyxPQUFPdlI7UUFDNUIsU0FENEJBLFlBQzVCOzs7O1VBQ0U7O2tCQUZRc1MsU0FDVmxhO2FBQ0UsbUJBdkJjc0g7YUF1QmQsTUFGbUI2UixTQUNyQm5aOztpQkFEcUJtWixVQUdmNUc7O2dCQUNtQixrQkF6QmIxQyxJQXlCaUIsaUJBSlp3QyxvQkFFWGlHO2tCQUdGO3dCQUZFL0Y7bUJBRWUsc0JBTEpGO21CQUtJLEtBRmZFO2tCQUVGLGlCQUxhRjtrQkFLYjs7Y0FHRixTQUxJRTtjQUtKLGlCQVJlRixzQkFFWGlHO2NBTUosU0FQRnRZOzs7O2dCQVFJO01BN0JOLFNBK0JRbWEsT0FBT0QsT0FBTzdILElBQUk4RyxPQUFPdlI7UUFDL0IsR0FEK0JBLGdCQUNULFFBRFRzUyxPQUFPN0gsSUFBSThHLE9BQU92UjtRQUMwQixPQUQxQkEsWUFDMEIsR0FEMUJBLE1BRXpCcEM7UUFFSixPQUpXMFUsU0FFUDFVLE9BRmM2TSxJQUFJOEcsU0FFbEIzVCxPQUNBQztRQUVKLE9BTFd5VSxPQWhDRzVTLEVBZ0NINFMsU0FHUHpVLE9BREFEO1FBR0osYUFMVzBVLFNBR1B6VSxPQURBRCxHQUZjNk0sSUFBSThHLFNBRWxCM1QsT0FDQUMsR0FIYzRNLElBQUk4RyxPQU9yQjtNQXRDTCxJQXdDSWhULEVBekNjbUI7TUFDbEIsR0F3Q0luQixjQUNnQixVQTFDRm1CLElBeUNkbkI7TUF4Q0o7T0F5Q3lDLEdBRHJDQTtPQUNxQyxHQURyQ0EsSUFFRVg7T0FFWSxpQkFEWkMsR0FDWSxpQkE3Q0E2QjtNQThDaEIsT0FISTlCLEdBRUE0VSxJQURBM1U7TUFHSixTQS9DZ0I2QixFQTRDWjdCLEdBREFEO01BSUosYUFISUMsR0FEQUQsR0FFQTRVLElBREEzVSxHQTVDWTZCLElBaURmO3NCQU9NQTtNQUNULFNBQVFrSyxJQUFJeFI7UUFDVixHQURVQSxJQURIc0g7VUFJTCxNQUpLQSxFQUNHdEgsT0FHUixLQUhRQTtVQUlLLFVBRFR3RSxpQnBCeFRYLE9vQnFUV2dOO1FBS0QsUUFBTztNQUxkOzRCcEJyVEgsT29CcVRXQSxlQU9IO3VCQUVLbEs7TUFDVixTQUFRa0ssSUFBSXhSO1FBQ1YsR0FEVUEsSUFERnNIO1VBSU4sTUFKTUEsRUFDRXRILE9BR1IsS0FIUUE7VUFJUyxhQUpUQSxFQUdKd0Usa0JwQmxVWCxPb0IrVFdnTjtRQUtELFFBQU87TUFMZDs0QnBCL1RILE9vQitUV0EsZUFPSDtzQkFhSWtIO01BQ1QsV0FBUSxxQkFBbUJ0TSxJQUFJNUgsR0FBSyxVQUFMQSxFQUFKNEgsSUFBZSxPQURqQ3NNO01BWE8sR0FFZHZTO1FBQ1k7U0FEUkssR0FBSkw7O1NBQ1ksa0JBRFpBO1NBQ1ksaUJBQU55QixJQURObkI7U0FDWSxJQUFObUI7O2VBREZwQjs7O2dCQUtNeVIsY0FBSkM7WUFBNkIsV0FBN0JBO1lBQTZCLDhCQUF6QkQ7O1VBREUsT0FGTjNRO01BSEEsVUFZSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ3hTWCtTLE9BQ0FDLE1BQ0FDO2FBQ0FDLE9BQUs3VSxHQUFJLE9BQUpBLFNBQVk7YUFDakI4VSxPQUFLOVUsR0FBSSxPQUFKQSxTQUFZO2FBQ2pCK1UsTUFBSS9VLEdBQUkseUJBQUpBLGNBQWdDO1FBQ3BDZ1Ysc0JBQ0FDO2FBQ0FDLE9BQU9sVixHQUFJLE9BQUpBLE1BQWtCO2FBR3pCbVYsWUFBVW5WLEdBQUksNkJBQUpBLEVBQWlCO2FBSTNCb1YsZ0JBQWMxVztNQUVoQjtRQUFTLCtCQUZPQTs7OztRQUpBLFdBT007UUFJcEIyVzthQUNBQyxRQUFPelcsRUFBT0MsR0FBUSw4QkFBZkQsRUFBT0MsTUFBdUI7Ozs7T0F2QnJDNFY7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUU7T0FEQUQ7T0FFQUU7T0FPQUU7T0FKQUQ7T0FXQUU7T0FDQUM7O2FuQnRCQUMsT0FBS3ZWLEdBQUksc0JBQUpBLE1BQVk7YUFDakJ3VixPQUFLeFYsR0FBSSxzQkFBSkEsTUFBWTthQUNqQnlWLE1BQUl6VjtNQUFJLHlCQUFKQSxTQUEyQix1QkFBM0JBLEVBQWdDO2FBR3BDMFYsU0FBTzFWLEdBQUksOEJBQUpBLE1BQWtCO2FBR3pCMlYsWUFBVTNWLEdBQUksaUNBQUpBLEVBQWlCO2FBSTNCNFYsZ0JBQWNsWDtNQUVoQjtRQUFTLGlDQUZPQTs7OztRQUpBLFdBT007UUFhcEJtWDthQUNBQyxRQUFPalgsRUFBT0MsR0FBUSxnQ0FBZkQsRUFBT0MsTUFBdUI7Ozs7T0FoQ3JDL0Y7T0FDQUM7T0FDQUM7T0FDQXNjO09BQ0FDO09BQ0FDO09BRUF0YztPQURBRDtPQUVBd2M7T0FPQUU7T0FKQUQ7T0FvQkFFO09BQ0FDOztRV2xDQUMsU0FDQUMsUUFDQUM7YUFDQUMsT0FBS2xXLEdBQUksT0FBSkEsU0FBWTthQUNqQm1XLE9BQUtuVyxHQUFJLE9BQUpBLFNBQVk7YUFDakJvVyxNQUFJcFcsR0FBSSx5QkFBSkEsY0FBZ0M7UUFFcENxVyxzQkFDQUM7YUFDQUMsU0FBT3ZXLEdBQUksT0FBSkEsTUFBa0I7YUFHekJ3VyxZQUFVeFcsR0FBSSwrQkFBSkEsRUFBaUI7YUFJM0J5VyxnQkFBYy9YO01BRWhCO1FBQVMsK0JBRk9BOzs7O1FBSkEsV0FPTTtRQUlwQmdZO2FBQ0FDLFFBQU85WCxFQUFPQyxHQUFRLDhCQUFmRCxFQUFPQyxNQUF1Qjs7OztPQXhCckNpWDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBNU47T0FFQThOO09BREFEO09BRUFFO09BT0FFO09BSkFEO09BV0FFO09BQ0FDOzthVkRBQyxPQUFPQyxJQUFJQyxNQUFNdlQ7TUFDbkIsSUFBSXdULE9BQUosd0JBRFNGLElBQUlDLE1BQU12VDtNQUNuQixRQUFJd1Q7UUFDZ0IsVUFGRHhUO1FBRUMsU0FGREE7UUFFQyxxQ0FGREE7TUFPbkIsT0FOSXdULE1BTUU7YUFHSkMsV0FBV0gsSUFBSUMsTUFBTXZUO01BQ3ZCLElBQUl3VCxPQUFKLDRCQURhRixJQUFJQyxNQUFNdlQ7TUFDdkIsUUFBSXdUO1FBQ2dCLFVBRkd4VDtRQUVILFNBRkdBO1FBRUgscUNBRkdBO01BT3ZCLE9BTkl3VCxNQU1FO2FBbUVKRSxjQUFjMVk7TUFDYTs7T0FBN0I7Ozs7Ozs7O09BQ2U7TUFEQzt1QkFqRWlCNFk7Z0JBRS9COzs2QkE4RGM1WSxFQWhFTTJZLFdBQ3RCLHFCQURzQkE7aUJBRXBCLE1BREVFLFdBRDZCRDtnQkFhakMsd0JBYmlDQSwwQkFHN0JuWDtrQkFVK0Q7c0JBYmxDbVgsNkJBRzdCblg7O29CQVUrRCxxQkFibENtWDttQkFpQjFCO3FCQWpCMEJBOztvQkE0QjNCO3FCQURFRTtzQkFDRjs0QkFMSyxxQkF2QnNCRjtvQkE0QjNCLEdBREVFLFdBM0J5QkYsNkJBRzdCblg7cUJBMkJLO29CQUZILElBR0VzWCxPQURpRCxrQkFIakREO29CQU1KLEtBakM2QkYsb0JBK0J6QkcsU0EvQnlCSDtvQkFpQzdCLFlBRklHO2tCQVNOLElBQUk1WSxFQXhDMkJ5WTtrQkF3Qy9CLFlBeEMrQkEsWUF3QzNCelk7a0JBQUosWUF4QytCeVksWUF3QzNCelk7a0JBQUo7OEJBeEMrQnlZLFlBd0MzQnpZO2tCQUFKLFlBeEMrQnlZLFlBd0MzQnpZO2tCQUFKLE1BeEMrQnlZLFdBd0MvQixLQU1JMUMscUJBTko7O3dCQU9BcGE7b0JBQ0U7MEJBQUlnSSxFQUFKLGlCQUZFb1MsRUFDSnBhO3NCQUNFLFFBQUlnSSxFQUVGLGlCQUpBb1MsRUFDSnBhLFlBQ01nSSxJQVJGM0Q7c0JBUUYsU0FERnJFOzs7Z0JBT0YsS0F0RHNCNmMsYUFBV0Msb0JBRzdCblg7Z0JBbURKLFlBdERpQ21YLFlBRzdCblg7Z0JBbURKOzs7Ozs7Ozs7O2NBR0UzRzt1QkFvQkQ7YUFFQ2tlLGFBQWEzVTtNQUNmLDhCQUFtQlcsSUFBSXZELEdBQUssYUFEYjRDLEdBQ0lXLE1BQUl2RCxFQUFxQixFQUFDO2FBRTNDd1gsY0FBWTlZO01BQ2Q7Ozs7Ozs7O2tDQURjQTtPQUVDLGVBRkRBO01BRUM7dUJBRE15WSxRQUFVLHNCQUE4Qjs7Ozs7Ozs7OztjQTFCM0Q5ZDt1QkF1Q0Q7YUFFQ29lLE9BQU9OO01BQ1QsSUFBSWxWLElBREtrVjtNQUNULGtCQURTQSxvQkFDTGxWLElBQ3VEO2FBRXpEeVYsV0FBV1AsT0FBT3RELEdBQUdDO01BQ3ZCLElBQUk3UixJQURtQjZSLEtBQUhELE9BQ3BCLGtCQURhc0QsVUFBT3RELEdBQ2hCNVIsSUFDcUM7YUFFdkMwVixlQUFlUixPQUFPdEQsR0FBR0M7TUFDM0IsUUFEd0JELElBQ1IsSUFDVjVSLElBRnFCNlIsS0FBSEQsT0FHakIscUJBSFVzRCxVQUFPdEQsR0FFbEI1UjtNQUVHLFFBRU47YUFFRDJWLGdCQUFnQlQsT0FBTzljLEdBQUksc0JBQVg4YyxVQUFPOWMsRUFBaUM7YUFFeER3ZCxvQkFBb0JWLE9BQU85YztNQUM3QixZQUQ2QkEsS0FFdEIsZUFGZThjLFVBQU85YyxLQUl2QjthQUdKeWQsWUFBWVgsT0FBTzljO01BQ3JCLHNCQURjOGMsc0JBQU85YyxNQUNpQzthQUVwRDBkLGFBQWFaLFFBQVMsT0FBVEEsYUFBb0M7YUFDakRhLFdBQVdiLFFBQVMsT0FBVEEsYUFBbUM7YUFFOUNjLGVBQWVkLFFBQVMsT0FBVEEsVUFBMkI7YUFDMUNlLGFBQWFmLFFBQVMsT0FBVEEsVUFBMEI7YUFFdkNnQixTQUFTaEI7TUFDWCxJQUFJaUIsSUFET2pCO01BQ1gsZ0JBQUlpQjtNQUFKLFFBSUM7YUFNQ0MsWUFBWW5HO01BQ2Q7O2VBRGNBO01BQ2Q7O2NBR3VCOzs7O09BOU1yQjlZO09BMElBbWU7T0FHQUM7T0FsQkFQO09Ba0NBUTtPQXlCQUs7T0FHQUM7T0FDQUM7T0FFQUM7T0FDQUM7T0FFQUM7T0FXQUU7T0F6Q0FYO09BSUFDO09BUUFDO09BRUFDO09BeElBakI7T0FVQUk7O0ltQmVVOzs7Ozs7T0FDQTtPQUNTLG1CbkJsRW5CNWQ7T21CbUVpQixtQm5CbkVqQkE7Ozs7Ozs7Ozs7Ozs7SW1CZ0VVLFNBaUJWbWY7TUFDRjtlQW5CRUQ7T0FtQkYsUUFBSUU7T0FFUSxxQkFEUkM7T0FFUSxxQkFGUkE7T0FHWSx5QkFIWkEsUW5CbkZGcmY7T21Cc0ZjLHVCQUhacWYsUW5CbkZGcmY7TW1Cd0ZBLE9BekJBa2YsU0FxQkVJLFFBRkFGO01BTUYsU0FKRUU7TUFNRixPQTNCQUosU0FzQkVLLFFBSEFIO01BUUYsU0FMRUc7TUFPRixPQTdCQUwsU0F1QkVNLFlBSkFKO01BVUYsU0FORUk7TUFRRixPQS9CQU4sU0F3QkVPLFVBTEFMO01BWUYsU0FQRUs7TUFPRixTQVhFSjtNQVdGLFFBRXdCO0lBaENkLFNBa0NWSztNQUNGLE9BcENFUixtQkFvQ0YsbUJBQ3VCO0lBcENYLElBc0NWUyx5Q0FBZ0QsUUFBSztJQXRDM0MsU0F3Q1ZDLFFBQVFDLE9BQU9DLE1BQU1DLE1BQU1oQztNQUM3QjtnQkExQ0VtQjtPQTBDRixRQTFDRUE7T0EwQ0YsZUExQ0VBO09BMENGLFdBMUNFQTtPQTBDRixlQTFDRUE7T0EwQ0YsVUExQ0VBO09BMENGLGFBMUNFQTtNQTBDRixTQTFDRUE7TUEwQ0YsU0FEaUJZO01BQ2pCLFVBRDZCL0I7TUFDN0I7WUFBYXdDLE1BQUlDO1FBQ2Y7VUFBTSxvQ0FGRVgsT0F6Q1JYLElBMENXcUIsSUFBSUM7VUFDVDs7YUFFYyxJQUhMQyxNQUdLLFdBSkNWLE1BQU1oQzthQUlQLFNBSk9BO2FBSVAsVUFKT0E7YUFJUCxJQUhUd0MsTUFBSUM7O21CQVFYO21CQVNBLG1CQWpCT0QsTUFBSUM7bUJBbUJYLG1CQW5CT0QsTUFBSUM7O2FBVVg7ZUFFK0Q7cUJBdERuRXRCO2dCQXNEbUU7NEJBQWhDLGlCQWIzQlcsMEJBekNSWDtnQkFzRG1FO2dCQVp4RHdCO2dCQUFJQzs7OzttQkFBSkQsUUFBSUM7aUJBQUpKLFVBQUlDOzs7YUFxQlgsV0F0QklYLGlDQUNHVSxNQUFJQztZQW1DWkk7O1FBQ0gsSUFBSUMsVUE5RUozQjtRQThFQSxVQWJFYztRQWFGLFVBWkVDO1FBWUYsU0FYRUM7UUFXRixVQVZFQztRQVVGLFNBVEVDO1FBU0YsU0FSRUM7UUFRRixVQVBFQztRQU9GLEdBREdNLG1CQVdDLElBREszWCxFQVZOMlgsT0FXQyxPQURLM1g7UUFHTDs7aUJBQ082WDtVQUNBLFlBREFBO1lBRXVCLHNCQUZ2QkE7WUFFRSx3QkFwRExqQiw4QkFxQ0pnQjs7O1VBZ0JTLHdCQXJETGhCLFVBa0RHaUIsa0JBYlBELGFBZ0J3RDtRQUp4RCxNQWJERCxJQWtCVTtJQTlGSCxTQWdHVkcsU0FBUzdCLElBQUl0WTtNQUNmLFNBRFdzWSxVQUFJdFksTUFDZix3QkFEV3NZLHNCQUN3QjtJQWpHdkIsU0FtR1Y4QjtNdEI1TEwsSXNCNkxnQi9mLEVBckdYaWU7TUFzR0E7ZUFEV2plO1VBRU47aUJBdkdMaWUsVUFxR1dqZTtXQUVOLG9CQXZHTGllO1dBdUdLLE1BdkdMQSxVQXFHV2plO1dBRU4sb0JBdkdMaWU7VUEwR0ssaUJBRkMrQixHQUNBQyxXQURBRDtVQURELElBR3NCLElBTGhCaGdCOztRQUNJLFNBdEdmaWU7UUFzR2Usd0JBdEdmQSx1QkE2R2U7SUE1R0wsU0E4R1ZpQztNQUFvQixTQS9HcEJqQyxRQStHb0Isd0JBL0dwQkEsc0JBK0dnRDtJQTlHdEMsU0ErR1ZrQyxjQUFjeGE7TUFBSSxTQWhIbEJzWSxxQkFnSGN0WTtNQUFJLHdCQWhIbEJzWSxzQkFnSHFFO0lBL0czRCxTQWdIVm1DLFlBQVl6YTtNQUFJLFNBakhoQnNZLHFCQWlIWXRZO01BQUksd0JBakhoQnNZLHNCQWlIaUU7SUFoSHZELFNBa0hWb0Msb0JBQWtCLDZCQUE4QjtJQWxIdEMsU0FtSFZDLGtCQUFnQiwyQkFBNEI7SUFuSGxDLFNBb0hWQyxVQUFVNWEsR0FBSSxxQkFBSkEsS0FBOEI7SUFwSDlCLFNBcUhWNmEsUUFBUTdhLEdBQUksbUJBQUpBLEtBQTRCO0lBckgxQixTQXVIVjhhLHFCQUFxQlo7TUFDdkIsa0JBbEZFbkIseUJBaUZxQm1CLElBQ2U7SUF4SDFCLFNBMEhWYSxtQkFBMkIsUUFBRTtJQTFIbkI7OztPQWtIVkw7T0FDQUM7T0FDQUM7T0FDQUM7T0FsQkFUO09BV0FHO09BQ0FDO09BQ0FDO09BOUVBM0I7O3NCdEIzSEw7O09zQmlJS0U7T0F3REFtQjtPQXVCQVc7T0FHQUM7SUExSFU7Ozs7O2tCQ1pOQyxjQUFTLFVBRUcsSUFBTkMsV0FBTSxPQUFOQSxFQURHLFFBQ0k7a0JBT2JDLE9BQU8xYSxFQUFFNkIsRUFBRVc7V0FDYixHQURTeEMsRUFDc0MsTUFEdENBLEtBQ0wyYSxHQUFxQ0YsV0FBckNFO1dBQ0osR0FGYW5ZLEVBRWtDLFFBRmxDQSxLQUVUcVksR0FBcUNELGFBQXJDQztXQUNKLFNBRElBLE1BREFGLGNBQ0FFO3FCQUZLN2EsRUFBRTZCLEVBQUVXLE9BR3lDO2tCQU9wRHNZLElBQUk5YSxFQUFFNkIsRUFBRVc7V0FDVixHQURNeEMsRUFDeUMsTUFEekNBLEtBQ0YyYSxHQUFxQ0YsV0FBckNFO1dBQ0osR0FGVW5ZLEVBRXFDLFFBRnJDQSxLQUVOcVksR0FBcUNELGFBQXJDQztXQUNKLElBRElBLGNBREFGO2FBRWdCLEdBSGQzYTtlQU9nQixJQURDK2EsR0FOakIvYSxLQU1XZ2IsR0FOWGhiLEtBTUtpYixHQU5MamIsS0FPZ0IsWUFEQythO2VBQ2Qsa0JBREVFLFdBRVUsT0FGVkEsR0FBTUQsR0FFSSxPQUZFRCxHQU5mbFosRUFBRVc7ZUFTQyxHQUhZdVk7aUJBT21CLElBRFhHLElBTlJILE1BTUNJLElBTkRKLE1BTU5LLElBTk1MLE1BT21CLFlBRFhHLElBWnZCclosRUFBRVc7aUJBYVMscUJBUFJ5WSxHQUFNRCxHQU1BSSxLQUFPRDtlQURMO2FBTk47V0FVSixJQWRMUixjQUNBRTthQWF5QixHQWZuQnJZO2VBbUJZLElBREM2WSxHQWxCYjdZLEtBa0JPOFksR0FsQlA5WSxLQWtCQytZLEdBbEJEL1ksS0FtQlksWUFEWCtZO2VBQ0Ysa0JBRGNGLFdBRVIsY0FwQlRyYixFQUFFNkIsRUFrQkcwWixJQUFNRCxHQUFNRDtlQUdaLEdBSEFFO2lCQU82QixJQURUQyxJQU5wQkQsTUFNYUUsSUFOYkYsTUFNTUcsSUFOTkgsTUFPNkIsWUFEVEMsSUFOZEYsR0FBTUQ7aUJBT0oscUJBekJicmIsRUFBRTZCLEVBd0JTNlosS0FBT0Q7ZUFETDthQU5OO1dBV1gsU0ExQkVaLE1BREFGLGNBQ0FFO3FCQUZFN2EsRUFBRTZCLEVBQUVXLE9BNEI4QztrQkFJbERtWixJQUFJdGQsRUFFUjRWO1d2QmxJVCxHdUJrSVNBO2FBQ1UsSUFEQ3pSLEVBQVh5UixLQUFRcFMsRUFBUm9TLEtBQUtqVSxFQUFMaVUsS0FDVSxvQkFIRjVWLEVBRUF3RDthQUNFLFNBQUpmLFNBRE5tVDthQUdFLFFBRkluVCxHQU1PLElBQUx1YSxHQUFLLElBVExoZCxFQUVHbUUsR0FPRSxPQVBGQSxNQU9INlksR0FQUnBILEVBUTJCLElBUnRCalUsRUFBRzZCLEVBT0F3WjthQU5FLElBR0ZKLEdBQUssSUFOTDVjLEVBRUgyQjthQUlRLE9BSlJBLE1BSUdpYixHQUpSaEgsRUFLMkIsSUFEbkJnSCxHQUpBcFosRUFBR1c7V0FERixZQUREbkU7a0JBWVJ1ZCxVQUFVdmQsR0FBSSxZQUFKQSxNQUFvQztrQkFTMUN3ZCxnQkFBZ0J4ZDtXdkJySjdCO2lCdUJ1SnFCbUUsV0FBSFgsV0FBSDdCO2FBQ0YsMkJBSGdCM0IsRUFFZDJCLEdBQUc2QixFQUFHVztXQURILGlCQURXbkU7a0JBS2hCeWQsZ0JBQWdCemQ7V3ZCMUo3QjtpQnVCNEpxQm1FLFdBQUhYLFdBQUg3QjthQUNFLFdBREZBLEVBQUc2QixFQUNELGdCQUhZeEQsRUFFUm1FO1dBREgsaUJBRFduRTtrQkFRaEIwZCxLQUFLL2IsRUFBRTZCLEVBQUVXO1dBQ2YsR0FEV3hDO2dCQUFJd0M7O2dCQUkyQ3daLEdBSjNDeFo7Z0JBSXFDNlksR0FKckM3WTtnQkFJK0I4WSxHQUovQjlZO2dCQUl5QitZLEdBSnpCL1k7Z0JBSWF5WixHQUpqQmpjO2dCQUlXK2EsR0FKWC9hO2dCQUlLZ2IsR0FKTGhiO2dCQUlEaWIsR0FKQ2piO3VCQUkrQ2djLGNBQTlCQzt3QkFDTSxJQUR4QmhCLEdBQU1ELEdBQ2tCLEtBRFpELEdBSlRsWixFQUFFVzt5QkFJYXlaLGNBQThCRCxHQUU5QixTQU5qQmhjLEVBQUU2QixFQUkyQjBaLElBQU1ELEdBQU1ELElBR2hELE9BUE9yYixFQUFFNkIsRUFBRVc7YUFHQyx1QkFISFgsRUFBRjdCO1dBRUssdUJBRkg2QixFQUFFVyxFQU9DO2tCQUlWMFo7V3ZCN0tiO1d1QjZLdUI7Ozs7ZUFFTSxJQUFOcmE7ZUFBTSxPQUFOQTthQURMLGdCQUVXO2tCQUVoQnNhO1d2QmxMYjtXdUJrTDJCOzs7O2VBRUUsSUFBTnRhO2VBQU0sVUFBTkE7YUFETCxTQUVlO2tCQUVwQnVhO1d2QnZMYjtXdUJ1THVCOzs7O2VBRU07YUFEWCxnQkFFVztrQkFFaEJDO1d2QjVMYjtXdUI0TDJCOzs7O2VBRUU7YUFEWCxTQUVlO2tCQUlwQkM7V0FBaUI7OzttQkFHVjlaLFdBQUhYLFdBQWEsZ0NBQWJBLEVBQUdXO2FBRFMsSUFBTitaO2FBQU0sT0FBTkE7V0FETCwwQ0FFa0M7a0JBZ0IzQ0MsT0FHQ3ZJLEVBRE90SztXQURWLEdBRUdzSzthQUNTLEdBRkZ0SztlQUV1Qix3QkFGdkJBO2VBRVUsWUFEakJzSyxFQUNpQixRQUZWdEs7YUFDTSxPQUFic0s7V0FEYSxPQUFOdEssS0FFMEM7a0JBUTlDOFMsTUFBTXBlO1d2QmxPbkI7YXVCc09tQixJQURDbUUsV0FBSFgsV0FBSDdCLFdBQ0ssb0JBSkEzQixFQUdGd0Q7YUFDRSxTQUFKZixZQUREZCxJQUFNd0M7YUFHSixRQUZEMUI7ZUFLbUIsZ0JBVGZ6QyxFQUdDbUUsR0FNYztlQUFjLGVBTmxDeEMsRUFBRzZCLEVBTUNrWixJQUFJMkIsS0FBTXJCO2FBTFQ7Y0FHZSxjQVBmaGQsRUFHTDJCO2NBSW9COzs7YUFBd0IsVUFBeENpYixHQUFJMEIsT0FBb0MsS0FBOUJwQixHQUpYMVosRUFBR1c7V0FEVDthQVdGMkM7a0JBRUF5WCxnQkFBVyxnQkFBbUM7a0JBRTFDQyxJQUFJeGU7V3ZCblBqQjs7O2V1QnNQbUI7Z0JBRENtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSyxvQkFIRjNCLEVBRUF3RDtnQkFDRSxXQUFKZjtlQUFJO21CQURDK1EsYUFDTC9RLEVBREswQixFQUFOeEMsVUFBTTZSOzthQURGO2tCQUtMaUwsT0FBT3plLEVBRVg0VjtXdkIzUFQsR3VCMlBTQTthQUNVLElBREV6UixFQUFaeVIsS0FBU3BTLEVBQVRvUyxLQUFNalUsRUFBTmlVLEtBQ1Usb0JBSEM1VixFQUVGd0Q7YUFDQyxTQUFKZjtlQS9DUixHQThDUWQ7aUJBM0NJLEdBMkNFd0M7bUJBM0NrQix3QkEyQ2xCQSxHQTNDSyxXQTJDWHhDLEVBM0NXLFFBMkNMd0M7aUJBNUNFLE9BNENSeEM7ZUE3Q1EsT0E2Q0Z3QzthQUlSLFFBSEUxQixHQVFTLElBQUx1YSxHQUFLLE9BWEpoZCxFQUVDbUUsR0FTRyxPQVRIQSxNQVNGNlksR0FUVnBILEVBV1csSUFYTGpVLEVBQUc2QixFQVNDd1o7YUFSQSxJQUlBSixHQUFLLE9BUEo1YyxFQUVMMkI7YUFLUyxPQUxUQSxNQUtJaWIsR0FMVmhILEVBT1csSUFGRGdILEdBTERwWixFQUFHVztXQURIO2tCQWNMdWEsTUFHSGpULEdBRE9IO1dBRFYsR0FFR0c7Z0JBRE9IOztnQkFFZ0RFLEdBRmhERjtnQkFFMENxVCxHQUYxQ3JUO2dCQUVvQ3NULEdBRnBDdFQ7Z0JBRThCckssR0FGOUJxSztnQkFFa0JJLEdBRHpCRDtnQkFDbUJvVCxHQURuQnBUO2dCQUNhcVQsR0FEYnJUO2dCQUNPekssR0FEUHlLO2tCQUN1REQsTUFBOUJFO2lCQUV0QixTQUZvREYsVUFFckMsSUFGeUJvVCxHQUQzQ25UO2lCQUl1QjtnQ0FIVnFULEdBRk54VDtrQkFLZ0I7O2tCQUNJLFdBSlJ1VCxHQUdGRTtpQkFDUCxrQkFKSC9kLEdBR0d1SixNQUhHdVU7ZUFPVixTQVBzQnBULFVBT1AsSUFQTG9ULEdBRk54VDtlQVVnQjs4QkFSb0JzVCxHQUQzQ25UO2dCQVN1Qjs7Z0JBQ0ksV0FEVnVULEtBUmdDTDtlQVN2QyxrQkFEQXJVLEtBUjJCckosSUFBTTJkO2FBRDdCLE9BQWRuVDtXQURjLE9BQVBILEtBWUQ7a0JBRUgyVCxNQUFNbmUsR0FJZXdLO1dBSDNCLEdBRFl4SztnQkFJZXdLO2VBQ2pCO2dCQURZdVQsR0FKVi9kO2dCQUlJZ2UsR0FKSmhlO2dCQUlGRSxHQUpFRjtnQkFLRixXQURNZ2UsR0FBV3hUO2dCQUNqQjs7aUJBRUYsZUFBcUIsV0FIUHVULEdBRUpGO2lCQUNILG9CQUhMM2Q7ZUFDQSxJQUdPK2QsYUFDYSxXQUxSRixHQUlMRTtlQUNKLGtCQUxIL2QsU0FBTThkO2FBREE7V0FEQSxRQU8yQjtrQkFFckNJLEtBR0h6VCxHQUN3Qkg7V0FIM0IsR0FFR0c7Z0JBQ3dCSDtlQUNqQjtnQkFEWXVULEdBRG5CcFQ7Z0JBQ2FxVCxHQURiclQ7Z0JBQ096SyxHQURQeUs7Z0JBRU8sV0FETXFULEdBQVd4VDtnQkFDakI7O2lCQUVGLGVBQXFCLFVBSFB1VCxHQUVKRjtpQkFDTCxpQkFISDNkLFNBQU04ZDtlQUNOLElBR09DLGFBQ1csVUFMTkYsR0FJTEU7ZUFDRixtQkFMTC9kO2FBRE8sT0FBZHlLO1dBRGEsUUFPd0I7a0JBSWxDMFQsVUFBVXRmLEVBQUVpVTtlQUFGOUwsTUFBRW1NO1dBQ2xCO2dCQURnQm5NOztnQkFHSDdELEVBSEc2RDtnQkFHTnhFLEVBSE13RTs7Z0JBQUVxWCxPQUdSN2IsRUFBR1csRUFIS2dRO2dCQUFGbk07Z0JBQUVtTTs7YUFFUCxPQUZPQSxJQUc0QjtrQkFhNUM5TCxRQUFRdkgsR0FBR0M7V0FDa0IsbUJBRGxCQSxNQUNELGVBREZELE1BWFEwZSxRQUFHdFE7V0FDbkI7Z0JBRGdCc1E7a0JBQUd0UTtpQkFNVDtrQkFEc0J1USxLQUxidlE7a0JBS1N5UCxHQUxUelA7a0JBS0swUCxHQUxMMVA7a0JBS0x3USxLQUxFRjtrQkFLTlgsR0FMTVc7a0JBS1ZWLEdBTFVVO2tCQU1OLG9CQURKVixHQUFrQkY7aUJBQ2QsU0FBSm5jO21CQUcrQjttQ0FKVGtjLEdBQUljO29CQUliLGVBSlRaLEdBQUlhO29CQUxFRjtvQkFBR3RROztpQkFRWixPQUZEek07ZUFGTTthQURDLE9BSE15TSxRQVk0QjtrQkFFL0MxRyxNQUFNMUgsR0FBR0MsSUFDWCxxQkFEUUQsR0FBR0MsT0FDTTtrQkFFWDhlLE9BQU8vZSxHQUFHQztlQUFIeVUsUUFBR0g7V0FDaEI7Z0JBRGFHO2tCQUFHSDtpQkFPSjtrQkFEb0NzSixHQU5oQ3RKO2tCQU0wQnVKLEdBTjFCdko7a0JBTW9CcFUsR0FOcEJvVTtrQkFNTXdKLEdBTlRySjtrQkFNR3NKLEdBTkh0SjtrQkFNSHhVLEdBTkd3VTtrQkFPRCxvQkFESXNKLEdBQTBCRjtpQkFDOUIsU0FBSm5jO21CQUVGLGdCQUhJekIsR0FBMEJDO21CQUc5QixhQVRPdVUsS0FNU3FKLEdBTk54SixLQU1nQ3NKO21CQUl2Qzt5QkFIRGxjO21CQU1GLHFCQVBVcWMsR0FBTUQsTUFBMEJGO21CQU8xQyxhQWJPbkosS0FNSHhVO21CQUROO2lCQUVRLFNBSU4sVUFMSUEsR0FBTThkLFFBQW9CN2Q7aUJBSzlCLGFBWE91VSxLQU1TcUo7aUJBT2hCO2VBUkY7YUFGQSxTQVU2RDtrQkFFM0RoYyxLQUFLbkQ7V3ZCclZsQjs7O21CdUJ1Vm9CeUUsYUFBSFgsYUFBSDdCO2VBQVksS0FGUmpDLEVBRUppQztlQUFzQixXQUZsQmpDLEVBRUQ4RDsyQkFBR1c7O2FBREY7a0JBR0wyYixLQUFLcGdCLEVBQUVHLEVBQUU4RTtlQUFGcUQsTUFBRW5EO1dBQ2Y7Z0JBRGFtRDtlQUdlO2dCQUFmN0QsRUFIQTZEO2dCQUdIeEUsRUFIR3dFO2dCQUdOckcsRUFITXFHO2dCQUdlLGtCQUhqQnRJLEVBR0Q4RCxFQUF1QixLQUh0QjlELEVBR0ppQyxFQUhRa0Q7Z0JBQUZtRCxJQUdBN0Q7Z0JBSEVVOzthQUVKLE9BRklBLE9BR2tDO2tCQUUzQ2tiLFFBQVE5VTtXdkI5VnJCOzs7ZXVCZ1cwQjtnQkFBTjlHO2dCQUFIWDtnQkFBSDdCO2dCQUFZLGdCQUZMc0osRUFFSnpIO2VBQVM7aUJBQU8saUJBRlp5SCxFQUVQdEo7aUJBQW1CLHFCQUFid0M7aUJBQWE7OztlQURmOztrQkFHTDZiLE9BQU8vVTtXdkJsV3BCOzs7ZXVCb1cwQjtnQkFBTjlHO2dCQUFIWDtnQkFBSDdCO2dCQUFZLGdCQUZOc0osRUFFSHpIO2VBQVM7OztpQkFBTyxnQkFGYnlILEVBRU50SjtpQkFBbUIsdUJBQWJ3QztpQkFBYTtlQURmOztrQkFHTGtELE9BQU80RCxFQUVYMks7V3ZCeFdULEd1QndXU0E7YUFFVztjQUZDelIsRUFBWnlSO2NBQVNwUyxFQUFUb1M7Y0FBTWpVLEVBQU5pVTtjQUVXLFdBSkEzSyxFQUVMdEo7Y0FHSyxjQUxBc0osRUFFRnpIO2NBSUUsV0FOQXlILEVBRUM5RzthQUlELEdBREw4YixJQUdGLEdBTkV0ZSxNQUVBcUksT0FGTTdGLE1BSU4rWixXQUpOdEksRUFNa0MsWUFKNUI1TCxJQUZHeEcsRUFJSDBhO2FBR0MsY0FMRGxVLElBRUFrVTtXQUxHO2tCQVVMZ0MsVUFBVWpWO1d2QmpYdkI7YXVCcVgwQjtjQUZOOUc7Y0FBSFg7Y0FBSDdCO2NBRVksZ0JBSkhzSixFQUVUdEo7Y0FFWTs7Y0FDTixjQUxHc0osRUFFTnpIO2NBSVMsa0JBTkh5SCxFQUVIOUc7Y0FJTTs7Z0JBRFg4YixJQUdnQixnQkFKWEUsR0FFQUUsSUFFSCxlQUpERCxHQUZDNWMsRUFJRDhjO2FBRlUsU0FLSyxLQUxYSCxHQUZIM2MsRUFJRzZjO2FBR0gsaUJBTERELEdBRUFFO1dBTEU7a0JBVUxDO1dBQVc7YUFFZ0IsSUFBdkJwYyxXQUFIeEMsV0FBMEIsY0FBdkJ3QzthQUFNLGlCQUFUeEM7V0FESSxRQUNnQztrQkFFckM2ZTs7OztlQUVnQztnQkFBekJyYztnQkFBSFg7Z0JBQUg3QjtnQkFBK0IsVUFBNUI2QixFQUE0QixvQkFBekJXOzt3QkFBTnhDOzthQURJO2tCQUdUOGUsU0FBUzVnQixHQUNYLHNCQURXQSxFQUNNO2tCQU1YNmdCLEtBQUsxZ0I7V3ZCM1lsQjs7O2V1QjhZbUI7Z0JBRENtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSyxvQkFIRDNCLEVBRUR3RDtlQUNFLFNBQUpmLFNBREVlO2VBQ0UsSUFFSCxhQUZEZixFQURLMEIsRUFBTnhDLFVBQU02Ujs7YUFERjtrQkFlTG1OLFdBVGtCamhCO1d2QmxaL0I7OzttQnVCOFpvQndlLGVBQUgwQyxlQUFINVc7ZUFDQSxjQWJpQnRLLEVBWWRraEI7a0NBQUg1Vzs7O3lCQVRNN0YsV0FBSFgsV0FBSDdCO3FCQUNBLGNBSmlCakMsRUFHZDhELG1CQUFIN0I7K0JBQU13Qzs7bUJBRFQ7MkJBVVMrWjs7YUFEVDtrQkFnQkUyQyxlQVRzQm5oQjtXdkJwYW5DOzs7bUJ1Qmdib0J3ZSxlQUFIMEMsZUFBSDVXO2VBQ0EsY0FicUJ0SyxFQVlsQmtoQjtrQ0FBSDVXOzs7eUJBVE03RixXQUFIWCxXQUFIN0I7cUJBQ0EsY0FKcUJqQyxFQUdsQjhELG1CQUFIN0I7K0JBQU13Qzs7bUJBRFQ7MkJBVVMrWjs7YUFEVDtrQkFnQkU0QyxVQVRpQnBoQjtXdkJ0YjlCOzs7bUJ1Qmtjb0J3ZSxlQUFIMEMsZUFBSDVXO2VBQ0EsY0FiZ0J0SyxFQVlia2hCO2tDQUFHMUM7Ozt5QkFUQS9aLFdBQUhYLFdBQUg3QjtxQkFDQSxjQUpnQmpDLEVBR2I4RCxtQkFBR1c7K0JBQU54Qzs7bUJBREg7MkJBVUdxSTs7YUFESDtrQkFnQkUrVyxjQVRxQnJoQjtXdkJ4Y2xDOzs7bUJ1Qm9kb0J3ZSxlQUFIMEMsZUFBSDVXO2VBQ0EsY0Fib0J0SyxFQVlqQmtoQjtrQ0FBRzFDOzs7eUJBVEEvWixXQUFIWCxXQUFIN0I7cUJBQ0EsY0FKb0JqQyxFQUdqQjhELG1CQUFHVzsrQkFBTnhDOzttQkFESDsyQkFVR3FJOzthQURIO2tCQU9FZ1gsU0FBU2hoQjtXdkIxZHRCOzs7ZXVCNmRtQjtnQkFEQ21FO2dCQUFIWDtnQkFBSDdCO2dCQUNLLG9CQUhHM0IsRUFFTHdEO2VBQ0UsU0FBSmYsWUFERWU7ZUFDRSxJQUVILGFBRkRmLEVBREswQixFQUFOeEMsVUFBTTZSOzthQURGO2tCQWVMeE0sSUFBSXRILEVBRVJrVztXdkI1ZVQsR3VCNGVTQTthQUVVO2NBRkN6UixFQUFYeVI7Y0FBUXBTLEVBQVJvUztjQUFLalUsRUFBTGlVO2NBRVUsUUFKRmxXLEVBRUhpQztjQUdLLGVBTEZqQyxFQUVBOEQ7Y0FJRSxRQU5GOUQsRUFFR3lFO2FBSUQsR0FKTHhDLE1BWElxSSxPQVdEeEcsTUFYR29kLE9BV0F6YyxNQVhFK1osV0FXYnRJO2FBUEYsU0FKVzVMOzs7Y0FJa0I7NEJBSmxCQTtlQUlNLHFDQUpKNFc7YWZ3Q1g7d0JleENhMUM7OztnQkFLZ0I7OEJBTGhCQTtpQkFLRSxnQ0FMSjBDO29DQU1SLEtBTk01VyxJQUFFNFcsSUFBRTFDO2FBT0YsYUFQRmxVLElBT0UsSUFQQTRXLElBQUUxQztXQVVKO2tCQThCVCtDLFFBQVF0ZjtXQUNWLEdBRFVBOzs7Ozs7Ozs7O3VCQVFZOzZDQVJaQTt3QkFwQlY7a0NBQVlSLEVBQUVROzJCQUNaLFVBRFVSOztxQ0FFQSxZQUZFUTs7eUNBR0R3ZixJQUhDeGYsS0FHUHlmLEdBSE96ZixvQkFHUHlmLFFBQU1EOzs7a0NBSEN4Zjs7O3VDQUlLMGYsWUFBTnBWLFdBQU5xVixLQUpPM2Y7cURBSVAyZixVQUFNclYsUUFBTW9WOzs7a0NBSkwxZjs7Ozs7eUNBTVc0ZixZQUFOdlYsV0FBTkksYUFBTm9WLEtBTk83Zjt1REFNUDZmLFVBQU1wVixVQUFNSixXQUFNdVY7MkJBSXJCLE9BVlFwZ0IsVUFXTSxVQURWc2dCLEdBVk05ZixHQVdJOzhCQUFKcUk7NkJBSU87OEJBRFJFLElBSENGOzhCQUdSNkYsSUFIUTdGOzhCQUlPLGFBZlQ3SSxJQVVKc2dCLGdCQUlLdlg7OEJBQ1E7OzZCQUNmLGlCQUxFa0QsS0FHRnlDLElBQ0l4QyxPQUFPcVU7MkJBRkwsNEJBR2tCO3VCQUUxQixXQUFLLE9BbkJRMVg7eUJBNEJFMlg7cUJBQWMsV0FBZEEsR0FBYyxTQUFRLFNBQVEsU0FBUTttQkFENUIseUJBQVEsU0FBUTtpQkFEcEIseUJBQVE7ZUFEWjthQURYO1dBREYsT0E1Uk43YSxLQWtTa0Q7a0JBRWxEOGEsUUFBUXBtQixFQUFFcW1CO1dBQ1osMEJBQW1CaGlCLEVBQUVHLEdBQUssV0FBTEEsRUFBRkgsRUFBYyxFQURyQmdpQixFQUFGcm1CLEVBQzRCO2tCQUVwQ3NtQixPQUFPdG1CLEdBQUksZUFBSkEsRUF2U1BzTCxNQXVTMEI7a0JBRXRCaWIsWUFBYXRmO1dBQU8sR0FBUEE7YUFFOEIsSUFBbkMvRyxLQUZLK0csS0FFUm1ULEVBRlFuVCxLQUVYekMsRUFGV3lDLEtBRThCLGVBQXRDbVQsRUFBR2xhO2FBQXNCLFVBQTVCc0UsaUJ2QjFoQmYsT3VCd2hCYStoQjtXQUNHLFFBQzJEO2tCQUVsRUMsT0FBT3ZmO1dBQWlCLG1CQUFqQkE7V0FBaUIsc0J2QjVoQmpDLE91QndoQmFzZix1QkFJcUM7a0JBRXpDRSxZQUFZQyxJQUFJcmlCO2VBQ0ZtSSxJQURFbkksRUFDQTRDO1dBQUk7Z0JBQU51RjtlQUdFLElBREw3RCxFQUZHNkQsT0FFQXhFLEVBRkF3RSxPQUVOckcsRUFGTXFHLE9BR0Usb0JBREZ4RSxFQUhGMGU7ZUFJSSxTQUVSL2dCO2lCQUFPLFFBQVBBLEdBQ0ssV0FKQ3FDLEVBQUhXLEVBRksxQixHQUFGdUYsSUFFTnJHLEVBRlFjO3FCQUFGdUYsSUFFSDdEOztlQUNLLFlBREZYLEVBQUhXLEVBRksxQjs7O21DdkIvaEJ6QixPdUJ3aEJhc2Ysd0JBZ0JzQjs7aUJBelQxQmpiO2lCQUVBeVg7aUJBRUlDO2lCQW5IQWxCO2lCQVlKQztpQkE2R0lrQjtpQkFlQUM7aUJBZ0JBTztpQkFXQUM7aUJBNkJKN1c7aUJBR0FHO2lCQUdJcVg7aUJBZUFoZDtpQkFxSkFtRTtpQkFqSkE4WTtpQkFLQUM7aUJBSUFDO2lCQUlBM1k7aUJBV0E2WTtpQkFXQUs7aUJBUUpFO2lCQXZOSTVDO2lCQUtBQztpQkFLQUM7aUJBS0FDO2lCQWZBSDtpQkFLQUM7aUJBZ0RBTTtpQkF5S0FzQztpQkErRUFNO2lCQS9EQUw7aUJBa0JBRTtpQkFrQkFDO2lCQWtCQUM7aUJBd0RKRTtpQkFxQkFnQjtpQkFGQUQ7aUJBVEFKO2lCQUdBRTs7SUQ3Yk07Ozs7a0JFZE4zRixjQUFTLGNBRUhDLG9CQURHLFFBQ0k7a0JBRWJDLE9BQU8xYSxFQUFFM0IsRUFBRWtWLEVBQUUvUTtXQUNOLGNBREF4QyxHQUNrQixVQURad0MsR0FDWSxLQUFMcVksTUFBbEJGLGNBQWtCRTtxQkFEYjdhLEVBQUUzQixFQUFFa1YsRUFBRS9RLE9BRTRDO2tCQUV6RG9aLFVBQVV2ZCxFQUFFa1YsR0FBSSxZQUFObFYsRUFBRWtWLE1BQXVDO2tCQUVuRHVILElBQUk5YSxFQUFFM0IsRUFBRWtWLEVBQUUvUTtXQUNaLEdBRE14QyxNQUNtQ3lhLEVBRG5DemEsS0FDRjJhLEdBQXFDRixXQUFyQ0U7V0FDSixHQUZZblksTUFFNkJvWSxJQUY3QnBZLEtBRVJxWSxHQUFxQ0QsYUFBckNDO1dBQ0osSUFESUEsY0FEQUY7YUFFZ0IsR0FIZDNhO2VBT2dCLElBRE8rYSxHQU52Qi9hLEtBTWlCd2dCLEdBTmpCeGdCLEtBTVdnYixHQU5YaGIsS0FNS2liLEdBTkxqYixLQU9nQixZQURPK2E7ZUFDcEIsa0JBREVFLFdBRWEsT0FGYkEsR0FBTUQsR0FBTXdGLEdBRUMsT0FGS3pGLEdBTnJCMWMsRUFBRWtWLEVBQUUvUTtlQVNELEdBSGtCdVk7aUJBT29CO2tCQURYRyxJQU5USDtrQkFNRTBGLElBTkYxRjtrQkFNTEksSUFOS0o7a0JBTVpLLElBTllMO2tCQU9vQixZQURYRyxJQVo5QjdjLEVBQUVrVixFQUFFL1E7aUJBYU8scUJBUFJ5WSxHQUFNRCxHQUFNd0YsR0FNTnBGLEtBQU9ELElBQU9zRjtlQURaO2FBTk47V0FVSixJQWRMOUYsY0FDQUU7YUFheUIsR0FmakJyWTtlQW1CVSxJQURPNlksR0FsQmpCN1ksS0FrQldrZSxHQWxCWGxlLEtBa0JLOFksR0FsQkw5WSxLQWtCRCtZLEdBbEJDL1ksS0FtQlUsWUFEWCtZO2VBQ0Ysa0JBRG9CRixXQUVkLGNBcEJUcmIsRUFBRTNCLEVBQUVrVixFQWtCQ2dJLElBQU1ELEdBQU1vRixHQUFNckY7ZUFHbEIsR0FIQUU7aUJBT21DO2tCQURSQyxJQU4zQkQ7a0JBTW9Cb0YsSUFOcEJwRjtrQkFNYUUsSUFOYkY7a0JBTU1HLElBTk5IO2tCQU9tQyxZQURSQyxJQU5yQkYsR0FBTW9GLEdBQU1yRjtpQkFPVixxQkF6QmJyYixFQUFFM0IsRUFBRWtWLEVBd0JPbUksS0FBT0QsSUFBT2tGO2VBRFo7YUFOTjtXQVdYLFNBMUJFOUYsTUFEQUYsY0FDQUU7cUJBRkU3YSxFQUFFM0IsRUFBRWtWLEVBQUUvUSxPQTRCaUQ7YUFFM0QyQztrQkFFQXlYLGdCQUFXLGdCQUFtQztrQkFFMUNqQixJQUFJdGQsRUFBRXVpQixLQUdWVjtXeEIxSFQsR3dCMEhTQTthQUNVLElBRFF6RixFQUFsQnlGLEtBQWUxZCxFQUFmMGQsS0FBWTNNLEVBQVoyTSxLQUFTcmUsRUFBVHFlLEtBQU1sZ0IsRUFBTmtnQixLQUNVLG9CQUpGN2hCLEVBR0N3RDthQUNDLFNBQUpmLFNBRE15UyxNQUhGcU4sS0FHVlYsS0FBTWxnQixFQUhFM0IsRUFBRXVpQixLQUdLcGUsRUFBR2lZO2FBSVgsUUFIRDNaLEdBT08sSUFBTHVhLEdBQUssSUFYTGhkLEVBQUV1aUIsS0FHS3BlLEdBUUYsT0FSRUEsTUFRUDZZLEdBUlI2RSxFQVMyQixJQVRyQmxnQixFQUFHNkIsRUFBRzBSLEVBUUo4SDthQVBFLElBSUZKLEdBQUssSUFSTDVjLEVBQUV1aUIsS0FHSjVnQjthQUtPLE9BTFBBLE1BS0VpYixHQUxSaUYsRUFNMkIsSUFEbkJqRixHQUxDcFosRUFBRzBSLEVBQUcvUTtXQURiLFlBRk1uRSxFQUFFdWlCO2tCQWNON0IsS0FBSzFnQjtXeEJySWxCOzs7ZXdCeUltQjtnQkFES21FO2dCQUFIK1E7Z0JBQUgxUjtnQkFBSDdCO2dCQUNJLG9CQUpEM0IsRUFHQXdEO2VBQ0MsU0FBSmYsU0FETXlTO2VBQ0YsSUFFSCxhQUZEelMsRUFEUzBCLEVBQVR4QyxVQUFTNlI7O2FBRGI7a0JBZUVtTixXQVRxQmpoQjtXeEI3SWxDOzs7O2dCd0J5SndCd2U7Z0JBQUg5STtnQkFBSHdMO2dCQUFINVc7ZUFDRCxjQWJvQnRLLEVBWWhCa2hCOytCQUFHeEwsVUFBTnBMOzs7eUJBVFM3RixXQUFIK1EsV0FBSDFSLFdBQUg3QjtxQkFDRCxjQUpvQmpDLEVBR2hCOEQsZ0JBQUcwUixRQUFOdlQ7K0JBQVN3Qzs7bUJBRGI7MkJBVWErWjs7YUFEYjtrQkFnQkUyQyxlQVR5Qm5oQjtXeEIvSnRDOzs7O2dCd0IyS3dCd2U7Z0JBQUg5STtnQkFBSHdMO2dCQUFINVc7ZUFDRCxjQWJ3QnRLLEVBWXBCa2hCOytCQUFHeEwsVUFBTnBMOzs7eUJBVFM3RixXQUFIK1EsV0FBSDFSLFdBQUg3QjtxQkFDRCxjQUp3QmpDLEVBR3BCOEQsZ0JBQUcwUixRQUFOdlQ7K0JBQVN3Qzs7bUJBRGI7MkJBVWErWjs7YUFEYjtrQkFnQkU0QyxVQVRvQnBoQjtXeEJqTGpDOzs7O2dCd0I2THdCd2U7Z0JBQUg5STtnQkFBSHdMO2dCQUFINVc7ZUFDRCxjQWJtQnRLLEVBWWZraEI7K0JBQUd4TCxVQUFHOEk7Ozt5QkFUQS9aLFdBQUgrUSxXQUFIMVIsV0FBSDdCO3FCQUNELGNBSm1CakMsRUFHZjhELGdCQUFHMFIsUUFBRy9ROytCQUFUeEM7O21CQURKOzJCQVVJcUk7O2FBREo7a0JBZ0JFK1csY0FUd0JyaEI7V3hCbk1yQzs7OztnQndCK013QndlO2dCQUFIOUk7Z0JBQUh3TDtnQkFBSDVXO2VBQ0QsY0FidUJ0SyxFQVluQmtoQjsrQkFBR3hMLFVBQUc4STs7O3lCQVRBL1osV0FBSCtRLFdBQUgxUixXQUFIN0I7cUJBQ0QsY0FKdUJqQyxFQUduQjhELGdCQUFHMFIsUUFBRy9ROytCQUFUeEM7O21CQURKOzJCQVVJcUk7O2FBREo7a0JBT0VnWCxTQUFTaGhCO1d4QnJOdEI7Oztld0J5Tm1CO2dCQURLbUU7Z0JBQUgrUTtnQkFBSDFSO2dCQUFIN0I7Z0JBQ0ksb0JBSkczQixFQUdKd0Q7ZUFDQyxTQUFKZixZQURNeVM7ZUFDRixJQUVILGFBRkR6UyxFQURTMEIsRUFBVHhDLFVBQVM2Ujs7YUFEYjtrQkFNRWdMLElBQUl4ZTtXeEI3TmpCOzs7ZXdCaU9tQjtnQkFERW1FO2dCQUFIWDtnQkFBSDdCO2dCQUNJLG9CQUpGM0IsRUFHQ3dEO2dCQUNDLFdBQUpmO2VBQUk7bUJBREUrUSxhQUNOL1EsRUFETTBCLEVBQU54QyxVQUFNNlI7O2FBRFY7a0JBS0VnUDtXeEJwT2I7V3dCb08yQjs7OzttQkFFQXROLGFBQUgxUjsyQkFBRzBSO2FBRFQsZ0JBRWdCO2tCQUVyQnVOO1d4QnpPYjtXd0J5TytCOzs7O21CQUVKdk4sYUFBSDFSOzhCQUFHMFI7YUFEVCxTQUVtQjtrQkFFeEJ3TjtXeEI5T2I7V3dCOE8yQjs7OztlQUVNO2FBRGYsZ0JBRWdCO2tCQUVyQkM7V3hCblBiO1d3Qm1QK0I7Ozs7ZUFFRTthQURmLFNBRW9CO2tCQUV6QkM7V0FBcUI7OzttQkFHVnplLFdBQUgrUSxXQUFIMVI7ZUFBZ0Isb0NBQWhCQSxFQUFHMFIsRUFBRy9RO2FBRE0sSUFBTitaO2FBQU0sT0FBTkE7V0FETiwwQ0FFNEM7dUJBS3BEdEksRUFET3RLO1dBRFYsR0FFR3NLO2FBRUMsR0FITXRLO2VBR08sd0JBSFBBLE9BR087ZUFDRixXQUhac0ssRUFFTTVWLEVBQUdrVixFQUNHLG1CQUpMNUo7YUFDTSxPQUFic0s7V0FEYSxPQUFOdEssS0FJNEI7a0JBRWhDbVQsT0FBT3plLEVBR1g2aEI7V3hCeFFULEd3QndRU0E7YUFDVSxJQURNMWQsRUFBaEIwZCxLQUFhM00sRUFBYjJNLEtBQVVyZSxFQUFWcWUsS0FBT2xnQixFQUFQa2dCLEtBQ1Usb0JBSkM3aEIsRUFHRHdEO2FBQ0EsU0FBSmYsU0FDVSxLQUZUZCxFQUFTd0M7YUFHVCxRQUZEMUIsR0FLTyxJQUFMdWEsR0FBSyxPQVRGaGQsRUFHS21FLEdBTUgsT0FOR0EsTUFNUjZZLEdBTlI2RSxFQU1rRCxJQU4zQ2xnQixFQUFHNkIsRUFBRzBSLEVBTUw4SDthQUxFLElBR0ZKLEdBQUssT0FQRjVjLEVBR0oyQjthQUlNLE9BSk5BLE1BSUNpYixHQUpSaUYsRUFJa0QsSUFBMUNqRixHQUpFcFosRUFBRzBSLEVBQUcvUTtXQURkO2tCQVNFMGUsT0FBTzdpQixFQUFFTixFQU1ibWlCO1d4QnRSVCxHd0JzUlNBO2FBQ1UsSUFEUXpGLEVBQWxCeUYsS0FBZTFkLEVBQWYwZCxLQUFZM00sRUFBWjJNLEtBQVNyZSxFQUFUcWUsS0FBTWxnQixFQUFOa2dCLEtBQ1Usb0JBUEM3aEIsRUFNRndEO2FBQ0MsU0FBSmY7ZUFFSSxxQkFURy9DLEtBTUR3VjtlQUdGO2lCQUdGLElBREdxTixjQUNILE9BTklyTixNQUtEcU4sS0FMWFYsS0FBTWxnQixFQU5LM0IsRUFXQXVpQixLQUxJcGUsRUFBR2lZO2VBSUosWUFKUnphLEVBQVN3QzthQU9KLFFBTkwxQixHQVVPLElBQUx1YSxHQUFLLE9BakJGaGQsRUFBRU4sRUFNRXlFLEdBV0YsT0FYRUEsTUFXUDZZLEdBWFI2RSxFQVkyQixJQVpyQmxnQixFQUFHNkIsRUFBRzBSLEVBV0o4SDthQVZFLElBT0ZKLEdBQUssT0FkRjVjLEVBQUVOLEVBTVBpQzthQVFPLE9BUlBBLE1BUUVpYixHQVJSaUYsRUFTMkIsSUFEbkJqRixHQVJDcFosRUFBRzBSLEVBQUcvUTtXQUpELHVCQUZEekU7V0FFQyxZQUVHLElBQVJvakIsa0JBQVEsWUFKTjlpQixFQUlGOGlCO1dBREc7a0JBaUJSamdCLEtBQUtuRDtXeEJwU2xCOzs7bUJ3QnNTd0J5RSxhQUFIK1EsYUFBSDFSLGFBQUg3QjtlQUNKLEtBSE9qQyxFQUVIaUM7ZUFDTSxXQUhIakMsRUFFQThELEVBQUcwUjsyQkFBRy9ROzthQUROO2tCQUlMNkMsSUFBSXRIO1d4QnpTakI7YXdCNlNvQjtjQURPMGM7Y0FBSGpZO2NBQUgrUTtjQUFIMVI7Y0FBSDdCO2NBQ0ssUUFKSGpDLEVBR0ZpQztjQUVLLGVBTEhqQyxFQUdJd1Y7Y0FHRCxRQU5IeFYsRUFHT3lFO2FBR0osVUFGTDZGLElBREd4RyxFQUVINFIsSUFDQThJLElBSFk5QjtXQURoQjtrQkFPRTJHLEtBQUtyakI7V3hCbFRsQjthd0JzVG9CO2NBRE8wYztjQUFIalk7Y0FBSCtRO2NBQUgxUjtjQUFIN0I7Y0FDSyxTQUpGakMsRUFHSGlDO2NBRUssZUFMRmpDLEVBR0E4RCxFQUFHMFI7Y0FHRCxTQU5GeFYsRUFHTXlFO2FBR0osVUFGTDZGLElBREd4RyxFQUVINFIsSUFDQThJLElBSFk5QjtXQURoQjtrQkFPRTBELEtBQUtwZ0IsRUFBRW1pQixFQUFFbGQ7ZUFBRnFlLE1BQUVuZTtXQUNmO2dCQURhbWU7ZUFJQTtnQkFESTdlLEVBSEo2ZTtnQkFHQzlOLEVBSEQ4TjtnQkFHRnhmLEVBSEV3ZjtnQkFHTHJoQixFQUhLcWhCO2dCQUlBLGtCQUpGdGpCLEVBR0E4RCxFQUFHMFIsRUFDTSxLQUpUeFYsRUFHSGlDLEVBSE9rRDtnQkFBRm1lLElBR0k3ZTtnQkFIRlU7O2FBRUosT0FGSUEsT0FJcUI7a0JBRTlCa2IsUUFBUTlVO1d4QmpVckI7Oztld0JtVThCO2dCQUFOOUc7Z0JBQUgrUTtnQkFBSDFSO2dCQUFIN0I7Z0JBQWUsZ0JBRlRzSixFQUVIekgsRUFBRzBSO2VBQVM7aUJBQVMsaUJBRmxCakssRUFFTnRKO2lCQUF3QixxQkFBZndDO2lCQUFlOzs7ZUFEckI7O2tCQUdMNmIsT0FBTy9VO1d4QnJVcEI7Oztld0J1VThCO2dCQUFOOUc7Z0JBQUgrUTtnQkFBSDFSO2dCQUFIN0I7Z0JBQWUsZ0JBRlZzSixFQUVGekgsRUFBRzBSO2VBQVM7OztpQkFBUyxnQkFGbkJqSyxFQUVMdEo7aUJBQXdCLHVCQUFmd0M7aUJBQWU7ZUFEckI7O2tCQVdMOGUsZ0JBQWdCclgsRUFBRTVMO1d4QmpWL0I7aUJ3Qm1Wd0JtRSxXQUFIK1EsV0FBSDFSLFdBQUg3QjthQUNGLDJCQUhnQmlLLEVBQUU1TCxFQUVoQjJCLEdBQUc2QixFQUFHMFIsRUFBRy9RO1dBRE4saUJBRFd5SCxFQUFFNUw7a0JBS2xCa2pCLGdCQUFnQnRYLEVBQUU1TDtXeEJ0Vi9CO2lCd0J3VndCbUUsV0FBSCtRLFdBQUgxUixXQUFIN0I7YUFDSSxXQURKQSxFQUFHNkIsRUFBRzBSLEVBQ0YsZ0JBSFV0SixFQUFFNUwsRUFFUG1FO1dBRE4saUJBRFd5SCxFQUFFNUw7a0JBUWxCMGQsS0FBSy9iLEVBQUU2QixFQUFFMFIsRUFBRS9RO1dBQ2pCLEdBRFd4QztnQkFBTXdDOztnQkFJcUR3WixHQUpyRHhaO2dCQUkrQzZZLEdBSi9DN1k7Z0JBSXlDa2UsR0FKekNsZTtnQkFJbUM4WSxHQUpuQzlZO2dCQUk2QitZLEdBSjdCL1k7Z0JBSWlCeVosR0FKdkJqYztnQkFJaUIrYSxHQUpqQi9hO2dCQUlXd2dCLEdBSlh4Z0I7Z0JBSUtnYixHQUpMaGI7Z0JBSURpYixHQUpDamI7dUJBSTJEZ2MsY0FBcENDO3dCQUNHLElBRDNCaEIsR0FBTUQsR0FBTXdGLEdBQ2UsS0FEVHpGLEdBSmZsWixFQUFFMFIsRUFBRS9RO3lCQUlpQnlaLGNBQW9DRDswQkFFMUMsU0FOakJoYyxFQUFFNkIsRUFBRTBSLEVBSStCZ0ksSUFBTUQsR0FBTW9GLEdBQU1yRjswQkFHNUQsT0FQT3JiLEVBQUU2QixFQUFFMFIsRUFBRS9RO2FBR0QsdUJBSEhYLEVBQUUwUixFQUFKdlQ7V0FFSyx1QkFGSDZCLEVBQUUwUixFQUFFL1EsRUFPQztrQkFNaEJnYSxPQUdDdkksRUFET3RLO1dBRFYsR0FFR3NLO2FBRUMsR0FITXRLO2VBR08sd0JBSFBBLE9BR087ZUFDRCxZQUhic0ssRUFFTTVWLEVBQUdrVixFQUNJLG1CQUpONUo7YUFDTSxPQUFic0s7V0FEYSxPQUFOdEssS0FJNkI7a0JBRXJDNlgsZUFBZTFYLEdBQUdqSSxFQUFFMFIsRUFBRTNKO1dBQ3hCLEdBRHNCMkosR0FFVixJQUFMRSxJQUZlRixLQUVWLFlBRkt6SixHQUFHakksRUFFYjRSLElBRmlCN0osSUFHZCxjQUhPRSxHQUFPRixHQUdGO2tCQUVoQjZTLE1BQU1wZTtXeEJ4WG5CO2F3QjRYbUI7Y0FES21FO2NBQUgrUTtjQUFIMVI7Y0FBSDdCO2NBQ0ksb0JBSkEzQixFQUdEd0Q7YUFDQyxTQUFKZixZQURBZCxLQUFNdVQsR0FBRy9RO2FBR1IsUUFGRDFCO2VBS21CLGdCQVRmekMsRUFHS21FLEdBTVU7ZUFBYyxlQU5qQ3hDLEVBQUc2QixFQUFHMFIsRUFNSHdILElBQUkyQixLQUFNckI7YUFMVDtjQUdlLGNBUGZoZCxFQUdKMkI7Y0FJbUI7OzthQUF3QixVQUF4Q2liLEdBQUkwQixPQUFvQyxLQUE5QnBCLEdBSlYxWixFQUFHMFIsRUFBRy9RO1dBRGI7a0JBU0VrUSxNQUFNM1UsRUFBRW9CLEdBQUdDO1dBQ2pCLEdBRGNEO2lCQUdxQjRLLEdBSHJCNUssTUFHZStkLEdBSGYvZCxNQUdTc2lCLEdBSFR0aUIsTUFHR2dlLEdBSEhoZSxNQUdIRSxHQUhHRjthQUd3QyxVQUhyQ0MsT0FHa0IySztlQUNaOzRCQUROb1QsR0FIQS9kO2dCQUlNOzs7Z0JBQ21DLFdBTDlDckIsRUFHaUJtZixHQUNaRjtnQkFDcUIsZ0JBTDFCamYsRUFHS29mLE1BQU1zRSxJQUNWQztlQUNNLDRCQUxQM2pCLEVBR0RzQixHQUNGQyxJQURRNmQ7O2lCQUhBL2Q7O2FBT007Y0FEU2dlLEtBTmZoZTtjQU1TdWlCLEtBTlR2aUI7Y0FNRzZkLEdBTkg3ZDtjQU1Id0osS0FOR3hKO2NBT00sY0FESDZkLEdBTk45ZDtjQU9TOzs7Y0FDbUMsV0FSOUNwQixFQU9Lc2YsS0FEZUQ7Y0FFTSxnQkFSMUJyZixFQU1Ra2YsR0FDUDJFLFFBRGFEO2FBRVAsNEJBUlA1akIsRUFPSDRLLEtBREtDLE1BQU1xVTtXQUloQiw0QkFBWTtrQkFFVkYsTUFBTWhmLEVBQUVvQixHQUFHQztXQUNqQixHQURjRDtnQkFBR0M7O2dCQUd1RHlLLEdBSHZEeks7Z0JBR2lENGQsR0FIakQ1ZDtnQkFHMkNzaUIsR0FIM0N0aUI7Z0JBR3FDNmQsR0FIckM3ZDtnQkFHK0JFLEdBSC9CRjtnQkFHa0IySyxHQUhyQjVLO2dCQUdlK2QsR0FIZi9kO2dCQUdTc2lCLEdBSFR0aUI7Z0JBR0dnZSxHQUhIaGU7Z0JBR0hFLEdBSEdGO2tCQUcwRDBLLE1BQXJDRTtpQkFFVjs4QkFGUm9ULEdBSEEvZDtrQkFLUTs7O2tCQUNYLFFBTkZyQixFQUdEc0IsR0FFQXVKO2tCQUN5QixRQU54QjdLLEVBR2lCbWYsR0FFVkU7aUJBQ2lCLEdBRHJCdUU7bUJBSUksSUFBTkUsS0FKRUY7bUJBSXdCLHNCQUg3QjNoQixFQUhPbWQsR0FNc0IsV0FUM0JwZixFQUdLb2YsR0FBTXNFLEdBTVZJLE1BSG1CcmY7aUJBRWhCLFlBRk54QyxFQUhPbWQsR0FBTXNFLEdBR1NqZjtlQUtQOzhCQVI2QnlhLEdBSHhDOWQ7Z0JBV1c7OztnQkFDWCxVQVpGcEIsRUFXRDRLLEtBUnFDcko7Z0JBU1osVUFaeEJ2QixFQVdPc2YsS0FSK0NMO2VBUzlCLEdBRHJCNEU7aUJBSUksSUFBTkUsS0FKRUY7aUJBSXdCLHNCQUg3QnZaLElBVDRDNFUsR0FZZixXQWYzQmxmLEVBRzBDa2YsR0FZekM2RSxLQVorQ0osSUFTNUJuRjtlQUVoQixZQUZObFUsSUFUNEM0VSxHQUFNeUUsR0FTNUJuRjtpQkFWdEJyZSxFQUZJaUI7O2dCQUVKakIsRUFGT2tCO1dBRVksT0FBbkJsQixDQWEyQztrQkFFL0N3SCxPQUFPNEQsRUFFWDRXO1d4QmxhVCxHd0JrYVNBO2FBRVc7Y0FGSTFkLEVBQWYwZDtjQUFZM00sRUFBWjJNO2NBQVNyZSxFQUFUcWU7Y0FBTWxnQixFQUFOa2dCO2NBRVcsV0FKQTVXLEVBRUx0SjtjQUdNLGVBTERzSixFQUVGekgsRUFBRzBSO2NBSUQsV0FOQWpLLEVBRUk5RzthQUlKLEdBREx1ZjtlQUVRLEdBTFIvaEIsTUFFQXFJLE9BRlM3RixNQUlUK1osV0FKTjJELEVBSzRDLFlBSHRDN1gsSUFGR3hHLEVBQUcwUixFQUlOZ0o7YUFFQyxjQUpEbFUsSUFFQWtVO1dBTEc7a0JBU0xnQyxVQUFValY7V3hCMWF2Qjthd0I4YTBCO2NBRkY5RztjQUFIK1E7Y0FBSDFSO2NBQUg3QjtjQUVXLGdCQUpIc0osRUFFUnRKO2NBRVc7O2NBQ0wsZUFMRXNKLEVBRUx6SCxFQUFHMFI7Y0FJSyxrQkFOSGpLLEVBRUM5RztjQUlFOztnQkFEWHVmLEtBR2tCLGdCQUpidkQsR0FFQUUsSUFFSCxlQUpERCxHQUZFNWMsRUFBRzBSLEVBSUxvTDthQUZVLFNBS0ssS0FMWEgsR0FGRjNjLEVBQUcwUixFQUlEbUw7YUFHSCxpQkFMREQsR0FFQUU7V0FMRTtrQkFZTG5CLFVBQVUwQyxFQUFFL047ZUFBRmtQLE1BQUU3TztXQUNsQjtnQkFEZ0I2Tzs7Z0JBR0M3ZSxFQUhENmU7Z0JBR0Y5TixFQUhFOE47Z0JBR0x4ZixFQUhLd2Y7O2dCQUFFM0QsT0FHUDdiLEVBQUcwUixFQUFHL1EsRUFIQ2dRO2dCQUFGNk87Z0JBQUU3Tzs7YUFFUCxPQUZPQSxJQUdtQztrQkFFbkQ5TCxRQUFRZ0QsSUFBSXVZLEdBQUdDO1dBWWlCLG1CQVpqQkEsTUFZRixlQVpERCxNQUNNcEUsUUFBR3RRO1dBQ25CO2dCQURnQnNRO2tCQUFHdFE7aUJBTVQ7a0JBRDhCdVEsS0FMckJ2UTtrQkFLaUJ5UCxHQUxqQnpQO2tCQUthbVUsR0FMYm5VO2tCQUtTMFAsR0FMVDFQO2tCQUtEd1EsS0FMRkY7a0JBS0ZYLEdBTEVXO2tCQUtONEQsR0FMTTVEO2tCQUtWVixHQUxVVTtrQkFNTixvQkFESlYsR0FBc0JGO2lCQUNsQixTQUFKbmM7bUJBRUksSUFBSitKLElBQUksV0FUSm5CLElBTUkrWCxHQUFzQkM7bUJBR3RCLFNBQUo3VztxQkFFMEI7cUNBTEltUyxHQUFJYztzQkFLMUIsZUFMQVosR0FBSWE7c0JBTEZGO3NCQUFHdFE7O21CQVNGLE9BRFgxQztpQkFEVyxPQURYL0o7ZUFGTTthQURDLE9BSE15TSxRQVc2QjtrQkFFbEQxRyxNQUFNNkMsSUFBSXVZLEdBQUdDO1dBU2lCLG1CQVRqQkEsTUFTRixlQVRERCxNQUNNcEUsUUFBR3RRO1dBQ2pCO2dCQURjc1E7a0JBQUd0UTtpQkFNZjtrQkFEc0N1USxLQUx2QnZRO2tCQUttQnlQLEdBTG5CelA7a0JBS2VtVSxHQUxmblU7a0JBS1cwUCxHQUxYMVA7a0JBS0N3USxLQUxKRjtrQkFLQVgsR0FMQVc7a0JBS0o0RCxHQUxJNUQ7a0JBS1JWLEdBTFFVO2tCQU1aLDZCQURJVixHQUFzQkY7aUJBQzFCO21CQUF5QixvQkFQdkJ2VCxJQU1NK1gsR0FBc0JDO21CQUNMO3FCQUNHO3FDQUZNMUUsR0FBSWM7c0JBRTVCLGVBRkVaLEdBQUlhO3NCQUxKRjtzQkFBR3RROzttQkFNVTs7O2lCQUZmOzthQURDLE9BSElBLE9BUTZCO2tCQUU1Q3FSO1dBQVc7YUFFaUIsSUFBdkJwYyxXQUFIeEMsV0FBMEIsY0FBdkJ3QzthQUFNLGlCQUFUeEM7V0FERyxRQUNpQztrQkFFdENtaUI7Ozs7ZUFFeUM7Z0JBQTlCM2Y7Z0JBQUgrUTtnQkFBSDFSO2dCQUFIN0I7Z0JBQXVDLGFBQXBDNkIsRUFBRzBSLEdBQWlDLG9CQUE5Qi9ROzt3QkFBVHhDOzthQURHO2tCQUdUb2lCLFNBQVNsa0IsR0FDWCxzQkFEV0EsRUFDTTtrQkFNZitoQixRQUFRcG1CLEVBQUVxbUI7V0FDWjs2QkFBbUJBO3NCQUFMLHFDQUFRalcsRUFBRXBJLEVBQUxxZSxFQUFxQjtvQkFENUJBO29CQUFGcm1CLEVBQ2tDO2tCQUUxQ3NtQixPQUFPdG1CLEdBQUksZUFBSkEsRUFwWFBzTCxNQW9YMEI7a0JBRXRCaWIsWUFBYXRmO1dBQU8sR0FBUEE7YUFFa0MsSUFBdkMvRyxLQUZLK0csS0FFUG1ULEVBRk9uVCxLQUVUZSxFQUZTZixLQUVYbUosRUFGV25KLEtBRWtDLGVBQXpDbVQsRUFBRWxhO2FBQTBCLGFBQWhDa1EsRUFBRXBJLGtCeEIzZWpCLE93QnllYXVlO1dBQ0csUUFDK0Q7a0JBRXRFQyxPQUFPSDtXQUNJLG1CQURKQTtXQUNJLHNCeEI5ZXBCLE93QnllYUUsdUJBS3dCO2tCQUU1QkUsWUFBWUMsSUFBSUw7ZUFDRm1CLElBREVuQixFQUNBcGY7V0FBSTtnQkFBTnVnQjtlQUdFO2dCQURDN2UsRUFGSDZlO2dCQUVBOU4sRUFGQThOO2dCQUVIeGYsRUFGR3dmO2dCQUVOcmhCLEVBRk1xaEI7Z0JBR0Usb0JBREx4ZixFQUhDMGU7ZUFJSSxTQUVSL2dCO2lCQUFPLFFBQVBBLEdBQ0ssV0FKRnFDLEVBQUcwUixFQUFHL1EsRUFGRDFCLEdBQUZ1Z0IsSUFFTnJoQixFQUZRYztxQkFBRnVnQixJQUVHN2U7O2VBQ0QsWUFETFgsRUFBRzBSLEVBQUcvUSxFQUZEMUI7OzttQ3hCamZ6QixPd0J5ZWFzZix3QkFpQnNCOztpQkF2WTFCamI7aUJBRUF5WDtpQkF3R0lDO2lCQXRHQWxCO2lCQXlKQXVGO2lCQTdMSnRGO2lCQWtMSWtCO2lCQThIQXBLO2lCQVlBcUs7aUJBNkNKclc7aUJBY0FHO2lCQXRLSTNGO2lCQXVCQWlkO2lCQU1BQztpQkFJQUM7aUJBMkZBM1k7aUJBVUE2WTtpQkEyQ0FLO2lCQVFKd0Q7aUJBelBJdkI7aUJBS0FDO2lCQUtBQztpQkFLQUM7aUJBZkFIO2lCQUtBQztpQkErSUFyRTtpQkFuUEFzQztpQkFnRkFNO2lCQS9EQUw7aUJBa0JBRTtpQkFrQkFDO2lCQWtCQUM7aUJBNkZBL1o7aUJBU0ErYjtpQkEyTEpmO2lCQUdBQztpQkFaQUw7aUJBR0FFOztJRjlZTTthR3JFVnpGLGNBQVksY0FBb0I7YUFFaEMySCxNQUFNbmtCLEdBQUksMEJBQXFCO2FBRS9Cb2tCLE9BQUtwa0IsR0FBSSxVQUFKQSxVQUE2QjthQUVsQ3FrQixLQUFLbGtCLEVBQUVILEdBQUksVUFBTkcsRUFBRUgsTUFBSSxPQUFKQSxhQUFJLFFBQW1DO2FBRTlDc2tCLElBQUl0a0I7TUFDTixTQURNQTtNQUNOO1lBQ01tQyxXQUFKQyxXQUZJcEMsT0FFQW1DLEdBRkFuQywyQkFFSm9DO01BQ1UsV0FBVzthQUVyQm1pQixJQUFJdmtCO01BQ04sU0FETUEsS0FDTixTQUNXLElBQVRvQyxXQUFTLE9BQVRBLEdBQ1UsV0FBVzthQUVyQnNjLFNBQVMxZSxHQUFJLGFBQUpBLFFBQWM7YUFFdkJ3a0IsU0FBT3hrQixHQUFJLE9BQUpBLElBQVM7YUFFaEJ5a0IsT0FBSzVrQixFQUFFRyxHQUFJLGNBQU5ILEVBQUVHLEtBQW1CO2FBRTFCaWdCLEtBQUtwZ0IsRUFBRWtJLElBQUkvSCxHQUFJLG1CQUFWSCxFQUFFa0ksSUFBSS9ILEtBQTRCO2FBSXZDMGtCLFNBQU8xa0IsR0FBSSxjQUFKQSxLQUFtQjthQUUxQitoQixRQUFRNEMsRUFBRWhwQixHQUFJLHFCQUFjd0UsR0FBSyxZQUFMQSxFQUFwQndrQixFQUFpQyxFQUEvQmhwQixFQUFrQzthQUU1Q2lwQixTQUFPaGUsR0FDRCxJQUFKNUcsRUFBSSxVQUNSLFFBRElBLEVBREs0RyxHQUVULE9BREk1RyxDQUVIOzs7OztPQW5DQ3djO09BTUE2SDtPQUVBQztPQUtBQztPQVhBSjtPQUVBQztPQWNBMUY7T0FFQThGO09BRUFDO09BRUF4RTtPQUlBeUU7T0FFQTNDO09BRUE2Qzs7O2FDdkJBQyxnQkFBWSxnQkFJZjthQUVHQyxRQUFNSCxHQUNSLG1DQUVhO2FBRVhsSCxJQUFJdGQsRUFBRXdrQjtNQUNSLFlBRE14a0IsS0FDTixLQURRd2tCO01BQ1I7Z0JBRFFBLDhCQUNKSSxLQURJSixPQUNKSTtnQkFESUosZ0JBQ0pJLEtBRElKLE9BQ0pJLE9BWVk7YUFLZEMsS0FBS0w7TUFDUCxTQURPQSxLQUNQLFNBRXNCLElBQWJNLGdCQUFhLE9BQWJBLFFBREEsYUFDb0I7YUFLM0JDLEtBQUtQO01BQ1AsU0FET0E7TUFDUDs7cUJBRE9BLHVDQUlMLFFBSktBO01BRUUsYUFPQTthQUtQUSxPQVlFUjtNQUFLLGFBQUxBLFVBWGVVLE9BQUtOLEtBV3BCSjtNQVZGO1dBRHNCSTtjQUdiRSxRQUhhRixRQUdKMWQsS0FISTBkLFFBSWhCOWYsT0FER2dnQjthQUhRSSxlQUlYcGdCLFNBSkttZ0IsV0FJTG5nQjtjQUpXb2dCLEtBSVhwZ0IsSUFKZ0I4ZixLQUdKMWQ7O1FBRFQsV0FGUWdlO1FBRVIsT0FGRUQsTUFXMkQ7YUFFdEVFLFdBQVNYLEdBQ1gsYUFEV0EsUUFDQzthQUVWWSxTQUFPWixHQUNULE9BRFNBLElBQ0Q7YUFFTmEsT0FRRTNsQixFQUFFOGtCO00xQjVHVCxJMEJxR2tCSSxLQU9USjtNQU5KO1dBRGFJO2NBR0pFLFFBSElGLFFBR0sxZCxLQUhMMGQ7VUFJWCxXQUdBbGxCLEVBSk9vbEI7Y0FISUYsS0FHSzFkOztRQURULFNBS2M7YUFFdkJvZSxPQVFFNWxCLEVBQUVvTCxPQUFLMFo7VUFQSTdmLEtBT1RtRyxPQVBjOFosS0FPVEo7TUFOVDtXQURrQkk7VUFJTDtXQURKRSxRQUhTRjtXQUdBMWQsS0FIQTBkO1dBSUwsa0JBR1hsbEIsRUFQV2lGLEtBR0ptZ0I7V0FISW5nQjtXQUFLaWdCLEtBR0ExZDs7UUFEVCxPQUZJdkMsS0FPb0I7YUFFakM0Z0IsU0FBU0MsR0FBR0M7TUFDZCxhQURXRDtNQUNYO1FBQ0UsU0FGWUM7UUFFWjtrQkFGWUE7Ozs7a0JBQUhEOzs7Ozs7a0JBQUdDOztrQkFBSEQ7a0JBU1AsUUFUT0E7a0JBQUdDLFFBQUhELE1BQUdDLFFBQUhELE1BQUdDLFFBQUhELE1BSVAsUUFKT0E7aUJBWUM7YUFJVkUsU0FBT2xCO01BQ1QsU0FBUXhYLElBQUl2SztRQUFPLEdBQVBBO2NBRU96QyxFQUZQeUMsS0FFVXlFLEtBRlZ6RTtVQUVrQyxVQUEzQnpDLGlCMUIzSXRCLE8wQnlJV2dOLElBRWM5RjtRQURYLFFBQzRDO01BRnZELFNBRFNzZDtNQUNULHNCMUJ6SUgsTzBCeUlXeFgsZUFJRzthQUVUMlksVUFBUW5CLEVBQUVocEIsR0FBSSxxQkFBY3dFLEdBQUssV0FBTEEsRUFBcEJ3a0IsRUFBaUMsRUFBL0JocEIsRUFBa0M7YUFFNUNvcUIsU0FBT25mLEdBQ0QsSUFBSitkLEVBQUksWUFDUixVQURJQSxFQURLL2QsR0FFVCxPQURJK2QsQ0FFSDs7Ozs7T0F2SENFO09BV0FwSDs7T0EwQkF5SDs7T0FSQUY7O09BdkJBRjtPQTZDQUs7T0FjQUc7T0FHQUM7T0FHQUM7T0FVQUM7T0FVQUM7T0FnQkFHO09BT0FDO09BRUFDOzs7YUM3SEFDLHVCQUFzQyxlQUFlO2FBR3JEQyxpQkFBa0JDO01BQ3BCLElBQUlDLFFBRGdCRDtNQUdwQixTQU5FRjtNQU1GO1FBQ2UsSUFBVDNOLE9BQVMsV0FIWDhOO1FBTUYsU0FISTlOO1FBR0osaUJBUGtCNk47UUFVbEIsT0FOSTdOO1lBS0RwRTttQ0FFSCx5QkFEb0QsTUFEakRBLENBQ3dELEVBQzNELE1BRkdBLEVBRUk7YUFJUG1TLHFCQUFzQkY7TUFDeEIsSUFBSUMsUUFEb0JEO01BR3hCLFNBckJFRjtNQW1CRixJQUVJM04sT0FBUyxXQUZUOE47TUFLSixTQUhJOU47TUFHSixpQkFOd0I2TjtNQU14QixPQUhJN04sTUFJRTthQU9KZ08sTUFBT0M7TUFDVCxJQUNJdlEsRUFESixhQURTdVE7TUFDVCxPQUNJdlEsVUFGS3VRLE9BRUx2USxVQUZLdVEsSUFLSixpQkFMSUEsSUFLZ0I7YUNHdkJDLFVEQVdEO01BQ2IsSUFDSXZRLEVBREosYUFEYXVRO01BQ2IsT0FDSXZRLFVBRlN1USxPQUVUdlEsVUFGU3VRLElBS1IscUJBTFFBLElBS2dCOzs7bUJBMUMzQkwsaUJBZUFHLHFCQWNBQyxNQ1FBRTs7YUFFQUMsU0FBVTNtQixHQUNaLElBQUlNLEVBQUosc0JBRUMsT0FIV04sRUFHWCxPQUZHTSxDQUVnQjthQUdsQnNtQixTQUFVOWlCO01BQ1osSUFBSW9TLEVBQUosYUFEWXBTO01BQ1osR0FBSW9TLDJDQURRcFM7TUFFMEQsc0NBRjFEQSxFQU1UO2FBR0QraUIsT0FBUTVrQixHQUFjLG9CQUFkQSxjQUFrRDs7Ozs7T0FqQjFEeWtCO09BRUFDO09BTUFDO09BU0FDO09BZkFGO09BTUFDO09BU0FDOzs7OzthQzdDQUM7TUFBUSw2QkFFREEsNEJBREMsUUFDZTthQUN2QmpFO01BQU8sNkJBRUFBLDBCQURDLFFBQ2E7YUFFckJrRSxVQUFVcGxCO01BQ0gsYUFER0EsWUFDWixxQkFEWUEsT0FDSCxpQkFBcUQ7YUFHeERxbEIsU0FBaURGLE1BQU10UjtNN0IzQ2hFLEk2QjJDZ0VFO01BQUs7a0JBQUxBO1NBQUssT0FBTEE7O1lBTzlDLElBREppTyxHQU5rRGpPLE9BTXREZ08sR0FOc0RoTyxPQU85QyxlQVB3Q29SLE1BTWhEcEQ7WUFDUTtrQkFQOENoTyxJQU1sRGlPOztjQUNJO29CQUNBc0QsYUFBSDdqQiwwQkFBRzZqQixJQUZKdEQ7Y0FJRDs7WUFpQkU7ZUEzQmlEak87YUEyQmpELGtCQUFMMVY7YUFBSyxpQkFBTEEsa0JGL0NMb21CLGlCRStDS3BtQjthQTNCc0QwVjs7Ozs7O3VCQWMxRCxJQURzQndSLFlBQ3RCLHNCQURzQkEsSUFib0N4UjtjQVlqQztZQUliLCtCQWhCd0NvUjtZQWdCeEMsWUFFQSxJQUFMSyxlQUFLLFVBQUxBLElBbEJtRHpSO1lBaUJoRDs7O1lBS1YsSUFETS9ULEVBckJvRCtUO1lBc0IxRCxHQURNL1QsYUFDaUIsVUFEakJBO1lBQzRCLFNBRDVCQTtZQUNOLElBRU04QyxFQUFKLHNCQUhJOUM7WUFHSixPQUhJQTtZQUdKLFVBQUk4QyxFQXhCb0RpUjs7UUFLbkMsT0FMbUNBLElBMkJwQjthQUduQzBSLFVBQTZDam5CO01BRXBEO2lCQUZvREE7UUFFcEQ7U0FDWTs7U0FEWjtrQkFFa0IsSUFBVGlELFVBQVMsVUFBVEE7O1lBRU8sSUFDVm9TLEVBRFUsU0FOb0NyVjtZQU1wQyxVQUNWcVY7YUFDVTs7Y0FGQSxTQUNWQSxNQUFvQixJQUFkMFIsSUFBTjFSLEtBQW9CLE9BQXBCQSxFQUFvQixVQUFkMFI7Y0FFRDs7WUFFRTs7K0JBQUxsbkI7YUFBSyxrQkFBTEEsa0JGN0RMb21CLGlCRTZES3BtQjtZQUFlOzs7O3FCQUNHLElBQU5tbkIsWUFBTSxPQUFOQTtZQUNBLElBQUo3bUIsRUFBSSxtQkFiZ0NIO1lBYWhDLGFBQUpHO1lBQUksT0FBSkE7O1lBRVosSUFETXFCO1lBQ04sR0FETUEsYUFDaUIsVUFEakJBO1lBQzRCLGFBRDVCQTtzQkFkMEN4Qjt3QkFpQjNDLHNCQUhDd0IsYUFHbUM7YUFHMUMwbEI7TUFBTyxVQUVHLElBQUxsbkIsV0FBSyxpQkFBTEEsR0FERyxRQUNhO2FBR2pCbW5CLFVBQXlDbm5CO01BQy9DO2lCQUQrQ0E7UUFDL0M7O2tCQUNrQixJQUFOcVYsVUFBTSxPQUY2QnJWLGFBRTdCLE9BQU5xVixFQUFNOzs7d0JBQ2UsT0FIY3JWLGFBR2Q7OztZQUU3QixJQURNd0I7WUFDTixHQURNQSxhQUNpQixVQURqQkE7WUFDNEIsYUFENUJBO3NCQUpxQ3hCOzBDQUlyQ3dCOztRQUhWLFVBUVUsVUFUcUN4QjtRQVNyQztRQUNJLFNBQ2E7YUFHekJvbkI7TUFBTyxVQUVNLElBQVIxRSxjQUFRLGlCQUFSQSxNQURHLFFBQ21CO2FBRXZCMkUsVUFBVS9sQixFQUFFdEI7TUFDbEIsT0FEZ0JzQjtRQUdSLG9CQUhVdEI7UUFHVjtVQUVGLElBREdpRDtVQUNILFVBTFlqRDtVQUtaO1dBQ2lCLGtCQU5Qc0IsVUFBRXRCO1dBTUs7Ozt1QkFGZGlELEVBRUVxa0IsT0FGRnJrQixFQUVNb1MsR0FBR3RKO1FBQ04sWUFQTS9MO01BQ0gsWUFER0EsT0FPTzthQVV2QnVuQixNQUFNam1CO003QnJJWDtRNkJ1SWU7O1NBUk8sZ0JBTVhBLEVBRURpVTtTQVJZOzs7aUJBUVpBLFNBUktoUztRQUFPLFNBQVY4UjtRQUFVLE9BQWRpUztNQU9LO2FBR1JqZ0IsS0FBS3JIO01BQ0QsaUJBRENBO01BQ0QsVUFDTSxJQUFMaUQsV0FBSyxLQUZMakQsR0FFSyxPQUFMaUQ7TUFDRyxlQUFhO2FBR3JCdWtCLFFBQU14bkIsR0FDRixpQkFERUEsR0FDRix5QkFFSSxRQUFFO2FBR1Z5bkIsT0FBSzVuQixFQUFFNm5CO01BRVA7UUFBTSxpQkFGQ0E7UUFFRCxjQUNDemtCLFdBQUssS0FITHlrQixNQUdzQixXQUh4QjduQixFQUdFb0Q7UUFDRyxTQUVIO2FBS1Awa0IsS0FBSzluQixHQUFJLHVCQUFKQSxLQUF5RDthQUU5RCtuQixVQUFROWxCO01BQ1Y7TUFBd0IsbUNBQXFCM0IsRUFBRTJCLEdBQUssVUFBUDNCLEVBQUUyQixFQUFpQixFQUR0REEsU0FDaUU7YUFHekUrbEIsWUFBVTduQjtNQUNaLElBQUkybUI7TUFBSjs7aUJBUUUsSUFBSS9qQixFQVJGK2pCO2lCQVFGLE9BQUkvakIsSUFBSixzQkFUVTVDOzJCQUNSMm1CLGNBVXFCLGdCQVhiM21CLEVBU040QzsyQkFHSyxFQUFDO2FBR1ZrbEIsU0FBUzluQjtNQUNYLElBQUkybUI7TUFBSjs7aUJBRUUsSUFBSS9qQixFQUZGK2pCO2lCQUVGLE9BQUkvakIsSUFBSixxQkFIUzVDOzJCQUNQMm1CLGNBSXFCLGVBTGQzbUIsRUFHTDRDOzJCQUdLLEVBQUM7YUFHVm1sQixXQUFXN2pCO01BRXlCLHFCQUZ6QkEsR0FFeUIsK0JBQXFDO2FBS3pFOGpCLEtBQUtyc0IsRUFBRXFFLEdBQTBDLGNBQTFDQSxHQUFrQyx1QkFBcENyRSxVQUFvRDthQUN6RHNzQixNQUFNdHNCLEVBQUVxRSxHQUFzQyxrQkFBeENyRSxFQUF3QyxLQUF0Q3FFLEtBQThDO2FBQ3REa29CLE1BQU12c0IsR0FBSSxrQkFBSkEsTUFBOEM7YUFFcER3c0IsS0FBS3RvQixFQUFFRztNQUNUOzs7Ozs7bUJBQXVELGNBRDlDQSxHQUNpQyxlQUFLLFdBRHhDSCxXQUNzRCxLQUFJO2FBRS9EdW9CLE1BQU12b0IsRUFBRUc7TUFBSTs7Ozs7O21CQUFpRCxjQUFyREEsR0FBK0MscUJBQWpESCxVQUE2RCxLQUFJO2FBQ3ZFd29CLE1BQU14b0I7TUFBSSxzQ0FBMkMscUJBQS9DQSxZQUErRDtRQUVyRXlvQjthQUNBQyxNQUFNMW9CO01BQUksc0NBQXlDLHVCQUE3Q0EsS0FBbUQsS0FBRzthQUl4RDJvQixLQUFnRDNvQixFQUFFRztNQUN4RDtNQUNBLFVBQVUsTUFGOENBO01BR3hEO01BQ0EsVUFKc0RILEVBSTFDLEtBSjRDRztNQUt4RDs2QkFDZ0I7YUFDZHlvQixVQUF3RDVvQjtNQUF4RDtPQUVVOztPQUZWOztjQUdVd1YsV0FBSHBTO1VBQ0w7VUFDQSxXQUxzRHBELEVBR2pEb0Q7VUFHTDtVQUNBLFVBUHNEcEQsRUFHOUN3VjtVQUlSOztjQUVRbU8sWUFBSkQ7VUFDSjtVQUNBLFVBWHNEMWpCLEVBU2xEMGpCO1VBR0o7VUFDQSxVQWJzRDFqQixFQVM5QzJqQjtVQUlSO2dCQUVTO2dCQUNEO2lCQUNHLGlDQUFzQjs7Ozs7O09BNUVuQ21FO09BRUFDO09BSUFDO09BZUFDO09BU0FDO09BekNBTjtPQVpBcGdCO09BTUFtZ0I7T0FsREFOO09BbUJBRTtPQWhGQVQ7T0FxR0FZO09BZ0VBUztPQUNBQztPQUNBQztPQUVBQztPQUdBQztPQUNBQztPQUVBQztPQUNBQztPQUlJQzs7YUM1TEpFLFNBQU9wbkI7TUFDVjtnQkFEVUE7T0FFVix3QkFESThJO09BRUosb0JBRElFO01BQ0osVUFBSXRLLElBREFzSyxJQUNBdEssRUFDc0Q7YUFFdkQyb0IsU0FBU25uQixHQUFJLGtCQUFKQSxZQUEwQzthQUNuRG9uQixTQUFTcG5CLEdBQUksV0FBSkEsWUFBbUM7YUFFNUNxbkIsTUFBSXJuQixFQUFFOEIsSUFBSUM7TUFDWixRQURRRDtlQUFJQztlQUFOL0IsT0FBTStCLFdBQUpELFlBR0gsV0FIQzlCLEtBQUU4QixJQUFJQztNQUVQLGtDQUNpQzthQUdwQ3VsQixPQUFLQyxJQUFJdGIsT0FBT08sSUFBSU4sT0FBT25LO01BQzdCLFFBRDZCQTtlQUFsQmtLO2VBQUpzYixTQUFzQnhsQixXQUFsQmtLO2lCQUFXQztzQ0FBSk0sT0FBV3pLLFdBQVBtSztrQkFLcEIsZ0JBTEtxYixPQUFJdGIsT0FBT08sSUFBSU4sT0FBT25LO01BR3hCLG1DQUUrQzthQUdsRHlsQixNQUFJeG5CLEVBQUU4QjtNQUNSLFFBRFFBLFVBQUY5QixRQUFFOEIsWUFHSCxzQkFIQzlCLEtBQUU4QjtNQUVQLGtDQUNpQzthQUdoQzJsQixTQUFPem5CLEdBQUksT0FBSkEsSUFBYzthQUVyQjBuQixRQUFNMW5CLEdBQUksaUJBQWU7YUFFekIybkIsTUFBTTNuQjtNQUNSLGdCQURRQSxLQUNSLDRCQURRQSxNQUNSLFFBQ2lDO2FBRS9CNG5CLE9BQU81bkIsRUFBRTZuQjtNQUNYLFFBRFM3bkIsS0FDVCxXQUFJK0I7O1dBQ0FtTCxjQUZLbE4sT0FBRTZuQjtVQUcyQixpQkFEbEMzYTtRQUVKLHVCQUZJQTthQUZLbE4sT0FBRTZuQjtVQUVQM2E7O1VBS0c7UUFBeUMsSUFFNUM0YSxXQUY0QyxrQkFMNUM1YTtRQVVKLEtBWlNsTixPQVNMOG5CLGFBVEs5bkI7UUFZVCxPQUhJOG5CO1FBR0osT0FWSTVhO1FBVUosU0FFb0I7YUFFbEI2YSxTQUFTL25CLEVBQUVvQjtNQUNiLElBQUl1TyxJQURPM1A7TUFDWCxHQURXQSxRQUNQMlAsSUFDb0IsT0FGYjNQO01BRXVCLHNCQUZ2QkEsS0FDUDJQLElBRFN2TztNQUVxQixPQUQ5QnVPO01BQzhCLFFBRWI7YUFFbEJxWSxnQkFBZ0Job0IsRUFDbEIySDtNOUJwRkosUThCb0ZJQTtRQUNPLFNBRFBBO1VBR08sVUFIUEE7WUFXTyxXQVhQQTtjQXFCTyxhQXJCUEE7Y0FzQkUsSUFBSWdJLElBdkJZM1A7Y0F1QmhCLEdBdkJnQkEsUUF1QloyUCxhQUN1QixPQXhCWDNQO2NBd0JxQixzQkF4QnJCQSxLQXVCWjJQLFVBdEJOaEk7Y0F1QnVDO2dCQXhCckIzSCxLQXVCWjJQLG1CQXRCTmhJO2NBdUJ1QyxzQkF4QnJCM0gsS0F1QloyUCxtQkF0Qk5oSTtjQXVCdUMsc0JBeEJyQjNILEtBdUJaMlAsa0JBdEJOaEk7Y0F1QnVDLE9BRGpDZ0k7Y0FDaUM7WUFYckMsSUFBSXNZLE1BYllqb0I7WUFhaEIsR0FiZ0JBLFFBYVppb0IsZUFDdUIsT0FkWGpvQjtZQWNxQixzQkFkckJBLEtBYVppb0IsWUFaTnRnQjtZQWF1QyxzQkFkckIzSCxLQWFaaW9CLHFCQVpOdGdCO1lBYXVDLHNCQWRyQjNILEtBYVppb0Isb0JBWk50Z0I7WUFhdUMsT0FEakNzZ0I7WUFDaUM7VUFUckMsSUFBSUMsTUFMWWxvQjtVQUtoQixHQUxnQkEsUUFLWmtvQixlQUN1QixPQU5YbG9CO1VBTXFCLHNCQU5yQkEsS0FLWmtvQixZQUpOdmdCO1VBS3VDLHNCQU5yQjNILEtBS1prb0Isb0JBSk52Z0I7VUFLdUMsT0FEakN1Z0I7VUFDaUM7UUFIckMsZ0JBSGdCbG9CLEVBQ2xCMkg7TUFBZ0IsNEJBaUNDO2FBRWZ3Z0IsbUJBQW1Cbm9CLEVBQ3JCMkg7TTlCeEhKLFE4QndISUE7UUFDTyxXQURQQTtVQU9PLGFBUFBBO1VBUUU7ZUFSRkE7V0FRRSxXQUFJeWdCO1dBQUosV0FBSUE7V0FBSixJQVRtQnBvQjtVQVNuQixHQVRtQkEsUUFZZjJQLGFBQ3VCLE9BYlIzUDtVQWFrQixzQkFibEJBLEtBWWYyUCxJQUZBdEI7VUFHaUMsc0JBYmxCck8sS0FZZjJQLFlBRkF0QjtVQUdpQyxzQkFibEJyTyxLQVlmMlAsWUFEQXZCO1VBRWlDLHNCQWJsQnBPLEtBWWYyUCxZQURBdkI7VUFFaUMsT0FEakN1QjtVQUNpQztRQVZyQyxJQUFJc1ksTUFIZWpvQjtRQUduQixHQUhtQkEsUUFHZmlvQixlQUN1QixPQUpSam9CO1FBSWtCLHNCQUpsQkEsS0FHZmlvQixNQUZOdGdCO1FBR3VDLHNCQUpsQjNILEtBR2Zpb0IsY0FGTnRnQjtRQUd1QyxPQURqQ3NnQjtRQUNpQztNQUh2Qiw0QkFrQkM7YUFFZkksbUJBQW1Ccm9CLEVBQ3JCMkg7TTlCN0lKLFE4QjZJSUE7UUFDTyxXQURQQTtVQU9PLGFBUFBBO1VBUUU7ZUFSRkE7V0FRRSxXQUFJeWdCO1dBQUosV0FBSUE7V0FBSixJQVRtQnBvQjtVQVNuQixHQVRtQkEsUUFZZjJQLGFBQ3VCLE9BYlIzUDtVQWFrQixzQkFibEJBLEtBWWYyUCxJQUZBdEI7VUFHaUMsc0JBYmxCck8sS0FZZjJQLFlBRkF0QjtVQUdpQyxzQkFibEJyTyxLQVlmMlAsWUFEQXZCO1VBRWlDLHNCQWJsQnBPLEtBWWYyUCxZQURBdkI7VUFFaUMsT0FEakN1QjtVQUNpQztRQVZyQyxJQUFJc1ksTUFIZWpvQjtRQUduQixHQUhtQkEsUUFHZmlvQixlQUN1QixPQUpSam9CO1FBSWtCLHNCQUpsQkEsS0FHZmlvQixNQUZOdGdCO1FBR3VDLHNCQUpsQjNILEtBR2Zpb0IsY0FGTnRnQjtRQUd1QyxPQURqQ3NnQjtRQUNpQztNQUh2Qiw2QkFrQkM7YUFFaEJLLGNBQWN0b0IsRUFBRXhCLEVBQUUrcEIsT0FBT3htQjtNQUMzQixTQURvQndtQjtNQUNwQjs7OzthQUQyQnhtQjs2Q0FBVHZELEtBQVN1RCxXQUFQd21CO01BRWY7TUFETCxJQUVJQyxhQUhZeG9CLE9BQVcrQjtNQUV5QixHQUZwQy9CLE9BR1p3b0IsYUFDNEIsT0FKaEJ4b0IsRUFBVytCO01BSzNCLE9BTGtCdkQsRUFBRStwQixPQUFKdm9CLFVBQVcrQjtNQUszQixPQUZJeW1CO01BRUosUUFDMEI7YUFFeEJDLGFBQWF6b0IsRUFBRXhCLEVBQUUrcEIsT0FBT3htQjtNQUNWLHFCQUREL0IsRUFDQyxxQkFEQ3hCLEdBQUUrcEIsT0FBT3htQixJQUMyQjthQUVuRDJtQixXQUFXMW9CLEVBQUV4QjtNQUNmLDhCQURlQSxHQUNmLGFBRGF3QixPQUNUK0I7TUFBSixHQURhL0IsT0FFVHdvQixhQUM0QixPQUhuQnhvQixFQUNUK0I7TUFHSixPQUpldkQsSUFBRndCLFVBQ1QrQjtNQUdKLE9BRkl5bUI7TUFFSixRQUMwQjthQUV4QkcsVUFBVTNvQixFQUFFeEIsR0FBaUIsa0JBQW5Cd0IsRUFBbUIscUJBQWpCeEIsR0FBMkM7YUFFdkRvcUIsV0FBVzVvQixFQUFFNm9CLElBQ2Ysb0JBRGE3b0IsRUFBRTZvQixjQUN1QjthQVdwQ0MsWUFBWTlvQixFQUFFMEMsR0FBR0s7TUFDbkIsU0FEbUJBLGNBQ25CLGtDQURtQkE7TUFFakI7TUFBZ0MsR0FGcEIvQyxlQUFLK0MsV0FHaUIsT0FIdEIvQyxFQUFLK0M7TUFDbkIsSUFUMkJoQixJQVFSZ0I7TUFQbkI7cUJBRDJCaEI7UUFDM0I7VUFDVSxJQUFKakMsRUFBSSxNQU1NNEMsR0FBRjFDLFVBUmErQjtVQUVqQixPQU1JL0IsT0FOUkY7VUFBSSxTQUFKQTtVQUFJLElBR0gsTUFMb0JpQyxNQUVyQmpDLE1BRnFCaUM7O1FBa0gzQixZQXRHd0I7YUFFdEJnbkIsY0FBY3BuQixHQUFHM0IsR0FDbkIsY0FEZ0IyQixHQUFHM0IsWUFDWTthQTRDN0JncEIsZUFBZWhwQixFQUFFM0IsRUFBRUc7TUFDckIsZ0NBRHFCQSxHQUVQMHFCLFlBQVNDO01BQ3JCO1dBRHFCQSxNQWpCRkY7VUFtQlgsSUFlSkcsUUFmSSxnQkFKVzVxQixFQUVFMnFCO1VBRWIsVUFlSkM7WUFkb0IsVUFIWkY7Y0FJUCxTQU5VbHBCLEVBbUJYb3BCO2NBYkMsUUFKZ0JELFlBQVRELFlBQVNDOztZQU9oQixJQXhCUW5RLE1BaUJRbVE7WUFoQnZCLEdBRHFCRixTQUFOalE7WUF3QlIsSUExQ2NzUSxRQW9CZixnQkFhZTlxQixFQWZOd2E7WUFFVCxVQXBCZXNROzs7Ozs7ZUE0QmxCLFFBVll0USxjQVJmLDRCQXVCcUJ4YSxHQXZCTGlyQjtlQUNkO29CQURnQkQsU0FBRkM7c0JBa0JUQyxLQWxCV0Y7O21CQUVWOzBDQXFCYWhyQixFQXZCTGlyQjtvQkFFUjs7OztnQ0FDMEMsUUFIbENBO21CQUVSLElBZ0JEQyxLQWxCU0Q7OzZCQW1CYixNQUlrQmpyQixFQWZOd2EsTUFVUjBRLE9BVlExUSxXQVVSMFE7OztZdEIwUkQ7Y3NCL1JILFFBTFkxUSxjQUtaO2NBaENTLFVBU1NzUTs7OztjQXVCbEIsSUF0QkgsMEJBZ0NxQjlxQixHQWhDTCtMLE1BQUVwUTtjQUNoQjttQkFEa0IwUyxPQUFGMVM7Z0JBRWIsbUJBOEJnQnFFLEVBaENIckUsT0FER212QjtrQkFHSyxRQUZSbnZCLFVBRVEsSUFGVm9RLGdCQUFFcFE7Z0JBR2IsbUJBNkJnQnFFLEVBaENIckU7a0JBS1gsUUFMV0E7Z0JBSWQsU0FKWW9RO2tCQUlTLFFBSlBwUSxVQUlPLElBSlRvUSxnQkFBRXBROzs7cUJBd0JmLE1BUWtCcUUsRUFoQ0hvckIsU0FpQkg1USxvQkFqQkc3ZTs7WUF5Q1gsSUFDVzJ2QixrQkFBUEM7WUFDSixXQVhVL3BCLEVBV0csV0FYRDNCLEVBVVIwckI7WUFESixJQVBPYixZQUFTQyxJQVFMVzs7VUFHQyxVQVhMWjtZQVlQLFNBZFVscEI7WUFlVixTQWZVQSxFQW1CWG9wQjtZQUpDLFFBYmdCRCxZQUFURCxZQUFTQzs7b0JBaUJqQkM7WUFEQyxTQWhCZ0JELFlBQVRELFNBaUJSRSxRQWpCaUJEO1VBa0JoQixTQXBCVW5wQixFQW1CWG9wQjtVQWZJLElBZ0JILEtBbEJnQkQsWUFBVEQsU0FpQlJFLFFBakJpQkQ7O1FBcUJyQixnQkFyQllEO1FBcUJaLFlBQXdCLFNBdkJUbHBCLEVBRUhrcEIsZUFzQkg7YUFFVGlCLFNBQVNucUIsRUFBRStCO01BQ1gsUUFEV0EsVUFBRi9CLE9BQUUrQixNQUlULE9BSlNBLElBSVQ7TUFGQSx1Q0FFaUI7YUFJbkJxb0IsU0FBT3BxQjtNQUNULFNBQVEyTCxJQUFJeFI7UUFDVixHQUZPNkYsUUFDRzdGO1FBR1IscUJBSks2RixLQUNHN0YsR0FHUixLQUhRQTtRQUlLLFVBRFR3RSxpQjlCMVJYLE84QnVSV2dOLGdCQUltQjtNQUozQjs0QjlCdlJILE84QnVSV0EsZUFNSDthQUVIMGUsVUFBUXJxQjtNQUNWLFNBQVEyTCxJQUFJeFI7UUFDVixHQUZRNkYsUUFDRTdGO1FBR1IscUJBSk02RixLQUNFN0YsR0FHUixLQUhRQTtRQUlTLGFBSlRBLEVBR0p3RSxrQjlCblNYLE84QmdTV2dOLGdCQUl1QjtNQUovQjs0QjlCaFNILE84QmdTV0EsZUFNSDthQUVIMmUsVUFBUXRxQixFQUFFNEY7TUFBZSwyQjlCeFM5QixPOEI2RUttaUIsU0EyTlEvbkIsU0FBRTRGLElBQStCO2FBRXpDMmtCLFNBQU9wd0IsR0FDRCxJQUFKNkYsRUFBSSxhQUNSLFVBRElBLEVBREs3RixHQUVULE9BREk2RixDQUVIOzs7O09BclJDa25CO09BTUFDO09BQ0FDO09BRUFDO09BTUFDO09BUUFFO09BTUFDO09BRUFDO09BRUFDO09Bb0JBSTtPQU1DQztPQXlEQUs7T0FyQkFGO09BcURETztPQU9BQztPQWxCQUw7T0FRQUc7T0EyRUFPO09BL0RBSjtPQVlBRTtPQU1BQztPQXVFQW9CO09BUUFDO09BU0FDO09BU0FDO09BRUFDOzthMUJsUkFDLHVCQUFxQixpQkFBb0I7YUFHekNDLGdCQUFnQjVzQixTQUFTdUQ7TUFDM0IsWUFEMkJBLFlBQzNCLFdBRDJCQTtNQUl6QjtlQUpnQnZEO2VBRWQ2c0I7ZUFFRixZQUEwQixlQUpWN3NCLFNBRWQ2c0IsV0FBd0JDLE1BRXVDO2FBRWpFQyxnQkFBZ0Ivc0IsVUFDbEIsaUJBRGtCQSxTQUNNO2FBR3RCZ3RCLGFBQWFodEI7TUFDQyxrQ0FDaEIxRDtNQUNFOztVQUZFMndCLFdBQ0ozd0IsRUFFSSxZQUEwQixnQkFKZjBELFNBRWYxRDtRQUNFLFNBREZBOztRQUlBLDRCQUxJMndCLFlBSzRCO2FBRzlCQyxlQUFlbHRCLFNBQVN1RDtNQUMxQixZQUQwQkEsWUFDMUIsV0FEMEJBO01BR2IsOEJBSEl2RCxTQUViNnNCLFdBQXdCQyxTQUM4QjthQWF4REssZUFBZUM7TUFBVSxHQUFWQSxTQUVELElBQVRDLE1BRlVELFdBRUQsWUFBVEMsT0FERyxRQUNnQzthQVN4Q0MsK0JBR0FodEIsSUFBSWl0QjtNQUFPLFVBQVhqdEI7T0FBVyxPQUFYQTtnQkFFQSxhQUZJaXRCO2dCQUlKLGFBSklBO2dCQStCSixjQS9CSUE7aUJBcUNKLGNBckNJQTs7T0FBTyxPQUFYanRCO2dCQU1BLElBRGU4c0IsUUFMZjlzQixPQU0wQiw0QkFEWDhzQixTQUxYRzs7VUFRSixJQURvQkMsVUFQcEJsdEIsT0FRK0IsNEJBRFhrdEIsV0FQaEJEOztjQVNnQkUsVUFUcEJudEIsT0FTYWxDLE1BVGJrQztVQVU4QixhQURqQmxDLE1BQ2lCLGVBRFZxdkIsYUFUaEJGOztjQVdrQkcsVUFYdEJwdEIsT0FXZS9CLFFBWGYrQjtVQWFpQixhQUZGL0IsUUFFRSxlQUZLbXZCLGFBWGxCSDs7Y0Fjc0JJLFVBZDFCcnRCLE9BY21CNUIsUUFkbkI0QjtVQWdCcUIsYUFGRjVCLFFBRUUsZUFGS2l2QixhQWR0Qko7O2NBaUJrQkssVUFqQnRCdHRCLE9BaUJlekIsUUFqQmZ5QjtVQW1CaUIsYUFGRnpCLFFBRUUsZUFGSyt1QixhQWpCbEJMOztjQW9Cb0JNLFNBcEJ4QnZ0QixPQW9CZXd0QixVQXBCZnh0QjtVQVQ0QixHQTZCSnV0QixTQTNCWCxTQTJCV0Esb0JBM0JuQkU7VUE2QmMsOEJBRkpELGdCQXBCWFA7O1VBd0JKLElBRGFTLFVBdkJiMXRCLE9Bd0J3Qiw0QkFEWDB0QixXQXZCVFQ7O2NBeUJ5Qm51QixNQXpCN0JrQixPQXlCb0IydEIsVUF6QnBCM3RCO3dCQXlCb0IydEIsVUFBUzd1QixNQXpCekJtdUI7O2NBMkIyQmp1QixRQTNCL0JnQixPQTJCc0I0dEIsVUEzQnRCNXRCO3dCQTJCc0I0dEIsVUFBUzV1QixRQTNCM0JpdUI7O2NBZ0M4QnZ0QixTQWhDbENNLE9BZ0N1QkwsVUFoQ3ZCSzt3QkFnQ3VCTCxVQUFXRCxTQWhDOUJ1dEI7aUJBbUNKLElBRHlCcHRCLFFBbEN6QkcsT0FtQ0EsY0FEeUJILFFBbENyQm90QixNQXFDaUM7UUEwR3JDWTthQStCQUMsY0FBY0M7TUFBK0IsOEJBQS9CQSxXQUF1RDthQUdyRUMsa0JBQWtCOW9CLElBQUkrb0I7TUFDeEI7Z0NBRG9CL29CO09BQ3BCLFFBRG9CQSxTQUFJK29CO09BQ3hCLEtBQUlycUIsTUFDQXNxQjtNQURKO1FBR2dCO3FCQUhadHFCLFlBQ0FzcUI7U0FFWSwwQkFBVm5mO1FBRUosS0FOa0I3SixTQUtkaXBCLFVBSkZ2cUI7UUFLRixTQURJdXFCO1FBRFU7OztNQVBZLFdBVzNCO2FBR0NDLGdCQUFnQmxwQixJQUFJakM7TUFDdEIsa0JBRGtCaUM7TUFFbEIsZUFGa0JBLGNBQUlqQztNQUV0QixTQUZrQmlDO01BRWxCLFFBQ3NCO2FBR3BCbXBCLGtCQUFrQm5wQixJQUFJN0U7TUFDeEIsSUFBSWl1QixRQUFKLHNCQUR3Qmp1QjtNQUV4QixrQkFGb0I2RSxJQUNoQm9wQjtNQUVKLE9BSHdCanVCLElBQUo2RSxjQUNoQm9wQjtNQUVKLFNBSG9CcHBCLFNBQ2hCb3BCO01BRUosUUFDNEI7YUFHMUJDLGdCQUFnQnJwQixLQUNsQixrQkFEa0JBLGdCQUNrQjthQUtsQ3NwQixjQUFjMXdCO01BQVEsT0FBUkE7Z0JBR0w7O2VBRFM7O2VBQXdCOztnQkFBd0I7OztlQUR2QztnQkFBaUMsV0FFaEQ7YUFHWjJ3QixjQUFjL3ZCO01BQVEsT0FBUkE7Z0JBR29DOzs7ZUFGakI7OztlQUF1Qzs7O2VBQ3ZDOzs7Z0JBQXVDOzs7Z0JBQ3ZDOzs7Z0JBQ0E7Z0JBQXVDLFVBQUc7YUF5RTNFZ3dCLGFBQWF4cEIsSUFBSXlwQjtNQUFRLE9BQVJBO2VBQ1IsdUJBREl6cEI7ZUFFSjtnQkFDQSx1QkFISUEsUUFHbUI7YUFHaEMwcEIsb0JBQW9CMXBCLElBQUkycEI7TUFDMUIsT0FEMEJBLFNBQ1QsZ0JBREszcEIsUUFBSTJwQixRQUNjO2FBSXRDQyxlQUFlNXBCLElBQUk0bkI7TUFBVSxHQUFWQTtRQUVMLElBQVRDLE1BRmNEO1FBRWlCLHlCQUZyQjVuQixJQUVxQixxQkFBL0I2bkI7TUFERyxRQUNpRDthQUt6RGdDLGVBQ0E3cEIsSUFBSXhIO01BQU8sVUFBUEE7T0FDVTs7UUFESCxTQUFQQTtjQUVnQmlFLEVBRmhCakUsT0FFU2l4QixNQUZUanhCO1VBR0osYUFIQXdILElBRWF5cEI7VUFFUyx5QkFKdEJ6cEIsSUFJc0IscUJBRkZ2RDtRQUlwQixJQURZcXRCLFFBTFJ0eEI7UUFNSixhQU5Bd0gsSUFLWThwQjtRQUNaLHVCQU5BOXBCLFFBT3VCO2FBR3ZCK3BCLGlCQUNFL3BCLElBQUl0SDtNQUFRLFVBQVJBOzJCQU1OLGtCQU5Fc0g7VUFFWXZELEVBRlIvRDtNQUdOLGdCQUhFc0g7TUFJb0IseUJBSnBCQSxJQUlvQixxQkFGUnZELEdBSVk7YUFLMUJ1dEIsa0JBQWtCaHFCLElBQUlwSDtNQUFRLE9BQVJBOztlQUNILHVCQUREb0g7O2VBRUMsdUJBRkRBOzs7Z0JBR1UsdUJBSFZBO2dCQUkrQixTQUFFO2FBWW5EaXFCLGtCQUFrQmpxQixJQUFJMnBCLFNBQVMvd0IsTUFBTUosSUFBSUUsS0FBS3FGO01BQ2hELGdCQURvQmlDO01BRXBCLG9CQUZvQkEsSUFBSTJwQjtNQUd4QixrQkFIb0IzcEIsSUFBYXBIO01BSWpDLGVBSm9Cb0gsSUFBbUJ4SDtNQUt2QyxpQkFMb0J3SCxJQUF1QnRIO01BTTNDLGdCQU5vQnNILElBQTRCakM7TUFPNUIsdUJBUEFpQyxJQU9BLGNBUGFwSCxPQU9RO2FBS3ZDc3hCLGtCQUFrQmxxQixJQUFJeEc7TUFBUSxPQUFSQTs7Ozs7OztnQkFHdEIsdUJBSGtCd0c7Ozs7Ozs7Z0JBTWxCLHVCQU5rQkE7Z0JBU2xCLFNBQUU7YUFhRm1xQix5QkFBeUJuMEI7TUFBaUIsVUFBakJBO09BQWlCLE9BQWpCQTtnQkFDRDtnQkFDQTtnQkFFQTtnQkFDQTtnQkFDQTtnQkFFQTtpQkFDQTs7T0FUa0IsT0FBakJBO2dCQUdELElBQWpCMEQsSUFIa0IxRCxrQkFHRCxPQUFqQjBEO2dCQUlpQixJQUFaMHdCLE1BUGFwMEIsa0JBT0QsT0FBWm8wQjtpQkFHSSxJQUFMcnNCLEVBVmMvSCxrQkFVSCwyQkFBWCtILElBQTRCO2FBSXZDc3NCLHlCQUVFQztNQUFrQixTQUFsQkE7b0NBQ21CNXdCO2tCQURuQjR3QixrQkFFbUJGO2tCQUFZO2FBS2pDRyxvQkFBb0J2cUIsSUFBSXJHO01BQU0sY0FBTkEsSUFDakIsa0JBRGFxRyxZQUVmLGdCQUZlQSxJQUFJckcsSUFFSTthQUc1QjZ3QixzQkFBc0J4cUIsSUFBSXRHO01BQzVCLCtCQUQ0QkEsYUFDNUI7OztRQUNFOzhCQUZzQnNHLElBRUUsZ0JBRkV0RyxJQUM1QjVDO1VBQ0UsU0FERkE7OztjQUVJO2FBTUUyekIsYUFFSnpxQixJQUFJcEc7TUpoZlQsSUlnZlNFO01BQVM7aUJBQVRBO1FBeUJZOztRQXpCSCxPQUFUQTs7ZUFDSTlDLEtBREo4QztXQUNpQixrQkFEckJrRztlQUFJbEcsUUFDSTlDOzs7ZUFDRUMsT0FGTjZDO1dBRWlCLGtCQUZyQmtHO2VBQUlsRyxRQUVNN0M7OztlQUNIQyxPQUhINEM7V0FHaUIsa0JBSHJCa0c7ZUFBSWxHLFFBR0c1Qzs7O2VBQ0VDLE9BSkwyQztXQUlpQixrQkFKckJrRztlQUFJbEcsUUFJSzNDOzs7ZUFDSUMsT0FMVDBDO1dBS2lCLGtCQUxyQmtHO2VBQUlsRyxRQUtTMUM7OztlQUNKQyxPQU5MeUM7V0FNaUIsa0JBTnJCa0c7ZUFBSWxHLFFBTUt6Qzs7O2VBQ0FDLE9BUEx3QztXQU9pQixrQkFQckJrRztlQUFJbEcsUUFPS3hDOzs7ZUFDREMsT0FSSnVDO1dBUWlCLGtCQVJyQmtHO2VBQUlsRyxRQVFJdkM7OztlQVVrQkMsT0FsQnRCc0MsV0FrQlc0d0IsVUFsQlg1d0I7V0FtQkosa0JBbkJBa0c7V0FtQjRCLGFBbkI1QkEsSUFrQmUwcUI7V0FFZixrQkFwQkExcUI7ZUFBSWxHLFFBa0JzQnRDOzs7ZUFHS0UsT0FyQjNCb0MsV0FxQmE2d0IsWUFyQmI3d0I7V0FzQkosa0JBdEJBa0c7V0FzQjRCLGFBdEI1QkEsSUFxQmlCMnFCO1dBRWpCLGtCQXZCQTNxQjtlQUFJbEcsUUFxQjJCcEM7OztlQVp0QkUsT0FUTGtDO1dBU2lCLGtCQVRyQmtHO2VBQUlsRyxRQVNLbEM7OztlQUNBQyxRQVZMaUM7V0FVaUIsa0JBVnJCa0c7ZUFBSWxHLFFBVUtqQzs7O2VBQ0ZDLFFBWEhnQztXQVdpQixrQkFYckJrRztlQUFJbEcsUUFXR2hDOzs7ZUFDR0MsUUFaTitCO1dBWWlCLGtCQVpyQmtHO2VBQUlsRyxRQVlNL0I7OztlQUVRQyxRQWRkOEI7V0FlSixrQkFmQWtHO2VBQUlsRyxRQWNjOUI7b0JBV0E7YUFJZDR5QjtnQkFJYSxJQUFMdHZCLFdBQVMsK0JBQVRBLE9BREcsUUFDMkI7YUE4RzFDdXZCLGNBQWNDO01BQ04sMEJBekdOL0MsSUF3R1krQyxNQXhHUm5COztNQUFZO2lCQUFoQjVCO2VBbFFGc0IsZ0JBK1BXcnBCOztRQUdPLE9BQWhCK25COztlQTBCSy93QixLQTFCTCt3QjtXQTJCQSxnQkE5QlMvbkI7V0E4QmdCLG9CQTlCaEJBLElBR0wycEI7V0E0QkosZ0JBL0JTM3BCO2VBR1QrbkIsSUEwQksvd0IsS0ExQkQyeUI7OztlQTZCTTF5QixPQTdCVjh3QjtXQThCQSxnQkFqQ1MvbkI7V0FpQ2dCLG9CQWpDaEJBLElBR0wycEI7V0ErQkosZ0JBbENTM3BCO2VBR1QrbkIsSUE2QlU5d0IsT0E3Qk4weUI7OztlQUNTenlCLE9BRGI2d0IsT0FDUXZ2QixJQURSdXZCO1dBRUEsZ0JBTFMvbkI7V0FLZ0Isb0JBTGhCQSxJQUdMMnBCO1dBR0osZUFOUzNwQixJQUlEeEg7V0FFZ0IsZ0JBTmZ3SDtlQUdUK25CLElBQ2E3d0IsT0FEVHl5Qjs7O2VBS2N4eUIsT0FMbEI0d0IsT0FLYXR2QixNQUxic3ZCO1dBTUEsZ0JBVFMvbkI7V0FTZ0Isb0JBVGhCQSxJQUdMMnBCO1dBT0osZUFWUzNwQixJQVFJdkg7V0FFVyxnQkFWZnVIO2VBR1QrbkIsSUFLa0I1d0IsT0FMZHd5Qjs7O2VBVW1CdnlCLE9BVnZCMndCLE9BVWlCcnZCLEtBVmpCcXZCLE9BVVlwdkIsTUFWWm92QixPQVVLbnZCLE1BVkxtdkI7V0F4SEosZ0JBcUhhL25CO1dBcEhiLG9CQW9IYUEsSUFHTDJwQjtXQXRIUixrQkFtSGEzcEIsSUFhSnBIO1dBL0hULGVBa0hhb0gsSUFhR3JIO1dBOUhoQixpQkFpSGFxSCxJQWFRdEg7V0E3SEQsZ0JBZ0hQc0gsSUFoSE8sY0E2SFhwSDtlQVZMbXZCLElBVXVCM3dCLE9BVm5CdXlCOzs7ZUFhcUJ0eUIsT0FiekIwd0IsT0FhbUJsdkIsT0FibkJrdkIsT0FhY2p2QixNQWJkaXZCLE9BYU9odkIsUUFiUGd2QjtXQWNBLGtCQWpCUy9uQixJQUdMMnBCLFNBYUc1d0IsUUFBT0QsTUFBS0Q7ZUFibkJrdkIsSUFheUIxd0IsT0FickJzeUI7OztlQWdCeUJyeUIsT0FoQjdCeXdCLE9BZ0J1Qi91QixPQWhCdkIrdUIsT0FnQmtCOXVCLE1BaEJsQjh1QixPQWdCVzd1QixRQWhCWDZ1QjtXQWlCQSxrQkFwQlMvbkIsSUFHTDJwQixTQWdCT3p3QixRQUFPRCxNQUFLRDtlQWhCdkIrdUIsSUFnQjZCendCLE9BaEJ6QnF5Qjs7O2VBbUJxQnB5QixPQW5CekJ3d0IsT0FtQm1CNXVCLE9BbkJuQjR1QixPQW1CYzN1QixNQW5CZDJ1QixPQW1CTzF1QixRQW5CUDB1QjtXQW9CQSxrQkF2QlMvbkIsSUFHTDJwQixTQW1CR3R3QixRQUFPRCxNQUFLRDtlQW5CbkI0dUIsSUFtQnlCeHdCLE9BbkJyQm95Qjs7O2VBc0JxQm55QixPQXRCekJ1d0IsT0FzQm1CenVCLE9BdEJuQnl1QixPQXNCY3h1QixNQXRCZHd1QixPQXNCT3Z1QixNQXRCUHV1QjtXQXZGSixnQkFvRmEvbkI7V0FuRmIsb0JBbUZhQSxJQUdMMnBCO1dBckZSLGtCQWtGYTNwQixJQXlCRnhHO1dBMUdYLGVBaUZhd0csSUF5Qkt6RztXQXpHbEIsaUJBZ0ZheUcsSUF5QlUxRztXQXhHSCxnQkErRVAwRyxJQS9FTyxjQXdHVHhHO2VBdEJQdXVCLElBc0J5QnZ3QixPQXRCckJteUI7OztlQWdDT2p5QixPQWhDWHF3QixPQWdDTXR1QixNQWhDTnN1QjtXQWlDQSxnQkFwQ1MvbkI7V0FvQ2dCLG9CQXBDaEJBLElBR0wycEI7V0FrQ0osZUFyQ1MzcEIsSUFtQ0h2RztXQUVrQixnQkFyQ2Z1RztlQUdUK25CLElBZ0NXcndCLE9BaENQaXlCOzs7ZUFtREUveEIsT0FuRE5td0I7V0FvREEsa0JBdkRTL25CO2VBR1QrbkIsSUFtRE1ud0I7OztlQUllQyxRQXZEckJrd0IsT0F1RGdCcnVCLElBdkRoQnF1QjtXQXdEQSxzQkEzRFMvbkIsSUEwRE90RztlQXZEaEJxdUIsSUF1RHFCbHdCOzs7ZUFHRkMsUUExRG5CaXdCLE9BMERjZ0QsTUExRGRoRDtXQTJEQSxvQkE5RFMvbkIsSUE2REsrcUI7ZUExRGRoRCxJQTBEbUJqd0I7OztlQUlTQyxRQTlENUJnd0IsT0E4RHFCbnVCLE1BOURyQm11QixPQThEWUgsUUE5RFpHO1dBK0RBLGdCQWxFUy9uQjtXQWtFZ0Isb0JBbEVoQkEsSUFHTDJwQjtXQWdFSixlQW5FUzNwQixJQWlFRzRuQjtXQUVnQixnQkFuRW5CNW5CO1dBb0VULGFBcEVTQSxJQWlFWXBHO1dBR0csZ0JBcEVmb0c7V0FvRXdDLGdCQXBFeENBO2VBR1QrbkIsSUE4RDRCaHdCLFFBOUR4QjR4Qjs7O2VBbUUwQjN4QixRQW5FOUIrdkIsT0FtRXVCanVCLFFBbkV2Qml1QixPQW1FY0MsVUFuRWREO1dBb0VBLGdCQXZFUy9uQjtXQXVFZ0Isb0JBdkVoQkEsSUFHTDJwQjtXQXFFSixlQXhFUzNwQixJQXNFS2dvQjtXQUVjLGdCQXhFbkJob0I7V0F5RVQsYUF6RVNBLElBc0VjbEc7V0FHQyxnQkF6RWZrRztXQXlFd0MsZ0JBekV4Q0E7ZUFHVCtuQixJQW1FOEIvdkIsUUFuRTFCMnhCOzs7ZUFvQ0UzdkIsUUFwQ04rdEI7V0FxQ0EsZ0JBeENTL25CO1dBd0NnQixvQkF4Q2hCQSxJQUdMMnBCO1dBc0NKLGdCQXpDUzNwQjtlQUdUK25CLElBb0NNL3RCLFFBcENGMnZCOzs7ZUF1Q0UxdkIsUUF2Q044dEI7V0F3Q0EsZ0JBM0NTL25CO1dBMkNnQixvQkEzQ2hCQSxJQUdMMnBCO1dBeUNKLGdCQTVDUzNwQjtlQUdUK25CLElBdUNNOXRCLFFBdkNGMHZCOzs7ZUF5RndCenZCLFFBekY1QjZ0QixPQXlGZ0I1dEIsV0F6RmhCNHRCO1dBMEZBLHNCQTdGUy9uQixJQTZGaUIseUJBRFY3RjtlQXpGaEI0dEIsSUF5RjRCN3RCOzs7ZUFHQUUsUUE1RjVCMnRCLE9BNEZnQjF0QixXQTVGaEIwdEI7V0E2RkEsc0JBaEdTL25CO1dBaUdULHNCQWpHU0EsSUFpR2lCLHlCQUZWM0Y7ZUE1RmhCMHRCLElBNEY0QjN0Qjs7O2VBNUNyQkUsUUFoRFB5dEI7V0FpREEsZ0JBcERTL25CO1dBb0RnQixvQkFwRGhCQSxJQUdMMnBCO1dBa0RKLGdCQXJEUzNwQjtlQUdUK25CLElBZ0RPenRCLFFBaERIcXZCOzs7ZUF5RWdDcHZCLFFBekVwQ3d0QixPQXlFMEJ2dEIsU0F6RTFCdXRCLE9BeUVldHRCLFVBekVmc3RCO1dBMEVBLGdCQTdFUy9uQjtXQTZFZ0Isb0JBN0VoQkEsSUFHTDJwQjtXQTJFSixlQTlFUzNwQixJQTRFTXZGO1dBOVNuQjtZQTRDSTZGO3NCQUFXTixJQUFJbEo7ZUFBVSxJQUd6QmlILEVBSHlCLFlBQVZqSDtlQUFVLGNBR3pCaUg7eUJBRk8sZ0JBRElpQyxRQUNKLGdCQURJQTsrQkFHWGpDOzJCQURPLGdCQUZJaUMsUUFFSixnQkFGSUE7MEJBR0osZ0JBSElBLElBR1hqQyxFQUE2QjtXQUVqQyxnQkFpTGFpQztXQWxPYjtZQW1ESzs0QkEyUHlCeEY7Z0JBMVByQixnQkE4S0l3RixRQTlLcUIsYUEwUEp4Rjs7WUE3UzVCOzt3QkFBSXl3QixTQUFTbHRCO2lCQUNpQzs0QkFEakNBO2tCQUNlLFdBRGZBO2tCQUVYLHlCQUZXQTtpQkFFWDtrQkFDUTs7NkJBQTZCOzs7O2lCQUh2QyxXQUdnRTtzQkFINURrdEI7WUFBSjtXQUlHLGdCQUFrQixnQkE2TlZqckI7V0FsT2IsSUFRa0JsSjs7V0FDaEI7Z0JBRGdCQTtlQUVYLHlCQUFtQixZQUZSQTtpQkFHVCxRQUhTQTtlQUtWLHNCQUxVQSxHQUtWOzs4Q0FDTSxXQW9ORGtKOzs7MkNBbk5JLFFBUENsSjs7ZUkrTVo7aUJKdk1HLElBQ1kyUyxJQVRIM1M7aUJBVWIseUJBQW1CLFlBREgyUzttQkFnQmpCLFdBaU1TekosSUFqTlF5SjttQkFnQmpCLFFBaEJpQkEsWUFUSDNTOztpQkFRVCxJQUdDLG9CQUZXMlMsS0FFWDs7Ozs7dUJBRUosV0E2TU96SixTQTdNUCxXQTZNT0E7Ozs7O3FCQTNNWSx5QkFBb0IsWUFOeEJ5Sjt1QkFPZixXQTBNT3pKLElBak5ReUo7dUJBT2YsUUFQZUEsWUFUSDNTOzs7Ozs7bUJBa0JELHlCQUFvQixZQVRoQjJTO3FCQVVmLFdBdU1PekosSUFqTlF5SjtxQkFXZixXQXNNT3pKLElBak5ReUo7cUJBV2YsUUFYZUEsWUFUSDNTOzttQkF1QlosTUFkZTJTLFlBY2YsSUFkZUEsWUFtQkZ5aEI7bUJBQ2pCO2dDQURpQkE7eUJBQ0Msb0JBQW9CLFlBRHJCQTt3QkFPZixRQVBlQTtxQkFFZixXQTRMU2xyQixJQTlMSW9tQjtxQkFHYixXQTJMU3BtQjtxQkExTFQsV0EwTFNBLElBOUxNa3JCO3FCQUlmLEdBSmVBLFdBS0MsUUFMREEsWUE1QkRwMEI7O2FBRGIsZ0JBQWtCLGdCQTJOVmtKO2FBNVFYa3BCLGdCQTRRV2xwQjtpQkFHVCtuQixJQXlFb0N4dEIsUUF6RWhDb3ZCOzs7ZUE2RXVCanZCLFFBN0UzQnF0QixPQTZFa0JwdEIsUUE3RWxCb3RCO1dBOEVBLGdCQWpGUy9uQjtXQWlGZ0Isb0JBakZoQkEsSUFHTDJwQjtXQTlPb0IsT0EyVE5odkI7Ozs7V0FFbEIsZ0JBbEZTcUY7ZUFHVCtuQixJQTZFMkJydEIsUUE3RXZCaXZCOzs7ZUFpRlcvdUIsUUFqRmZtdEI7V0FrRkEsZ0JBckZTL25CO1dBcUZnQixvQkFyRmhCQSxJQUdMMnBCO1dBbUZKLHNCQXRGUzNwQjtlQUdUK25CLElBaUZlbnRCLFFBakZYK3VCOzs7V0FzRndCO1lBRFI5dUIsUUFyRnBCa3RCO1lBcUZlanRCLElBckZmaXRCO1lBc0Y0Qix1Q0FEYmp0QixJQUFLRDtZQUNRO1lBdEY1Qmt0QjtZQUFJNEI7OztXQTJDVTtZQURJNXVCLFFBMUNsQmd0QjtZQTBDUTlzQixNQTFDUjhzQjtZQTJDYyx5QkFETjlzQjs7V0FDTTtpQkFBZCtxQjthQUNFOytCQS9DT2htQjtlQStDa0Isb0JBL0NsQkEsSUFHTDJwQjtlQTZDRixnQkFoRE8zcEI7ZUFnRFAsU0FGRmdtQjs7O1dBQWMsSUEzQ2QrQixJQTBDa0JodEIsUUExQ2Q0dUI7b0JBMkdXO2FBV2IwQjs7T0F1Qlk7O09BdkJaO2dCQU1ZLElBQVJyMEIsY0FBZ0IsZUFBaEJBO2dCQU9VLElBQVJDLGdCQUFrQixlQUFsQkE7Z0JBTkssSUFBUkMsZ0JBQWUsZUFBZkE7Z0JBQ1UsSUFBUkMsZ0JBQWlCLGVBQWpCQTtnQkFFWSxJQUFSQyxnQkFBcUIsZUFBckJBO2dCQURJLElBQVJDLGdCQUFpQixlQUFqQkE7Z0JBRVEsSUFBUkMsZ0JBQWlCLGVBQWpCQTtnQkFDTyxJQUFSQyxnQkFBZ0IsZUFBaEJBO29CQU9XQyxnQkFBSkMsWUFDSSxVQURKQSxHQUNJLEtBREFEOztjQUVRRSxnQkFBTFUsYUFBTFQ7VUFDVSxVQURMUyxJQUFMVCxJQUNVLEtBREFEO2lCQU5WLElBQVJFLGdCQUFpQixnQkFBakJBO2lCQURRLElBQVJDLGlCQUFpQixnQkFBakJBO2lCQUVNLElBQVJDLGlCQUFlLGdCQUFmQTtpQkFDVyxJQUFSQyxpQkFBa0IsZ0JBQWxCQTtpQkFDZ0IsSUFBUkMsaUJBQTBCLGdCQUExQkEsVUFLVTthQUV4QnN6Qjs7UUFTSjs4QkFHYSxRQUFJO1NBSGpCLHFCQUVhLFFBQUk7U0FGakIscUJBQ2EsUUFBSTtRQURqQiwwQkFBYSxRQUFJOztPQVRiOztVQWNKOztXQUFxQixvQkFEYnQwQjtXQUNhOzs7O2dDQUVHLFdBRmhCeTBCLE1BRWdCLFFBQWU7VUFGbEIsMEJBQ0csV0FEcEJDLE1BQ29CLFFBQWUsT0FEM0JGLEdBQUlEOztVQUtoQjs7V0FBcUIsc0JBRFh0MEI7V0FDVzs7OztnQ0FFRyxXQUZoQjQwQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFLaEI7O1dBQXFCLHNCQURkejBCO1dBQ2M7Ozs7Z0NBRUcsV0FGaEIrMEIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBS2hCOztXQUFxQixzQkFEWjUwQjtXQUNZOzs7O2dDQUVHLFdBRmhCazFCLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQVVoQjs7V0FBcUIsc0JBRFIvMEI7V0FDUTs7OztnQ0FFRyxXQUZoQnExQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFMaEI7O1dBQXFCLHNCQURabDFCO1dBQ1k7Ozs7Z0NBRUcsV0FGaEJ3MUIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBVWhCOztXQUFxQixzQkFEWnIxQjtXQUNZOzs7O2dDQUVHLFdBRmhCMjFCLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtoQjs7V0FBcUIsc0JBRGJ4MUI7V0FDYTs7OztnQ0FFRyxXQUZoQjgxQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFpQ2hCOztXQUFxQixzQkFERDMxQjtXQUNDOzs7O2dDQUVHLFdBRmhCaTJCLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtLO1dBRE03MUI7V0FBTFU7V0FBTFQ7V0FDSSxzQkFETUQ7V0FDTjs7OztXQUNaLFNBQU0sS0FGRUMsS0FBS1M7V0FHRCxzQkFEakJYO1dBQ2lCOzs7O2dDQUlHLFdBSlJ1MkIsTUFJOEIsV0FOOUJMLFFBTThCLFFBQWU7V0FKeEMscUJBR0csV0FMWkMsUUFLa0MsV0FIbENLLE1BR2tDLFFBQWU7V0FIeEMscUJBRUcsV0FGaEJDLE1BRXNDLFdBSnRDTCxRQUlzQyxRQUFlO1VBRnhDOztvQkFDRyxXQUhwQkMsUUFHMEMsV0FEMUNLLE1BQzBDLFFBQWU7Ozs7O1VBOUI3RDs7V0FBcUIsdUJBRFp2MkI7V0FDWTs7OztnQ0FFRyxXQUZoQjAyQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFMaEI7O1dBQXFCLHVCQURadjJCO1dBQ1k7Ozs7Z0NBRUcsV0FGaEI2MkIsU0FFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsU0FDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBVWhCOztXQUFxQix1QkFEZDEyQjtXQUNjOzs7O2dDQUVHLFdBRmhCZzNCLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtoQjs7V0FBcUIsdUJBRFg3MkI7V0FDVzs7OztnQ0FJRyxXQUpSaTNCLFNBSVEsUUFBZTtXQUpsQixxQkFHRyxXQUhaQyxTQUdZLFFBQWU7V0FIbEIscUJBRUcsV0FGaEJDLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7Ozs7O1VBS3ZDOztXQUFxQix1QkFESG4zQjtXQUNHOzs7O2dDQUlHLFdBSlJvM0IsU0FJUSxRQUFlO1dBSmxCLHFCQUdHLFdBSFpDLFNBR1ksUUFBZTtXQUhsQixxQkFFRyxXQUZoQkMsU0FFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsU0FDb0IsUUFBZTs7O3dCQWdCdUI7YUFpQjlEeEIsTUFXRXAyQixJQUFJaVA7TUFBTyxVQUFYalA7aUJBQUlpUDtRQThDd0I7O2VBOUN4QkE7Ozs7Ozs7O2tCQStDYTs7T0EvQ04sT0FBWGpQOzs7b0JBQUlpUDs7OztvQkFDMEIsSUFBVDRvQixNQURqQjVvQixTQUNrQyxxQkFBakI0b0I7Ozs7Ozs7Ozs7OzttQkFEckI3M0I7b0JBQUlpUDs7OztvQkFFOEIsSUFBVDZvQixRQUZyQjdvQixTQUV3QyxxQkFBbkI2b0I7Ozs7Ozs7Ozs7OzttQkFGekI5M0I7b0JBQUlpUDs7OztvQkFJd0IsSUFBVDhvQixRQUpmOW9CLFNBSStCLHFCQUFoQjhvQjs7Ozs7Ozs7Ozs7O21CQUpuQi8zQjtvQkFBSWlQOzs7O29CQUs0QixJQUFUK29CLFFBTG5CL29CLFNBS3FDLHFCQUFsQitvQjs7Ozs7Ozs7Ozs7O21CQUx2Qmg0QjtvQkFBSWlQOzs7O29CQU9vQyxJQUFUZ3BCLFFBUDNCaHBCLFNBT2lELHFCQUF0QmdwQjs7Ozs7Ozs7Ozs7O21CQVAvQmo0QjtvQkFBSWlQOzs7O29CQU00QixJQUFUaXBCLFFBTm5CanBCLFNBTXFDLHFCQUFsQmlwQjs7Ozs7Ozs7Ozs7O21CQU52Qmw0QjtvQkFBSWlQOzs7O29CQVE0QixJQUFUa3BCLFFBUm5CbHBCLFNBUXFDLHFCQUFsQmtwQjs7Ozs7Ozs7Ozs7O21CQVJ2Qm40QjtvQkFBSWlQOzs7O29CQUcwQixJQUFUbXBCLFFBSGpCbnBCLFNBR2tDLHFCQUFqQm1wQjs7Ozs7Ozs7Ozs7O21CQUhyQnA0QjtvQkFBSWlQOzs7OztjQWdDd0IsSUFEa0JvcEIsUUEvQjFDcHBCLFNBK0JxQ3hPLElBL0JyQ3dPLFNBZ0N3QixnQkFEa0JvcEI7Y0FDakMscUJBRDRCNTNCOzs7Ozs7Ozs7O21CQS9CekNUO29CQUFJaVA7Ozs7OztjQXNDRztlQURvQnFwQixRQXJDdkJycEI7ZUFxQ2lCc3BCLEtBckNqQnRwQjtlQXFDV3VwQixLQXJDWHZwQjtlQXNDRyxTQUFNLFdBREV1cEI7ZUFFRSxzQkFEZjE0QjtlQUNlOztjQUNSLFdBREo0NEI7Y0FFSSxXQUZHRDtjQUdlLGVBTE5GLEtBS00sV0FMQUQ7Ozs7Ozs7Ozs7bUJBckMzQnQ0QjtvQkFBSWlQO1lBVTRCLElBQVQwcEIsUUFWbkIxcEIsU0FVcUMsc0JBQWxCMHBCO1VBQ1I7O21CQVhmMzRCO29CQUFJaVA7Ozs7O3FCQWM0QixJQUFUMnBCLFNBZG5CM3BCLFNBY3FDLHNCQUFsQjJwQjs7Ozs7bUJBZHZCNTRCO29CQUFJaVA7Ozs7OztxQkFrQndCLElBQVQ0cEIsU0FsQmY1cEIsU0FrQitCLHNCQUFoQjRwQjs7Ozs7bUJBbEJuQjc0QjtvQkFBSWlQOzs7Ozs7O3FCQXNCOEIsSUFBVDZwQixTQXRCckI3cEIsU0FzQndDLHNCQUFuQjZwQjs7Ozs7bUJBdEJ6Qjk0QjtvQkFBSWlQOzs7Ozs7OztxQkEyQk4sSUFEMkM4cEIsU0ExQnJDOXBCLFNBMkJZLHNCQUR5QjhwQjs7O01JaFR2QztlSmtTYTtlQUlBO2VBSUY7ZUFJRztlQUtRO2VBS0o7ZUFVRTtnQkFJTCw4QkFBWTthQWtHL0JDLHVCQUVFbjRCLElBQUlvQjtNQUFTLGNBQWJwQixpQkFBSW9CLFlBQUpwQixPQUFJb0IsZUFHeUI7YUFyQy9CZzNCLGdCQUdBMzFCLE1BQU1yQjtNQUFTLEdBQWZxQjtRQUVxQixJQUFUNDFCLFFBRlo1MUIsU0FFNEIsMkJBQWhCNDFCLFFBRk5qM0I7TUFDUyxPQURUQSxLQUVtRDthQTdEekRrM0IsYUFFQWwzQjtNSjMxQkwsSUkyMUJLRTtNQUFTO2lCQUFUQTtRQW9EOEI7O1FBcERyQixPQUFUQTtpQkEyQjhCLElBQXpCOUMsS0EzQkw4QyxXQTJCc0MsdUJBQWpDOUM7aUJBQ3lCLElBQXBCQyxPQTVCVjZDLFdBNEJzQyx1QkFBNUI3Qzs7ZUEzQkdDLE9BRGI0QyxXQUNRdEIsSUFEUnNCO1dBRXNDLDhCQUQ5QnRCLE9BQzhCLGFBRHpCdEI7O2VBRUtDLE9BSGxCMkMsV0FHYXJCLE1BSGJxQjtXQUlzQyw4QkFEekJyQixTQUN5QixhQURwQnRCOztXQUlKO1lBREtDLE9BTm5CMEM7WUFNYXBCLEtBTmJvQjtZQU1RbkIsTUFOUm1CO1lBT2MscUJBREsxQztZQUVMLGlDQUZEc0IsUUFDVHE0QjtXQUNVLDhCQUZOcDRCLE1BRUpxNEI7O1dBR1U7WUFETzM1QixPQVZyQnlDO1lBVWVqQixPQVZmaUI7WUFVVWhCLE1BVlZnQjtZQVdjLHVCQURPekM7WUFFUCxtQ0FGQ3dCLFVBQ1hxNEI7V0FDVSw4QkFGSnA0QixNQUVOcTRCOztXQUdVO1lBRFc3NUIsT0FkekJ3QztZQWNtQmQsT0FkbkJjO1lBY2NiLE1BZGRhO1lBZWMsdUJBRFd4QztZQUVYLG1DQUZLMEIsVUFDZm80QjtXQUNVLDhCQUZBbjRCLE1BRVZvNEI7O1dBR1U7WUFETzk1QixPQWxCckJ1QztZQWtCZVgsT0FsQmZXO1lBa0JVVixNQWxCVlU7WUFtQmMsdUJBRE92QztZQUVQLG1DQUZDNEIsVUFDWG00QjtXQUNVLDhCQUZKbDRCLE1BRU5tNEI7O1dBR1U7WUFETy81QixPQXRCckJzQztZQXNCZVIsT0F0QmZRO1lBc0JVUCxNQXRCVk87WUF1QmMsdUJBRE90QztZQUVQLG1DQUZDOEIsVUFDWGs0QjtXQUNVLDhCQUZKajRCLE1BRU5rNEI7O2VBS08vNUIsT0E3QlhvQyxXQTZCTUwsTUE3Qk5LO1dBNkJrRSw4QkFBNURMLFNBQTRELGFBQXZEL0I7a0JBV21CLFlBeEM5Qm9DO2tCQXlDOEIsWUF6QzlCQTtrQkEwQzhCLFlBMUM5QkE7O2VBbUNtQmxDLE9BbkNuQmtDLFdBbUNlckMsR0FuQ2ZxQztXQW9DbUIsVUFESnJDLEdBQ0ksYUFEQUc7O2VBRUVDLFFBckNyQmlDLFdBcUNpQiszQixLQXJDakIvM0I7V0FzQ3lCLFVBRFIrM0IsVUFDUSxhQURKaDZCO2tCQVBTLElBQXhCQyxRQTlCTmdDLFdBOEJ1Qyx3QkFBakNoQztrQkFDd0IsSUFBeEJDLFFBL0JOK0IsV0ErQnVDLHdCQUFqQy9CO2tCQWlCd0IsWUFoRDlCK0I7O1dBa0RrRDtZQUR0QjlCLFFBakQ1QjhCO1lBaURnQk8sV0FqRGhCUDtZQWtEa0Qsa0JBRHRCOUI7V0F4RFYsU0F3REZxQztvQ0F2REUwdEIsa0JBSWxCK0ksYUFKa0IvSTs7O3FCQXVERjF0QjthQXRERSt3QjtrQkFHbEIwRixhQUhrQjFGO2tCSTFSZG56QjtrQkpnVTBCLElBQXZCK0IsUUFqQ1BGLFdBaUN3Qyx3QkFBakNFO2tCQVd1QixJQUFUQyxRQTVDckJILFdBNEN3Qyx1QkFBbkJHO2tCQUNTLElBQVRDLFFBN0NyQkosV0E2Q3FDLHVCQUFoQkk7a0JBQ1MsSUFBZkUsUUE5Q2ZOLFdBOENzQyx1QkFBdkJNOztlQUNLRSxRQS9DcEJSLFdBK0NlZ0IsSUEvQ2ZoQjtXQW1FVyxVQXBCSWdCO1lBb0JKLE9BcEJJQTt5QkEvQ2ZoQixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7cUJBaUNpQyx3QkFqQ2pDQTswQkEvQ3BCUixRQStDb0JROztZQW9CVCxPQXBCSVE7eUJBL0NmaEIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7eUJBL0NwQlIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7eUJBL0NwQlIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7O2VBZ0NlLElBQVZ5M0IsUUFoQ1ZqM0I7ZUFnQ3VDLG9CQUE3QmkzQixRQUE2QixhQWhDbEN6M0I7MEJBL0NwQlIsUUErQ29CUTswQkEvQ3BCUixRQStDb0JROztlQWZGQyxRQWhDbEJULFdBZ0NRbUIsTUFoQ1JuQjtXQWdDb0QsdUJBQTVDbUIsTUFBNEMsYUFBbENWLFVBb0J3QjthQTBDMUMwMkIseUJBRUV2NEIsS0FBS2tCO01BQVMsY0FBZGxCLDZCQUFLa0IscUJBRzBCOzs7O2FBV2pDbzRCLGFBR0F4NUIsSUFBSW9PO01BQVMsVUFBYnBPO09BQ2lCLFlBRGJvTzs7UUFBUyxTQUFicE87Y0FFb0J5NUIsRUFGcEJ6NUIsT0FFYWl4QixNQUZianhCLG9CQUVhaXhCLE1BQU93SSxHQUZoQnJyQjs7Y0FHc0I1UCxLQUh0QjRQLFNBR1FrakIsUUFIWnR4QixvQkFHWXN4QixTQUFjOXlCO1FBQ3JCLG9CQUFtQjthQUt4Qms3QixhQUdBMTVCLElBQUlFLEtBQUtrQjtNQUFxQix1QkFBOUJwQixJQUFTb0I7TUFBcUIsVUFBMUJsQjs7Y0FDa0MxQixjQUFMeUIsaUNBQUt6Qjs7O2NBSVFDLGVBQVowQixpQ0FBWTFCO1FBRWY7TUFQRCxJQUdXQyxnQkFBTDRCLGVBQXRCeU4sRUFIVjdOO2dCQUdnQ0ksU0FBdEJ5TixHQUEyQnJQLE9BSVM7YUFNOUNpN0IsWUFNRnBLLElBQUludUI7TUFBZSx5QkFBbkJtdUIsSUFBSW51QjtNQUFlLGdDQUNpQixJQUF2Qnd4QixjQUF1QixPQUF2QkE7TUFDVixtQkFBbUI7YUFrTHhCaUgsdUJBS0V2M0IsSUFBSWl0QixJQUFJbnVCO01BQ3VCLDBCQUQzQm11QixJQUFJbnVCLE9BQ3VCO29CQUQvQmtCLElBQ2Vzd0IsT0FBTXR4QixRQUN3QjthQXZML0NzNEIsZ0JBTUVySyxJQTRJTW51QjtNQTVJTyxVQUFibXVCO09BbUgyQixZQXlCckJudUI7O09BNUlPLE9BQWJtdUI7O29CQTRJTW51QjtZQTFJMkI7YUFEWjA0QixXQTJJZjE0QjthQTNJSDI0QixTQURIeEs7YUFFaUMsc0JBRDlCd0ssU0FBa0JEO2FBQ1k7O3lCQUFoQmxILE9BQU10eEI7OztvQkEwSWpCRjtZQXZJMkI7YUFEUDQ0QixhQXdJcEI1NEI7YUF4SUU2NEIsV0FKUjFLO2FBS2lDLHdCQUR6QjBLLFdBQWtCRDthQUNPOzt5QkFBaEIxSCxPQUFNNEc7OztVQUduQjtXQURPZ0IsV0FQWDNLO1dBT012dkIsSUFQTnV2QjtXQVFJLGtCQURFdnZCLElBcUlBb0I7V0FwSUY7OztZQUVKOzthQUFtQyx3QkFIeEI4NEIsV0FFdUJDO2FBQ0M7OzhCQUFoQkMsT0FBTWpCO1VBRUc7O1VBR3hCO1dBRFlrQixXQWRoQjlLO1dBY1d0dkIsTUFkWHN2QjtXQWVJLGtCQURPdHZCLE1BOEhMbUI7V0E3SEY7OztZQUVKOzthQUFtQyx3QkFIbkJpNUIsV0FFa0JDO2FBQ0M7OzhCQUFoQkMsT0FBTW5CO1VBRUc7O1VBR3hCO1dBRGlCb0IsV0FyQnJCakw7V0FxQmVydkIsS0FyQmZxdkI7V0FxQlVwdkIsTUFyQlZvdkI7V0FxQkdudkIsTUFyQkhtdkI7V0FzQkksa0JBRE1wdkIsTUFBS0QsS0F1SFRrQjtXQXRIRjs7OztZQUVKOzthQUFtQyx3QkFIZG81QixXQUVnQkM7YUFDRjs7eUJBSGhDcjZCLGdCQUdnQnM2QixPQUFNcEI7VUFFTTs7VUFHM0I7V0FEbUJxQixXQTVCdkJwTDtXQTRCaUJsdkIsT0E1QmpCa3ZCO1dBNEJZanZCLE1BNUJaaXZCO1dBNEJLaHZCLFFBNUJMZ3ZCO1dBNkJJLGtCQURRanZCLE1BQUtELE9BZ0hYZTtXQS9HRjs7OztZQUVKOzthQUFtQyx3QkFIWnU1QixXQUVnQkM7YUFDSjs7eUJBSDlCcjZCLGtCQUdjczZCLE9BQU10QjtVQUVNOztVQUczQjtXQUR1QnVCLFdBbkMzQnZMO1dBbUNxQi91QixPQW5DckIrdUI7V0FtQ2dCOXVCLE1BbkNoQjh1QjtXQW1DUzd1QixRQW5DVDZ1QjtXQW9DSSxrQkFEWTl1QixNQUFLRCxPQXlHZlk7V0F4R0Y7Ozs7WUFFSjs7YUFBbUMsd0JBSFIwNUIsV0FFZ0JDO2FBQ1I7O3lCQUgxQnI2QixrQkFHVXU2QixPQUFNRDtVQUVNOztVQUczQjtXQURtQkUsV0ExQ3ZCM0w7V0EwQ2lCNXVCLE9BMUNqQjR1QjtXQTBDWTN1QixNQTFDWjJ1QjtXQTBDSzF1QixRQTFDTDB1QjtXQTJDSSxrQkFEUTN1QixNQUFLRCxPQWtHWFM7V0FqR0Y7Ozs7WUFFSjs7YUFBbUMsd0JBSFo4NUIsV0FFZ0JDO2FBQ0o7O3lCQUg5QnQ2QixrQkFHY3c2QixPQUFNRDtVQUVNOztVQUczQjtXQURtQkUsV0FqRHZCL0w7V0FpRGlCenVCLE9BakRqQnl1QjtXQWlEWXh1QixNQWpEWnd1QjtXQWlES3Z1QixNQWpETHV1QjtXQWtESSxrQkFEUXh1QixNQUFLRCxPQTJGWE07V0ExRkY7Ozs7WUFFSjs7YUFBbUMsd0JBSFprNkIsV0FFZ0JDO2FBQ0o7O3lCQUg5QnY2QixnQkFHY3k2QixPQUFNRDtVQUVNOztVQUczQjtXQURLRSxXQXhEVG5NO1dBd0RJdHVCLE1BeERKc3VCO1dBeURJLGtCQURBdHVCLE1Bb0ZFRztXQW5GRjs7O1lBRUo7O2FBQW1DLHdCQUgxQnM2QixXQUV1QkM7YUFDRzs7OEJBQWhCRSxPQUFNRDtVQUVHOztVQUdLO1dBRDdCRSxXQS9ESnZNO1dBZ0VpQyx3QkFEN0J1TSxXQTZFRTE2QjtXQTVFMkI7O3dCQUFoQjQ2QixRQUFNRDs7VUFJVTtXQURkRSxZQW5FbkIxTTtXQW1FY3J1QixJQW5FZHF1QjtXQW9FaUMseUJBRGQwTSxZQXlFYjc2QjtXQXhFMkI7O3dCQURuQkYsSUFDR2k3QixRQUFNRDs7VUFHVTtXQURoQkUsWUF0RWpCN007V0FzRVlwdUIsSUF0RVpvdUI7V0F1RWlDLHlCQURoQjZNLFlBc0VYaDdCO1dBckUyQjs7d0JBRHJCRCxJQUNLbTdCLFFBQU1EOztvQkFxRWpCajdCOzthQWpFbUJtN0IsYUFpRW5CbjdCO2FBakVPOHdCLFVBaUVQOXdCO2FBbEV3Qm83QixZQTFFOUJqTjthQTBFbUI0QyxZQTFFbkI1QzthQTBFVUgsUUExRVZHO1lBNEVDLG9CQUZrQjRDLGdCQUNORDs7WUFFb0I7c0NBSEhzSyxZQUNMRDthQUVROzswQkFIdkJuTixRQUNHOEMsVUFFSXdLLFFBQU1EOzs7b0JBK0RqQnI3QjtZQTNEd0M7YUFETnU3QixjQTREbEN2N0I7YUE1RFN3N0IsV0E0RFR4N0I7YUE3RDBCeTdCLFlBL0VoQ3ROO2FBK0VxQnVOLFlBL0VyQnZOO2FBK0VZQyxVQS9FWkQ7YUFpRjhDLGtCQUQvQnFOO1lBQ2Qsb0JBQVUsVUFGVUU7O1lBRXlCO2FBRzlDLHlCQUxnQ0QsWUFLUCxVQUplRjthQUl4Qzs7MEJBTFluTixVQUNHb04sV0FHRUksUUFBTUQ7OztvQkF5RGpCMzdCO1lBbkQyQjthQURWNjdCLGNBb0RqQjc3QjthQXBERjg3QixZQXhGSjNOO2FBeUZpQyx5QkFEN0IyTixZQUFtQkQ7YUFDVTs7MEJBQWhCRyxRQUFNRDs7O29CQW1EakIvN0I7WUFoRDJCO2FBRFZpOEIsY0FpRGpCajhCO2FBakRGazhCLFlBM0ZKL047YUE0RmlDLHlCQUQ3QitOLFlBQW1CRDthQUNVOzswQkFBaEJHLFFBQU1EOzs7VUFLVTtXQURIRSxZQWhHOUJsTztXQWdHYy94QixlQWhHZCt4QjtXQWlHaUMseUJBREhrTyxZQTRDeEJyOEI7V0EzQzJCOzt3QkFEbkI1RCxlQUNHbWdDLFFBQU1EOztjQUVPRSxZQW5HOUJyTyxPQW1HY3VDLGVBbkdkdkM7VUE0SDRCLFNBekJkdUM7WUEyQm1CO3NCQTNCbkJBO2FBMEJRRjthQUFOOXhCO2FBQ2lCLHlCQURqQkEsS0FlVnNCO2FBZDJCOzthQUNBLHlCQTVCSHc4QixZQTJCUGorQjthQUNVOztnQ0FEaEJJLEtBREs2eEIsUUFFTGtNLE1BQU1EO1VBR1U7b0JBL0JuQi9MO1dBOEJRaU07V0FBTkM7V0FDaUIseUJBRGpCQSxPQVdWNThCO1dBVjJCOztXQUNBLHlCQWhDSHc4QixZQStCUEs7V0FDVTs7OEJBRGhCQyxPQURLSCxRQUVMSyxRQUFNRDs7b0JBU2pCLzhCO1lBcEMyQjthQURSaTlCLGNBcUNuQmo5QjthQXJDRGs5QixZQXZHTC9PO2FBd0dpQyx5QkFENUIrTyxZQUFvQkQ7YUFDUTs7MEJBQWhCRyxRQUFNRDs7O29CQW9DakJuOUI7WUFqQzJCO2FBRHNCcTlCLGNBa0NqRHI5QjthQWxDNEJzOUIsWUExR2xDblA7YUEwR3dCdnRCLFNBMUd4QnV0QjthQTBHYXR0QixVQTFHYnN0QjthQTJHaUMseUJBRENtUCxZQUFxQkQ7YUFDdEI7OzBCQURwQng4QixVQUFXRCxTQUNQNDhCLFFBQU1EOzs7b0JBaUNqQnY5QjtZQTlCMkI7YUFEVXk5QixjQStCckN6OUI7YUEvQm1CMDlCLFlBN0d6QnZQO2FBNkdnQnB0QixRQTdHaEJvdEI7YUE4R2lDLHlCQURSdVAsWUFBa0JEO2FBQ1Y7OzBCQURqQjE4QixRQUNDNjhCLFFBQU1EOzs7Y0FFTHZnQyxLQWhIbEIrd0IsT0FnSGFqdEIsSUFoSGJpdEI7VUE0SWUsVUE1QkZqdEI7V0E0QkUsT0E1QkZBO29CQTZCdUIsOEJBN0J2QkEsSUFBSzlELEtBNEJaNEM7b0JBRThCLDhCQTlCdkJrQixJQUFLOUQsS0E0Qlo0Qzs7Y0FzQlUsVUF0QlZBO2dCQXlCTjsrQkF6Qk1BO2lCQXlCNkIseUJBckRqQjVDLEtBb0RBeWdDO2lCQUNpQjs7Z0NBQWhCRSxRQUFNRDtjQUVwQjtxQkFkK0IsOEJBekN2QjU4QixJQUFLOUQsS0E0Qlo0Qzs7V0FBUyxPQTVCRmtCO29CQStCdUIsOEJBL0J2QkEsSUFBSzlELEtBNEJaNEM7b0JBSThCLDhCQWhDdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFLOEIsOEJBakN2QmtCLElBQUs5RCxLQTRCWjRDO29CQU04Qiw4QkFsQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBTzhCLDhCQW5DdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFROEIsOEJBcEN2QmtCLElBQUs5RCxLQTRCWjRDO29CQVM4Qiw4QkFyQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBVThCLDhCQXRDdkJrQixJQUFLOUQsS0E0Qlo0Qzs7a0JBY3FCZytCLFlBMUNkOThCLE9BMENLbXRCLFVBMUNMbnRCO3FCQTBEZnUzQjswQkFoQm9CcEssVUFBUzJQLGFBMUNUNWdDLEtBNEJaNEM7O2NBa0JOO2VBRjZCaStCLFlBNUNoQi84QjtlQTRDT290QixVQTVDUHB0QjtlQThDYixzQ0FGNkIrOEIsWUE1Q1g3Z0MsS0E0Qlo0QztlQWtCTjs7OzsrQkFGb0JzdUIsVUFDSCtQLGFBQTJCRCxRQUFNRDtxQkFOZCw4QkF2Q3ZCajlCLElBQUs5RCxLQTRCWjRDO3FCQVk4Qiw4QkF4Q3ZCa0IsSUFBSzlELEtBNEJaNEM7O01BdkJILG1CQUFtQjthQStEeEJrK0IsaUNBSUFwTixVQUFVM0MsSUFBSW5oQjtNQUFTLFVBQXZCOGpCO09BMEU2Qiw0QkExRW5CM0MsSUFBSW5oQjs7T0FBUyxPQUF2QjhqQjs7b0JBQWM5akI7WUFHWjthQUY4QjByQixXQURsQjFyQjthQUNOc3hCLGVBRFJ4TjthQUdFOytDQUZNd04sZUFERW5RLElBQ3NCdUs7YUFFOUI7O3lCQURpQjZGLGtCQUFpQi9NOzs7b0JBRnRCeGtCO1lBT1o7YUFGa0M0ckIsYUFMdEI1ckI7YUFLSnd4QixpQkFMVjFOO2FBT0U7O2dCQUZRME4saUJBTEFyUSxJQUswQnlLO2FBRWxDOzt5QkFEaUI2RixrQkFBaUJ2Tjs7O29CQU50QmxrQjtZQVdaO2FBRjRCK3JCLGFBVGhCL3JCO2FBU1AweEIsaUJBVFA1TjthQVdFOztnQkFGSzROLGlCQVRHdlEsSUFTb0I0SzthQUU1Qjs7eUJBRGlCNEYsa0JBQWlCM0Y7OztvQkFWdEJoc0I7WUFlWjthQUZnQ2tzQixhQWJwQmxzQjthQWFMNHhCLGlCQWJUOU47YUFlRTs7Z0JBRk84TixpQkFiQ3pRLElBYXdCK0s7YUFFaEM7O3lCQURpQjJGLGtCQUFpQjFGOzs7b0JBZHRCbnNCO1lBbUJaO2FBRndDcXNCLGFBakI1QnJzQjthQWlCRDh4QixpQkFqQmJoTzthQW1CRTs7Z0JBRldnTyxpQkFqQkgzUSxJQWlCZ0NrTDthQUV4Qzs7eUJBRGlCMEYsa0JBQWlCekY7OztvQkFsQnRCdHNCO1lBdUJaO2FBRmdDd3NCLGFBckJwQnhzQjthQXFCTGd5QixpQkFyQlRsTzthQXVCRTs7Z0JBRk9rTyxpQkFyQkM3USxJQXFCd0JxTDthQUVoQzs7eUJBRGlCeUYsbUJBQWlCeEY7OztvQkF0QnRCenNCO1lBMkJaO2FBRmdDMnNCLGFBekJwQjNzQjthQXlCTGt5QixrQkF6QlRwTzthQTJCRTs7Z0JBRk9vTyxrQkF6QkMvUSxJQXlCd0J3TDthQUVoQzs7eUJBRGlCd0YsbUJBQWlCdEY7OztvQkExQnRCN3NCO1lBK0JaO2FBRjhCK3NCLGFBN0JsQi9zQjthQTZCTm95QixrQkE3QlJ0TzthQStCRTs7Z0JBRk1zTyxrQkE3QkVqUixJQTZCc0I0TDthQUU5Qjs7eUJBRGlCc0YsbUJBQWlCcEY7OztvQkE5QnRCanRCOzthQW1EY210QixhQW5EZG50QjthQW1EQ3N5QixXQW5ERHR5QjthQWtEYXV5QixrQkFsRDNCek87YUFrRGUwTyxhQWxEZjFPO1lBb0RHLG9CQUZZME8saUJBQ0FGOztZQUdiOzs7Z0JBSnlCQyxrQkFsRGpCcFIsSUFtRGtCZ007YUFHMUI7O3lCQUhhbUYsV0FFSUcsbUJBQWlCcEY7OztvQkFyRHRCcnRCO1lBMkRtQzthQUZOdXRCLGFBekQ3QnZ0QjthQXlEZ0IweUIsYUF6RGhCMXlCO2FBeURHMnlCLFdBekRIM3lCO2FBd0Q2QjR5QixrQkF4RDNDOU87YUF3RDhCK08sYUF4RDlCL087YUF3RGlCZ1AsYUF4RGpCaFA7YUEyRGlELGtCQUZoQzZPO1lBRWQsb0JBQVUsVUFISUc7O1lBR2dDLFlBRUEsVUFKbkJKO1lBSTNCLG9CQUFVLFVBTGlCRzs7WUFHbUI7YUFJaEMsa0JBQU0sS0FOTkYsWUFBYUQ7YUFPWCxzQkFEZjNPO2FBQ2U7O1lBQ1IsV0FESjBGO1lBRUksV0FGR0Q7WUFMbUM7YUFTL0M7O2dCQUFpQyxVQVpRb0osbUJBeERqQ3pSLElBeURpQ29NO2FBV3pDOztZQUc4Qjt1QkFkZm9GLFdBQWFELGFBY0UsS0FKYks7b0JBQWlCdEY7OztvQkFuRXRCenRCO1lBbUNaO2FBRmdDbXVCLGFBakNwQm51QjthQWlDTGd6QixrQkFqQ1RsUDthQW1DRTs7Z0JBRk9rUCxrQkFqQ0M3UixJQWlDd0JnTjthQUVoQzs7MEJBRGlCOEUsbUJBQWlCckY7OztvQkFsQ3RCNXRCO1lBdUNaO2FBRmdDdXVCLGNBckNwQnZ1QjthQXFDTGt6QixrQkFyQ1RwUDthQXVDRTs7Z0JBRk9vUCxrQkFyQ0MvUixJQXFDd0JvTjthQUVoQzs7MEJBRGlCNEUsbUJBQWlCcEY7OztvQkF0Q3RCL3RCO1lBMkNaO2FBRmtDNnVCLGNBekN0Qjd1QjthQXlDSm96QixrQkF6Q1Z0UDthQTJDRTs7Z0JBRlFzUCxrQkF6Q0FqUyxJQXlDMEIwTjthQUVsQzs7MEJBRGlCd0UsbUJBQWlCbkY7OztvQkExQ3RCbHVCO1lBK0NaO2FBRmtEaXZCLGNBN0N0Q2p2QjthQTZDSXN6QixrQkE3Q2xCeFA7YUErQ0U7O2dCQUZnQndQLGtCQTdDUm5TLElBNkMwQzhOO2FBRWxEOzswQkFEaUJzRSxtQkFBaUJqRjs7O01BNkIvQixtQkFBbUI7YUEwQnhCa0YsT0FRRXJTLElBQUludUIsT0FDUSxtQkFEWm11QixJQUNZLFVBQVcsS0FEbkJudUIsUUFDZ0M7YUFNdEN5Z0MsWUFBWTVRLE1BQU01QixNQUFNbnVCO01BQzFCO2lDQUQwQkE7T0FDMUIsYUFEb0JtdUIsTUFBTjRCO09BR1osWUFIa0I1QjtNQUdsQixjQUZFbnBCLFdBRHNCaEY7TUFDMUIsSUFjRSxXQWZZb3dCLGNBZUY7YUFmRUE7ZUFpQkQsT0FqQmFwd0IsTUFlcEIwRyxNQWRGMUI7ZUFpQlMsT0FsQmFoRixNQWVwQjBHLGNBZEYxQjs7U0FrQlcsT0FsQlhBO1dBa0J1QiwwQkFuQkRoRjs7O3NCQW1Ca0IsZ0JBbkJsQkE7Ozt1QkFtQm1DLGdCQW5CbkNBOzs7OzthQW9CdEIsZUFMRTBHLE1BS2MsZ0JBcEJNMUc7YUFxQnRCLE9BckJzQkEsTUFlcEIwRyxlQWRGMUI7Ozs7U0l6eEJFO1dKOHlCUyxPQXJCWEE7c0JBcUJzQixnQkF0QkFoRjtjQXNCa0IsMkJBdEJsQkE7Ozt5QkFzQm1DLGdCQXRCbkNBOzs7OztnQkF1QnRCLGVBUkUwRyxNQVFjLGdCQXZCTTFHO2dCQXdCdEIsT0F4QnNCQSxNQWVwQjBHLGVBZEYxQjs7Ozs7O3lCQXlCQSxPQTFCc0JoRixNQWVwQjBHLGNBZEYxQjtNQTJCRiw0QkFiSTBCLElBYXNCO2FBRzFCazZCLGtCQUFrQjVoQyxLQUFLZ0I7TUFDZDtrQkFEU2hCO09BQ1QsMEJBRGNnQjtPQUduQixrQkFIbUJBO01BR25CLFNBQ0pxRTs7Ozs7Ozs7OztjQUtTLEdBUFBXLE9BREE3RjtzQkFDQTZGO2lCQU9xQzs7MkNBVGhCaEY7OzRCQVNpQyxnQkFUakNBOzttQkFVYixJQUFONmdDLE1BQU0sS0FUUjFoQzttQkFVRixlQURJMGhDLFFBQ1ksZ0JBWE83Z0M7bUJBWXZCLE9BWnVCQSxNQVVuQjZnQyxPQVRGMWhDLFNBQ0E2RjttQkFVRiw0QkFGSTY3Qjs7Ozs7Ozs7Ozs7O1VBTndCLEdBRjFCNzdCLE9BREE3RjtZQUlRLElBQU4rVixNQUFNLEtBSlIvVjtZQUtGLGVBREkrVixRQURKN1E7WUFHQSxPQVB1QnJFLE1BS25Ca1YsT0FKRi9WLFNBQ0E2RjtZQUtGLDRCQUZJa1E7O01JNXpCQTtVSnl6QkZsUSxNQURBN0Y7U0FjUSxJQUFOdUgsSUFBTSxLQWRSdkg7U0FlRixPQWhCdUJhLE1BZW5CMEcsSUFkRnZILFNBQ0E2RjtTQWNGLDRCQURJMEI7TUFJSixPQW5CdUIxRyxHQW1CcEI7YUFHSDhnQyxzQkFBc0I5Z0M7TUFDZDt1QkFEY0E7T0FDZCx3QkFBTjB3QjtPQUVNLFNBRE5udEI7TUFFSixpQkFISW10QixRQUVBaHFCLE1BREFuRDtNQUVKLDRCQURJbUQsSUFFc0I7YUFrRHhCcTZCLFlBQVk3aEMsTUFBTTZEO01BOUNBLE9BOENON0Q7Ozs7Ozs7Ozs7Ozs7O2tDQUFNNkQsRUFBd0M7YUFDMURpK0IsY0FBYzloQyxNQUFNNkQ7TUEvQkQsT0ErQkw3RDs7Ozs7Ozs7Ozs7Ozs7a0NBQU02RCxFQUEyQzthQUMvRGsrQixrQkFBa0IvaEMsTUFBTTZEO01BeEJMLE9Bd0JEN0Q7Ozs7Ozs7Ozs7Ozs7O2tDQUFNNkQsRUFBK0M7YUFDdkVtK0IsY0FBY2hpQyxNQUFNNkQ7TUF6Q0QsT0F5Q0w3RDs7Ozs7Ozs7Ozs7Ozs7b0NBQU02RCxFQUEyQzthQUkvRG8rQixjQUFjcmhDLE1BQU1YLE9BQUt5QztNQUMzQixTQURnQjlCO1FBR2QsU0FIY0E7Ozs7c0JBR1ZzaEM7Ozs7UUk5NEJBLGtCSjg0QkFBO1FBS0osSUFBSXBoQyxJQUFKLGdDQVJ5QjRCLEVBQUx6QyxPQUdoQmlpQztRQUtKLGFBUmN0aEMsTUFVcUIsa0JBRi9CRTtNQTNCTixVQW1CZ0JGOzs7UUFsQkgsYUFrQlNYLFFBakJULG1CQWlCR1csT0FoQko7UUFDVixnQkFESXdHO1FBRUosa0JBRklBLElBZ0JVeEc7UUFiZCxnQkFISXdHO1FBSUosa0JBSklBLElBSWtCLHFCQU5sQnRIO1FBT0osZ0JBTElzSCxJQURBKzZCO1FBRE8sU0FPWCxnQkFMSS82QjtVQThCQW9xQiw2QkFkcUI5dUI7Z0JBQVg5QjtRQWdCWjttQ0FGRTR3QjtTQVNJLG9DQXZCaUI5dUI7UUF1QmpCLHdCQXZCaUJBOztRQWdCdkIsSUFDaUJ4RTtRQUNmO2FBRGVBLE1BRGI0SDs7O1lBR007bUNBTFIwckIsTUFHZXR6QjthQUVQOzs7MkJBRUMsUUFKTUE7WUFFUDtzQkFMUnN6QixNQVc0QixJQVg1QkE7TUFDcUIsT0FEckJBLEtBY2U7YUFXbkI0USxnQkFBZ0JwaEM7TUFDUixJQUFOb0csSUFBTTtNQUNWLGFBRElBLElBRGNwRztNQUVsQix1QkFESW9HLElBRWU7YUF1TGpCaTdCLDJCQUtFL3pCLEVBQUVnMEIsRUFBRWg0QixJQUFJNmtCLElBQUl2dkIsSUFBSW9PLE1BQUttbkIsTUFBTW4xQjtNQUFTLFVBQXhCSjtrQkFBSW9POzsyQkFFZHRMO29CQUNRLElBQU41QixJQUFNLFdBSFdxMEIsTUFBTW4xQixNQUV6QjBDO29CQUNRLG1CQUhWNEwsRUFBRWcwQixLQUFFaDRCLElBR0F4SixLQUhJcXVCLElBSXdDOzJCQU05Q3hoQixFQUFFakw7b0JBQ00sSUFBTjVCLElBQU0sa0JBRFI2TSxFQUM0QixXQVhUd25CLE1BQU1uMUIsTUFVdkIwQztvQkFDTSxtQkFYVjRMLEVBQUVnMEIsS0FBRWg0QixJQVdBeEosS0FYSXF1QixJQVl3QztRQU5sRCxJQUQwQnhoQixFQUxSSztRQU1sQixnQkFBSXRMO1VBQ1EsSUFBTjVCLElBQU0sa0JBRmM2TSxFQUVNLFdBUFR3bkIsTUFBTW4xQixNQU16QjBDO1VBQ1EsbUJBUFY0TCxFQUFFZzBCLEtBQUVoNEIsSUFPQXhKLEtBUElxdUIsSUFRd0M7O1FBUlosU0FBeEJ2dkI7O29CQUFJb087OzZCQWNkdEw7c0JBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLFdBZlRxMEIsTUFBTW4xQixNQWN6QjBDO3NCQUNRLG1CQWZWNEwsRUFBRWcwQixLQUFFaDRCLElBZUF4SixLQWZJcXVCLElBZ0J3Qzs2QkFNOUN4aEIsRUFBRWpMO3NCQUNNO3VCQUFONUI7d0JBQU07b0NBQW9CLGtCQUQ1QjZNLEVBQ2lELFdBdkI5QnduQixNQUFNbjFCLE1Bc0J2QjBDO3NCQUNNLG1CQXZCVjRMLEVBQUVnMEIsS0FBRWg0QixJQXVCQXhKLEtBdkJJcXVCLElBd0J3QztjQVBacVQsSUFqQnBCeDBCOzBCQWtCZHRMO1lBQ1E7YUFBTjVCO2NBQU07MEJBQW9CLGtCQUZNMGhDLElBRWUsV0FuQjlCck4sTUFBTW4xQixNQWtCekIwQztZQUNRLG1CQW5CVjRMLEVBQUVnMEIsS0FBRWg0QixJQW1CQXhKLEtBbkJJcXVCLElBb0J3QztpQkFwQnBDdnZCO2tCQUFJb087OzJCQTBCZHFyQixFQUFFMzJCO29CQUNNLElBQU41QixJQUFNLGlCQURSdTRCLEVBQzRCLFdBM0JUbEUsTUFBTW4xQixNQTBCdkIwQztvQkFDTSxtQkEzQlY0TCxFQUFFZzBCLEtBQUVoNEIsSUEyQkF4SixLQTNCSXF1QixJQTRCd0M7MkJBTTlDa0ssRUFBRTFyQixFQUFFakw7b0JBQ0k7cUJBQU41QjtzQkFBTTs2QkFEUnU0QixFQUM0QixrQkFEMUIxckIsRUFDK0MsV0FuQzlCd25CLE1BQU1uMUIsTUFrQ3JCMEM7b0JBQ0ksbUJBbkNWNEwsRUFBRWcwQixLQUFFaDRCLElBbUNBeEosS0FuQ0lxdUIsSUFvQ3dDO1lBUGpCc1QsSUE3QmZ6MEI7d0JBOEJkcXJCLEVBQUUzMkI7VUFDTTtXQUFONUI7WUFBTTttQkFEUnU0QixFQUM0QixrQkFGQ29KLElBRW9CLFdBL0I5QnROLE1BQU1uMUIsTUE4QnZCMEM7VUFDTSxtQkEvQlY0TCxFQUFFZzBCLEtBQUVoNEIsSUErQkF4SixLQS9CSXF1QixJQWdDd0MsRUFJQTthQTdEbER1VCxhQUlFcDBCLEVBQUVnMEIsRUFBRWg0QixJQUFJNmtCLElBQUl2dkIsSUFBSXUxQjtNQUFTLFVBQWJ2MUI7T0FFZCxnQkFBSThDO1NBQ2tDLElBQWhDaWdDLFdBSEFyNEIsSUFHZ0MsV0FIcEI2cUIsTUFFZHp5QjtTQUNrQyxtQkFIcEM0TCxFQUFFZzBCLEVBR0VLLFFBSEl4VCxJQUltQjs7UUFKRixTQUFidnZCO2NBS01xdkIsTUFMTnJ2QixPQUtEaXhCLE1BTENqeEI7MEJBTVY4QztZQUNrQyxJQUFoQ2lnQyxXQVBBcjRCLElBT2dDLFlBRnpCdW1CLE1BQU81QixNQUUwQyxXQVA1Q2tHLE1BTWR6eUI7WUFDa0MsbUJBUHBDNEwsRUFBRWcwQixFQU9FSyxRQVBJeFQsSUFRbUI7UUFFN0IsSUFEWStCLFFBVEV0eEI7UUFVZCxnQkFBSXk1QixFQUFFMzJCO1VBQ2dDLElBQWhDaWdDLFdBWEFyNEIsSUFXZ0MsWUFGMUI0bUIsUUFDUm1JLEVBQ3NELFdBWHhDbEUsTUFVWnp5QjtVQUNnQyxtQkFYcEM0TCxFQUFFZzBCLEVBV0VLLFFBWEl4VCxJQVltQjthQXZLekJ5VCxzQkFHSnQwQixFQXlOSWcwQixFQXpOQWg0QixJQUFJNmtCO1VBQVI1Z0IsTUFBSWhFLFVBQUlpb0I7TUFBTztpQkFBUEE7UUF1RlIsa0JBdkZBamtCLElBeU5JK3pCLEVBek5BLzNCOztRQUFXLE9BQVBpb0I7O1dBRVIsSUFES3AwQixLQURHbzBCO1dBRVIsZ0JBQUlydEI7YUFDRixJQUFJdzlCLFdBSEZwNEIsTUFFQXBGLEdBQ0YsbUJBSEZvSixJQXlOSSt6QixFQXRORUssUUFGRHZrQyxLQUd5Qjs7V0FFOUIsSUFEVUMsT0FMRm0wQjtXQU1SLGdCQUFJcnRCO2FBL0JJOzBCQStCSkE7Y0EvQkksd0JBQU5yRTtjQUVNLFNBRE51RDthQUVKLGlCQUhJdkQsTUFFQTBHLE1BREFuRDthQURNLElBZ0NGcytCLFdBUEZwNEIsTUF0Qk4scUJBREkvQztvQkFvQkUrNkIsWUFHSmgwQixJQXlOSSt6QixFQWxORUssUUFGSXRrQyxPQUdvQjs7ZUFDakJDLE9BVExrMEIsU0FTQTV5QixJQVRBNHlCO2tCQW9KUmtRO29CQXBKQW4wQixJQXlOSSt6QixFQXpOQS8zQixNQVNTak0sT0FBTHNCLGFBQzJCa0IsS0FBTyxPQUFQQSxHQUFVOztlQUMzQnZDLE9BWFZpMEIsU0FXSzN5QixNQVhMMnlCO2tCQW9KUmtRLGFBcEpBbjBCLElBeU5JK3pCLEVBek5BLzNCLE1BV2NoTSxPQUFMc0IsTUFsSWIraEM7O2VBb0l1QnBqQyxPQWJmZzBCLFNBYVMxeUIsS0FiVDB5QixTQWFJenlCLE1BYkp5eUIsU0FhSHh5QixNQWJHd3lCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQWFtQi9MLE9BQVh1QixNQUFLRCxLQTdFakIraEMsWUE2RUs3aEM7OztZQUVvQnZCLE9BZmpCK3pCO1lBZVd2eUIsT0FmWHV5QjtZQWVNdHlCLE1BZk5zeUI7WUFlRHJ5QixRQWZDcXlCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQWVxQjlMLE9BQVh5QixNQUFLRCxPQTlFbkI2aEMsY0E4RU8zaEM7OztZQUVzQnpCLE9BakJyQjh6QjtZQWlCZXB5QixPQWpCZm95QjtZQWlCVW55QixNQWpCVm15QjtZQWlCR2x5QixRQWpCSGt5QjtrQkF3S1I2UDtvQkF4S0E5ekIsSUF5TkkrekIsRUF6TkEvM0IsTUFpQnlCN0wsT0FBWDJCLE1BQUtELE9BL0V2QjJoQyxrQkErRVd6aEM7OztZQUVjM0IsT0FuQmpCNnpCO1lBbUJXanlCLE9BbkJYaXlCO1lBbUJNaHlCLE1BbkJOZ3lCO1lBbUJEL3hCLFFBbkJDK3hCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQW1CcUI1TCxPQUFYNkIsTUFBS0QsT0FoRm5CeWhDLGNBZ0ZPdmhDOztlQUVrQjdCLE9BckJqQjR6QixTQXFCVzl4QixPQXJCWDh4QixTQXFCTTd4QixNQXJCTjZ4QixTQXFCRDV4QixNQXJCQzR4QjtXQXlOd0IsVUFwTWxCN3hCO3VCQUFLRDs7Z0NBc01mZ0M7eUJBQ1EsSUFBTjVCLElBQU0sY0F2TUxGLE1BdndDUG12Qix3QkE2OENJcnRCO3lCQUNRLG1CQTVOWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BNE5FekosS0F2TW1CbEMsT0F3TXlCO2dDQU05QytPLEVBQUVqTDt5QkFDTSxJQUFONUIsSUFBTSxjQS9NTEYsTUE4TUgrTSxFQUFFakw7eUJBQ00sbUJBcE9aNkwsSUF5TkkrekIsS0F6TkEvM0IsTUFvT0V6SixLQS9NbUJsQyxPQWdOeUI7YUFObEQsSUFEMEIrTyxFQXpNUGpOO2FBME1uQixnQkFBSWdDO2VBQ1EsSUFBTjVCLElBQU0sY0EzTUxGLE1BeU1tQitNLEVBQ3RCakw7ZUFDUSxtQkFoT1o2TCxJQXlOSSt6QixLQXpOQS8zQixNQWdPRXpKLEtBM01tQmxDLE9BNE15Qjs7YUFSbEIsU0FwTWxCK0I7O3lCQUFLRDs7a0NBa05mZ0M7MkJBQ1E7OENBbk5MOUIsTUF2d0NQbXZCLHdCQXk5Q0lydEI7NEJBRVMsNEJBRFA1QjsyQkFDTyxtQkF6T2J5TixJQXlOSSt6QixLQXpOQS8zQixNQXlPRWluQixPQXBObUI1eUIsT0FxTjBCO2tDQU0vQytPLEVBQUVqTDsyQkFDTSxJQUFONUIsSUFBTSxzQkFBb0IsY0E1TnpCRixNQTJOSCtNLEVBQUVqTDsyQkFDTSxtQkFqUFo2TCxJQXlOSSt6QixLQXpOQS8zQixNQWlQRXpKLEtBNU5tQmxDLE9BNk55QjttQkFQWjRqQyxJQXRObkI5aEM7K0JBdU5mZ0M7aUJBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLGNBeE56QkYsTUFzTitCNGhDLElBQ2xDOS9CO2lCQUNRLG1CQTdPWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BNk9FekosS0F4Tm1CbEMsT0F5TnlCO3NCQXpOcEMrQjt1QkFBS0Q7O2dDQStOZjI0QixFQUFFMzJCO3lCQUNNOzRDQWhPTDlCLE1BdndDUG12Qix3QkFzK0NNcnRCOzBCQUVPLHVCQUZUMjJCLEVBQ0V2NEI7eUJBQ08sbUJBdFBieU4sSUF5TkkrekIsS0F6TkEvM0IsTUFzUEVpbkIsT0FqT21CNXlCLE9Ba08wQjtnQ0FNL0N5NkIsRUFBRTFyQixFQUFFakw7eUJBQ0ksSUFBTjVCLElBQU0saUJBRFJ1NEIsRUFDNEIsY0F6T3pCejRCLE1Bd09EK00sRUFBRWpMO3lCQUNJLG1CQTlQWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BOFBFekosS0F6T21CbEMsT0EwT3lCO2lCQVBqQjZqQyxJQW5PZC9oQzs2QkFvT2YyNEIsRUFBRTMyQjtlQUNNLElBQU41QixJQUFNLGlCQURSdTRCLEVBQzRCLGNBck96Qno0QixNQW1PMEI2aEMsSUFDM0IvL0I7ZUFDTSxtQkExUFo2TCxJQXlOSSt6QixLQXpOQS8zQixNQTBQRXpKLEtBck9tQmxDLE9Bc095Qjs7ZUFwT3ZDRSxPQXZCSDB6QixTQXVCRjN4QixNQXZCRTJ4QjtrQkFvSlJrUSxhQXBKQW4wQixJQXlOSSt6QixFQXpOQS8zQixNQXVCT3pMLE9BQUwrQixNS3B2Q05pRDs7V0x1d0NBLFVBMUNRMHVCLFNBMENSLFNBMUNJam9CLG1CQUFJaW9COzs7OztZQTRDUTF4QixJQTVDUjB4QjtZQUFKcVEsZUE0Q1kvaEM7WUE1Q1p5SjtZQUFJaW9COzs7OztZQThDTXp4QixJQTlDTnl4QjtZQUFKc1EsZUE4Q1UvaEM7WUE5Q1Z3SjtZQUFJaW9COzs7V0FrREM7WUFEaUJ4ekIsT0FqRGxCd3pCO1lBaURPVixVQWpEUFU7WUFrREMsbUJBRE1WO1dBQ04sZ0JBQ0poeEI7YUFDSCxtQkFwREZ5TixJQXlOSSt6QixLQXpOQS8zQixNQWtEQTFMLElBRHNCRyxPQUl3Qjs7ZUFDMUJDLFFBdERoQnV6QixTQXNEU3h4QixNQXREVHd4Qjs7YUF1RFIsSUFBYXJEO2FBQ1g7c0JBeERGNWdCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0RGLFdBQVksT0FERDRrQixJQURJbnVCLE9BQU8vQixTQUVjOztXQTlCdEMsSUFETUMsUUF6QkVzekI7V0EwQlIsZ0JBQUlwd0IsRUFBRU07YUFBSztzQkExQlg2TDtzQkF5TkkrekI7eUJBek5BLzNCLGVBMEI0QyszQixHQUFLLGtCQUFqRGxnQyxFQUE0Q2tnQyxFQUExQzUvQixFQUFvRDtzQkFEcER4RCxRQUMyRDs7V0FFakUsSUFETUMsUUEzQkVxekI7V0E0QlIsZ0JBQUlwd0IsR0FBSyxtQkE1QlRtTSxJQXlOSSt6QixLQXpOQS8zQixNQTRCQW5JLEdBREVqRCxRQUM0Qzs7O1lBNUIxQ203QjtZQTJFUS80QixXQTNFUml4QjtZQUFKdVEsZUEyRVl4aEM7WUEzRVpnSjtZQUFJaW9COzs7Ozs7Y0E2RXFDcHpCLFFBN0VyQ296Qjs7O2NBQVJ3UTt3QkFBSTE0QixJQUFKZ0UsRUE2RTZDbFE7MEJBN0U3Q21RLElBOEVPMDBCLElBQUlDO21CQUNULG1CQS9FRjUwQixFQThFTzIwQixPQTlFSDM0QixPQThFTzQ0QixPQURrQzlrQyxLQUV5Qjt3QkEvRXRFbVE7c0JBQUloRSxNQUFKZ0UsSUE2RTZDblA7Y0E3RTdDbVA7Y0FBSWhFO2NBQUlpb0I7OztZQWlGcUNweEIsUUFqRnJDb3hCOzs7WUFBUjJRO3NCQUFJNzRCLElBQUpnRSxFQWlGNkNsUTt3QkFqRjdDbVEsSUFrRk8wMEIsSUFBSUM7aUJBQ1QsbUJBbkZGNTBCLEVBa0ZPMjBCLE9BbEZIMzRCLE9Ba0ZPNDRCLE9BRGtDOWtDLEtBRXlCO3NCQW5GdEVtUTtvQkFBSWhFLE1BQUpnRSxJQWlGNkNuTjtZQWpGN0NtTjtZQUFJaEU7WUFBSWlvQjs7a0JBd0NSOztlQWtCcUJueEIsUUExRGJteEIsU0EyREptUSxXQTNEQXA0QjtrQ0E0REssbUJBNURUZ0UsSUF5TkkrekIsRUE5SkFLLFFBRGlCdGhDLFFBRWdCOztXQUtyQyxJQUpxQkMsUUE3RGJreEI7V0FpRVIsZ0JBQUkzdUI7YUFDa0MsSUFBaEM4K0IsV0FsRUZwNEIsTUFrRWtDLHdCQURsQzFHO2FBQ2tDLG1CQWxFdEMwSyxJQXlOSSt6QixFQXZKRUssUUFMZXJoQyxRQU1TOztXQUU5QixJQURlRSxRQXBFUGd4QjtXQXFFUixnQkFBSXJ0QjthQUNGLElBQUl3OUIsV0F0RUZwNEIsTUFxRUFwRjthQUNGLG1CQXRFRm9KLElBeU5JK3pCLEVBbkpFSyxRQUZTbmhDLFFBR2U7O2VBQ1ZFLFFBeEVaOHdCLFNBd0VPdHdCLElBeEVQc3dCOzs7b0JBMkZSNFEsK0JBM0ZBNzBCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0VXckksSUFBS1I7O29CQW1CcEIwaEMsd0JBM0ZBNzBCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0VXckksSUFBS1I7O1dBMUNXO1lBRGJDLFFBN0JWNndCO1lBNkJPcHdCLEVBN0JQb3dCO1lBNkJBbndCLE1BN0JBbXdCO1lBOEJ1QixnQkFEaEJwd0I7V0FDZ0I7O29CQWtPL0JpaEMsd0JBaFFBOTBCLElBeU5JK3pCLEVBek5BLzNCLE1BNkJjNUksUUFBVlU7O29CQW1PUmdoQyxpQkFoUUE5MEIsSUF5TkkrekIsRUF6TkEvM0IsTUE2QmM1SSxRQUFWVSxhQTBERDthQUlQK2dDLDZCQUlBOTBCLEVBQUVnMEIsRUFBRWg0QixJQUFJcEksSUFBSWl0QjtNQUFPLFVBQVhqdEI7T0FBVyxPQUFYQTs7VUFDMkI7O21CQTZDbkNvaEMsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFFdUI7O21CQTRDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO2dCQWF1Qjs7VUFHQTs7bUJBOEJuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O09BQU8sT0FBWGp0Qjs7VUFHMkI7O21CQTJDbkNvaEMsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFJdUI7O21CQTBDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQUt1Qjs7bUJBeUNuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBTXVCOzttQkF3Q25DbVUsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFPdUI7O21CQXVDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQVF1Qjs7bUJBc0NuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBU3VCOzttQkFxQ25DbVUsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFVdUI7O21CQW9DbkNtVSw0QkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQVd1Qjs7bUJBbUNuQ21VLDRCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBWXVCLElBQVZudUIsTUFaakJrQjtVQVkyQjs7bUJBUW5DcWhDLDZCQXBCQWoxQixFQUFFZzBCLEVBQUVoNEIsSUFZcUJ0SixNQVpibXVCOzttQkFvQlpvVSxxQkFwQkFqMUIsRUFBRWcwQixFQUFFaDRCLElBWXFCdEosTUFaYm11Qjs7VUFjdUI7O21CQWdDbkNtVSw0QkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQWV1Qjs7bUJBK0JuQ21VLDRCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0IsTUFnQm1EO2FBSS9Eb1UsMEJBSUFqMUIsRUFBRWcwQixFQUFFaDRCLElBQUl0SixNQUFNbXVCO01BQU8sVUFBYm51QjtRQWVtQjs7aUJBTzNCc2lDLDJCQXRCQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBVTZrQjtzQ0FzQmRtVSxvQkF0QkFoMUIsRUFBRWcwQixFQUFFaDRCLElBQVU2a0I7O09BQU8sT0FBYm51Qjs7VUFDbUIsSUFBbkI1QyxLQURBNEM7VUFDbUIsdUJBQVMsdUJBRHBDc04sRUFBRWcwQixFQUFFaDRCLElBQ0lsTSxLQURNK3dCLElBQ3NEOztVQUN6QyxJQUFqQjl3QixPQUZGMkM7VUFFbUIsdUJBQVMsdUJBRnBDc04sRUFBRWcwQixFQUFFaDRCLElBRU1qTSxPQUZJOHdCLElBRXNEOztVQUN6QyxJQUFwQjd3QixPQUhDMEM7VUFHbUIsdUJBQVMsdUJBSHBDc04sRUFBRWcwQixFQUFFaDRCLElBR0doTSxPQUhPNndCLElBR3NEOztVQUN6QyxJQUFsQjV3QixPQUpEeUM7VUFJbUIsdUJBQVMsdUJBSnBDc04sRUFBRWcwQixFQUFFaDRCLElBSUsvTCxPQUpLNHdCLElBSXNEOztVQUN6QyxJQUFkM3dCLE9BTEx3QztVQUttQix1QkFBUyx1QkFMcENzTixFQUFFZzBCLEVBQUVoNEIsSUFLUzlMLE9BTEMyd0IsSUFLc0Q7O1VBQ3pDLElBQWxCMXdCLE9BTkR1QztVQU1tQix1QkFBUyx1QkFOcENzTixFQUFFZzBCLEVBQUVoNEIsSUFNSzdMLE9BTkswd0IsSUFNc0Q7O1VBQ3pDLElBQWxCendCLE9BUERzQztVQU9tQix1QkFBUyx1QkFQcENzTixFQUFFZzBCLEVBQUVoNEIsSUFPSzVMLE9BUEt5d0IsSUFPc0Q7O1VBQ3pDLElBQW5CeHdCLE9BUkFxQztVQVFtQix1QkFBUyx1QkFScENzTixFQUFFZzBCLEVBQUVoNEIsSUFRSTNMLE9BUk13d0IsSUFRc0Q7O1VBTXpDLElBQVR2d0IsT0FkVm9DO1VBY21CLHVCQUFTLHVCQWRwQ3NOLEVBQUVnMEIsRUFBRWg0QixJQWNjMUwsT0FkSnV3QixJQWNzRDs7VUFHM0Q7V0FEa0Jyd0IsT0FoQm5Ca0M7V0FnQmN4QixJQWhCZHdCO1dBZ0JTakMsSUFoQlRpQztXQWlCQyxTQUFNLEtBREVqQyxLQUFLUztVQUNiO1lBQ3dCLHVCQWxCakM4TyxFQUFFZzBCLEVBQUVoNEIsSUFrQjZCLGFBRDdCekwsR0FEdUJDLFFBaEJicXdCLElBa0I2Qzs7VUFUaEMsSUFBbEJud0IsT0FURGdDO1VBU21CO1lBQVcsdUJBVHRDc04sRUFBRWcwQixFQUFFaDRCLElBU0t0TCxPQVRLbXdCLElBU3dEOztVQUMzQyxJQUFsQmx3QixRQVZEK0I7VUFVbUIsdUJBQVMsdUJBVnBDc04sRUFBRWcwQixFQUFFaDRCLElBVUtyTCxRQVZLa3dCLElBVXNEOztVQUN6QyxJQUFwQmp3QixRQVhDOEI7VUFXbUIsdUJBQVMsdUJBWHBDc04sRUFBRWcwQixFQUFFaDRCLElBV0dwTCxRQVhPaXdCLElBV3NEO2lCQUN6QztpQkFDQSw4QkFLZ0M7YUFJM0RtVSx5QkFHQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBSTZrQjtNQUNWLFlBRE03a0I7TUFDTjs7ZUFwSk1zNEIsd0JBbUpKdDBCLEVBQUVnMEIsT0FBTW5UO29DQW5KSnlULGlCQW1KSnQwQixFQUFFZzBCLE9BQU1uVCxLQUM4RDthQStHdEVrVSxzQkFJRS8wQixFQUFFZzBCLEVBQUVoNEIsSUFBSWxNLEtBQUtpRSxNQUFNRDtNQUFLLEdBQVhDO1FBR2YsSUFEWTQxQixRQUZHNTFCO1FBR2YsZ0JBQUlLO1VBQzZCLG1CQUovQjRMLEVBQUVnMEIsRUFBRWg0QixJQUFJbE0sS0FFRTY1QixRQUVxQixXQUpaNzFCLEVBR2pCTSxHQUNrQztNQUh2QixZQURUNEgsSUFBZWxJO01BQ047O2VBeFFYd2dDLHdCQXVRRnQwQixFQUFFZzBCLE9BQU1sa0M7b0NBdlFOd2tDLGlCQXVRRnQwQixFQUFFZzBCLE9BQU1sa0MsTUFJNEI7YUEzUWxDbWtDLFlBR0pqMEIsRUF5TklnMEIsRUF6TkFoNEIsSUFBSTZrQjtNSjc4Q2IsdUJJMDhDU3lULGdCQUdKdDBCLEVBeU5JZzBCLEVBek5BaDRCLElBQUk2a0I7YUEyRlJ1VSxtQkFJQXAxQixFQUFFZzBCLEVBQUVoNEIsSUFBSXBJLElBQUlpdEI7TUo1aURqQix1Qkl3aURLaVUsdUJBSUE5MEIsRUFBRWcwQixFQUFFaDRCLElBQUlwSSxJQUFJaXRCO2FBb0JacVUsZ0JBSUFsMUIsRUFBRWcwQixFQUFFaDRCLElBQUl0SixNQUFNbXVCO01KcGtEbkIsdUJJZ2tES29VLG9CQUlBajFCLEVBQUVnMEIsRUFBRWg0QixJQUFJdEosTUFBTW11QjthQXlJZHNVLFlBSUVuMUIsRUFBRWcwQixFQUFFaDRCLElBQUlsTSxLQUFLaUUsTUFBTUQ7TUpqdEQxQix1Qkk2c0RLaWhDLGdCQUlFLzBCLEVBQUVnMEIsRUFBRWg0QixJQUFJbE0sS0FBS2lFLE1BQU1EO2FBaUZyQnVoQyx3QkFJRXIxQixFQUFFZzBCLEVBQUVuVCxJQUFJdnZCLElBQUlFO01BQVEsVUFBWkY7a0JBQUlFOztZQUVKLHNCQUZSd08sRUFBRWcwQixFQUFFblQsS0FFSSxzQkp4eURmO1VJNHlEc0Isc0JBTmY3Z0IsRUFBRWcwQixFQUFFblQsS0FNSSxvQko1eURmO1VJNHlEZSxzQko1eURmO1FJMHlEZSxzQkFKUjdnQixFQUFFZzBCLEVBQUVuVDtRQUlJLHNCSjF5RGY7O1FJc3lEMkIsU0FBWnZ2QjtvQkFBSUU7O2NBUUosc0JBUlJ3TyxFQUFFZzBCLEVBQUVuVDtjQVFJLHNCSjl5RGY7WUlrekRzQixzQkFaZjdnQixFQUFFZzBCLEVBQUVuVCxLQVlJLG9CSmx6RGY7WUlrekRlLHNCSmx6RGY7VUlnekRlLHNCQVZSN2dCLEVBQUVnMEIsRUFBRW5UO1VBVUksc0JKaHpEZjtrQklzeURtQnJ2Qjs7WUFjRyxzQkFkZndPLEVBQUVnMEIsRUFBRW5ULEtBY0ksb0JKcHpEZjtZSW96RGUsc0JKcHpEZjtVSXd6RDZCOzZCQWxCdEI3Z0IsRUFBRWcwQixFQUFFblQ7V0FrQlcsb0JKeHpEdEI7V0l3ekRlLG9CSnh6RGY7VUl3ekRlLHNCSnh6RGY7UUlzekRzQixzQkFoQmY3Z0IsRUFBRWcwQixFQUFFblQsS0FnQkksb0JKdHpEZjtRSXN6RGUsc0JKdHpEZixhSXd6RHFEO2FBL0Y1QzBVLHVCQUVGdjFCLEVBQUVnMEIsRUFBRW5UO1VBQUo1Z0IsTUFBSWlrQjtNQUFPO2lCQUFQQTtRQXNFRixrQkF0RUZqa0IsSUFBRSt6Qjs7UUFBUyxPQUFQOVA7O1dBRUYsU0FGRUEsU0FFSSxrQkFGUmprQixJQUFFK3pCLEVBQ0dsa0M7V0FDRyxzQko3dERmOztXSSt0RFMsV0FKRW8wQixTQUlJLGtCQUpSamtCLElBQUUrekIsRUFHUWprQztXQUNGLHNCSi90RGY7O29CSTJ0RFdtMEI7O2FBTUYsV0FORUEsU0FNSSxrQkFOUmprQixJQUFFK3pCLEVBS2tCaGtDO2FBQ1osc0JKanVEZjs7O2VJbXVEUyxXQVJFazBCLFNBUUksa0JBUlJqa0IsSUFBRSt6QixFQU9xQi9qQztlQUNmLHNCSm51RGY7YUlxdURTO3FCQVZFaTBCO2NBVVcsa0JBVmZqa0IsSUFBRSt6QixFQVNxQjlqQztjQUNmLG9CSnJ1RGY7YUlxdURlLHNCSnJ1RGY7O29CSTJ0RFdnMEI7O2FBWUYsV0FaRUEsU0FZSSxrQkFaUmprQixJQUFFK3pCLEVBV3VCN2pDO2FBQ2pCLHNCSnZ1RGY7OztlSXl1RFMsV0FkRSt6QixTQWNJLGtCQWRSamtCLElBQUUrekIsRUFhMEI1akM7ZUFDcEIsc0JKenVEZjthSTJ1RFM7cUJBaEJFOHpCO2NBZ0JXLGtCQWhCZmprQixJQUFFK3pCLEVBZTBCM2pDO2NBQ3BCLG9CSjN1RGY7YUkydURlLHNCSjN1RGY7O2VJNHVEMEJDLE9BakJmNHpCLFNBaUJTMXlCLEtBakJUMHlCLFNBaUJJNXlCLElBakJKNHlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBaUJpQjFqQyxPQUFYZ0IsSUFBS0U7O2VBRVFoQixPQW5CakIwekIsU0FtQld2eUIsT0FuQlh1eUIsU0FtQk0zeUIsTUFuQk4yeUI7a0JBdUVObVIsd0JBdkVFcDFCLElBQUUrekIsRUFtQm1CeGpDLE9BQVhlLE1BQUtJOztlQUVVakIsT0FyQnJCd3pCLFNBcUJlcHlCLE9BckJmb3lCLFNBcUJVenlCLE1BckJWeXlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBcUJ1QnRqQyxPQUFYZSxNQUFLSzs7ZUFFRW5CLFFBdkJqQnV6QixTQXVCV2p5QixPQXZCWGl5QixTQXVCTXR5QixNQXZCTnN5QjtrQkF1RU5tUix3QkF2RUVwMUIsSUFBRSt6QixFQXVCbUJyakMsUUFBWGlCLE1BQUtLOztlQUVNckIsUUF6QmpCc3pCLFNBeUJXOXhCLE9BekJYOHhCLFNBeUJNbnlCLE1BekJObXlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBeUJtQnBqQyxRQUFYbUIsTUFBS0s7O29CQXpCWDh4Qjs7YUE0QkYsWUE1QkVBLFNBNEJJLGtCQTVCUmprQixJQUFFK3pCLEVBMkJnQm5qQzthQUNWLHNCSnZ2RGY7OztlSXl2RFMsWUE5QkVxekIsU0E4Qkksa0JBOUJSamtCLElBQUUrekIsRUE2Qm1CbGpDO2VBQ2Isc0JKenZEZjthSTJ2RFM7c0JBaENFb3pCO2NBZ0NXLGtCQWhDZmprQixJQUFFK3pCLEVBK0JtQmxoQztjQUNiLG9CSjN2RGY7YUkydkRlLHNCSjN2RGY7a0JJdXdEUyxVQTVDRW94QjtrQkE4Q0YsVUE5Q0VBO2tCQWdERixVQWhERUE7O1dBa0RGLFlBbERFQSxTQWtESSxrQkFsRFJqa0IsSUFBRSt6QixFQWlEZ0JqaEM7V0FDVixzQko3d0RmOztlSTh3RCtCQyxRQW5EcEJreEIsU0FtRGF4eEIsTUFuRGJ3eEI7O2FBb0RGLElBQWFyRDthQUVULG9CQXRETjVnQixJQUFFK3pCLEVBc0RJLFdBQVksT0FGSG5ULElBREVudUIsT0FBT00sU0FHa0I7O1dBcEJ4QztvQkFsQ0VreEI7WUFrQ1csa0JBbENmamtCLElBQUUrekIsRUFpQ0k5Z0M7WUFDRSxvQko3dkRmO1dJNnZEZSxzQko3dkRmOztXSSt2RFMsWUFwQ0VneEIsU0FvQ0ksa0JBcENSamtCLElBQUUrekIsRUFtQ0k1Z0M7V0FDRSxzQkovdkRmO2tCSTJ4RFMsVUFoRUU4d0I7Ozs7O2NBaUV5Qzd3QixRQWpFekM2d0I7OztjQUFKd1E7MEJBaUU2QzVrQzswQkFqRTdDbVEsSUFrRW9CMDBCLEtBQU8sb0JBbEUzQjMwQixFQWtFb0IyMEIsSUFEeUI3a0MsS0FDSyxRQWxFbERtUTswQkFpRTZDNU07Y0FqRTdDNE07Y0FBSWlrQjs7O1lBbUV5QzF3QixRQW5FekMwd0I7OztZQUFKMlE7d0JBbUU2Qy9rQzt3QkFuRTdDbVEsSUFvRW9CMDBCLEtBQU8sb0JBcEUzQjMwQixFQW9Fb0IyMEIsSUFEeUI3a0MsS0FDSyxRQXBFbERtUTt3QkFtRTZDek07WUFuRTdDeU07WUFBSWlrQjs7a0JBMENGOztXQWNBLFlBeERFQSxTQXdESSxrQkF4RFJqa0IsSUFBRSt6QixFQXVEbUJ0Z0M7V0FDYixzQkpueERmOztXSXF4RFMsWUExREV3d0IsU0EwREksa0JBMURSamtCLElBQUUrekIsRUF5RG1CcmdDO1dBQ2Isc0JKcnhEZjs7V0l1eERTLFlBNURFdXdCLFNBNERJLGtCQTVEUmprQixJQUFFK3pCLEVBMkRhbmdDO1dBQ1Asc0JKdnhEZjs7ZUl3eEQyQjJoQyxRQTdEaEJ0UixTQTZEV3R3QixJQTdEWHN3QjtrQkFuTE5rUjs2QkFpUDRCaGhDLFNBQU8sa0JBOURqQzZMLElBOEQwQjdMLEVBQVU7b0JBOURsQzQvQjs7b0JBNkRhcGdDO29CQUFLNGhDOztlQXhCRkMsUUFyQ2R2UixTQXFDSW53QixNQXJDSm13Qjs7O29CQThGTndSLCtCQTlGRXoxQixJQUFFK3pCLEVBcUNnQnlCLFFBQVYxaEM7O29CQXlEVjJoQyx3QkE5RkV6MUIsSUFBRSt6QixFQXFDZ0J5QixRQUFWMWhDLFFBaUNIO2FBd0JQMmhDLDZCQUVFMTFCLEVBQUVnMEIsRUFBRW5UO01BRk47UUFNSSxtQkFBTSx3QkFKUjdnQixFQUFFZzBCLEVBQUVuVCxJQUdROXNCO1FBQ0osc0JKL3pEZjtNSTZ6RFM7O2VBcEdBd2hDLHlCQWtHRnYxQixFQUFFZzBCLEVBQUVuVDtvQ0FsR0YwVSxrQkFrR0Z2MUIsRUFBRWcwQixFQUFFblQsS0FJc0M7YUF0R3hDeVUsYUFFRnQxQixFQUFFZzBCLEVBQUVuVDtNSjN0RFgsdUJJeXREUzBVLGlCQUVGdjFCLEVBQUVnMEIsRUFBRW5UO2FBOEZOOFUsbUJBRUUzMUIsRUFBRWcwQixFQUFFblQ7TUozekRYLHVCSXl6REs2VSx1QkFFRTExQixFQUFFZzBCLEVBQUVuVDthQVlGK1UsV0FBVzVCLEVBQUVoNEI7TUp2MER0QixJSXUwRHNCQztNQUFNO2lCQUFOQTtRQWVXOztRQWZMLE9BQU5BOztXQUVUO1lBRGVoSixXQUROZ0o7WUFDR29ELEVBREhwRDtZQUVULDJCQURlaEo7V0FFdkIsV0FIZStnQyxFQUNLMzBCO1dBRXBCLHFCQUhlMjBCLEVBRVgvL0I7O29CQUZhZ0k7O2FBS2pCLElBRG9DQzthQUNwQyxXQUxlODNCO2FBS0MsY0FMREE7YUFLZixJQUxpQi8zQixNQUltQkM7O2VBRUFxNEI7V0FDcEMsV0FQZVA7V0FPQyxjQVBEQTtlQUFFLzNCLE1BTW1CczRCOzs7ZUFNdEJ6Z0MsRUFaR21JLFNBWU40NUIsSUFaTTU1QjtXQVlXLFdBWmIrM0IsRUFZSjZCO1dBQWlCLGtCQUFkL2hDLEVBWkNrZ0M7aUJBYWEsSUFBbEI4QixJQWJPNzVCLFNBYVcsV0FiYiszQixFQWFMOEIsS0FBa0IscUJBYmI5Qjs7ZUFjSytCLElBZEg5NUIsU0FjQSs1QixJQWRBLzVCO1dBY1csV0FkYiszQixFQWNFZ0M7V0FBVyxtQkFBUkQ7OzttQkFkSDk1QjtXQVNXLFdBVGIrM0I7V0FTYSxxQkFUYkE7O2lCQUFFLzNCO1dBV1csV0FYYiszQjtXQVdhLDJCQVhiQSxLQWVlO2FBSzFCaUMsV0FBV3hnQyxFQUFFdUc7TUozMUR0QixJSTIxRHNCQztNQUFNO2lCQUFOQTtRQWVXOztRQWZMLE9BQU5BOztXQUVUO1lBRGVoSixXQUROZ0o7WUFDR29ELEVBREhwRDtZQUVULDJCQURlaEo7V0FFdkIsV0FIZXdDLEVBQ0s0SjtXQUVwQixrQkFIZTVKLEVBRVh4Qjs7b0JBRmFnSTs7YUFLakIsSUFEb0NDO2FBQ3BDLFdBTGV6RzthQUtDLFdBTERBO2FBS2YsSUFMaUJ3RyxNQUltQkM7O2VBRUFxNEI7V0FDcEMsV0FQZTkrQjtXQU9DLFdBUERBO2VBQUV3RyxNQU1tQnM0Qjs7O2VBTXRCemdDLEVBWkdtSSxTQVlONDVCLElBWk01NUI7V0FZVyxXQVpieEcsRUFZSm9nQztXQUFpQixrQkFBZC9oQyxFQVpDMkI7aUJBYWEsVUFiWHdHOztlQWNHODVCLElBZEg5NUIsU0FjQTY1QixJQWRBNzVCO1dBY1csV0FkYnhHLEVBY0VxZ0M7V0FBVyxtQkFBUkM7OzttQkFkSDk1QjtXQVNXLFdBVGJ4RztXQVNhLGtCQVRiQTs7aUJBQUV3RyxzQkFXVyxXQVhieEcsT0FXYSxnQkFYYkEsS0FlZTthQU0xQnlnQyxXQUFXemdDLEVBQUV1RztNSmgzRHRCLElJZzNEc0JDO01BQU07aUJBQU5BO1FBZVc7O1FBZkwsT0FBTkE7O1dBRVQ7WUFEZWhKLFdBRE5nSjtZQUNHb0QsRUFESHBEO1lBRVQsMkJBRGVoSjtXQUV2QixXQUhld0MsRUFDSzRKO1dBRXBCLGtCQUhlNUosRUFFWHhCOztvQkFGYWdJOzthQUtqQixJQURvQ0M7YUFDcEMsV0FMZXpHO2FBS0MsV0FMREE7YUFLZixJQUxpQndHLE1BSW1CQzs7ZUFFQXE0QjtXQUNwQyxXQVBlOStCO1dBT0MsV0FQREE7ZUFBRXdHLE1BTW1CczRCOzs7ZUFNdEJ6Z0MsRUFaR21JLFNBWU40NUIsSUFaTTU1QjtXQVlXLFdBWmJ4RyxFQVlKb2dDO1dBQXFELGtCQVpqRHBnQyxFQVlpRCxXQUFsRDNCO2lCQUNjLFVBYlhtSTs7ZUFjRzg1QixJQWRIOTVCLFNBY0E2NUIsSUFkQTc1QjtXQWNXLFdBZGJ4RyxFQWNFcWdDO1dBQVcsbUJBQVJDOzs7bUJBZEg5NUI7V0FTVyxXQVRieEc7V0FTYSxrQkFUYkE7O2lCQUFFd0csc0JBV1csV0FYYnhHLE9BV2EsZ0JBWGJBLEtBZWU7YUFNOUIwZ0M7TUFDUSxJQURrQnRWLGFBQ2xCO2VBQ043Z0IsUUFBS2hFO1FBQU0sV0FEWGxELElBQ0trRCxLQUFtQyx5QkFEeENsRCxLQUM2RDtNQUR2RCxtQkFDTmtILE1BRndCNmdCO2FBUzFCdVYsbUJBQW1CNWpDO01BQ2xCLHFCQURrQkE7TUFFbkIsSUFBSWdGLElBQUosc0JBRm1CaEY7TUFFbkIsU0FDSTZqQztRQUFpQix5Q0FIRjdqQyxJQUdtRDtNQUR0RSxTQUVROGpDLGFBQWExbUM7UUpsNUQxQixJSWs1RDBCb0c7UUFDbkI7YUFEbUJBLFFBRmpCd0IsV0FFaUJ4QjtVQUVYLDBCQU5TeEQsSUFJRXdEO1VBRVgsc0NBRldBO1VBRVgsSUFDVSxJQUhDQTttQkFJVDtNQU5aLFNBT0l1Z0MsWUFBWTNtQyxFQUFFdVM7UUp2NUR2QixJSXU1RHVCNmhCO1FBQ2hCO2FBRGdCQSxRQVBkeHNCLFdBT2N3c0I7VUFFUiwwQkFYU3h4QixJQVNEd3hCLEtBRVI7d0NBRlFBO1VBRVIsSUFDVSxJQUhGQTttQkFJTjtNQVhaLFNBWUl3UyxVQUFVNW1DLEVBQUV1UztRSjU1RHJCLElJNDVEcUI2aEI7UUFDZDthQURjQSxRQVpaeHNCLFdBWVl3c0I7VUFFTjtpQ0FoQlN4eEIsSUFjSHd4QjtXQUVOO1VJcjVDTixhSnM1Q3NCLFFBSFZBO1VBSUwsT0FKS0EsSUFJSjtNQUNDOztPQUNGLGlCQURQeVM7T0FFVyxlQXJCSWprQyxJQW1CZmlrQyxPQUNBQyxPQURBRDtPQUdTLG9CQUZUQztPQUdPLGVBRFBFO01BQ08sR0FEUEEsV0FDQUM7V0FDQUM7OztTQUV5RDtrQ0FBdkMsTUExQkh0a0MsSUFzQmZva0MsT0FDQUMsT0FEQUQ7VUFFQUU7Ozs7b0JBR2tCO01BUlQsSUFTVEMsUUFBVSxhQUxWRjtNQUtVLEdBQVZFLFlBMUJBdi9CLElBMkJtQjtNQUFjLHdCQVJqQ20vQjs7Ozs7O2dCQVNBSyxTQU1ZOztnQkFOWkE7Ozs7Ozs7Ozs7O01JbjZDQSxrQkptNkNBQTtNQU9KLFVBYklGLE9BTUFFLFNBT2M7YUFPbEJDLHFCQUdBM2xDLElBQUl1dkI7TUFBTyxVQUFYdnZCO09BQ3NCLFlBRGxCdXZCOztRQUFPLFNBQVh2dkIsWUFFZ0J5NUIsRUFGaEJ6NUIsT0FFYTJDLEVBRmIzQyxvQkFFYTJDLEVBQUc4MkIsR0FGWmxLO1FBR2tCLElBQVZ6a0IsSUFIWjlLO1FBR3NCLGFBQVY4SyxLQUhSeWtCLEtBR3NEO2FBZTFEcVcscUJBSUE1bEMsSUFBSUUsS0FDdUJxdkI7TUFiZixVQVlScnZCO2lDQUN1QnF2Qjs7T0FYUixNQVVmcnZCLG9CQVZVNk4sR0FXYXdoQjtVQUFObHZCO2dCQURyQkw7T0FHc0IsWUFGREssT0FBTWt2Qjs7aUJBRDNCdnZCLFlBSWdCeTVCLEVBSmhCejVCLE9BSWEyQyxFQUpiM0Msb0JBSWEyQyxFQUFHODJCLEdBSEtwNUIsT0FBTWt2QjtRQUlMLElBQVZ6a0IsSUFMWjlLO1FBS3NCLGFBQVY4SyxLQUpTekssT0FBTWt2QixLQUlzQzthQU9qRXNXLGtCQUFtQkMsZ0JBQWdCNWtDO01BaUJyQyxHQWpCcUI0a0M7T0FrQkosU0FsQklBLG1CQWlCakJFLGtCQUNLRDs7V0FETEM7TUFpQkosU0FBSUMsdUJBQXVCcFgsUUFBUTRWO1FBQ2pDLHlDQW5DbUN2akMsSUFrQ1YydEIsUUFBUTRWLElBR2hCO01BSG5CLFNBUUl5Qix5QkFBeUJDO1FBQzNCLDhCQUQyQkEscUNBRUM7TUFWOUIsU0FvQklDLHVCQUF1QnZYLFFBQVF0cEIsRUFBRTVDO1FBQ25DLHlDQXZEbUN6QixJQXNEVjJ0QixRQUFRdHBCLEVBQUU1QyxFQUdsQjtNQXZCbkIsU0E0QkkwakMsbUJBQW1CeFgsUUFBUXlYLFNBQVNqckI7UUFDdEMseUNBL0RtQ25hLElBOERkMnRCLFFBQVF5WCxTQUFTanJCLEtBR1g7TUEvQjdCLFNBNnZCSWtyQixZQUdBQyxVQUFVM1gsUUFBUVU7UUFBTyxJQUd6QjlpQixLQUhVb2lCLFVBQVYyWDtRQUF5QixhQUd6Qi81QjtvQkFIa0I4aUI7dUJBR2xCOWlCOzBCQUQrQixnQkFweUJFdkwsSUFreUJqQ3NsQyxXQUFrQmpYOzBCQUdlLE1BcnlCQXJ1QixJQWt5QmpDc2xDLFVBR0EvNUIsTUFIa0I4aUIsS0FHbUQ7TUFud0J6RSxTQW1DUWtYLE1BS0pELFVBa2RRTDtRSjMvRWYsSUl5aUVpQnRYLFFBQVYyWDtRQUNGO2FBRFkzWCxZQWtkRnNYLGVBamRnQixZQUR4QkssVUFBVTNYO1VBRUosMEJBNUUyQjN0QixJQTBFdkIydEI7VUFFSjtZQVlhLElBR1g2WCxVQWpCRTdYO1lBa0JaLEdBRFU2WCxjQWljQVAsUUFoY2dCLHlCQWdjaEJBO1lBcGNXO2FBS2Ysd0JBN0Y2QmpsQyxJQTJGekJ3bEM7YUFFSjs7Z0JBQ0ssWUFwQkM3WCxRQWlCRjZYLGtCQWljQVA7Z0JBN2JELFlBckJHdFgsUUFpQkY2WCxVQWljQVA7YUE5Y01wTTttQkFpdEJkd00sWUFydEJBQyxVQUFVM1gsUUFJSWtMOztZQUdaLElBMmNGNk0sVUFsZFUvWDtZQW1kWixHQURFK1gsY0FBUVQ7OztjQUdGLElBdUNKNWdDLEVBdkNJLGdCQS9oQjJCckUsSUE0aEJqQzBsQztjQUdNLFNBdUNKcmhDOzs7Ozs7Ozs7OEJBaENBLFlBVkZxaEMsa0JBQVFUOzs7OztxQkFZaUI7b0NBWnpCUyxrQkFBUVQ7c0JBWWlCO3VDQUFYOUw7Ozt5QkE4Qlo5MEI7Ozs7OzhCQXJDQSxZQUxGcWhDLGtCQUFRVDs7Ozs7cUJBT2lCO29DQVB6QlMsa0JBQVFUO3NCQU9pQjt1Q0FBWDNMOzs7Ozt5QkFtQ1pqMUI7Z0JBaEJ1QjsrQkExQnpCcWhDLGtCQUFRVDtpQkEwQmlCO2tDQUFYeEw7Ozt5QkFnQlpwMUI7Ozs7cUJBeEJ1QjtvQ0FsQnpCcWhDLGtCQUFRVDtzQkFrQmlCOzBDQUFYckw7Ozs7cUJBa0JILElBcENYOEwscUJBQVFUO2dDQW9DNEIsZ0JBaGtCSGpsQyxJQTRoQmpDMGxDO3VCQXFDeUI7c0NBckN6QkEsa0JBQVFUO3dCQXFDaUI7eUNBQVhqTDs7Ozs7Ozs7c0JBR1c7cUNBeEN6QjBMLFVBQVFUO3VCQXdDaUI7eUNBQVg3Szs7OztxQkF6Qlc7b0NBZnpCc0wsa0JBQVFUO3NCQWVpQjswQ0FBWHpLOzs7O3FCQWNXO3FDQTdCekJrTCxrQkFBUVQ7c0JBNkJpQjt1Q0FBWHJLOzs7Ozs4QkFSWixpQkFyQkY4SyxrQkFBUVQ7Ozs7OzhCQWdDTixpQkFoQ0ZTLGtCQUFRVDs7OztxQkF1QmlCO3FDQXZCekJTLGtCQUFRVDtzQkF1QmlCO3VDQUFYbEs7Ozs7cUJBV1c7cUNBbEN6QjJLLGtCQUFRVDtzQkFrQ2lCO3VDQUFYL0o7Ozs7OztjSXBoRVo7ZUo2aEV1Qjs4QkEzQ3pCd0ssa0JBQVFUO2dCQTJDaUI7a0NBRHZCNWdDLEdBQ1kyMEI7WUF0ZlosSUFBWUQ7bUJBOHNCZHNNLFlBcnRCQUMsVUFBVTNYLFFBT0lvTDtVQUxSLElBUUosVUFWUXBMO21CQUo4QztNQXBDNUQsU0ErTUlvWTtRQTZvQm1CQyxRQUFRclksUUEzTkpzWCxRQS9hQ2dCLEtBQUszNkIsS0FBSzQ2QixNQUFNOWtDLElBQUl0QyxJQUFJRSxLQUFLbW5DLFFBMG9CUDlFO1FBeG9CaEQ7Ozs7Ozs7aUJBS0lxRixnQkFBaUIsd0JBUEtULElBT21CO1FBTDdDLFNBTUlVLGdCQUFnQix3QkFSV3I3QixJQVFZO1FBTjNDLFNBT0lzN0IsaUJBQWlCLHlCQVRlVixLQVNVO1FBUDlDLFNBUUlXLGVBQWlCLHVCQVZxQnpsQyxHQVVFO1FBUjVDLFNBU0kwbEMsZUFBaUIsdUJBWHlCaG9DLEdBV0Y7UUFUNUMsU0FVSWlvQyxnQkFBaUIsd0JBWjZCL25DLElBWUw7UUFWN0MsU0FXSWdvQyxtQkFBaUIsdUJBYmtDYixPQWFQO1FBWGhELFNBYUljO1VBWUssbUJBQVk7NkRBVWRub0M7O1dBUnFCOztxQkFRckJBOztnQkFOQSxJQURvQmlFLEVBT3BCakU7Z0JBTkEsT0FsUUxnbUM7OEJBaVF5Qi9oQzt5QkFFZixrQkEwbUJTaWpDLFFBQVFyWTtjQXRtQkssT0FDM0I3dUI7O3FCQXhRTGdtQzs7dUJBc1FVLGtCQXVtQlNrQixRQUFRclk7cUJBcm1CdEI3dUIsSUFBOEI7UUFuQ3JDLFNBc0NJcW9DLFdBQVc5RixLQUF3QnZpQztVQUNyQyxVQURxQ0E7V0FFckIsT0FGcUJBOztZQUNyQyxTQURxQ0E7O2dCQU1uQyxJQURvQnF2QixNQUxlcnZCO2dCQU1uQyxPQWpSRmdtQzs4QkFnUnNCM1c7eUJBRWYsa0JBMmxCWTZYLFFBQVFyWSxRQWxtQmQwVDtjQUd3QixPQUhBdmlDOztxQkEzUXJDZ21DOzt1QkFxUk8sa0JBd2xCWWtCLFFBQVFyWSxRQWxtQmQwVDtxQkFBd0J2aUMsSUFVWTtRQWhEbkQsU0FzRElzb0MsV0FBVy9pQyxFQUFxQnZGO1VBQXdCLFVBQXhCQTtXQUNsQjs7WUFEMEMsU0FBeEJBOzs7Z0JBT2hDLElBRG1CcXZCLE1BTmFydkI7Z0JBT2hDLE9BbFNGZ21DOzRCQWlTcUIzVzt5QkFFZCxrQkEwa0JZNlgsUUFBUXJZLFFBbGxCZHRwQjtzQkFFbUIsSUFBVmdqQyxRQUZZdm9DLE9BRUYsVUFBVnVvQzs7Z0JBRXBCLElBRG9CQyxRQUhZeG9DO2dCQUloQyxPQS9SRmdtQzs0QkE4UnNCd0M7eUJBRWYsa0JBNmtCWXRCLFFBQVFyWSxRQWxsQmR0cEI7WUFTTSx5QkF5a0JBMmhDLFFBQVFyWSxRQWxsQmR0cEIsVUFTK0M7UUEvRDlELFNBaUVJa2pDLFlBQVlsakMsR0FBaUIsa0JBQWpCQSxFQUFpQixXQUFZO1FBakU3QyxTQWtFSW1qQyxnQkFBZ0JuakMsR0FBaUIsa0JBQWpCQSxFQUFpQixlQUFnQjtRQWxFckQsVUF3b0JnRGc5Qjs7Ozs7WUE3YXZCOzJCQTZhSTFULFFBM05Kc1g7YUFsTkE7YUE5SXJCd0Msa0JBOElVN047Ozs7WUFnQkU7MENBNlphak0sUUEzTkpzWDthQWpNQSxjQURuQnlDLGdCQWtNbUJ6QzthQWpNQTthQUNELGNBMlpLdFgsUUE3WnZCK1o7YUFFa0I7YUFDTix1QkFESkU7WUFFVDthQUNtQzsyQ0FGbEM1VzswQkFFRTZXLFVBSk16Tjs7NkJBT2EsZ0JBTHJCcEosVUFGUW9KO1lBREUsSUE5SlpxTjs7a0NBRUYsTUF5akIyQjlaLFFBM05Kc1g7O1lBeFVBOzRCQW1pQkl0WCxRQTNOSnNYO2FBeFVBO2FBQ3BCLHlCQURTbEs7YUF4QlYwTTs7OztZQTJEcUI7NEJBZ2dCSTlaLFFBM05Kc1g7YUFyU0E7O1lBRXBCO2FBQ0Qsa0JBRkU2Qyx1QkFFRUMsVUFITS9MOzs2QkFDUjhMLFVBRFE5TDtZQUFXLElBM0RyQnlMOzs7WUFzQ1E7OEJBcWhCb0NwRyxLQXJoQnBCO2FBQ0gsZUFvaEJJMVQsUUEzTkpzWDthQXpUQTtZQUNwQjthQUNpQzs7MEJBQTlCK0MsVUFGTTVMOzthQU1SOzRDQVBBcjhCLE1BQ1FxOEI7Y0FNUjs7eUJBRG1CajhCLE1BQU1vOEI7WUFObkIsSUF0Q1JrTDs7O1lBaVdKLEdBME42QjlaLFlBM05Kc1gsUUFDQyx5QkFEREE7WUFHVjs7K0JBQ0Y1Z0MsR0FDWCx1QkFGRXZELFNBQ1N1RCxFQUNlO2FBRmI7dUJBSUQrSixJQUFFL0o7Z0JBQ2QsTUFEY0EsSUFBRitKO3NCQUNaaFIsRUFEWWdSO2tCQUVWO29DQU5BdE4sU0FNeUIsWUFEM0IxRDtvQkFDRSxTQURGQTt1QkFEY2lILE1BQ2RqSDs7Z0JBSEEsUUFLSTthQVBTO3VCQVVTdXdCO2dCQUN0Qix5Q0FqckJpQzN0QixJQWdyQlgydEIsUUFHMEI7YUFibkM7K0JBdUJZQSxRQUFRc1g7Z0JKNXBGeEMsSUk0cEZnQ1M7Z0JBQ3pCO3FCQUR5QkEsY0FBUVQsUUFDUCx5QkFET0E7a0JBRTNCLElBTUo1Z0MsRUFOSSxnQkEvckIyQnJFLElBNnJCUjBsQztrQkFFbkIsVUFNSnJoQztvQkFGQTtrQ0FOdUJxaEM7OzRCQVF2QnJoQyxTQVJ1QnFoQztrQkFFbkIsU0FGbUJBO2tCQVN2Qjs7MkJBR0EwQywyQ0FaK0JuRCxRQVEvQjVnQzs7MkJBSUErakMsb0NBWitCbkQsUUFRL0I1Z0MsSUFDaUQ7YUFoQ3RDOytCQW1DZXNwQixRQW9CU3NYLFFBcEJPNWdDO29CQUFoQnFoQyxrQkFBZ0J0M0I7Z0JBQzVDO3FCQUQ0QnMzQixjQW9CU1QsUUFuQlgseUJBbUJXQTtrQkFsQi9CLElBRnNDNTJCLElBRXRDLGdCQTNzQjJCck8sSUF5c0JMMGxDO2tCQUV0QixTQUZzQ3IzQjs7OztvQ0FJMUMsU0FKMENELEtBSTFDLE9BSjBCczNCOzs7NkJBQWdCcjNCOzs7O3VCQU8xQyxJQWEyQm0zQixVQXBCREU7dUJBcUI1QixHQUQ2QkYsY0FBUVAsUUFDWCx5QkFEV0E7dUJBYm5DLElBNEJBMzJCLElBYkksZ0JBL3RCMkJ0TyxJQTZ0Qkp3bEM7dUJBRXZCLFVBYUpsM0I7eUJBUEEsSUFSMkJrM0IsdUJBQVFQOzBCQVFMLHlCQVJLQTt5QkFTdkIsSUFDUjEyQixJQURRLGdCQXR1Qm1Cdk8sSUE2dEJKd2xDO3lCQVNmLFVBQ1JqM0I7K0NBR0ssb0JBYmtCaTNCO3lCQVd2QixVQS9Cc0NwM0IsSUE4QnRDRzt5QkFEUSxTQVRlaTNCO3lCQVd2Qjs7a0NBM0NKMkMsc0NBZ0NtQ2xEOztrQ0FoQ25Da0QsK0JBZ0NtQ2xEO2lDQWVuQzMyQjt5QkFYQSxTQXhCMENGLEtBeUIxQyxvQkFMMkJvM0I7dUJBZ0IzQixVQXBDMENwM0IsSUFtQzFDRTt1QkE1QkEsU0FhMkJrM0I7dUJBZ0IzQjs7Z0NBaERBMkMsc0NBZ0NtQ2xEOztnQ0FoQ25Da0QsK0JBZ0NtQ2xEOztrQkluckVuQzs2QkorcEUwQzcyQjtxQkFTMUMsU0FUMENDO3FCQVMxQyxTQVQwQnEzQjtxQkFTMUI7OzhCQXJCQXlDLHNDQWdDbUNsRDs7OEJBaENuQ2tELCtCQWdDbUNsRDtrQkFSbkMsVUFaMEM3MkIsSUFZMUIsb0JBWlVzM0I7a0JBZ0IxQixTQWhCMEN0M0I7a0JBRXRDLElBY0osVUFoQjBCczNCLHNDQUFnQnQzQjsyQkFpQlE7YUFwRHZDO3VCQW1DZXVmLFFBb0JTc1gsUUFwQk81Z0M7Z0JKeHFGbkQ7eUJJd3FGUytqQyw4QkFBMEJ6YSxRQW9CU3NYLFFBcEJPNWdDO1lBbkMvQixHQXdOY3NwQixZQTNOSnNYLFFBOEVHLHlCQTlFSEE7WUFHVixhQTRFUCxnQkFsdkIyQmpsQyxJQTgzQk4ydEI7WUE1SXJCO2FBQ0ssY0EySWdCQSxnQkE5SXpCbVksb0JBQVN3Qzs7aUJBQVR4QyxVQThJeUJuWSxRQTlJaEIyYTtZQXhEWCxHQXdERXhDLGNBN0VxQmIsUUFxQkcseUJBckJIQTtZQUdWO2FBa0I2QyxrQkF4ckJ6QmpsQyxJQWd2Qi9COGxDO2FBeER3RCxtQ0F3RHhEQSxrQkE3RXFCYixRQXNCbkI1Z0M7YUE2RFMsMkJBaEZYdkQ7YUFnRlcsV0FORnduQyxRQU9jLGFBRHZCdmE7YUExUXFCLGVBeVFyQndhLFNBbEZxQnREO2FBdkxBO1lBQ3BCO2FBQ29DOzRDQUh6QnVEOzBCQUdSQyxVQUZNakw7OzZCQUtjLGdCQU5aZ0wsV0FDRmhMO1lBMExDLElBbldYaUs7OztZQW9JcUI7NEJBdWJJOVosUUEzTkpzWDthQTVOQTthQXBJckJ3QyxrQkFvSVU3Sjs7OztZQWhJWjs7dUJBQWdCL0U7Z0JBQ1gsMkJBRFdBLDJCQUdjO2FBT1AsZUE2aUJJbEwsUUEzTkpzWDthQWxWQTthQUNYOzs7ZUFMUDt5Q0FJTzBEOzs7ZUFLUDs7aUJBclVMN0Q7bUJBdVV5QyxZQVA3QjZEO21CQWhTZDtxQkE2MEI2QmhiOzs7O3NCQTNpQmYsWUFGQWdiO1lBVlosSUFKRWxCOzs7WUEwSXFCOzRCQWliSTlaLFFBM05Kc1g7YUF0TkE7YUFDcEIseUJBRFMyRDthQTFJVm5COzs7O1lBNEJROzhCQStoQm9DcEcsS0EvaEJwQjthQUNILGVBOGhCSTFULFFBM05Kc1g7YUFuVUE7WUFDcEI7YUFDNEI7OzBCQUF6QjhELFdBRk1EOzthQU1SOzRDQVBBRCxNQUNRQztjQU1SOzt5QkFEbUJHLE9BQU1EO1lBTm5CLElBNUJSdkI7OztZQXVJcUI7NEJBb2JJOVosUUEzTkpzWDthQXpOQTthQXZJckJ3QyxrQkF1SVV5Qjs7OztZQWFFOzRDQXVhYXZiLFFBM05Kc1g7YUEzTUQsZUFzYUt0WCxRQXZhdkJ3YjthQUNrQjthQUNDLGVBRm5CQSxrQkE0TW1CbEU7YUExTUE7YUFDUCx5QkFGSm1FO1lBR1Q7YUFDaUM7NENBRmhDblk7MEJBRUVxWSxXQUhNRDs7NkJBTVcsaUJBTG5CcFksWUFEUW9ZO1lBRkUsSUFwSlo1Qjs7OztZQTBIUTs4QkFpY29DcEcsS0FqY3BCO2FBQ0gsZUFnY0kxVCxRQTNOSnNYO2FBck9BO1lBQ3BCO2FBQzBCOzswQkFBdkJzRSxVQUZNL087O2FBTVI7NENBUEFqN0IsTUFDUWk3QjtjQU1SOzt5QkFEbUI5NkIsTUFBTWs3QjtZQU5uQixJQTFIUjZNOzs7O1lBaUpxQjsyQkEwYUk5WixRQTNOSnNYO2FBL01BO2FBakpyQndDLGtCQTJqQjRDcEcsS0ExYWxDckg7Ozs7OztZQS9FUyxHQXlmTXJNLFlBM05Kc1g7OztjQTlSa0MsMkJBcll4QmpsQyxJQTgzQk4ydEIsU0EzQ1IsS0FBUDZiO2NBQU87Ozs7Ozs7Ozs7Ozs7O2NBN2NJLG1CQXdmSTdiLFFBM05Kc1gsU0E3UkE7Y0FrZEEsVUFzQ3VCNUQ7Ozs7Ozs4QkF2ZjFDcGdDOzs7O3lCQXVmMENvZ0MsU0F2ZjFDcGdDOztjQUNEO2VBQ0Qsa0JBRkVBLHFCQUVFd29DLFVBSE05Tjs7K0JBQ1IxNkIsUUFEUTA2QjtjQUFXLElBbkVyQjhMOzs7Ozs7Ozt3QkFnTEYsa0NBbmZpQ3puQyxJQTgzQmRnbUMsUUFBMkIzRTs7Ozs7Ozs7O1lBMWdCNUM7O2FBRHlEO2FBQS9DOytCQTJnQk8yRSxRQUFRclksUUEzZ0JrQixzQkEyZ0JDMFQ7YUF6Z0J2QixlQXlnQkkxVCxRQTNOSnNYO2FBOVNBO1lBQ3BCO2FBQ2lDOzJCQUpoQ3RsQyxRQUlnQzswQkFBOUJncUMsVUFGTWpOOzthQU04Qjs7Y0FBdEMsOEJBQXFCLG9CQU5iQTtjQU1SOzs7eUJBUkEvOEIsUUFPbUJVLE1BQU11cEMsT0FBT3hNO1lBTmxDLElBakRBcUs7Ozs7Ozs7Ozs7WUFnSEE7O2FBRDZDO2FBNGNac0M7YUFBS0M7WUFDNUM7dUJBRHVDRDt3QkFBS0M7MEJBQU0zSTs7Ozs7O2lDQTVjMUN2aEM7Ozs7OzJCQTRjMEN1aEM7OztpQ0E1YzFDdmhDOzs7Ozs7OzswQkE0YzBDdWhDOzs7Ozs7aUNBNWMxQ3ZoQzs7Ozs7MkJBNGMwQ3VoQzs7O2lDQTVjMUN2aEM7Ozs7Ozs7bUJBb2VKLEdBcjRCQWdsQyx1QkE2MkJ3Q2tGO3VCQTVjcENscUMsTUFzZUMsa0JBMUJja21DLFFBQVFyWSxRQUFtQjBUOzt3QkFBTjJJOzBCQUFNM0k7Ozs7OztpQ0E1YzFDdmhDOzs7OzsyQkE0YzBDdWhDOzs7aUNBNWMxQ3ZoQzs7Ozs7OzttQkF3ZUosR0F6NEJBZ2xDLHVCQTYyQm1DaUY7dUJBNWMvQmpxQyxNQTBlQyxrQkE5QmNrbUMsUUFBUXJZLFFBQW1CMFQ7O2lCQW1COUMsR0FoNEJBeUQsdUJBNjJCd0NrRjtxQkE1Y3BDbHFDLE1Ba2VDLGtCQXRCY2ttQyxRQUFRclk7Y0ExY0osbUJBMGNJQSxRQTNOSnNYLFNBL09BO2NBQ3BCO2dCQXhIdUI7Ozs7aUNBR0Ysa0JBOGpCTGUsUUFBUXJZOztpQkEvakJILDBCQUFSa0I7Z0JBRlU7aUJBeUhLOzZCQUF6Qm9iLFVBRk0vTzs7ZUFNMEI7O2dCQUFsQyw4QkFBcUIsZ0JBTmJBO2dCQU1SOzs7MkJBUkFwN0IsTUFPbUJELE1BQU1ELE9BQU8wN0I7Y0FMYixJQWpIckJtTTs7OztRSXp4REE7b0JKbzFFNENwRzs7Ozs7OztnQkE5ZTNCO3NDQWhaY3JoQyxJQTgzQk4ydEI7aUJBOWV2QjtpQkFEbUQ7aUJBQXJEOztvQkErZWlCcVksUUFBUXJZLGdCQS9lYztpQkFFbEIsY0E2ZUlBLGdCQTNOSnNYO2lCQWxSQTtnQkFDcEI7aUJBQ21DOzZCQUxsQy9sQyxNQUtrQzs4QkFBaENnckMsUUFGTXJSOztpQkFNOEI7O2tCQUF0Qyw2QkFBcUIsb0JBTmJBO2tCQU1SOzs7NkJBVEEzNUIsTUFRbUJILE1BQU1JLE9BQU80NUI7Z0JBTmpCOzs7O2dCQVljO3NDQTVaQS80QixJQTgzQk4ydEI7aUJBbGVUO2lCQUFkO2lCQURGOztvQkFtZWlCcVksUUFBUXJZLGdCQW5lYztpQkFFbEIsY0FpZUlBLGdCQTNOSnNYO2lCQXRRQTtnQkFDcEI7aUJBQ3VDOytCQUx0QzVsQyxRQUtzQzs4QkFBcEM4cUMsVUFGTW5SOztpQkFNOEI7O2tCQUF0Qyw2QkFBcUIsb0JBTmJBO2tCQU1SOzs7NkJBVEEzNUIsUUFRbUJKLE1BQU1LLE9BQU82NUI7Z0JBTkg7NkJBekYvQnNPOztxQkEyakI0Q3BHO2FBdGQzQjttQ0F4YWNyaEMsSUE4M0JOMnRCO2NBdGR2QjtjQURtRDtjQUFyRDs7aUJBdWRpQnFZLFFBQVFyWSxnQkF2ZGM7Y0FFbEIsY0FxZElBLGdCQTNOSnNYO2NBMVBBO2FBQ3BCO2NBQ21DOzRCQUxsQ3psQyxRQUtrQzsyQkFBaEM0cUMsVUFGTTlROztjQU04Qjs7ZUFBdEMsNkJBQXFCLG9CQU5iQTtlQU1SOzs7MEJBVEE5NUIsUUFRbUJKLE1BQU1LLE9BQU9nNkI7YUFOakIsSUFyR2pCZ087Ozs7OzthQXFMRixrQ0F4ZmlDem5DLElBODNCTjJ0QixnQkFBbUIwVDtRQXBZUSxPQXpldER5RDtVQStlMEIsYUExUXhCc0IsYUEwUXdCLFlBNVFGSDtVQThReEIsR0E5UXdCb0UsT0E4UXhCLGtCQTRYbUJyRSxRQUFRclksUUFBbUIwVDtVQTlYcEIsSUFFa0IsU0E1UWZnRixhQTRRZSxZQTlRZi82QjtVQWdSN0IsR0FoUjZCc0osT0FnUjdCLGtCQTBYbUJveEIsUUFBUXJZLFFBQW1CMFQ7VUE5WHBCLElBSWtCLFNBN1ExQ2lGLGNBNlEwQyxhQWhSVko7VUFrUmxDLEdBbFJrQ29FLFFBa1JsQyxrQkF3WG1CdEUsUUFBUXJZLFFBQW1CMFQ7VUE5WHBCLElBTWtCLFNBOVExQ21GLFlBOFEwQyxVQUN6QixpQkFuUnlCMW5DO1VBbVJnQixRQUM1RCxrQkFzWG1Ca25DLFFBQVFyWSxRQUFtQjBUO1VBOVhwQjtXQVF3QixTQWhSckJvRjtXQWdScUIsVUFDL0IsaUJBclI2QnpuQztVQXFSbUI7WUFDbkUsU0F0UndDb0MsT0Ewb0JNaWdDO1lBcFg5QyxrQkFvWG1CMkUsUUFBUXJZO1VBOVhELElBNVFGNGMsT0FBZ0JucEMsSUFBaEI2a0MsS0FBZ0I3a0M7VUF3UnRCLEdBeFJNbXBDLE9Bd1JOLGtCQWtYQ3ZFLFFBQVFyWTtRQWxYa0MsYUFyUmhDNFksWUFxUmdDLFdBeFJyQm5sQztRQThSeEMsR0E5UndDb3BDO1VBOFJ4Qzs7a0JBNFc4Q25KOzs7Z0NBNzJCOUN5RDt5QkFxZ0JJLGtCQXdXZWtCLFFBQVFyWSxRQUFtQjBUO1FBeFdFLE9Bbk45Q29HLFVBcU5NO01BdGZaLFNBcUxJZ0Q7UUFHQXpFLFFBQVFyWSxRQUFRc1gsUUFBUXlGLE1BQU16RSxLQUFLMzZCLEtBQUs0NkIsTUFBTTlrQyxJQW9COUN0QyxJQXBCc0RvTztRQUN4RCxHQURVeWdCLFlBQVFzWCxRQUNRLHlCQURSQTtRQUN3QyxTQUN0RDBGLFdBQThCeEU7VUFFakI7bUJBSmZIO21CQUFRclk7bUJBQVFzWDttQkFBY2dCO21CQUFLMzZCO21CQUFLNDZCO21CQUFNOWtDO21CQW9COUN0QzttQkFwQnNEb087bUJBRXRCaTVCO21CQUVqQixnQkE5TmtCbm1DLElBME56QjJ0QixTQUlvQjtRQUg0QixVQW1CeEQ3dUI7VUFSYyxVQVp3Q29PLHlDQWMvQjttQkFkQ3c5QjtzQkFBOEJ4OUIsMEJBaUIxQjtZQUZFLElBQUxuSyxFQWY2Qm1LO1lBZXhCLHVCQUFMbks7b0JBZjZCbUssMEJBa0IzQjtVQUZFLElBQUxyQixJQWhCOEJxQjtVQWdCekIsdUJBQUxyQjtRQUlqQixrQkFBUC9NLElBQXFCO01BNU16QixTQW9JSThyQztRQWlCQTVFLFFBZFFyWSxRQWNRc1gsUUFBUXlGLE1BQU16RSxLQUFLMzZCLEtBQUs0NkIsTUFBTTlrQyxJQUFJdEM7UUFicEQsR0FEVTZ1QixZQWNRc1gsUUFiUSx5QkFhUkE7UUFaWixJQUlKNUQsS0FKSSxnQkEzSzZCcmhDLElBeUt6QjJ0QjtRQUVKLFVBSUowVDtVQUZBLElBVVFxRSxVQWRBL1g7VUFlVixHQURVK1gsY0FBUVQsUUFDUSx5QkFEUkE7VUFWaEI7V0FXd0Q7cUJBQ3hDeUYsTUFBTS9jO2NBQ0Y7b0NBREVBLFFBRk5zWDtlQUdJOzs7dUJBSHBCZTt1QkFHSStFO3VCQUhZOUY7dUJBRUF5Rjt1QkFGY3pFO3VCQUFLMzZCO3VCQUFLNDZCO3VCQUFNOWtDO3VCQUFJdEM7MEJBR3JDRSxNQUVhO1dBQ3RCLHVCQTdMNkJnQixJQXVMekIwbEM7VUFNSixTQUVKOEQ7dUNBRGMsY0FQVWtCLE1BQWhCaEY7O29CQVFSOEQ7Ozs7Z0JBV0E7eUJBbkJBeEQ7eUJBQVFOO3lCQUFRVDt5QkFBUXlGO3lCQUFNekU7eUJBQUszNkI7eUJBQUs0NkI7eUJBQU05a0M7eUJBQUl0Qzs7OztnQkFRekIsR0E5S3pCZ21DO2tCQXVMQTt3QkFqQlFZO21CQWlCUixRQWpCd0JnRixpQkFReEJsQjtrQkFjQSxxQkF0QndCd0I7OztVQXNCeEIsT0E1TEFsRzttQkFnTUU7cUJBMUJGa0I7cUJBQVFOO3FCQUFRVDtxQkFBUXlGO3FCQUFNekU7cUJBQUszNkI7cUJBQUs0NkI7cUJBQU05a0M7cUJBQUl0Qzs7bUJBNkJoRCx1QkE3Qk00bUM7UUFQUjtpQkFPQU07aUJBZFFyWTtpQkFjUXNYO2lCQUFjZ0I7aUJBQUszNkI7aUJBQUs0NkI7aUJBQU05a0M7aUJBQUl0Qzs7O2lCQVJsRHVpQyxLQUV1QjtNQS9JM0IsU0ErRElvRSxZQWlDQU8sUUFuQmlCclksUUFtQkRzWCxRQUFtQzdqQztRQTlCckQ7aUJBR0k2cEMsU0FBU3RkLFFBQVFrWDtVQUVuQixTQUZtQkEsUUFFbkIsY0F4RkFDO1VBeUZFO1lBRWMseUJBNUdpQjlrQyxJQXVHdEIydEI7WUFHVCxrQ0ExRytCM3RCLElBdUd0QjJ0QjtVQUtrQjtrQkFDaEI7WUFFSStYO1FBQ2pCO2FBRGlCQSxjQW1CRFQsUUFsQlUseUJBa0JWQTtVQWpCSiwwQkFqSHFCamxDLElBK0doQjBsQyxXQUVMOzs7O2NBS0gsU0FQUUEsVUFWTVE7Y0FpQmQsY0FQUVI7OztjQU1SLFNBTlFBLFVBVGZwNkI7Y0FlTyxjQU5RbzZCOzs7Y0FLUixTQUxRQSxVQVZmTztjQWVPLGNBTFFQOzs7Y0FJUixTQUpRQSxVQVhNZ0Y7Y0FlZCxjQUpRaEY7OztjQUdSLFNBSFFBLFVBWGZqdUI7Y0FjTyxjQUhRaXVCOzs7VUFFTDtXQU9WLEtBbkJxQlE7V0FtQnJCLEtBbEJBNTZCO1dBa0JBLEtBbkJBMjZCO1dBbUJBLEtBcEJxQnlFO1dBb0JyQixLQXBCQWp6QjtVQStCSixHQXBCbUJpdUIsY0FtQkRULFFBQ1EseUJBRFJBO1VBakJKO1dBa0I0Qzs7Ozs7Z0JBbEh4REg7O2tCQXlITyxrQkFSUGtCLFFBbkJpQk47V0E0QmIsd0JBM0k2QjFsQyxJQStHaEIwbEM7VUE0QmI7O2NBRWlCO3NDQTlCSkEsVUFtQkRUO2VBV0s7Ozt1QkFYckJlO3VCQVdJK0U7dUJBWFk5Rjs7Ozs7dUJBQW1DN2pDOzBCQUVqRDJ1QixNQVNXNUI7OzttQkFJYjtxQkFmQTZYO3FCQW5CaUJOO3FCQW1CRFQ7Ozs7O3FCQUFtQzdqQzt3QkFFakQydUI7VUFnQkYsT0FoQkVBOzthQWtCQSxPQXJJRitVO2NBc0lJLHVCQXhDYVk7YUF3Q3FDO3NCQXJCdERNLFFBbkJpQk4sVUFtQkRULDRCQUFtQzdqQzs7YUErQmpEO3NCQS9CRjRrQyxRQW5CaUJOLFVBbUJEVCw0QkFBbUM3akM7O2FBNEJqRDtzQkE1QkY0a0MsUUFuQmlCTixVQW1CRFQsNEJBQW1DN2pDLFdBTm5DO01BMUZwQixTQWlqQkl1a0MsVUFDQTBGLFlBQVkxZCxRQUFRc1g7UUFDdEI7YUFEY3RYLFlBQVFzWDtVQUdkLDRCQXZsQjJCamxDLElBb2xCckIydEI7VUFHTjtZQUVNLElBQU4yZCxJQUFNLGFBemxCcUJ0ckMsSUFvbEJyQjJ0QjtZQUtBLEdBTFFzWCxXQUtkcUc7WUFBTTthQUVJLGNBM2xCaUJ0ckMsSUFvbEJyQjJ0QixTQUtOMmQsTUFMTTNkO2FBUWEsY0FIbkIyZCxZQUxjckc7YUFRSzthQUNELGNBVFp0WCxRQUtOMmQ7YUFJa0I7NkJBQVYxRCxRQUZSMkQ7WUFFa0IsR0FUeEJGO2lCQVdNSSxnQkFEQUQ7O2NBbkJDLFVBa0JPNUQ7OztlQWxCUCxVQWtCT0E7O2tCQWpCeUIsSUFBdkJsWCxNQWlCRmtYO2tCQWpCeUI7b0JBQzVCLG1CQURLbFg7Ozs7Ozs7Ozs7a0JBbUJWK2EsZ0JBREFEO1lBTE0sZ0JBTU5DLGFBSFExUzs7VUFRWjs7OztZQUVxQjt5QkFsQlhwTCxRQUFRc1g7YUFrQkc7d0JBbEJ2Qm9HLGVBbUJJaHZDO1lBR0osY0FGSXF2QyxXQUZRN1M7cUJBSW1DO01BeGtCbkQsU0Eya0JJK00saUJBQ0FqWSxRQUFRc1g7UUFDVjs7Z0JBREV0WCxZQUFRc1g7Z0NBR2tCLGdCQWpuQk9qbEMsSUE4bUJqQzJ0QjtVQUdvRDtVQUNsQztrQ0FKbEJBLGdCQUFRc1g7V0FLQSx3QkFubkJ5QmpsQyxJQWtuQjNCMnJDO1dBQ0U7VUl6a0VOO1VKd2tFZ0I7V0FHUyxzQkFIckJBLFVBSkUxRztXQU9tQjs7V0FDTCx1QkFEZDRHLFVBUEE1RztXQVNJLHdCQXZuQnFCamxDLElBc25CdkI4ckM7V0FDRTs7O1lBRU07cUJBem5CZTlyQyxJQThtQmpDMnRCLGlCQVFVbWUsWUFSVm5lO2FBV2tCLFFBQUpsc0IsRUFKSzBzQjthQUlELEtBSFIyZDthQVBSdkQ7YUFBVXdEOzs7Ozs7O2NBYXNCO3FDQU54QkQsVUFSRjdHO2VBYzBCOztlQUNSLHVCQURaK0csVUFkTi9HO2NBZ0JLLDBCQTluQm9CamxDLElBNm5CbkJpc0M7Y0FEb0I7ZUFHaEI7c0JBL25CZWpzQyxJQThtQmpDMnRCLGlCQWVjc2UsWUFmZHRlO2VBaUJrQixRQUFKL2pCLElBVkt1a0IsTUFPTTNDO2VBR1AsS0FGSnlnQjtlQWRaMUQ7ZUFBVXdEOzs7Ozs7OztjQUFWeEQsU0FERjVhLFFBQ1lvZTtRQXdCUyxnQkF4Qm5CeEQsU0FETXRELFNBeUJhO3NCQXhCVDhHLGlCQXdCRmxULFVBQ3VDO01BdG1CckQsU0F5bUJJZ04saUJBQ0FsWSxRQUFRc1g7UUFDVjtVQUVvQjtrQ0FIbEJ0WCxRQUFRc1g7V0FJQSx3QkFocEJ5QmpsQyxJQStvQjNCMnJDO1dBQ0U7VUl0bUVOO1lKd21Fd0I7bUNBSHBCQSxVQUhFMUc7YUFNa0I7O2FBQ04sdUJBRFo0RyxVQU5BNUc7WUFRRCwwQkFwcEIwQmpsQyxJQW1wQnpCOHJDO1lBRGtCO2FBR2QsUUFycEJxQjlyQyxJQTRvQmpDMnRCLGlCQU9RbWUsWUFQUm5lO3dCQU9RbWUscUJBRUFycUMsRUFIVzhKOzs7VUFIRDs7Ozs7O1VBYUs7O1dBRFBqUDtXQUFWaXNDO1dBQ2lCLGNBRGpCQSxTQWZFdEQ7V0FnQmU7d0JBRFAzb0MsZUFDSnU4QjtRQUdXLGtCQW5CdkJsTCxRQUFRc1gsU0FtQmU7MkJBQVhsTSxZQUN1QztNQTluQnZELFNBd3RCSStLLGFBQWFuVyxRQUFRc1g7UUp6dEY1QixJSXl0Rm9CUztRQUNmO2FBRGVBLGNBQVFULFFBQ0cseUJBREhBO1VBRXBCLDBCQTV2QmdDamxDLElBMHZCcEIwbEM7WUFFYSxjQUZiQTtVQUVxRCxPQUZyREEsVUFFNEQ7TUExdEI3RSxTQTh0QklvRixlQUFlbmQsUUFBUXNYLFFBQVF6N0I7WUFBaEJrOEIsa0JBQWdCajhCO1FBQ2pDO2FBRGlCaThCLGNBQVFULFFBQ0MseUJBRERBO1VBRW5CLHNCQWx3QjZCamxDLElBZ3dCbEIwbEMsV0FFWCxTQUNKcmhDO1VBREksZ0NBRldxaEMsVUFBZ0JqOEI7VUFFM0IsSUFGMkJDLDBCQUcvQnJGO1VBQ0EsdUJBSitCcUY7a0JBTTdCOzJDQXR3QitCMUosSUFnd0JGMEo7VUFFM0IsSUFRRixVQVZhZzhCLHNDQUFnQmo4QjttQkFXZDtNQXp1QnJCLFNBNnVCSW1pQyxjQUFjamUsUUFBUXNYO1FBQ3hCLEdBRGdCdFgsWUFBUXNYLFFBQ0UseUJBREZBO1FBRWxCLDBCQWp4QjZCamxDLElBK3dCbkIydEI7UUFFVjtvQ0FDVSxlQUhBQSxRQUFRc1g7OztXQUlmLElBSk90WCxxQkFBUXNYLFFBS1EseUJBTFJBO1dBTWhCLHNCQXJ4QjJCamxDLElBK3dCbkIydEIsaUJBTVIsU0FJSnRwQjtXQUpJO21CQUtKLG1CQVhZc3BCLDBCQVVadHBCO1dBSkk7WUFFYyx1QkFSTnNwQixnQkFBUXNYO1lBUUY7O3FCQUFkc0QsV0FBVXhsQztRQUtYLDZCQUFZO01BMXZCckIsU0F1d0JJNGtDLHFCQUFxQmhhLFFBQVFzWCxRQUFRNWdDO1FKeHdGNUMsSUl3d0Y0QnFoQztRQUN2QjthQUR1QkEsY0FBUVQ7V0FFN0Isa0NBM3lCaUNqbEMsSUF5eUJJcUUsRUFBUjRnQztVQUt6QiwwQkE5eUI2QmpsQyxJQXl5QlowbEM7VUFLakI7WUFFSixJQVBxQkEsdUJBQVFUO2FBT0MseUJBUERBO1lBUTFCLG1CQWp6QjhCamxDLElBeXlCWjBsQyx1QkFBZ0JyaEMsU0FBaEJxaEM7WUFTUCw0QkFsekJtQjFsQyxJQXl5QlowbEM7WUFTUDs7Ozs7O3FCQWVJO21EQXhCR0Esa0JBQVFUO3NCQXdCWCxVQUFWeUM7c0JBeEJhaEM7Ozs7cUJBZ0NqQjs4QkFoQ2lCQTs7O2lCQVlqQixJQVppQkEsdUJBQVFUO2tCQVlLLHlCQVpMQTtpQkFhYiw0QkF0ekJpQmpsQyxJQXl5QlowbEM7aUJBYUw7bUJBS0k7bURBbEJDQSxrQkFBUVQ7b0JBa0JULFVBQVZrRTtvQkFsQld6RDs7O21CQWVEOzswQ0FmQ0Esa0JBQVFUO29CQWVULFVBQVZpSDtvQkFmV3hHOztpQkFhTCxJQU9MLFVBcEJVQTs7OztnQkE0Qkg7Z0RBNUJHQSxrQkFBUVQ7aUJBNEJYLFVBQVZrSDtpQkE1QmF6Rzs7O3NCQW1DakIsbUJBbkNpQkE7WUFTUCxJQTRCVixVQXJDaUJBOztVQUtqQixJQWtDQyxVQXZDZ0JBO21CQXVDNEI7TUE5eUJyRCxTQTgzQkl3QixrQkFDRWxCLFFBQVFyWSxRQUFRMFQsS0FBS2lMO1FBQ1YsSUFBVEMsT0FBUyxNQWw2Qm9CdnNDLElBaTZCL0JnbUMsUUFBUXJZLFVBQVJxWTtRQUNXO3dDQWw2Qm9CaG1DLElBaTZCL0JnbUMsUUFBcUJzRyxPQUFMakwsS0FDZGtMLE9BSTRCO01BcDRCcEMsU0EyekJJN0MsaUJBQWlCMUQsUUFBUXJZLFFBQVFzWSxLQUFLMzZCLEtBQUs0NkIsTUFBTTdFO1lBQWhCZ0osWUFBS3oxQixZQUFLMDFCO1FBQzdDO21CQURtQ0Q7b0JBQUt6MUI7cUJBQUswMUI7MkJBQU1qSjs7Ozs7d0JBS2dCO3lCQUhyQzt5QkFBcUM7eUJBS3JDO3lCQUVBO3lCQUpBOzs7eUJBTHFCQTs7OztxQkFBTmlKO3dCQUFNako7Ozs7Ozs7b0JBQVh6c0I7cUJBQUswMUI7eUJBQU1qSjs7Ozs7OztVSW56RS9DOzJCSm16RStDQTs7O3NCQVc1QixHQXYxQnJCeUQ7dUJBdzFCcUIsR0F4MUJyQkE7dUJBczFCcUIsR0F0MUJyQkE7Ozs7Z0JBMDFCQSxHQTExQkFBLHVCQTQwQnNDbHdCO2dCQWdCakMseUJBaEJZb3hCLFFBQVFyWSxRQUF3QjBUOzttQkFBaEJnSjtxQkFBVUM7WUF1QjNDLEdBbjJCQXhGLHVCQTQwQjJDd0Y7WUF5QnRDLHlCQXpCWXRFLFFBQVFyWSxRQUF3QjBUO21CQUFOaUo7WUEyQjNDLEdBdjJCQXhGLHVCQTQwQmlDdUY7WUE2QjVCLHlCQTdCWXJFLFFBQVFyWSxRQUF3QjBUO1VBa0JqRCxHQTkxQkF5RCx1QkE0MEIyQ3dGO1VBcUJ0Qyx5QkFyQll0RSxRQUFRclksbUJBOEJTO01BejFCdEMscUNBbENxQzN0QixLQXc2QlA7YUFPNUJ3c0MsdUJBQXVCeHNDLElBQUlFO01BQ1gsOEJBRE9GLEtBQ1A7O1FBQ04sd0JBREFxdUIsSUFEaUJudUIsT0FBSkY7Ozs7VUFNakIseUJBTnFCRTtVQU1yQix5Q0FOaUJGO21CQU1NO2FBSTdCeXNDLHdCQUF3QnpzQztNQUNSO09BRDJCMHdCO09BQU5yQztPQUNyQiwwQkFEUXJ1QjtPQUNSOztRQUNOLHdCQURBMHhCLE1BQ2dCLGFBRldyRCxNQUFicnVCOzs7O2dCQUl4QixrQ0FKd0JBLElBQW1CMHdCOzs7OztPQTEyRjNDMUM7T0FUQUY7T0FiQUw7T0FHQUM7T0FNQUc7T0F3Q0FPO09BaTRDSXFUO09BK1FBcUI7T0E4R0FNO09Bb0JBSztPQXFCQUM7T0EzNEJBakw7T0EwL0JKa007T0ErNkJBNkg7T0FVQUM7T0E3bkZBN2M7T0E4S0FhO09BY0FFO09BbytCQTJRO09BNXpCQW5RO09BK3dDQXlTO09BandDSWpTO09BdUlKMEM7T0E4ZkFxTTs7YTJCL3ZDQWdNLFNBQVNsL0IsRUFBRWcwQjtVQUFXblQ7YTNCdTdDbEJvVDt3QjJCdDdDV0QsRUFBRWg0QixLQUFPLFdBQVRnNEIsRUFBRWg0QixLQUFPLGtCQURmZ0UsRUFDTWcwQixFQUE4QjtlQURsQ0E7O2VBQVduVDthQUV0QnNlLFNBQVNuL0IsRUFBRXZLO1VBQVdvckI7YTNCcTdDbEJvVDt3QjJCcDdDV3grQixFQUFFdUcsS0FBTyxXQUFUdkcsRUFBRXVHLEtBQU8sa0JBRGZnRSxFQUNNdkssRUFBOEI7ZUFEbENBOztlQUFXb3JCO2FBRXRCdWUsVUFBVXAvQixFQUFFNUk7TS9CdkJqQixJK0J1QjZCeXBCLG9CM0Jrc0RwQnlVLGEyQmxzRE10MUIsRUFBRTVJLEdBQVl5cEI7YUFHeEJ3ZSxRQUFRam9DLEdBQUd5cEIsS0FBTSwrQi9CMUJ0QixVK0IwQmF6cEIsR0FBR3lwQixJQUE0QjthQUN2Q3llLFFBQVE3cEMsRUFBRW9yQixLQUFNLCtCL0IzQnJCLFUrQjJCYXByQixFQUFFb3JCLElBQTJCO2FBQ3JDMGUsU0FBU25vQyxHQUFHeXBCO01BQU0sZ0MvQjVCdkIsVStCNEJjenBCLEdBQUd5cEIsSUFBNkI7YUFDekMyZSxPQUFPM2UsS0FBTSxldEIrUWJ0cUIsT3NCL1FPc3FCLElBQXdCO2FBQy9CNGUsUUFBUTVlLEtBQU0sZXRCK1FkcnFCLE9zQi9RUXFxQixJQUF3QjthQUVoQzZlLFNBQVMxL0I7TS9CaENkLEkrQmdDeUI2Z0I7ZUFDbEI1Z0IsVUFBTWpFO1FBQ0UsSUFBTmxELElBQU07UUFDVixXQURJQSxJQURJa0Q7UUFHTixrQkFKT2dFLEVBSVAsU0FGRWxILEtBRW1CO2EzQnM2Q25CbTdCLFkyQno2Q0ZoMEIsUUFEa0I0Z0I7YUFPcEI4ZSxRQUFROWUsS0FBTSx5QkFBYzVzQixHQUFLLE9BQUxBLENBQU0sRUFBMUI0c0IsSUFBK0I7Ozs7T0FidkN3ZTtPQUdBRztPQUNBQztPQVNBRTtPQVpBTDtPQUNBQztPQVRBTDtPQUlBRTtPQVNBTTtPQVhBUDtPQVdBTzs7Ozs7O2FDNEJJRSxPQUFPeHJDLEVBQUUyQjtNaEM1RGxCLElnQzREa0JxSTtNQUNmO1dBRGVBO29DQUdSeWhDLFlBQUpDO1VBQXFCLGNBQXJCQSxHQUhVMXJDLFVBR055ckM7Y0FIUXpoQzs7UUFFUCxnQkFFYzthQUdwQjJoQyxRQUFNOXJDO01BQ0E7aUJBREFBO09BQ0EsMEJBREFBO09BR1UsV0FIVkEsRUFDSnJFLFVBQ0E0SCxPQURBNUg7TUFFSixnQkFIUXFFLElBQ0pyRSxRQUU0QzthQUc5Q293QyxhQUFhQyxPQUFPbCtCLElBQUltK0IsT0FBT25xQztNQUNqQyxHQURpQ0E7UUFHa0IsSUFBOUNpVSxFQUg0QmpVLEtBRy9CeWEsRUFIK0J6YSxLQUdrQixTQUhwQ2txQyxPQUdienZCO1FBQVE7c0NBQXFCcGMsRUFBRUMsR0FBUyxXQUFYRCxFQUFXLElBSHBCMk4sSUFHVzFOLEdBQWdCLE9BQTVDMlY7aUJBSHFCazJCO01BRWxCLGVBQ21FO2FBWXpFQyxtQkFBaUIsbUJBQThCO2FBRS9DQyxTQUFTQztNQUNYO1FBQ2Esa0JBRkZBLFVBRUU7Ozs7Ozs0QkFKWEY7O1FBUVcsa0JBTkZFLFVBTUUsV0FEVEM7Ozs7Ozs7NEJBUEZIOztNQVlTLGNBVkFFLFNBVUEsWUFMUEMsTUFLb0I7YUFHdEJDLFFBQVF6bkMsSUFBSXVuQyxTQUFTRztNQUN2QixtQkFEVTFuQyxVQUFhMG5DO01BRUksa0JBRmJIO01BRUo7OztrQkExQm1CSTtrQkFBTkM7a0JBQUxDO2lEQUFXRjs7bUJBRTNCLFVBRnFCQztxQkFJakIsTUFKaUJBLFFBSWEsdUNBRHhCM3FDO3FCQUN3QiwwQkFvQjFCK0MsVUF4QlE2bkMsU0FBV0Y7bUJBTXZCLDBCQWtCSTNuQyxVQXhCUTZuQyxJQUFXRjs7b0JBMEJpQjthQUc1Q0csYUFBYVAsU0FBU0c7TUFDaEIsSUFBSi9xQyxFQUFJLGNBQ1IsUUFESUEsRUFEVzRxQyxTQUFTRyxRQUV4QixnQkFESS9xQyxFQUVhO2FBR2ZvckMsTUFBTVIsU0FBU0c7TUFDSixzQkFETEgsU0FBU0c7TUFDSixxQ0FBOEI7UUFHekMzaEI7YUFFQWlpQixxQkFBbUIxc0M7TUFDckI7UUFBUywyQkFEWUE7Ozs7bUJBRVU7YUFFN0Iyc0Msb0JBQWtCM3NDO01BQ3BCO1FBQVMsK0JBRFdBOzs7O1FBSHBCLFdBS3NCO2FBRXBCNHNDLHNCQUFvQjVzQztNQUN0QjtRQUFTLGlDQURhQTs7OztRQUh0QixXQUtzQjthQUVwQjZzQztNQUFrQ0MsYUFBYXJpQixRQUFRc2lCLEtBQUtkLFNBQVNlLFFBQVFaO01BQy9FLElBQUlhLFFBRDZDeGlCO01BQ2pELFNBQ0l5aUIsY0FBY0M7UUFLUjs7O1VBTk5GLFVBRHFERjtZQVFELGlCQVJDQSxRQUNyREU7O1FBUUYsT0FQZ0JFOzs7OzthQVdWLG1CQU5GOXJDLFFBQ0ErckM7OztlQVFpQjVKLFNBZEwySixTQWNBcHlCLElBZEFveUIsU0FjTEUsSUFkS0Y7V0FlVixtQkFWRjlyQyxRQUNBK3JDLFNBUVlyeUIsSUFBTHN5QixJQUFVN0o7O2lCQURmLElBRE0zakMsRUFaSXN0QyxTQWFWLG1CQVJGOXJDLFFBQ0ErckMsU0FNUXZ0QztrQkFNTixJQURNbUksSUFqQkltbEMsU0FrQlYsbUJBYkY5ckMsUUFDQStyQyxTQVdRcGxDO1FBR1osUUFmSTNHLEVBUHdENHFDLFlBQWlCRztRQXVCMUUsZ0JBckJhZTtjQXFCYyxXQXJCZEEsMEJBdUJQLFNBbEJMOXJDO1FBaUJNLHdCQWpCTkEsR0FrQndCO01BeEI5Qjs7V0FEaURvcEIsYUFBUXNpQjtVQTZCdkQ7cUJBN0IrQ3RpQixXQThCekM1cUIsbUJBOUJpRGt0QzswQ0E4QmpEbHRDO3VCQUN1QixnQkFEdkJBO2VBQ3dDO2lCQUVwQzs7OEJBSEpBLEVBOUJzRG9zQztrQkFnQ3BEcUI7a0JBQVFDOzs7O2lCQUdWO21CQUNxQjtrQ0FOckIxdEM7b0JBTXFCOzs4QkFBTmtiO29CQUNiLFlBREl5eUIsUUFwQ2dEdkI7OzswREE4QnREcHNDOztxQkFFRXl0QyxZQUFRQztlQVFaOzswQkFWRTF0QyxFQUVVNnRDOzRCQVFSQztxQkFDRixHQVRVRDsyQkFXSDN5QixJQVhHMnlCLDJCQUZWN3RDLEVBYU9rYjtxQkFERyxRQUNnRDswQkFIeEQ0eUI7Z0JBQUosZ0JBVkU5dEMsRUFFVTB0QztnQkFRWjswQkFWRTF0QyxFQUVVNnRDOzRCQVlSRztxQkFDRixHQWJVSCxZQWlCSDN5QixJQWpCRzJ5QixpQkFpQkgzeUI7cUJBRkgsSUEvQ3FDMFAsc0JBQVFzaUI7dUJBK0NELFNBL0NQdGlCO3VCQStDTyx3QkEvQ0NzaUI7cUJBZ0R4QyxpQkFsQlRsdEMsR0FtQmlCOzBCQUxmZ3VDO2dCQUpKLGtCQVZFaHVDLEVBRVUwdEM7Z0JBUVo7MEJBUllHOzRCQW1CUks7cUJBQ0YsT0FwQlVMLFVBaEMrQmpqQixlQXNEM0I7MEJBSFpzakI7Z0JBWEosMEJBUllSO2dCQVFaOzBCQVZFMXRDLEVBVUU4dEMsT0FJQUUsUUFPQUU7NEJBS0lFO3FCQUFlOzhCQUNYLElBQUx2dUMsV0FBSyxrQkFBTEE7O3dCQUVIOzt5QkFBVTt5QkFDRSwyQkFEUnFiO3dCQUNROzBCQUVBLElBQUwvUyxhQUFLLFdBSlRrbUMsSUFJSWxtQyxLQUVQO3dCQUhVLGlCQS9CWm5JLEVBNkJNa2I7OEJBTUcsSUFBTDVXLFdBQUs7OEJBQ0UsSUFBTCtaLGFBQUs7O3dCQUVULGlCQUFVO3dCQUNWLFdBRktpd0IsSUFDRG56Qjt3QkFDSjs7d0JBWUEsSUFEU296QixhQUNKOzt3QkFHTDs7eUJBQVU7eUJBQ0UsNEJBRFJsekI7d0JBQ1E7MEJBRUEsSUFBTGxiLGFBQUssV0FKVnF1QyxJQUlLcnVDLEdBRVA7d0JBSFUsaUJBeERaSCxFQXNETXFiOzt3QkFPSjs7eUJBQVU7eUJBQ0UsNEJBRFJxekI7d0JBQ1E7MEJBRUEsSUFBTEMsZUFBSyxTQUFMQSxJQUVQO3dCQUhVLGlCQS9EWjN1QyxFQTZETTB1Qzs7d0JBT0o7O3lCQUFVO3lCQUNFLDhCQURSRzt3QkFDUTswQkFFQSxJQUFMQzswQkFBSyxXQUpSRixJQUlHRTswQkFFUDt3QkFIVSxpQkF0RVo5dUMsRUFvRU02dUM7O3dCQU9KOzt5QkFBVTt5QkFDRSw4QkFEUkc7d0JBQ1E7MEJBRUEsSUFBTEMsZUFBSyxTQUFMQSxJQUVQO3dCQUhVLGlCQTdFWmp2QyxFQTJFTWd2Qzs7d0JBT0osSUFESUUsZUFDSixjQXhESWQsYUF1REFjOzt3QkF2Q00sSUFERUMsYUFBTnZQLGNBQ0k7d0JBQ1AsT0FEQ3dQLE1BREV4UDswQkFHSixXQUhVdVAsSUFDUkMsT0FFRjt3QkFHNEI7OztnQ0EvQ2hDcHZDO2dDQTBDTW92QztnQ0FLMEIsZUFDRSxrQ0FQMUJ4UDs7d0JBMkNOLElBREd5UDt3QkFHYTs2QkFwSHVCemtCLGNBQVFzaUI7NEJBbUg3QyxTQW5IcUN0aUI7NEJBbUhyQyxXQUZDeWtCLElBRUMsaUJBbkgyQ25DOzRCQW9IN0M7Ozs7NEJBRUdvQzsrQkF0SHFCckM7Ozs7d0JBeUhoQixxQkFDRyxrQkFKUnFDLElBR0RDO3dCQUVKO3dCQUZVO3lCQUdHLGFBNUhrQ3JDLFVBQVJ0aUI7eUJBNkgzQjs7NEJBN0htQ3NpQjs0QkFBUnRpQjs2QkFBUXNpQixxQkFBUnRpQjt3QkE4SGhDOzs2Q0FGSDZrQixVQUZBRCxVQUdBRTt3QkFDRyxTQUFtQzswQkF0RXRDdEI7Z0JBaEJSLDRCQVZFcHVDLEVBVUU4dEMsT0FJQUUsUUFPQUU7ZUE2RUosYUFoR0lUO2VBUUo7Ozs7O1l4QjZWQSxjd0JwUUcsV0FqSThETixRQThCL0RudEM7OzsrQkFvR1UsSUFBTGdpQixTQUFXLHVCQUFYQTtnQ0FDTSxJQUFML04sU0FBVyxvQkFBWEE7O1VBRVo7O1FBeElGLFNBeUlJO2FBRUYwN0I7TUFBOEIva0IsUUFBUXNpQixLQUFLZCxTQUFTZSxRQUFRWjtNQUM5RDtpQkFEZ0MzaEIsUUFBUXNpQixLQUFLZCxTQUFTZSxRQUFRWixPQUNhO2FBRXpFcUQsbUJBQXFCcEMsSUFBaUJOLEtBQUtkLFNBQVNlLFFBQVFaO01BQzlELEdBRHVCaUIsSUFBUSxRQUFSQSxpQkFBUXFDLGFBQVJDLFVBekpyQmxsQjtNQTBKRjtpQkFEdUJrbEIsYUFBaUI1QyxNQUFLZCxTQUFTZSxRQUFRWixPQUNvQjthQUdoRndELFdBQWF2QyxJQUFpQk4sS0FBS2QsU0FBU2UsUUFBUVo7TUFDdEQsR0FEZWlCLElBQVEsUUFBUkEsaUJBQVFxQyxhQUFSQyxVQTdKYmxsQjtNQThKRjtrQkFEZWtsQixXQUFpQjVDLFFBQUtkLFVBQVNlLFFBQVFaLE9BQ2dCO2FBR3BFekksTUFBTWhpQyxFQUFFakMsRUFBRWlpQztNQUNaO1FBQ0UsMEJBRk1oZ0MsRUFBRWpDLEVBQUVpaUM7Ozs7VUFJQyxJQUFQa08sYUFBTyx5QkFBUEEsT0FBTzs7VUFDQyxJQUFQQyxhQUFPLHdCQUFQQSxPQUFPO2tCQUF1QjthQUduQ0MsY0FBY3B1QyxFQUFFakMsRUFBRWlpQztNQUNwQjtRQUNFLGtDQUZjaGdDLEVBQUVqQyxFQUFFaWlDOzs7O1VBSVAsSUFBUGtPLGFBQU8seUJBQVBBLE9BQU87O1VBQ0MsSUFBUEMsYUFBTyx3QkFBUEEsT0FBTztrQkFBdUI7YUFFbkNFLGFBQWFydUMsRUFBRWpDLEVBQUVpaUM7TUFDbkI7UUFJRTtTQUhJb0w7U0FDQVQsUUFIUzNxQztTQUlUZ3VDLGFBcExKbGxCO1NBcUxBLG1DQURJa2xCLFVBRkE1QyxLQUNBVCxLQUhXNXNDLEVBQUVpaUM7Ozs7O1VBT04sSUFBUGtPLGFBQU8seUJBQVBBLE9BQU87O1VBQ0MsSUFBUEMsYUFBTyx3QkFBUEEsT0FBTztrQkFBdUI7YUFHbkNHLFlBQVlwd0M7TUFDZCxJQUFJdUQsSUFBSixzQkFEY3ZEO01BQ2QsU0FDUXF3QyxLQUFLL3VDO1FoQ25UaEIsSWdDbVRnQjhJO1FBQ1g7YUFGRTdHLE9BQ1M2RyxXQURUN0c7VUFHTSwwQkFKSXZELEVBRURvSztZQUVjLFFBRmRBO1VBR04sT0FITUEsSUFHTDtNQUpSO1FBTU0sSUFDSkEsSUFESSxRQVBRcEs7Ozs7VUFVVjtZQUFZLElBQ1ZzQixFQURVLFFBVkZ0Qjs7O3lDQUNWdUQ7WUFVTztzQkFBTGpDO1FBSEM7a0JBQUw4SSxZQUtLO2FBR0xrbUMsWUFBWUM7VUFBZ0IvRCxhQUFOQyxjQUFMK0Q7b0JBQUsvRDtlQUVWLElBRkE4RCxJQUVBLHNCQUZLQztlQUdpQixJQUh0QkQsSUFHc0Isc0JBSGpCQyxPQUdpQixZQUhOaEU7YUFNNUJpRSxvQkFBb0J6d0M7TUFDdEIsSUFBSTB3QztNQUFKO3dCQUNnRTl0QztpQkFBckQsU0FBcURBLE9BRDVEOHRDLFNBQ3dDLHNCQUF5QixPQUFMOXRDLENBQU87ZUFGakQ1QyxFQUVtRDthQXlCdkUyd0MsTUFBUW5ELElBQWVwQjtNQUN6QixHQURVb0IsSUFBTSxRQUFOQSxhQUFNcUMsYUFBTmUsTXZCM1BSOXZDO011QjRQYzswQkFEU3NyQztPQUVmLGdCQW5DUmtFLGNBa0NFTztPQUVNLFVBRE50dEMsSUFGTXF0QztNQUlEO3dCQTNCU0U7aUJBQ2xCLFNBRGtCQSxPQUNsQixLQURrQkE7aUJBQ2xCLHdCQURrQkE7O3FCQU9kOzRCQVBjQTtzQkFPRCxxQkFEV2Q7c0JBRVgsZ0JBQWEsTUFSaEIzckMsUUFPTjBzQztxQkFFUTs7O3dDQUFPLElBRGZDLFNBQ3dCLG9CQUhKaEI7bUJBS1g7b0JBREhsTyxJQVZJZ1A7b0JBV0QsbUJBREhoUDtvQkFDRzswQkFYSHo5QixRQVlONnNDLGVBREFEO21CQUFTLE9BRVQ1eEI7cUJBSVc7b0NBSlhBO3NCQUtXLGFBQVcsb0JBUmhCeWlCLE9BQ05tUDtzQkFRVzs2QkFUTG5QLElBQ05tUCxPQU9XLHNCQVJMblAsT0FDTm1QO3FCQVNVLHdCQUZSakYsT0FFaUIsSUFIakJtRixPQUVBbEY7bUJBSlEsd0NBTEpuSztpQkFMVixPQUxjZ1A7ZUF3QmRELFVBR2dDO2FBU2xDTyxTQUFTQyxLQUFLdmpDLElBQUl3akM7TUFDWCxtQkFEV0EsTUFFVjtlQUVORTtRQUNTLElBWkh4eEMsRUFZRyxTQUhUNkU7UUFHUyxHQUxGd3NDO1VBTlgsSUFBSTl0QyxJQUFKLHNCQURVdkQ7VUFDVixPQUFJdUQ7cUJBQ1UsZ0JBRkp2RCxFQUNOdUQ7cUJBRUYsTUFIUXZELElBQ051RDs7Ozs7VXhCZ0tFLHVCd0JqS0l2RDtVQUNWLElBWU15eEM7O2tCQWJJenhDO1FBY1IsY0FESXl4QyxLQUhGRjtRQUlGLGVBTEUxc0MsSUFNYztNQU5SOztVQVVJLElBQUpqQyxFQUFJLG1CQVhWc0I7VUFXVSxHQUFKdEIsTUFaTWtMLElBYU0sY0FBYyxTQVhoQ2pKLElBVU1qQzs7Ozs7VUFLUCxPQWZDaUMsT0FlMEI7VUFDOUIsc0JBakJJWDtVQWtCVSxtQkFoQlZxdEM7bUJBZ0IyQjs7SUFFbEIsU0FBWEcsZWhDcFlMLE9nQytXS047SUFxQlc7SUFFQyxTQUFaTyxnQmhDdFlMLE9nQytXS1A7SUF1QlksU0FFWlEsVUFBVTlqQyxJQUFJd2pDLEtBQUtPO01BQ1osSUFBTDF1QyxHQUFLLGFBRE9tdUM7TUFFaEIsZ0JBQWdCdHhDLEdBQUssMEJBRGpCbUQsU0FDWW5ELEVBRko4TixJQUVnQyxFQUZ2QitqQztNQUVyQixpQkFESTF1QyxHQUVRO0lBTEU7SUFPQSxTQUFaMnVDLHFCaEM3WUwsT2dDd1lLRjtJQUtZO0lBRUMsU0FBYkcsc0JoQy9ZTCxPZ0N3WUtIO0lBT2E7OztPQXhIYjlOO09BUUFvTTtPQVpBSDtPQUpBSDtPQUhBRDtPQTBCQVE7OztPQXBMQXZEO09BTkFEO09Bc1BBZ0U7T0E1T0EvbEI7T0E4UUE4bUI7T0FFQUM7T0FPQUc7T0FFQUM7SUFBYTtRM0I3WGJDO2FBSUFDLE1BQU05eEMsRUFBRXhFO01BQ1YsSUFBSWtFLEVBRElNLEVBQUV4RTtNQUVILGdCQURIa0U7ZUFHSSxhQUhKQTtpQkFJRix5QkFKRUE7aUJBS0ksYUFMSkEsV0FNRixnQkFORUE7ZUFFRix5QkFGRUEsRUFRQzthQUVDcXlDLGFBQWEveEMsRUFBRXhFO01BQ3JCLEdBRG1Cd0UsZ0JBQUV4RTtNQUVhLHNCQUZmd0UsRUFBRXhFLFdBRUMsV0FGSHdFLEVBQUV4RTtNQUVDLDBDQUFrQzthQUV0RHcyQyxPQUFPaHlDO01BQ1QsVUFEU0E7TUFDVDtRQUlvQyxzQkFMM0JBLEtBS2UsV0FMZkE7UUFLZTs7ZUFIakI7ZUFDQTtnQkFDZSxlQUpiQSxLQUlhLHNDQUNnQzthQUVwRGl5QyxZQWlCWWp5QztNQWhCZCxTQUFRa3lDO1FMN0NYO1FLNkNrQjs7Z0JBQ0xsd0MsY0FBTkM7aUJBQ2Esb0JBRGJBLEdBZVVqQztxQkFiSSxJQUFMSCxVQUFLLE9BQUxBO3dCQUZIbUM7O1VBS0osR0FVUWhDOzs7MkJBUG9CbXlDLGdCQUFOQyxjQUFOakI7O3FCMEJmcEI1RixRMUJuQkE1d0M7cUJBa0NvQncyQztxQkFBTWlCO3FCQUFNRDs7O2FBT3BCbnlDOzs7YUFMcUJxeUM7YUFBTkM7YUFBTkM7O3FCMEJqQnJCaEgsUTFCbkJBNXdDO3FCQW9DcUI0M0M7cUJBQU1EO3FCQUFNRDs7O2FBS3JCcnlDOzs7YUFIaUN3eUM7YUFBTkM7YUFBTkM7O3FCMEJuQmpDbkgsUTFCbkJBNXdDO3FCQXNDaUMrM0M7cUJBQU1EO3FCQUFNRDs7O1VBSXJDLHNCQURJeHlDO1lBSUYsSUFBSTJ5QyxZQUpGM3lDLFFBTVksV0FGVjJ5QyxZQUVVLE9BTlozeUM7VUFFRCxPQUZDQSxLQU1zQjtNQXRCcEMsWUEzQkU2eEMsWUFrRFk7YUFFWmUsTUFBTUMsSUFBSTkzQjtNQUNaO1FBQ0Usb0JBRk04M0IsSUFBSTkzQixLQUlWO1lBREcvYTs7UUFDZ0MscUJBRGhDQTtRQUNIO1FBQ0EsY0lrT0FvQztRSmxPQSxNQUZHcEMsRUFHSTthQUVQOHlDLFFBQU1ELElBQUk5M0I7TUFDWjtRQUNFLG9CQUZNODNCLElBQUk5M0I7WUFHUC9hOztRQUNILGNJME5BbUM7UUp6Tm1DLHFCQUZoQ25DO1FBRUg7dUJBQ007YUFvQ04reUMsc0JBQXNCQztNTHhIM0IsVUt5SFksbUNBRGVBLElBRUY7YUFFcEJDLHNCQUFzQmppQyxJQUFJa0I7TUFDNUIsU0FBSWdoQyxLQUFLQztRQUNQLE9BRE9BO3VCQURlbmlDOzs7a0NBS2lEO01BSnpFLFNBRDRCa0I7UUFjeEI7Y0Fkd0JBO1NBY3hCLEtBZHdCQTtTQWN4QixLQWR3QkE7U0FjeEIsS0Fkd0JBOztTQWVoQixVQWZnQkE7UUFjbkI7TUFMTCxHQVR3QkE7TUFZYztNQUEvQix5Q0FLdUM7YUFjaERraEMsb0JBQW9CQyxRQUFRQztNQUNJLElBYkVDLFVBYUYsc0JBREpEO01BWDlCLEdBRG9DQztRQU1oQyxNQU5nQ0EsYUFNaEMsS0FER3p3QyxxQkFDSDs7O1VBQ0U7WUFBTSxnQ0FEUnRILEVBQ2dDLGlCQUY3QnNILEVBQ0h0SDtZQUNRLFVBRVUsSUFBUDRDLGFBQU8sbUJBR0FpMUMsY0FIUGoxQztZQUZILFNBRFI1Qzs7O1FBSEE7cUJBU2tCNjNDLGFBQ2lEO2FBR3JFRyxnQkFBZ0JIO01BQ1UsMkJBRFZBLFFBQ1Usb0NBQXNCO2FBZWhESSx3QkFBd0JIO01BQ04sSUFkRUMsVUFjRixzQkFETUQ7TUFaMUIsR0FEc0JDO1FBS1YsSUFETHp3QyxFQUpleXdDLGFBS1Ysc0JBREx6d0MscUJBQ0s7O2NBQ1J0SDtVQUNFO1lBQU0sZ0NBRFJBLEVBQ2dDLGlCQUg3QnNILEVBRUh0SDtZQUNRLFVBRVUsSUFBUDRDLGFBQU8sbUJBSmRpRCxRQUlPakQ7WUFGSCxTQURSNUM7OztRQUtBLGdCQU5JNkY7TUFGTCxpRUFXc0Q7YUFFdkRxeUMsd0JBRWlCN29DO01BRlMsYUFFVEEsMEJBQWU7YUFFaEM4b0MseUJBQ2U5b0MsT0FEWSxhQUNaQSxtQkFDWTthQVMzQitvQyx3QkFFZS9vQztNQUZXLGFBRVhBLHNEQU1kO2FBRURncEMsZ0JBQWdCUDtNQU9aLGdDQVBZQTtNQU9aO1FBR0YsMkJBREtDO1FBSW1COzs7O1lBRUg7b0NBTmhCQTthQUNhOztZQUtHO3lCQU5oQkE7TUFERyxRQVVDO2FBc0JYTztNQUEyQyxtRUFBc0I7YUFLakVDLGlCQUFpQkMsSUFDbkIsaUJBRG1CQSxHQXRPakJuQyxhQXVPRixRQUEyQjthQUl6Qm9DLFNBQ0VqMEMsR0FDSiwwQkFESUEsU0FDc0M7YUFFeENrMEMsWUFBWWwwQyxHQUNILElBQVBrUyxLQUFPLFNBREdsUyxHQUNILE9BQVBrUyxPQUM4QjthQUVoQ2lpQyxjQUFjbjBDLEdBQ0wsSUFBUGtTLEtBQU8sU0FES2xTLEdBQ0wsT0FBUGtTLE9BQ2lDO1FBR25Da2lDO2FBRUFDLCtCQUErQkw7TUFBSyxtQ0FBTEEsSUFBSyxRQUFxQztJQUUvQixvQkw5US9DO0lLOFErQyxvQkw5US9DO0lLOFErQztNTDlRL0M7SUs4UStDLG9CTDlRL0M7SUs4UStDOzs7T0E1RjFDTjtPQUlBQztPQVdBQztPQXJFQVg7SUFrSjBDLG9CTDlRL0M7SUs4UStDLG9CTDlRL0M7SUs4UStDLG9CTDlRL0M7SUs4UStDOzs7T0FsTzFDaEI7T0EwQkFXO09BUUFFO09BaUZBVTtPQW9GQU07c0JMblBMOztPS3dQS0M7O09BN0ZBWDtPQW9CQUs7O09BNkZBWTtPQWpFQVI7Ozs7OztPQXNEQUs7T0FJQUM7SUFTMEM7YTRCN00xQ0csV0FBVzd4QztNQUNiLG9DQUFJK1k7TUFDSixtQkFGYS9ZO01BQ2IsU0FBSStZO01BRUosbUJBSGEvWTtNQUNiLFNBQUkrWTtNQUdKLG1CQUphL1k7TUFLYixRQUxhQTtNQUNiO09BSUEsS0FKSStZO09BS21CO1lBTG5CQTtNQU1KLG1CQVBhL1ksUUFNVHpCO01BTEosU0FBSXdhO01BT0osbUJBUmEvWSxRQU1UekI7TUFMSixTQUFJd2E7TUFRSixtQkFUYS9ZLFFBTVR6QjtNQUlKLFFBVmF5QjtNQUNiO09BU0EsS0FUSStZO09BVW1CO1lBVm5CQTtNQVdKLG1CQVphL1ksUUFXVHhCO01BVkosU0FBSXVhO01BWUosbUJBYmEvWSxRQVdUeEI7TUFWSixTQUFJdWE7TUFhSixtQkFkYS9ZLFFBV1R4QjtNQVZKLFNBQUl1YTtNQWNKLG1CQWZhL1ksUUFXVHhCO01BVkosU0FBSXVhO01BZUosbUJBaEJhL1ksUUFXVHhCO01BVkosU0FBSXVhO01BZ0JKLG1CQWpCYS9ZLFFBV1R4QjtNQU9KLFFBbEJhd0I7TUFDYixTQUFJK1k7TUFrQkosbUJBbkJhL1k7TUFDYixTQUFJK1k7TUFtQkosbUJBcEJhL1k7TUFDYixTQUFJK1k7TUFtQkosMEJBcEJhL1ksYUFxQitCO2FBRzFDOHhDO01BQ2tCOzs7OztjQUFmRyxLQUFTRixLQUFMQyxRQUM0QzthQW1CbkRFLGFBQWFqMUMsR0FFZixZQUNXO2FBR1RrMUMsYUFBYTl4QyxHQUFJLGlCQUFVO3dCakNwSGhDOzs7Ozs7T2lDaUVLd3hDO09Bd0JBQzsyQmpDekZMOzs7T2lDOEdLSTtPQU1BQzs7YUMxRkFDLE9BQU96MkM7TUFDVCx1QkFEU0EsTUFDVCxzQkFEU0EsS0FDOEI7YUFFckMwMkMsTUFBTXp6QyxHQUFXLG1DQUFYQSxHQUFxQzthQUUzQzB6QyxVQUFVMzJDLElBQUkrRSxJQUFJQztNQUNwQixRQURnQkQ7ZUFBSUM7cUNBQVJoRixPQUFRZ0YsV0FBSkQ7Z0JBR1gsZ0JBSE8vRSxJQUFJK0UsSUFBSUM7TUFFZix3Q0FDeUI7YUFFNUI0eEMsU0FBUzN6QyxFQUFFOEIsSUFBSUM7TUFBZ0Isc0NBQXRCL0IsR0FBRThCLElBQUlDLElBQWtEO2FBRWpFK3RDLEtBQUs4RDtNQUNFLElBQUxseEMsR0FBSyxZQURGa3hDO01BQ0U7UUFDSCxJQUNGLy9CLEVBREUsc0JBREZuUjtZQUdVK1AsOEJBQUssc0JBSGYvUCxJQUdlLE1BQUwrUDtNQURMLHNCQUZML1A7TUFFSyxPQUFMbVIsQ0FDbUM7YUFFckNnZ0MsU0FBTzN4QyxLQUFLNHhDLFFBQ2QscUJBRFM1eEMsS0FBSzR4QyxPQUNXO2FBRXZCQyxRQUFNN3hDLE1BQU8sMkJBQVBBLFFBQWtDO2FBRXhDOHhDLFNBQVNsMEMsR0FDWCxlQURXQSwyQkFDaUU7YUFFMUVtMEMsT0FBT3BnQztNQUNULGdDQURTQSxHQUNxQjtNQUEyQixpQ0FFekQxWjtNQUNFO1lBQUl3RSxFQUFKLGdCQUpPa1YsRUFHVDFaO1FBRWdDLHNCQUg1QjBjLE9BQ0oxYyxVQUVnQyxTQUQxQndFO1FBRTRCLHNCQUo5QmtZLFFBQ0oxYyxtQkFHa0MsU0FGNUJ3RTtRQUFKLFNBREZ4RTs7UUFLQSw0QkFOSTBjLFFBTXlCO2FBRTNCcTlCLFNBQVMxMUM7TUFDWCxnQ0FEV0EsR0FDbUI7TUFBNkIsU0FDdkQyMUMsTUFBTS95QztRQUNSLFNBRFFBOzs7Ozs7O1FBS0QsZ0RBQTBDO01BTlEsaUNBVTNEakg7TUFDRTtvQkFERkEsTUFGaUMsV0FBTSxnQkFUNUJxRSxFQVNGK0I7UUFHUDtVQUZFc1csT0FDSjFjLEVBQ3FCLEtBSFIsTUFBTSxnQkFUUnFFLEVBU0YrQjtRQUdQLFNBREZwRzs7UUFHQSw0QkFKSTBjLFFBSXlCOzs7Ozs7T0FsRDNCMjhCO09BR0FDO09BRUFDO09BS0FDO09BRUE3RDtPQU1BK0Q7T0FHQUU7T0FLQUU7T0FVQUM7O2FDNUJFRSxpQkFBc0IsaUNBQTBCO2FBQ2hEQyxPQUFPQyxJQUFJQztNQUNiLE9BRGFBLFNBQUpELGFBQ1QsU0FEYUMsT0FDYixRQUNrQjthQUdoQkMsVUFBVWgyQyxFQUFFaTJDO01BQ2QsaUJBRGNBLDJCQU9kLEVBRElDLGtCQUVKbjBDO01BQ0U7eUJBVFUvQixLQVFaK0I7UUFDRSxTQURGQTs7UUFDRSxJQUVGLGlCQUNrQixpQkFMZEQsT0FJSjtRQUNrQjtjQUFsQm5HO1VBQ0U7O2VBREZBO2FBQ0UsV0FERkEsRUFMSW1HO2FBUW9CLG1CQVRwQm8wQyxPQVFFbnFDO1lBSEZqSCxVQVYrQixXQVUvQkEsUUFWdUMscUJBQTFCM0U7WUFZZjtrQkFGRTJFO2FBUFc7YUFEMEM7YUFBMUI7YUFBbkI7YUFhRyx1QkFoQkg5RSxLQWFOa087WUFHSixpQkFoQlVsTyxLQWFOa087WUFBSixTQURGdlM7OztRQU1BO2lCQUFVO2FBR1J3NkMsT0FBS0Y7TUFDTSxJQUFUNTlCLE9BQVMsYUFDYixVQURJQSxPQURHNDlCLE1BRVAsT0FESTU5QixNQUVFO2FBR0orOUIsc0JBQXlCLHNDQUFnQjthQUV6Q0MsT0FBS3IyQyxHQUNNLElBQVRxWSxPQUFTLGFBQ2IsT0FESUEsT0FER3JZLEdBRVAsT0FESXFZLE1BRUU7YUFJSmkrQixLQUFLdDJDO01BQ1AsUUFET0E7TUFDUDtZQURPQTtPQUNQLHdCQURPQTtPQUNQLE1BRE9BO09BR007eUJBSE5BOztTQUVIdTJDOzs7T0FDUyxTQUFUQztPQUFTLEtBSE54MkM7TUFNUCxpQkFOT0EsdUJBS0h5MkM7TUFDSixPQURJQSxRQUVJO2FBUU5DLE1BQUkxMkMsRUFBRTIyQztNQUNSLG1CQURRQTs7O1VBSkEsV0FJRjMyQyxHQUpFLFdBQUpzRSxFQUlJcXlDO1VBSkEsa0JBSUFBLHVCQUpKcnlDLElBQ0FYO1VBQytDLE9BRC9DQTtNQUtDLGtDQUNjO2FBWWpCaXpDLE1BQU01MkMsRUFBRTIyQztNQUNWLGtCQURVQSxnQkFFTDtNQVZMO1FBQXNCLFlBUWQzMkMsR0FQaUMsU0FPakNBLGNBUGlDLEVBRHJDNjJDLEtBQ0FDLEdBQXFDLFdBQ3JDeHlDLEVBTU1xeUM7UUFQK0Isb0JBQ3JDcnlDLElBQ0FYLG9CQUtNZ3pDOztRQUZMLE9BSERoekMsRUFRaUI7YUFhbkJvekMsTUFBTS8yQyxFQUFFMjJDO01BQ1Ysa0JBRFVBLG1CQUVMO01BWEw7UUFBc0I7cUNBU2QzMkM7U0FSZ0Msa0RBUWhDQTtTQVBpQyxrREFPakNBO1NBUGlDLGdCQUZyQzYyQyxHQUVxQyxjQURyQ0MsR0FDQUU7U0FBcUMseUJBQ3JDMXlDLEVBTU1xeUM7UUFQK0I7OzJCQUNyQ3J5QyxFQUNBWDtZQUZxQyw4QmpDakV6Q2xKLFVpQ3dFVWs4Qzs7UUFGTCxPQUhEaHpDLEVBUWlCO0lBS2hCLFNBRkhzekMsVUFFT2ozQyxFQUFFMjJDLE9BQTRCLGFBQTlCMzJDLEVBQUUyMkMsTUFBZ0U7YUFZekVPLFFBQU1sM0MsRUFBRTIyQztNQUxnQixZQUtsQjMyQyxHQUprQixRQUlsQkE7Y0FMSmdmLG1CQUNBRixvQkFJTTYzQixLQUEyQjthQUVuQ1EsS0FBS24zQyxHQUFLLG1CQUFMQSxXQUF1QjtRQU05Qm8zQzthQWdCQUMsY0FBVSxZQWhCVkQsVUFnQjRCO2FBQzVCRSxNQUFJWCxPQUFRLGFBakJaUyxVQWlCSVQsTUFBK0I7YUFDbkNZLFFBQU1aLE9BQVEsYUFsQmRTLFVBa0JNVCxNQUFpQzthQUN2Q2EsWUFBVWIsT0FBUSxpQkFuQmxCUyxVQW1CVVQsTUFBcUM7YUFDL0NjLFFBQU1kLE9BQVEsYUFwQmRTLFVBb0JNVCxNQUFpQzthQUN2Q2UsUUFBTUMsT0FBUSxlQXJCZFAsVUFxQk1PLE1BQWlDO2FBQ3ZDQyxjQUFVLFlBdEJWUixVQXNCNEI7YUFFNUJTLFlBQVU1QixNQUFPLGlCQXhCakJtQixVQXdCVW5CLEtBQW1DO2FBQzdDNkIsT0FBSzdCLE1BQU8saUJBekJabUIsYUF5QktuQixNQUF5QzthQUM5QzhCLGlCQUF5QiwyQ0FBZTthQUl4Q0MsaUJBQWUsY0E5QmZaLFVBOEJpQzthQUNqQ2EsVUFBVWo0QyxHQUFJLGNBL0JkbzNDLFVBK0JVcDNDLEVBQTBCOzs7O09BeEhsQ20yQztPQU1BQztPQUVBQztPQU9BQztPQWVBSTtPQWVBRTtPQXNCQUs7T0FOQUY7T0FvQkFHO09BRUFDOzs7T0ErQkZXO09BREFEO09BRUFFO09BVkFWO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FFOztPQVFBSTtPQUNBQzs7YUM5SkFDLE9BQUsvM0MsR0FBSSwwQkFBSkEsRUFBZ0M7YUFDckNnNEMsV0FBVzNyQyxHQUFHQyxHQUFHdE0sR0FBSSxpQkFBVnFNLEdBQUdDLEtBQUd0TSxFQUErQjthQUNoRGk0QyxZQUFZbkMsS0FBSzkxQyxHQUFJLHdCQUFUODFDLEtBQUs5MUMsRUFBbUM7YUF3QnBEazRDLGtCQUFrQjk3QjtNQUNwQixTQURvQkEscUJBQ3BCLGNBRG9CQSx5QkFFQzthQUVuQis3Qix1QkFBdUIvN0IsR0FDekIsU0FEeUJBLFNBQ3pCLFFBQWtDOztNQU01Qiw0Q0FERmc4Qjs7OztNQUVGO1FBQUk7Ozs7O1VBRkZBO0lBR0o7bUNBSElBO0tBR0osY0FKRUM7SUFJRixTQUlFRSxpQkFBZSwwQkFBa0I7SUFKbkMsU0FLRUMscUJBQW1CLE9BSG5CRixhQUc4QjtJQUxoQyxJQU9FRyx5QnBDckVMO0lvQzhERyxTQWdCRUMsU0FBU3JMLElBQXNCc0w7TUFDakMsR0FEV3RMLElBQVMsUUFBVEEsY0FBU3FDLGFBQVRrSixPQWRUTjtVQVNrQnQ0QztNQUNwQjtjQUlpQzI0QyxnQkFMYjM0Qzs7V0FHZixRQUhlQTtXQUtUNDRDO1NBRWU7NEJBWHhCSDtVQVd3QixrQkFYeEJBLHFCVDlDQTN5QixpQlM4Q0EyeUI7VUFXRTNDLEtBQXNCOzthQUF0QkE7UUFDOEMsMkJBUjlCOTFDLEtBT2hCODFDLEtBUGdCOTFDLEdBUWtEO0lBbkJ0RSxTQXFCRTY0QyxRQUFNejhCO01BQ1I7Y0FEUUEsZ0JBQ1IsS0FDSWhaLFlBREo7O1lBRUE1SDtRQUNFOzJCQUpNNGdCLEtBR1I1Z0I7VUFDRSxTQURGQTs7O2NBRUk7SUExQkosU0E0QkVzOUMsUUFBTTE4QjtNQUNSLElBQUloWixJQURJZ1o7TUFDUixRQURRQTtVQUNKaFosUUFFTyxJQUhIZ1o7U0FLSCxTQUVzQyxzQkFBcEIsSUFQZkEsU0FPbUM7TUFIekMsZUFKTUEsRUFRTDtJQXBDSCxTQXNDRTI4QjtNQUFrQjs7U0FFWnhNO1NBQUtocUI7U0FBTXJiO1NBV1gzSixVQVhBZ3ZDLElBQUtocUIsS0FBTXJiO2NBV1gzSjtpQkFYVzJKOzs7O2FBR0w4eEM7YUFBS2wyQjthQUFNbTJCO2FBQ1g5MEMsS0FEQTYwQyxNQUFLbDJCLE9BQU1tMkI7cUJBSUMsVUFIWjkwQyxxQkFEVzgwQztZQUdKO2lCQUtiMTdDO01BWkcsUUFjTjtJQXJETCxTQXVERTI3QyxPQUFLL2xDO01BQUksU0FBSkEsUUFBSSxLQUFKQSxRQUFvQixXQWpCekI0bEMsZ0JBaUJLNWxDO01BQW9CLFVBQXBCQSx1QkFBc0Q7SUF2RDdELFNBeURFZ21DLFNBQU8vOEIsR0FBSSxPQUFKQSxJQUFVO0lBekRuQixTQTJERWc5QixTQUFPQyxTQUFTajlCO01BQ2xCO2FBRGtCQTtPQUNsQixNQUFJazlCO09BQUosTUFDSUM7T0FESixLQUVJQztNQUZKO1FBR3FDOzhCQURqQ0E7U0FDaUMsMEJBRGpDQTtTQUlnQiw4QkFQRnA5QjtRQU9FLE9BRmRxOUI7UUFEK0IsSUFHakIsS0FMaEJGLGNBS2dCOztjQWlCbEIzM0M7O1VBQ0U7WUFBYyw0QkF4QmQwM0MsTUF1QkYxM0M7WUFmd0I7O2dCQU9QO2lCQUxQMnFDO2lCQUFLaHFCO2lCQUFNcmI7aUJBQ1gweUMsT0FMTkQsZ0JBSU1wTixJQUFLaHFCO2lCQUtFLGdCQWhCVjgyQixTQUFTajlCLEVBV05td0I7aUJBTVEsdUJBWGRtTixXQVVNRztnQkFDUSxHQUVMdnVDOzRCQVBIc3VDOztpQkFNTyxpQkFiYkgsTUFXTUksa0JBSkFEO2dCQVNKLGlCQWZGRixXQVVNRyxrQkFKQUQ7Z0JBSU8sU0FMSTF5Qzs7dUJBYXJCdEY7Ozs7UUFHQSxHQXBCSSszQztVQXFCRixTQXpCQUgsY0F5QkE7OztZQUNFO2NBQU0sSUFFQ00sUUFGRCxpQkF2Qk5KLFdBc0JGbCtDO2NBQ1EsR0FFQ3MrQztjQUZELFNBRFJ0K0M7Ozs7O2tCQXJCRW0rQztRQUgrQjs7O01BTnhCLFdBbUNWO0lBNUZILFNBOEZFSSxVQUFVMzlCLEVBQUVtd0I7TUFFZCxZQUZZbndCO2VBR1AsaUJBSE9BLEtBQUVtd0IsUUFBRm53QjtlQUlQO3FEQUpTbXdCLEtBQUZud0IsZ0JBSThDO0lBbEcxRCxTQW9HRTQ5QixNQUFJNTlCLEVBQUVtd0IsSUFBSWhxQjtNQUNKO21CQURGbkcsRUFBRW13QjtPQUUwQixVQUYxQkEsSUFBSWhxQixLQUVzQixpQkFGNUJuRyxLQUNGNWdCO01BRUosaUJBSE00Z0IsS0FDRjVnQixZQUNBeStDO01BQ0osT0FITTc5QjtNQUNFLFNBREZBO01BR04sWUFFMkMsU0FYekMyOUIsVUFNSTM5QixPQUt1RDtJQXpHN0QsU0F3SEVxQyxPQUFPckMsRUFBRW13QjtNQUNILGdCQURDbndCLEVBQUVtd0IsS0FFaUIscUJBRm5CbndCLEtBYmE1Z0I7OztjQUdUb1EsT0FBRzFFO1VBQ1Qsc0JBRE0wRSxFQVVGMmdDO1lBUkYsT0FRQW53QjtZQVJBO2dDQUZPbFY7cUJBS0MsaUJBS1JrVixLQWJhNWdCLFlBR04wTDs7O1FBRFosU0Fha0M7SUExSHRDLFNBa0lFZ3pDLE9BQUs5OUIsRUFBRW13QjtNQUNLLG1CQURQbndCLEVBQUVtd0IsS0FDSCx1QkFEQ253QjtNQUNEO1lBRUsrOUIsWUFBUy8yQixZQUFTZzNCO1FBQ3RCLHNCQUpFN04sSUFHRTROLFdBQVMvMkI7UUFFaEIsR0FGeUJnM0I7Y0FJZEMsR0FKY0QsU0FJTC8yQixHQUpLKzJCLFNBSUlFLE1BSkpGO1VBS2xCLHNCQVJGN04sSUFPTThOLFdBQVNoM0I7VUFFaEIsR0FGeUJpM0I7Z0JBSWRDLEdBSmNELFNBSUxFLEdBSktGLFNBSUlHLE1BSkpIO1lBS2xCLHNCQVpOL04sSUFXVWdPLFdBQVNDO3NCQUFTQzs7O29CQWQxQjd1QyxXQUFHMlcsY0FBTXJiO2dCQUNiLHNCQUVFcWxDLElBSEUzZ0MsVUFBRzJXOzBCQUFNcmI7O2NBRGhCO1VBY2U7UUFKSjtNQUpKLGVBVXNEO0lBOUlqRSxTQXNKRXd6QyxXQUFTdCtCLEVBQUVtd0I7TUFDQyxtQkFESG53QixFQUFFbXdCLEtBQ1AsdUJBREtud0I7TUFDTDtZQUVLKzlCLFlBQVMvMkIsWUFBU2czQjtRQUN0QixzQkFKTTdOLElBR0Y0TixjQUFTLzJCO1FBRWhCLEdBRnlCZzNCO2NBSWRDLEdBSmNELFNBSUwvMkIsR0FKSysyQixTQUlJRSxNQUpKRjtVQUtsQixzQkFSRTdOLElBT0U4TixjQUFTaDNCO1VBRWhCLEdBRnlCaTNCO2dCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtZQUtsQixzQkFaRi9OLElBV01nTyxjQUFTQztzQkFBU0M7OztvQkFkMUI3dUMsV0FBRzJXLGNBQU1yYjtnQkFDYixzQkFFTXFsQyxJQUhGM2dDLGFBQUcyVzswQkFBTXJiOztjQURoQjtVQWNlO1FBSko7TUFKSixRQVUrRDtJQWxLMUUsU0FvS0V5ekMsV0FBU3YrQixFQUFFbXdCO01BQ2IsU0FBUXFPO1FwQ25PWDtRb0NtTzRCOztnQkFHZGh2QyxhQUFHMlcsZ0JBQU1yYjtZQUNiLHNCQURJMEUsRUFKRTJnQyxlQUlDaHFCLEtBRUcsZUFGR3JiOzs7VUFEaEIsU0FJd0I7TUFDTCxtQkFSWmtWLEVBQUVtd0I7TUFRRSx1Q0FSSm53QixxQkFRNEI7SUE1S3ZDLFNBc0xFeStCLFFBQVF6K0IsRUFBRW13QixJQUFJaHFCO01BQ1I7bUJBREVuRyxFQUFFbXdCO09BQ0oseUJBREVud0IsS0FDTjVnQjthQUNBcU87OztjQVBTK0IsV0FBRzFFO1VBQ1Qsc0JBRE0wRSxFQUtEMmdDLGdCQUxJcmxDO1VBRVAsV0FHR3FsQztVQUhILFdBR09ocUI7Ozs7O1VBSWQsaUJBSlFuRyxLQUNONWdCLGVBRFErd0MsSUFBSWhxQixLQUVaMVk7VUFFRixPQUpRdVM7VUFJUixTQUpRQTtVQUlSLGVBRTJDLFNBOUYzQzI5QixVQXdGUTM5QjtVQUlSOzs7UUFyQnVCLFlBd0J0QjtJQTdMSCxTQStMRTArQixNQUFJMStCLEVBQUVtd0I7TUFNYztzQkFOaEJud0IsRUFBRW13QjtPQU1NLHlCQU5SbndCOztNQUNrQjs7VUFJcEIsSUFET3hRLFdBQUcxRSxjQUNWLHdCQURPMEUsRUFKSDJnQztVQUtKO29CQURVcmxDOztRQURWLFNBR2tDO0lBck10QyxTQXVNRTZ6QyxPQUFLcjdDLEVBQUUwYztNQUNULFNBQVE0K0I7UXBDdFFYO1FvQ3NRdUI7O2dCQUdYek8sZUFBS2hxQixnQkFBTXJiO1lBQ2QsV0FMQ3hILEVBSUU2c0MsSUFBS2hxQjt3QkFBTXJiOztVQURkLFNBRTBCO01BQ2pCLElBQVgrekMsU0FBVyxrQkFOTjcrQjtNQU1NLE9BQVg2K0IsU0FDaUIsdUJBUFo3K0I7TUFPb0M7UUFHM0MsTUFWT0EsS0FVUCxLQURJbEgscUJBQ0o7OztVQUNFO3NCQUFVLGlCQUZSQSxFQUNKMVo7WUFDRSxTQURGQTs7O1lBR0EsU0FQRXkvQyxTQU9GLFVBQXFCLHVCQWJkNytCO1FBY0s7WUFBVGpCOztRQUFTLEdBUlY4L0IsZUFRQzkvQjtRQUNILHVCQWZPaUI7UUFlUCxNQURHakIsSUFFTTtJQXZOWCxTQXlOTSsvQiwwQkFBMEJ4N0MsRUFBRTBjLEVBQUU1Z0I7Ozs7VUFPcEI7V0FETit3QztXQUFLaHFCO1dBQU1yYjtXQUNMLGlCQVBnQnhILEVBTXRCNnNDLElBQUtocUI7VUFDQztnQkFJTE87Ozs7YUFFUSxpQkFiZTFHLEtBQUU1Z0I7WUFhQyxZQUYxQnNuQjtxQ0FMVTViOztVQUdiLE9BVDBCa1Y7VUFPbEIsV0FES2xWOztRQUpqQixnQ0FDVyxpQkFIbUJrVixLQUFFNWdCO0lBek5wQyxTQTZPRTIvQyxtQkFBbUJ6N0MsRUFBRTBjO01BQ3ZCLE1BRHVCQSxLQUVSLDJCQUZRQTtNQUVSLE9BQVg2K0IsU0FDaUIsdUJBSEU3K0I7TUFHc0I7aUJBRnpDbEg7O2NBSUYxWjtVQUNFO3NDQU5pQmtFLEVBQUUwYyxFQUtyQjVnQixJQUN3QyxpQkFObkI0Z0IsS0FLckI1Z0I7WUFDRSxTQURGQTs7OztRQUdZO1lBQVQyZjs7UUFBUyxHQU5WOC9CLGVBTUM5L0I7UUFDSCx1QkFUcUJpQjtRQVNyQixNQURHakIsSUFFTTtJQXZQWCxTQXlQRWlnQyxPQUFLMTdDLEVBQUUwYyxFQUFFako7TUFDWCxTQUFRNm5DLFVBQVUzNUMsRUFBRXNEO1lBQUYwMkMsTUFBRXgyQztRQUNsQjthQURnQncyQztZQUtHO2FBRFo5TyxJQUpTOE87YUFJSjk0QixLQUpJODRCO2FBSUVuMEMsS0FKRm0wQzthQUtHLGtCQU5kMzdDLEVBS0U2c0MsSUFBS2hxQixLQUpNMWQ7YUFBRncyQyxJQUlFbjBDO2FBSkFyQzs7VUFHZCxPQUhjQSxPQUtrQjtNQUN2QixJQUFYbzJDLFNBQVcsa0JBUE43K0I7TUFPTSxPQUFYNitCLFNBQ2lCLHVCQVJaNytCO01BUW9DO1lBRXZDbEgsRUFWR2tILEtBV0h6WCxRQVhLd08sV0FVTCtCOztjQUVKMVo7VUFDRTtxQkFGRW1KO1lBRU0sb0JBQVUsaUJBSGhCdVEsRUFFSjFaO1lBQ0UsU0FERkE7OztRQUdBLE9BUkV5L0MsU0FRbUIsdUJBZmQ3K0I7UUFlc0MsU0FKekN6WDtRQU1RO1lBQVR3Vzs7UUFBUyxHQVZWOC9CLGVBVUM5L0I7UUFDSCx1QkFsQk9pQjtRQWtCUCxNQURHakIsSUFFTTtJQTVRWCxTQXFSTW1nQzs7OztVQUVVOzs7O21CQUFUOW5DOztRQURJO0lBdFJYLFNBeVJFK25DLE1BQU1uL0I7TUFDUjtZQURRQTtPQUNSO09BQ0U7NkJBQXFCeUYsRUFBRXhnQixHQUFXLFdBQWJ3Z0IsRUFBYSxnQkFBWHhnQixHQUE4QjtPQUFyRCxxQkFERW02QztPQUNGLEtBRk1wL0I7TUFJUjtpQkFDTy9hO1VBQ0ssSUFBSk0sRUFBSSxnQkFETE47VUFFVSxPQUpibzZDLE1BR0k5NUMsU0FDUyxpQkFKYjg1QyxNQUdJOTVDLGlCQUNzQjs7TUFIOUIsVUFKUXlhLHFCQUNKby9CLElBRUFDLE1BU3dCO0lBclM1QixTQXlTRUMsU0FBTzFqQztNQUdULElBQUkyakMsU0FISzNqQztNQUdULFNBRVFoTCxJQUFJeFIsRUFBRW9nRDtZQUFGaDZDLE1BQUVpNkM7UUFBVTthQUFWQTtnQkFLSnRQLElBTElzUCxVQUtDdDVCLEtBTERzNUIsVUFLTzMwQyxLQUxQMjBDO1lBTWUsYUFEbkJ0UCxJQUFLaHFCLHFCcENqWGxCLE9vQzRXV3ZWLElBQUlwTCxJQUtTc0Y7VUFIZixHQUZNdEYsUUFGUis1QztVQU1nQjttQ0FOaEJBLFNBRVEvNUM7V0FJUSxJQUpSQTs7V0FBRWk2QzttQkFNMEI7TUFSeEM7NEJwQzFXSCxPb0M0V1c3dUMsb0JBUUc7SUF0VFgsU0F3VEUrdUMsWUFBWWw2QjtNQUFnQixrQkFBaEJBO01BQWdCLG9CcEN0WGpDO01vQ3NYaUMsc0JwQ3RYakMsT1c0QlM3YSxvQnlCMFZrQztJQXhUeEMsU0EwVEVnMUMsY0FBY242QjtNQUFnQixrQkFBaEJBO01BQWdCLG9CcEN4WG5DO01vQ3dYbUMsc0JwQ3hYbkMsT1c0QlM3YSxvQnlCNFZvQztJQTFUMUMsU0E0VEVpMUMsVUFBUWprQyxJQUFJeGM7TUFDZDs7aUJBQVMsdUNBREN3YyxJQUNLcE0sRUFBRXBJLEVBQWtCO2VBRHJCaEksRUFDdUI7SUE3VHJDLFNBK1RFMGdELFlBQVlsa0MsSUFBSXhjO01BQ2xCOztpQkFBUyx5Q0FES3djLElBQ0NwTSxFQUFFcEksRUFBc0I7ZUFEckJoSSxFQUN1QjtJQWhVekMsU0FrVUUyZ0QsU0FBTzNnRCxHQUNDLElBQU53YyxJQUFNLGVBQ1YsWUFESUEsSUFES3hjLEdBRVQsT0FESXdjLEdBRUQ7SUFyVUg7ZUF5Wk0raEMsVUFBVTM5QixFQUFFbXdCO1FBQ2QsU0FEWW53QjtRQUNaLHVCQURZQSxLQUFFbXdCLFdBQ29DO2VBRWhEanZCLElBQUlsQixFQUFFbXdCLElBQUlocUI7UUFDSjtxQkFERm5HLEVBQUVtd0I7U0FFMEIsVUFGMUJBLElBQUlocUIsS0FFc0IsaUJBRjVCbkcsS0FDRjVnQjtRQUVKLGlCQUhNNGdCLEtBQ0Y1Z0IsWUFDQXkrQztRQUNKLE9BSE03OUI7UUFDRSxTQURGQTtRQUdOLFlBRTJDLFNBUnpDMjlCLFVBR0kzOUIsT0FLdUQ7ZUFlM0RxQyxPQUFPckMsRUFBRW13QjtRQUNIO3FCQURDbndCLEVBQUVtd0I7U0FFaUIscUJBRm5CbndCLEtBYmE1Z0I7Ozs7O2dCQUdUb1EsT0FBRzFFO1lBQ1QsbUJBRE0wRSxFQVVGMmdDO2NBUkYsT0FRQW53QjtjQVJBO2tDQUZPbFY7dUJBS0MsaUJBS1JrVixLQWJhNWdCLFlBR04wTDs7O1VBRFosU0Fha0M7ZUFRcEN3WixLQUFLdEUsRUFBRW13QjtRQUNLLG1CQURQbndCLEVBQUVtd0IsS0FDSCx1QkFEQ253QjtRQUNEO2NBRUsrOUIsWUFBUy8yQixZQUFTZzNCO1VBQ3RCLG1CQUpFN04sSUFHRTROLFdBQVMvMkI7VUFFaEIsR0FGeUJnM0I7Z0JBSWRDLEdBSmNELFNBSUwvMkIsR0FKSysyQixTQUlJRSxNQUpKRjtZQUtsQixtQkFSRjdOLElBT004TixXQUFTaDNCO1lBRWhCLEdBRnlCaTNCO2tCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtjQUtsQixtQkFaTi9OLElBV1VnTyxXQUFTQzt3QkFBU0M7OztzQkFkMUI3dUMsV0FBRzJXLGNBQU1yYjtrQkFDYixtQkFFRXFsQyxJQUhFM2dDLFVBQUcyVzs0QkFBTXJiOztnQkFEaEI7WUFjZTtVQUpKO1FBSkosZUFVa0Q7ZUFRM0Q4WixTQUFTNUUsRUFBRW13QjtRQUNDLG1CQURIbndCLEVBQUVtd0IsS0FDUCx1QkFES253QjtRQUNMO2NBRUsrOUIsWUFBUy8yQixZQUFTZzNCO1VBQ3RCLG1CQUpNN04sSUFHRjROLGNBQVMvMkI7VUFFaEIsR0FGeUJnM0I7Z0JBSWRDLEdBSmNELFNBSUwvMkIsR0FKSysyQixTQUlJRSxNQUpKRjtZQUtsQixtQkFSRTdOLElBT0U4TixjQUFTaDNCO1lBRWhCLEdBRnlCaTNCO2tCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtjQUtsQixtQkFaRi9OLElBV01nTyxjQUFTQzt3QkFBU0M7OztzQkFkMUI3dUMsV0FBRzJXLGNBQU1yYjtrQkFDYixtQkFFTXFsQyxJQUhGM2dDLGFBQUcyVzs0QkFBTXJiOztnQkFEaEI7WUFjZTtVQUpKO1FBSkosUUFVMkQ7ZUFFcEVrMUMsU0FBU2hnQyxFQUFFbXdCO1FBQ2IsU0FBUXFPO1VwQzNoQmY7VW9DMmhCZ0M7O2tCQUdkaHZDLGFBQVFzSixhQUFHaE87Y0FDZixtQkFESTBFLEVBSkUyZ0MsZUFJTXIzQixFQUVMLGVBRlFoTzs7O1lBRGxCLFNBSXdCO1FBQ0wsbUJBUlprVixFQUFFbXdCO1FBUUUsdUNBUkpud0IscUJBUTRCO2VBVXJDeStCLFFBQVF6K0IsRUFBRW13QixJQUFJaHFCO1FBQ1I7cUJBREVuRyxFQUFFbXdCO1NBQ0oseUJBREVud0IsS0FDTjVnQjtlQUNBcU87OztnQkFQUytCLFdBQUcxRTtZQUNULHFCQURNMEUsRUFLRDJnQyxnQkFMSXJsQztZQUVQLFdBR0dxbEM7WUFISCxXQUdPaHFCOzs7OztZQUlkLGlCQUpRbkcsS0FDTjVnQixlQURRK3dDLElBQUlocUIsS0FFWjFZO1lBRUYsT0FKUXVTO1lBSVIsU0FKUUE7WUFJUixlQUUyQyxTQTNGM0MyOUIsVUFxRlEzOUI7WUFJUjs7O1VBckJ1QixZQXdCdEI7ZUFFRG9DLElBQUlwQyxFQUFFbXdCO1FBTWM7d0JBTmhCbndCLEVBQUVtd0I7U0FNTSx5QkFOUm53Qjs7UUFDa0I7O1lBSXBCLElBRE94USxXQUFHMUUsY0FDVixxQkFETzBFLEVBSkgyZ0M7WUFLSjtzQkFEVXJsQzs7VUFEVixTQUdrQzs7Y0E3ZXhDd3hDO2NBS0FHO2NBT0FDO2NBMkJBSTtjQXFXSTU3QjtjQW9CQW1CO2NBVUFpQztjQW9CQU07Y0FjQW83QjtjQWtCQXZCO2NBU0FyOEI7Y0FoVEp1OEI7Y0FzQ0FJO2NBWUFDO2NBaE1BakM7Y0FnT0FvQztjQWdCQUc7Y0FlQUs7Y0FFQUM7Y0FFQUM7Y0FHQUM7Y0FHQUM7SUFsVUY7TXBDOURILElvQzhrQmEzekM7ZUFDQWtCLEtBQU1vc0MsS0FBWTkxQyxHQUFJLHVCQUFKQSxFQUFZOzs2QkFEOUJ3SSxNQUNBa0I7T0F6SlJzYTtPQUNBZ0Y7T0FDQXF6QjtPQUNBLytCO09BQ0FtQjtPQUNBaUM7T0FDQU07T0FDQW83QjtPQUNBdkI7T0FDQXI4QjtPQUNBM2I7T0FDQXM0QztPQUNBcjdCO09BQ0FsVztPQUNBMnhDO09BQ0F2NUI7T0FDQSs1QjtPQUNBQztPQUNBcDZCO09BQ0FzNkI7T0FDQXA2Qjs7ZUF1SUl6RixPQUFPaWdDLElBQUssNEJBQUxBLEdBQTRCOztjQUFuQ2pnQztjQTNKSjJIO2NBQ0FnRjtjQUNBcXpCO2NBQ0EvK0I7Y0FDQW1CO2NBQ0FpQztjQUNBTTtjQUNBbzdCO2NBQ0F2QjtjQUNBcjhCO2NBQ0EzYjtjQUNBczRDO2NBQ0FyN0I7Y0FDQWxXO2NBQ0EyeEM7Y0FDQXY1QjtjQUNBKzVCO2NBQ0FDO2NBQ0FwNkI7Y0FDQXM2QjtjQUNBcDZCO0lBNVlGOzs7T0FnQkU0MkI7T0FLQUc7T0FPQUM7T0EyQkFJO09BNkNBYztPQThCQUU7T0FvQkFRO09BY0FDO09BMkJBRztPQXZFQXI4QjtPQThEQW84QjtPQWlCQUU7T0FzQ0FJO09BWUFDO09BaE1BakM7T0FyREFaO09BQ0FDO09Bb1JBK0M7T0FnQkFHO09BZUFLO09BRUFDO09BRUFDO09BR0FDO09BR0FDOzs7T0F6V0FwRTtPQUVBRTtPQURBRDs7SUFzQ0Y7YUNyQ0V1RSxTQUFPdjhDLEdBQUksT0FBSkEsb0JBQTRDO2FBU25EdzhDLE9BQUtDLEdBQUd0NUMsSUFBSUMsSUFBSXBEO01BQ2xCLFFBRFVtRDtlQUFJQztjQUN1QixTQUQ5QnE1QyxPQUFHdDVDLE1BQUlDO1VBR1QsVUFIS0QsTUFBSUM7VUFHVCxhQUhLRDtnQkFHTDNILEVBSEsySDtZQUtOOzRCQUxHczVDLEdBR0ZqaEQsRUFIYXdFO2NBS2QsU0FGQ3hFOzs7VUFaUTtNQVdSLHdDQUtGOztNQTJCZSxJQUFka2hELFlBQWM7ZUFZZEMsVUFBVS9tQyxFQUFFd0csR0FBSSxnQkFBSkEsZUFBRnhHLGdCQUFpRDtNQVo3QyxJQWNkNjZCO01BZGMsU0FpQmRwMEIsT0FBT2lnQztRQUNUO21CQURTQTtTQUVULHdCQURJTTtRQUdNOytCQUZOQyxLQW5CRkg7Z0JBc0JTLGVBSFBHO2dCQUxGcE07O2tCQVlEO01BMUJlLFNBNEJkenNCLE1BQU1wTztRQUNSLFNBRFFBLHdCQUNSOzs7VUFDRTs2QkFGTUEsS0FDUnBhLFlBN0JFa2hEO1lBK0JBLGlCQUhNOW1DLEtBQ1JwYTtZQUVFLFNBRkZBOzs7UUFJQSxPQW5CRWkxQztRQW1CRjtnQkFDZTtNQWxDQyxTQXFDZDN3QixLQUFLcGdCLEVBQUVrVyxFQUFFekM7UUFDWCxTQURTeUMsS0FDVDtRQU1pQjswQkFOS3ZVLEVBQUV5Sjt1QkFBSmxKLE1BQUkrQzttQkFDdEI7cUJBQVEsWUFEWXRELE1BQUZPLFdBQUkrQztxQkFFaEIsd0JBRmN0RCxFQUFGTztxQkFFWjt1QkFDTTs7d0JBQW9CLGtCQUozQmxDLEVBSUU4RCxFQUhlbUI7d0JBR1UsSUFIZC9DOzt3QkFBSStDOztxQkFFaEIsSUFFSSxJQUpRL0M7OztpQkFEVHVSLEtBT2tDO01BNUM3QixTQStDZHRRLEtBQUtuRCxFQUFFa1c7UUFDVCxTQURTQSxLQUNUO1FBTVc7MEJBTld2VTttQnJDcEgzQixJcUNvSHlCTzttQkFDbEI7cUJBQVEsWUFEWVAsTUFBRk87cUJBRVosd0JBRmNQLEVBQUZPO3FCQUVaO3VCQUNNLElBQUw0Qjt1QkFBSyxXQUpQOUQsRUFJRThEO3VCQUFLLFFBSE01Qjs7cUJBRVosSUFFSSxJQUpRQTs7c0JBTWM7TUF0RGxCLFNBbUVWazdDLGFBQWF0aEQsRUFBRTZGLEVBQUVzRDtZQUFKL0MsTUFBSWlEO1FBQ3ZCO1VBQVEsWUFEYXhELE1BQUZPLFdBQUlpRDtVQUVVO2dDQUZaeEQsRUFBRk87V0FBSWtKO1dBQUpxRDs7V0FBSXRKO21CQUVtQztNQXJFMUMsU0F3RWQyaEIsTUFBTTVRO1FBQ1IsZ0JBRFFBLEtBQ1I7UUFBaUI7cUNyQzdJdEIsT3FDdUlXa25DOztzQkFNcUM7TUF6RTNCLFNBa0lkQyxRQUFRbm5DLEVBQUVvbkMsT0FBTzluQyxFQUFFa0gsRUFBRTZnQztRQUN2QjttQ0FEVXJuQyxLQUFhcW5DO1NBQ3ZCLHdCQURVcm5DLEtBQWFxbkM7U0FHZCxZQUZMQztTQUdTcHlCO1FBQ1g7YUFGRXd4QixNQUNTeHhCO1lBR1A7YUFERXN5QjtjQUNGLFVBSkZkO1lBSUUsR0FERWMsU0FISmQ7YUFNb0I7WUFGbEI7YUFHYywyQkFKWmM7YUFJWSx5QkFKWkE7WUFNSixlQVhBRixXQVNJRyxZQVBKZjtZQVVBLE9BWEFhLFNBU0lHLFlBUkpoQjtZQVdBLFdBZFFVLE9BVUpLLFVBUEpmLEdBSGVwbkM7WUFlZixpQkFKSW9vQyxVQVJKaEIsY0FIaUJsZ0M7WUFnQmpCLGlCQWhCTXhHLEtBQWFxbkMsb0JBVWZJO1lBT0osaUJBakJNem5DLEtBQWFxbkMsb0JBV2ZLO1lBSkYsSUFVRixLQWRBaEIsTUFITTFtQyxTQWlCTixVQWpCTUEsT0FNRnduQztZQVlxQztxQkFsQm5DeG5DO2tCQW9CSm9WO2NBQTRCO2dCQXRFbEM7c0JBa0RVcFY7aUJBbERWLHdCQWtEVUE7aUJBbERWLEtBa0RVQTtpQkFsRFYseUJBa0RVQTtpQkFoREEsV0FGTnFrQztpQkFIVSxZQUFKOTRDO2lCQU9DLG9CQUpQODRDO2dCQUlPLEdBQVB3RCxRQURBRDtrQkFhTSxpQkFoQk52RCxnQkFNV3I0QyxNQUFFbU07a0JBQ2I7dUJBSkF5dkMsWUFHYXp2QztzQkFFUixtQkFSTGtzQyxPQU1XcjRDO3dCQUVjLFFBRmRBO3NCQUdELG1CQVRWcTRDLE9BTWFsc0M7d0JBSVQsZUFWSmtzQyxPQU1hbHNDLEVBTmJrc0MsT0FNV3I0Qzt3QkFLUSwwQkFWbkIyN0MsUUFLYXh2Qzt3QkFLVCxpQkFWSnd2QyxRQUtXMzdDO3dCQUtRLElBQWYsSUFMU21NLFVBS1QsSUFMT25NLG9CQUFFbU07O3NCQU9GLFFBUEVBOzs2QkFIYnl2QztzQkFjbUIsU0FpQ2I1bkM7c0JBaENOLGlCQWdDTUEsdUJBbElSOG1DO3NCQWlHcUIsU0FpQ2I5bUM7c0JBL0JOLGlCQStCTUE7O3NCQTdCTixrQkFyQkFxa0MsT0FHQXVEO3NCQW1CQSxrQkFyQkFELFFBRUFDO29CQW1Cd0MsU0E0QmxDNW5DLE9BckRBelUsTUF5QmtDLFVBbkJ4Q3E4QyxZQStDTTVuQztvQkExQnFDLFFBMEJyQ0E7O2dCQXhCVixnQkF3QlVBO2dCQWxEVixTQXNFTW9WOzs7WUFiQSxXQVBJcFY7WUFzQk47Y0ExQ0o7bUJBb0JVQTtlQXRESSxpQkFBSjNMO3VCQW1DTnVPO2dCQUVTLGdCQUZUQSxRQXJESixLQXdFVTVDLEtBeEVWO2dCQU1ZOzJCQU5VN0gsRUF3RFA2dkM7b0JyQ3RMcEIsSXFDOEh5Qmg4QztvQkFDbEI7c0JBQVEsWUF1REtnOEMsT0F4REtoOEM7c0JBRVosMEJBc0RPZzhDLEdBeERLaDhDO3NCQUVaLGdCQUVLLFFBSk9BO3NCQUVaO3VCQUNRLG9CQXFFTmdVLEtBeEVZN0g7dUJBeURsQjtpQ0F6RGdCdlM7bUNBeURad2hELE9BQU9lLEdBQUdDOzRCQUFPLHNCQURWSixHQXhES3BpRCxFQXlETHVpRCxHQUFHQyxLQUF5QjtpQ0FBbkNoQjt1QkFBSixnQkF6RGdCcDdDO3VCQXlEaEIsbUJBRGNpOEMsR0F4REVqOEM7c0JBMkRXLFFBSnpCKzdDLEtBRUVYLFNBQ0E1Z0MsRUFDdUIsVUFKekJ1aEMsS0FHRXZoQztzQkF4REEsSUFGWWxJOzs7Z0JBd0VWMEIsT0FqQkorbkM7Z0JBaUJJL25DLE9BakJKK25DO2dCQWlCSS9uQyxPQWpCSituQztnQkFpQkkvbkMsT0FqQkorbkM7Z0JBaUJJL25DLHFCQWpCSituQzs7Y0FZRyxPNUIxRlRoOUM7YzRCMEZTOztZQTRCRTtVQUFHLG1CQXRCVnU4QyxTQUdTcHlCO1lBbUJxQixRQW5CckJBO1VBc0JULFdBMUJRa3lCLE9BQ1JFLFNBR1NweUIsSUFKTTVWO1VBMEJmLHdCQXhCQWlvQyxPQUVTcnlCLGdCQUpRMU8sRUE4QmY7TUFoS1UsU0FtS2RrQixJQUFJMUgsRUFBRVY7UUFDQSxJQUFKa0gsRUFBSSxnQkFEQWxIO1FBRWlCLGVBRm5CVSxtQkFBRVYsR0FDSmtILEVBQ3FCLFVBRm5CeEcsRUFDRndHLEdBQ29DO01Bckt4QixTQXdLZDZoQyxRQUFRcm9DLEVBQUVWLEVBQUVncEM7UUFDTjsyQkFESWhwQztTQUVBLGdCQUZGVSxFQUNOd0c7U0FDUSx3QkFGRnhHLEtBRU5xbkM7U0FBUSx3QkFGRnJuQyxLQUVOcW5DO1NBR0ssWUFGTGhEO1NBR1N6K0M7UUFDWDthQUZFOGdELE1BQ1M5Z0QsU0FDSyxXQVBKMGlELFdBQ1Y5aEMsRUFDQTZnQztVQU1VLEdBUFY3Z0MsTUFPVSxpQkFKVitnQyxPQUVTM2hEO1lBR0gsNkJBTk55K0MsT0FHU3orQztZQUdIO2NBQ1EsSUFBUGdJO2NBQU8sbUJBQVBBLEVBVkMwUjtnQkFXVSwwQkFSbEIra0MsT0FHU3orQztnQkFLUyxZQUNBLElBQUxvbEIsZUFBSyxPQUFMQTtnQkFESyxJQUVGLElBUFBwbEI7O1lBR0gsSUFNQyxJQVRFQTs7VUFVRixRQVZFQTttQkFZUDtNQTFMVSxTQTZMZDZZLE1BQU11QixFQUFFVjtRQUNWO2lCQURRVTtpQkFBRVY7MEJBQ09rSCxFQUFFNmdDO21CQUFTLFFBRHBCcm5DLG1CQUFFVixHQUNPa0gsRUFBRTZnQyxPQUFTLE9BRGxCL25DLENBQ21ELEVBQUM7TUE5TDlDLFNBaU1kd0wsS0FBSzlLLEVBQUVWO1FBQUksZUFBTlUsRUFBRVYsV0FBcUJrSCxFQUFHNmdDLE9BQVUsZUFBZSxFQUFDO01Bak0zQyxTQW1NZGo4QixTQUFTcEwsRUFBRVY7UUFDTDsyQkFES0E7U0FFRCxnQkFGRFUsRUFDUHdHO1NBQ1Esd0JBRkR4RyxLQUVQcW5DO1NBQVEsd0JBRkRybkMsS0FFUHFuQztTQUdLLFlBRkxoRDtTQUdTeitDO1FBQ1g7YUFGRThnRCxNQUNTOWdEO1VBRUMsR0FQVjRnQixNQU9VLGlCQUpWK2dDLE9BRVMzaEQ7WUFHSCw2QkFOTnkrQyxPQUdTeitDO1lBR0g7Y0FDUSxJQUFQZ0k7Y0FBTyxtQkFBUEEsRUFWRTBSO2dCQVdTLElBQ1YwTCxJQURVLGNBUmxCcTVCLE9BR1N6K0M7Z0JBS1MsR0FDVm9sQjtnQkFEVSxJQUVGLElBUFBwbEI7O1lBR0gsSUFNQyxJQVRFQTs7VUFVRixRQVZFQTttQkFZUDtNQXJOVSxTQXdOZDJpRCxZQUFZdm9DLEVBQUVWLEVBQUVrcEMsUUFBUUY7UUFDbEI7MkJBRFFocEM7U0FFSixnQkFGRVUsRUFDVndHO1NBQ1Esd0JBRkV4RyxLQUVWcW5DO1NBQVEsd0JBRkVybkMsS0FFVnFuQztTQUdLLFlBRkxoRDtTQUdTeitDO1FBQ1g7YUFGRThnRCxNQUNTOWdELFNBTmEwaUQ7VUFRWixHQVBWOWhDLE1BT1UsaUJBSlYrZ0MsT0FFUzNoRDtZQUdILDZCQU5OeStDLE9BR1N6K0M7WUFHSDtjQUNRLElBQVBnSTtjQUFPLG1CQUFQQSxFQVZLMFIsVUFVaUIsV0FWZmtwQyxRQUdkbkUsT0FHU3orQztZQUdILElBRUMsSUFMRUE7O1VBTUYsUUFORUE7bUJBUVA7TUF0T1UsU0F5T2RpakIsT0FBTzdJLEVBQUVWO1FBQUk7O2lCQUFOVSxFQUFFVixXQUF5QnloQixFQUFFbjdCLEdBQUsscUJBQVBtN0IsRUFBRW43QixJQUFpQixPQUFJO01Bek8zQyxTQTRPZGdqQixJQUFJNUksRUFBRVY7UUFBSSw4QkFBTlUsRUFBRVYsV0FBeUJ5aEIsRUFBR243QixHQUFNLFFBQUksT0FBTztNQTVPckMsU0ErT2Q0Z0QsU0FBU3htQyxFQUFFVjtRQUNMOzJCQURLQTtTQUVELGdCQUZEVSxFQUNQd0c7U0FDUSx3QkFGRHhHLEtBRVBxbkM7U0FBUSx3QkFGRHJuQyxLQUVQcW5DO1NBR0ssWUFGTGhEO1NBR1N6K0M7U0FBRW1KO1FBQ2I7YUFGRTIzQyxNQUNTOWdELFNBQUVtSjtVQUVELEdBUFZ5WCxNQU9VLGlCQUpWK2dDLE9BRVMzaEQ7WUFHSCw2QkFOTnkrQyxPQUdTeitDO1lBR0g7Y0FDUSxJQUFQZ0k7Y0FBTyxtQkFBUEEsRUFWRTBSO2dCQVdTLDBCQVJsQitrQyxPQUdTeitDO2dCQUtTO2tCQUNBOzs2QkFBTG9sQixJQU5GamM7bUJBTU8sSUFOVG5KOzttQkFBRW1KOztnQkFLTyxJQUVGLElBUFBuSjs7WUFHSCxJQU1DLElBVEVBOztVQVVGLFFBVkVBO21CQVlKO01BalFPLFNBb1FkKy9DLE1BQU0zbEM7UUFDUixRQURRQSxnQkFFRyxXQWpUWDJtQyxTQStTUTNtQztRQUdSLHNCQURJeW9DO1FBREo7U0FFQTtTQUNhOzBDckM1VWxCLDZCcUMwVVNBO1NBRVMsS0FIVGo3QztTQUkyQyxLQUozQ0E7U0FJMkMsc0JBSDNDaTdDO1NBRzZCLHNCQUg3QkE7U0FHbUIsc0JBSG5CQTtRQUdFLFVBSkZqN0MsSUFJRSxNQUxFd1MsR0FJSjBvQyxzQkFDd0Q7TUF6UTVDO2NBaUJkamlDO2NBV0EySDtjQWlLQTNQO2NBMUJBaUo7Y0FzRUFtQjtjQXhDQWlDO2NBRUFNO2NBNENBbzdCO2NBSEE1OUI7Y0E3TEEzYjtjQVZBaWQ7Y0FtQ0EwRztjQTRMQSswQjs7Ozs7T0EvU0ZnQjs7Ozs7T0FTQUM7Ozs7YUNrTUErQixVQUFVditDLEVBQUV3a0I7TUFDZCxTQURZeGtCLEtBQ1osS0FEY3drQjtNQUNkLGFBRGNBLE9BQ1YvaEIsa0JBRFUraEIsT0FDVi9oQixFQURVK2hCLE9BQ1YvaEIsSUFNd0I7O2FBVTFCKzdDLFdBQ0FoNkI7TUFEYSxTQUNiQTtNQURhO1lBQ1V4a0IsVUFBVWdDLFdBQWpDd2lCLE9BQWlDeGlCLGVBQWpDd2lCLFNBR0EsT0FIdUJ4a0I7TUFJUSxpQkFBaUI7YUFJaER5K0MsV0FBV3htQyxNQUFNeW1DO010QzlQdEIsSXNDOFBrQ3Q3QyxJQUFaczdDO01BQU56bUMsd0JBQWtCN1U7YUExQjdCbTdDLFVBMEJpQkcsTUFBTnptQztRQThCWDBtQzthQUdBQyxpQkFBaUIzbUMsTUFBTXBZO01BQUksa0JBQVZvWSxVQUFNcFksSUFBSSxzQkFBSkEsR0FBNkM7YUFDcEVnL0Msa0JBQWtCNW1DLE9BQVEsa0JBQVJBLFlBQStCO2FBS2pENm1DLGVBQWU3bUMsTUFBTTJSLE9BQU8yQztNQUM5QixrQkFEaUJ0VTtNQUNqQjs7ZUFEaUJBLFdBQWFzVSxhQUFQM0M7T0FLTCxnQkFMRDNSLFNBR2J5cUI7TUFFYyxZQUFkcWM7TUFBYyxXQUxEOW1DO01BSFksa0JBR1pBLG9CQVE2QjthQUk1QyttQyxXQUFXL21DLE1BQU1zVSxPQUFRLHNCQUFkdFUsUUFBTXNVLE1BQW9DO2FBR3JEMHlCLGdCQUFnQmhuQyxNQUFNc1U7TUFDeEIsV0FEa0J0VSxXQUFNc1UsVUFuQkssa0JBbUJYdFUsVUFBTXNVLE1BRUk7YUFNMUIyeUIsb0JBQW9Cam5DO01BQ3RCLFNBRHNCQTtNQUN0Qjs7O1NBQ3NCc1U7U0FBUDR5QjtjQUZPbG5DLFdBRUFzVTs7VUFFbEIsU0FGVzR5QiwwQkFLUixXQVBlbG5DLE1BRUFzVTs7OztRQU1kOytCQVJjdFUsTUFRUzthQUk3Qm1uQyxjQUFjbm5DO01BRVYscUJBRlVBLFdBRVY7a0JBRlVBLFlBR2U3VTtNQUR6QixXQUZVNlUsV0FHQXRPO01BRFYsUUFHeUQ7YUFVN0QwMUMsZ0JBQWdCcG5DLE1BQU10TztNdEN2VjNCOzs7VXNDNlhLLFNBdENnQnNPO1VBc0NoQjs7O2FBQ1VxbkM7YUFDQUM7dUJBQVFwK0MsRUFFWnErQztnQnRDallYLEdzQ2lZV0E7c0JBQUs3OUMsRUFBTDY5QztrQkFBbUIsNkJBRlByK0MsRUFFWm5COzhCQUZZbUIsRUFFWnErQztnQ0FBZ0QsUUFGcENyK0MsRUFFUFE7Z0JBREMsVUFETVI7WUFHUixrQkEzQ004Vyx3QkF1Q05xbkM7WUFJQTtVQUNGOztVQXJCUixTQXZCZ0JybkM7VUF1QmhCLFNBQ2EsSUFBTnVuQyxXQUFNLFdBQU5BLEdBQU07VUFDTDs7VUFPUixTQWhDZ0J2bkM7VUFnQ2hCLFNBQ2EsSUFBTnduQyxhQUFNLFdBQU5BLEtBQU07VUFDTDs7VUFvQ1IsU0F0RWdCeG5DO1VBc0VoQjtnQ0FDa0JzVTttQkE3R2xCeXlCLFdBc0NnQi9tQyxNQXVFRXNVO1VBQ1YseUJBeEVRdFU7O1VBNEVoQixTQTVFZ0JBO1VBNEVoQixZQUNLLGNBN0VXQTs7VUE4R2YsU0E5R2VBO1VBOEdmO1lBRWU7YUFERHluQzthQUFaQzthQUNhLGtCQWhIQTFuQyxVQStHYjBuQztZQUVBLGlCQWpIYTFuQyxNQWdIVDJuQztZQUNKLFdBRllGO1lBRVo7VUFFTTs7OztVQWhIVCxJQURRNy9DO1VBQ1IsV0FIZ0JvWSxXQUFNdE87VUFJdEIsaUJBSmdCc08sTUFFUnBZO1VBRVI7OztjQTJFYWdnRCxhQUFIMStDLGdCQS9FTThXOztnQ0FpRkd3dEIsbUJBQUp0cEM7O3FCQWtCQSx1QkFuR0M4YixNQStFTjlXO3FCQW1CSyxzQkFsR0M4VyxNQStFSDRuQyxJQUVNcGE7cUJBZUgsc0JBaEdBeHRCLE1BK0VING5DLElBRU1wYTs7ZUFHZixPQXBGWXh0QixXQUFNdE87d0JBcUZiLGVBckZPc08sTUErRUg0bkMsSUFFTXBhO3dCQUtWLGdCQXRGT3h0QixNQStFTjlXOztlQVVOLE9BekZZOFc7d0JBeUZpQixnQkF6RmpCQSxNQStFTjlXO3dCQS9FTThXLFdBQU10TzswQkEyRlosZUEzRk1zTyxNQStFSDRuQyxJQUVNcGE7NEJBakZIeHRCLFdBaUZHd3RCLGVBRk5vYSxXQS9FRzVuQzs0QkE4RlAsZUE5Rk9BLE1BK0VING5DLElBRU1wYTs0QkFjVixnQkEvRk94dEIsTUErRU45VztzQkFrQkssdUJBakdDOFcsTUErRU45VztVQXNCRjs7O1dBdERNMitDO1dBQUg3MUM7V0FDUDgxQyxnQkFoRFk5bkM7Ozs7O2FBa0ROK25DO2FBQ0F0L0I7dUJBQUt2ZjtnQnRDMVlwQjs7O3dCc0MyWWdCUSxhQUFMM0I7b0JBQWEscUJBQWJBLEVBRFNtQixVQUNUbkI7Z0NBQUsyQjs7a0JBQ0M7a0JBSEZxK0M7O2NBT0osSUFEQWhnRDtjQUNBO2dCQUNNLGNBVlIrL0MsZ0JBRU1DLFdBTUp4Ujs7Ozs7Y0FDQSxJQUhBeVIsSUFFQXpSOztpQkFGQXlSLElBTkZGO1lBY0YsSUFBSW4yQixPQVJBcTJCLE1BTkZGO1lBY0YsWUFBSW4yQjtxQkFFQyxnQkFoRVMzUixNQThEVjJSLFNBZkszZjtxQkFrQkosZUFqRVNnTyxNQXNEVmdvQyxNQVBRSCxVQS9DRTduQztVQWtFUjs7O1dBM0RPc2U7V0FBTDJwQjtXQUNOQyxrQkFSWWxvQzt3QkFRWmtvQyxrQkFHRixvQkFYY2xvQztVQVdxQjtvQkFYckJBLFdBT05pb0M7V0FJMkIsY0FKdEIzcEIsT0FQQ3RlLFdBQU10TyxLQU9QNHNCO1VBWWYsaUJBTkk4cEIsUUFEQUQsVUFaWW5vQztVQW1CaEI7Z0JBVUEsSUFEVXFvQyxjQUNWLGNBRFVBLEtBNUJNcm9DLFVBNkJoQjs7VUE0RUMsd0JBQWEsb0JBekdFQSxVQXdHSHNvQztVQUVaLGlCQTFHZXRvQyxNQXlHWHVvQztVQUNKLGNBRllELFdBeEdHdG9DO1VBMEdmO2FBbUJHd29DLGFBQWF4b0M7TUFDbkI7UUFyT2UsU0FvT0lBO1FBcE9KO1VBQ2lDOztXQXNPMUN0TyxLQXRPbUIzSjtXQXFPa0JvRCxJQXJPbEJwRDtXQXFPSXFiLElBck9KcmI7Z0JBc09uQjJKO3NCQUhhc087V0FPWjs7WUFDSSxXQVJRQTtZQVFSLElBTEx5b0Msc0JBM0xKL0I7WUFpTUUsZ0JBVGUxbUMsTUFHYnlvQyxPQUR1QnJsQztZQU96QixZQVB1Q2pZLE1BRnhCNlU7OztRQWxPYyxrQkE4TzVCO2FBR0gwb0MsYUFBYTFvQztNQUNmO1FBQUksc0JBRFdBOzs7O21CQUVJO2FBSWpCMm9DLGdCQUFnQjNvQyxNQUFNb0Q7TUFBTSxXQUFacEQsTUFBTW9ELEtBQU0sb0JBQVpwRCxNQUFvRDthQVFwRTRvQyxrQkFBa0I1b0MsTUFBTXRPLEtBQUs5SjtNQUVULHVCQUZGb1ksU0FBTXRPLFFBQUs5SixHQUFMOEosTUFFa0M7SUFhL0Msb0RBQVRtM0M7SUFBUyxTQUtYRSxpQkFBaUIvb0MsT0FBUSxXQU56QjhvQyxrQkFNeUIsUUFBd0M7SUFMdEQsU0FnQlhFLFNBQVNocEMsTUFBTTliO01BQ2pCLFNBRFc4YjtNQUNYOzs7U0FHS2lwQztTQURBQztTQUVDeDNDLEtBRER1M0M7U0FBbUV0ckM7U0FBdEN5RixJQUE3QjZsQztXQURBQyxXQUhNbHBDLGlCQU84QixpQkFQOUJBO1FBUVAsVUFKOEJvRDtTQUk5QixPQUo4QkE7O1lBWTVCO3NCQWhCV2xmO2FBZ0JYO29CQVpEK2tELGdCQUpNanBDLFlBS0x0TyxTQUxLc08sV0FJNkRyQztZQU1sRTs7Ozs7Y0FWV3paLElBSVora0QsZ0JBSk1qcEMsWUFLTHRPLFNBTEtzTyxXQUk2RHJDLEtBSnZEelo7WUF3Qlg7OztNQUVFLFFBQUU7SUExQ0csU0ErQ1hpbEQsVUFBVW5wQyxNQUFNNVcsRUFBRWdhO01BQ3BCLFdBRFlwRCxNQUFRb0Q7TUFDcEIsR0FEa0JoYSxFQUVSLFNBRkU0VztNQUVpQixpQkFGakJBLFVBQVFvRCxLQUFScEQ7TUFFaUIsUUFFaUM7SUFuRGpELFNBeURYb3BDLGdCQUFnQnBwQyxNQUFNeXFCLE9BQU80ZTtNQUMvQixZQURrQnJwQztNQUNsQixHQURrQkE7UUFJZCxJQURFc3BDLFVBSFl0cEMsaUJBQU15cUIsT0FBTzRlO1FBSTNCLGlCQUpjcnBDLFFBR1pzcEM7TUFNTixTQVRrQnRwQztNQVNsQjtRQUNLLFNBVmFBLFVBbEVsQjtpQ0FrRWtCQSxNQWxFZDdVO2lCQTRFdUM7SUFuRTlCLFNBMEVYbytDLGFBQWF2cEM7TUFDZixhQURlQTtNQUNmO1FBQ0EsR0FGZUE7VUFLWCxXQUxXQSxpQkFPWCxTQVBXQSxTQU9VLFNBUFZBO1FBTzhCLFlBUDlCQTs7OztNQUhXLFdBYXZCO0lBcEZVLFNBd0ZYd3BDLFlBQVl4cEMsTUFBTTBuQztNQUNwQixHQURjMW5DO1FBRWQsY0FGb0IwbkMsU0FBTjFuQyxVQUlaLFdBSllBLFVBQU0wbkM7TUFJYyxTQUpwQjFuQztNQUlvQixZQUdoQyxXQVBZQSxjQUFNMG5DLGtCQVdqQjtJQW5HVSxTQXVHWCtCLGFBQWF6cEM7TUFDZixHQURlQSxVQUViLFdBRmFBO01BTVosU0FOWUE7TUFNWjtRQUVILFNBUmVBO1FBUWY7Y0FFZ0J5bkMsYUFBWkM7VUFDQSxXQVhXMW5DLFVBVVgwbkM7VUFDQSxXQURZRDtVQUNaO1FBSEo7OztpQkFNRztJQXJIVSxTQXdIWGlDLGtCQUFrQjFwQyxNQUFNNVcsR0FBSSxZQUFKQSxFQUFJLFFBQXdCO0lBeEh6QyxTQXlIWHVnRCxpQkFBaUIzcEMsTUFBTTVXLEdBQUksWUFBSkEsRUFBSSxRQUF1QjtJQXpIdkMsU0EwSFh3Z0Qsa0JBQWtCNXBDLGFBQVcsT0FBWEEsU0FBOEI7SUExSHJDLFNBMkhYNnBDLGlCQUFpQjdwQyxhQUFXLE9BQVhBLFNBQTZCO0lBM0huQyxTQTRIWDhwQyxZQUFZOXBDLE1BQU01VztNQUNwQixrQkFEYzRXLE1BQU01VyxHQUNwQix3QkFEYzRXLE1BQU01VyxFQUMrQjtJQTdIdEMsU0FpSVgyZ0QsK0JBQStCL3BDO01BQVcsVUFBWEEsd0NBS2xDO0lBdEljLFNBeUlYZ3FDLCtCQUErQmhxQztVQUlaaXFDLGFBRERDLGFBREFDLGFBRERDO01BRGNwcUMsWUFDZG9xQztNQURjcHFDLFlBRWJtcUM7TUFGYW5xQyxZQUdia3FDO01BSGFscUMsWUFJWmlxQzs7SUE3SVIsU0FzSlhJLFNBQVNycUM7TUFsWlg7O2VBa1pXQTtNQXBiTzs7TUFzYmxCLGlCQUZXQTtNQUVYOzs7Ozs7aUJBRldBO01BL0VlLHVCQStFZkEsVUFVVTtJQWhLUixTQXlLWHNxQyxlQUFldHFDLE1BQU01VztNQU52QixTQU1pQjRXO01BTmpCLHVCQUNZLG9CQUtLQSxRQUxnQjtNQVFWO2VBSE5BLFdBR2YsYUFIZUE7UUFLakIsWUFsWkUwbUM7UUFtWkYsYUFOaUIxbUM7UUFNakIsR0FOdUI1VyxFQU9iLGtCQVBPNFc7UUFPZ0IsZ0JBUGhCQSxPQVFIO0lBakxELFNBMExYdXFDLGlCQUFpQnZxQyxNQUFNdE8sS0FBSzlKO01BQzlCLFNBRG1Cb1k7TUFDbkIsWUFDSyxrQkFGY0EsTUFBTXRPLEtBQUs5SixPQUVLO0lBNUx0QixTQStMWDRpRCxZQUFZeHFDLE1BQU15cUMsTUFBTTdpRDtNQUMxQix3QkFEY29ZLE1BQU15cUMsTUFBTTdpRCxFQUNrQjtJQWhNL0IsU0FtTVg4aUQsZ0JBQWdCMXFDLE1BQU1wWTtNQUN4QixtQkFEa0JvWSxNQUNsQixzQkFEd0JwWSxLQUNhO0lBcE14QixTQXdNWCtpRCxhQUFhM3FDLE1BQU16YztNQUEwQix1QkFBaEN5YyxNQUFnQyxxQkFBMUJ6YyxHQUEyQztJQXhNbkQsU0EyTVhxbkQsZUFBZTVxQyxNQUFNdlk7TUFBMEIsdUJBQWhDdVksTUFBZ0MsZ0JBQTFCdlksR0FBNkM7SUEzTXZELFNBOE1Yb2pELGNBQWM3cUMsTUFBTTVXO01BQTBCLHVCQUFoQzRXLE1BQWdDLGVBQTFCNVcsR0FBNEM7SUE5TXJELFNBaU5YMGhELGNBQWM5cUMsTUFBTXhWLEdBQ0YsbUJBREp3VixRQUNJLFNBREV4VixHQUNlO0lBbE54QixTQXNOWHVnRCxhQUFhL3FDLGFBQVcsdUJBQVhBLFVBQTBDO0lBdE41QyxTQXVOWGdyQyxhQUFhaHJDLE1BQU15cUI7TUFBUyx1QkFBZnpxQixNQUFNeXFCLFNBQTZDO0lBdk5yRCxTQXlOWHdnQixjQUFjanJDLE1BQU15cUI7TUFBUyx1QkFBZnpxQixNQUFNeXFCLFNBQThDO0lBek52RCxTQTBOWHlnQixlQUFlbHJDLE1BQU15cUI7TUFBUyx1QkFBZnpxQixNQUFNeXFCLFNBQStDO0lBMU56RCxTQTJOWDBnQixZQUFZbnJDLE1BQU15cUIsUUFBUyx1QkFBZnpxQixNQUFNeXFCLFNBQTRDO0lBM05uRCxTQXNPWDJnQixpQkFBaUJwckM7TUFDbkIsZUFEbUJBLFNBQ25CLGtCQURtQkEsWUFDNkI7SUF2T25DLFNBd09YcXJDLGVBQWVyckM7TUFDakIsZUFEaUJBLFNBQ2pCLGtCQURpQkEsWUFDZ0M7SUF6T3BDLFNBNk9Yc3JDLGlCQUFpQnRyQztNQUNuQixTQURtQkE7TUFDbkIsWUFDd0IsZ0JBRkxBLHFCQUVtRDtJQS9PekQsU0FtUFh1ckMsb0JBQW9CdnJDO01BQ3RCLFNBRHNCQTtNQUN0QixZQUN3QixnQkFGRkEscUJBRW1EO0lBclA1RCxTQTRQWHdyQyxlQUFleHJDLE1BQU1zVSxNQUFNM0M7TUFDN0IsU0FEaUIzUjtNQUNqQjtRQUVJLElBREVzcEMsVUFGV3RwQyxpQkFBTXNVLE1BQU0zQyxRQUFOMkM7UUFHbkIsaUJBSGF0VSxRQUVYc3BDO2lCQUtxQjtJQW5RZCxTQTJRWG1DLGVBQWV6ckMsYUFBVyxzQkFBWEEsVUFBbUM7SUEzUXZDLFNBNFFYMHJDLGFBQWExckMsYUFBVyxzQkFBWEEsVUFBbUM7SUE1UXJDLFNBZ1JYMnJDLGFBQWEzckM7TUFDZixZQURlQTtNQUNmLFNBRGVBO01BQ2Y7UUFHSSxJQURFc3BDLDJCQUNGLHVCQUpXdHBDLE1BR1RzcEM7aUJBRXNCO0lBclJmLFNBeVJYc0MsY0FBYzVyQztNQUNoQixhQURnQkE7TUFDaEI7UUFDQSxTQUZnQkE7UUFFaEI7VUFFYyxJQUFQc3BDO1VBQ0osZ0JBTGF0cEMsTUFJVHNwQztVQUNKLFlBTGF0cEM7VUFJRjs7Ozs7aUJBR1g7SUFoU1UsU0FvU1g2ckMsZ0JBQWdCN3JDLE1BQU1zVSxNQUFNM0M7TUFDOUIsU0FEa0IzUjtNQUNsQjtRQUVJLElBREVzcEMsVUFGWXRwQyxpQkFBTXNVLE1BQU0zQyxRQUFOMkM7UUFHcEIsaUJBSGN0VSxRQUVac3BDO2lCQUtxQjtJQTNTZCxTQThTWHdDLGFBQWE5ckMsYUFBVyx1QkFBWEEsVUFBb0M7SUE5U3RDLFNBZ1RYK3JDLFdBQVcvckM7TUFDYixTQURhQTtNQUNiLFNBRUksSUFERXNwQyxlQUNGLHVCQUhTdHBDLE1BRVBzcEM7aUJBRXNCO0lBcFRmLFNBOFRYMEMsaUJBQWlCaHNDLE1BQU05VztNQUFJLGFBQUpBLE1BQUksV0FBVjhXLFlBQU05VyxxQkFBeUM7SUE5VHJELFNBaVVYK2lELGlCQUFpQmpzQyxhQUFXLE9BQVhBLFNBQTZCO0lBalVuQyxTQW1VWGtzQyxrQkFBa0Jsc0M7TUFBVyxPQUFYQSwyQkFBbUQ7SUFuVTFELFNBc1VYbXNDLHFCQUFxQm5zQyxNQUFNcFksR0FBSSxZQUFKQSxFQUFJLFFBQXNCO0lBdFUxQyxTQXVVWHdrRCxxQkFBcUJwc0MsYUFBVyxPQUFYQSxTQUE0QjtJQXZVdEMsU0EyVVhxc0MsU0FBU25qRCxHQUNYLE9BRFdBLDJCQUNvQztJQTVVbEMsU0EyVlhvakQsa0JBQWtCdHNDLE1BQU1oTztNQUMxQixRQURvQmdPLFdBQU1oTyxRQVYxQixVQUQ4QkU7TUFDOUI7UUFDVSxJQUFKaEosRUFBSSxTQUZvQmdKO1FBRXBCLFdBQUpoSjtRQUFJLFdBU1U4VztRQVRWLGdCQVNVQTtNQWZwQixXQWdCaUQ7SUE1VnBDLFNBK1ZYdXNDLGtCQUFrQnZzQyxhQUFXLE9BQVhBLFFBQThCO0lBL1ZyQyxTQWlXWHdzQyxjQUFjeHNDLE1BQU05VztNQUN0QixjQURzQkE7TUFDdEI7UUFDVSxJQUFKOEksSUFBSSxTQUZZOUk7UUFFWixXQUFKOEk7UUFBSTtTQUVKeTZDO1VBSlV6c0M7O1lBV1gsSUFBSSxJQVhPQTtRQVlzQix5QkFadEJBLE1BSVZ5c0M7aUJBVWtDO0lBL1czQixTQWtYWEMsY0FBYzFzQyxhQUFXLE9BQVhBLFFBQTBCO0lBbFg3QixTQXFYWDJzQywrQkFBK0Izc0M7VUFLaEJsSyxXQURBdlMsV0FEQzRnQixXQURGM1YsV0FEQy9HO01BRGdCdVksWUFDaEJ2WTtNQURnQnVZLFlBRWpCeFI7TUFGaUJ3UixZQUdmbUU7TUFIZW5FLFlBSWhCemM7TUFKZ0J5YyxZQUtoQmxLOztJQTFYSixTQWtZWDgyQywrQkFBK0I1c0M7TUFBVyxVQUFYQSxrREFNbEM7SUF4WWMsU0E0WVg2c0Msa0NBQWtDN3NDLE1BQU12WSxFQUFFK0c7TUFDNUMsWUFEMEMvRyxFQUMxQyxZQUQ0QytHLEVBQzVDLFFBQWlEO0lBN1lwQyxTQStZWHMrQyxrQ0FBa0M5c0M7TUFDcEMsVUFEb0NBLG9CQUNLO0lBaFo1QixTQW9aWCtzQyxnQkFBZ0Ivc0M7TUFBVyxrQkFBWEEscUJBQXdDO0lBRzNDLElBQWJndEMsV0FBYTthQVdiQyxlQVZtQmp0QyxNQUFNOVc7TXRDeDVCOUIsSXNDdzVCOEI4STtNQUMzQjtxQkFEMkJBO1FBQzNCO1VBQ0EsUUFGMkJBO1lBSXpCLFdBSm1CZ08sVUFEbkJndEM7WUFLQSxRQUp5Qmg3Qzs7VUFFWCxrQkFGS2dPLFVBRG5CZ3RDLGFBQ3lCaDdDO29CQU14QjtJQVBZLFNBZWJrN0MsNkJBQTZCbHRDLE1BQU1qVjtNQUNkOzsrQnRDdjZCMUIsT1N5V0tLLGlCNkI2akJtQ0w7TUFDZCw0QkFDVSxxQkFGSUEsR0FFSTtNQUNqQiwyQnRDejZCM0IsT3NDbzVCS2dpRCxnQkFrQjZCL3NDO01BSVIsMkJ0QzE2QjFCLE9zQ2s2QktpdEMsZUFJNkJqdEM7TUFLUiwyQnRDMzZCMUIsT3NDazZCS2l0QyxlQUk2Qmp0QztNQUtSLFFBQW9CO0lBcEI1QixTQTRCYm10Qyx5QkFBeUJ2bEQsR0FBVSxzQkFBVkEsVUFBaUI7SUE1QjdCLFNBNkJid2xELDBCQUEwQnhsRCxHQUFXLHNCQUFYQSxVQUFrQjtJQTdCL0IsU0ErQmJ5bEQsZ0N0Q3Q3Qkw7SXNDdTVCa0IsU0FnQ2JDLGlDdEN2N0JMO0lzQ3U1QmtCLFNBb0NiQyxrQkFBa0I5bEQsRUFBRStHLEVBQUUyVixFQUFFNWdCLEVBQUV1UztNQTN0QlYscUJBK3RCaEI7TUFDRixVQUZJMjNDLFFBREFEO01BN3RCYyxJQWl1QmRFLHVCQUhBRCxTQS9iRjNFO01BaWNGO2NBQ0k0RTs7Ozs7Ozs7Ozs7Ozs7YzdCMTFCRmhsRDs7YzZCbzFCa0JqQjtjQUFFK0c7Y0FBRTJWO2NBQUU1Z0I7Y0FBRXVTOzs7Y0FSMUJxM0M7Y0FDQUM7Y0FFQUM7Y0FDQUM7Y0FNRUUsU0FxQ0g7SUEzRWMsU0ErRWJHLDJCQUEyQkM7TUFDN0I7ZUFENkJBLDREQU1SO0lBckZOLFNBMEZiQyxlQUFlNWlELE9BQU82aUQ7TUFDeEIsb0J0Q2wvQkg7TXNDay9CRyxvQnRDbC9CSDtNc0NrL0JhO09BQU5DO1FBQU0sa0JBRE85aUQsT0FBTzZpRCxxQnRDai9CM0I7TXNDbS9CeUIseUJ0Q24vQnpCLE9zQ281QktmLGdCQThGRWdCO01BRWlCLHlCdENwL0J4QixPc0NrNkJLZCxlQWdGRWM7TUFHaUIseUJ0Q3IvQnhCLE9zQ2s2QktkLGVBZ0ZFYztNQUdpQixPQUhqQkEsR0FJRDtJQS9GWSxTQW1HYkMseUJBQXlCampEO01BQzNCLHFCQUFnRCxxQkFEckJBLEdBQzZCO01BQXpDOztpQnRDMy9CbEIsT1N5V0tLLGlCNkJpcEJ5Qkw7b0JBQzhCO0lBcEcxQyxTQXdHYmtqRCxvQkFBb0I3a0Q7TUFDdEIsb0J0Q2hnQ0g7TXNDZ2dDa0I7O2lCdENoZ0NsQixPOEJpS0tzb0IsY1E4MUJvQnRvQjtvQkFDd0I7SUF6Ry9CLElBK0diOGtEO0lBL0dhLFNBZ0hiQyxzQkFBb0IsZ0JBRHBCRCxlQUNnRDtJQUd2Qzs7S0FJTztLQUNBO0tBQ0Esa0NBTmhCRTtJQU1nQixTQU9oQkksdUJBQXVCL2hELElBQUlzaEQ7TUFDN0IsZUFENkJBLE9BRXJCLElBQUpubUQsRUFBSSxTQUZpQjZFLEtBR3pCLE1BSHlCQSxLQUd6QixPQURJN0UsQ0FFSDtJQVhpQixTQWVoQjZtRDtNQUF5Qiw4QkFyQnpCTCxPQU1BRyxjQWVvRTtJQWZwRCxTQXlDaEJHLG1DQUNGLFlBQWlDO0lBMUNmLFNBNENoQkMsNkJBQTZCQyxLQUMvQixtQkFBa0M7SUE3Q2hCLFNBK0NoQkMsMkJBQTJCRCxLQUM3QixXQUQ2QkEsT0FDUTtJQWhEbkIsU0FrRGhCRSw2QkFBNkJGO01BQ25CLElBQVJHLE1BQVEsMkJBRG1CSDtNQUUvQiw2QkFGK0JBO01BRS9CLE9BRElHLEtBRUM7SUFyRGEsU0F1RGhCQyx5QkFBeUJKLElBQUlLO01BQy9CLFlBRCtCQSxLQUFKTCxRQUMzQixRQUFvRTtJQXhEbEQsU0EwRGhCTSxvQ0FBb0NOO01BWTlCLFNBQUpubkQsRUFQb0JHLEVBQUVyRSxFQUFFMkYsR0FDa0IsZ0NBTlIwbEQsT0FNUSxNQUR0QmhuRCxFQUFFckUsRUFBRTJGO01BUXBCLFNBQUpzRixRQVhGLGdDQUZvQ29nRDtNQWM5QixTQUFKenFDLFFBVkYsZ0NBSm9DeXFDO01BZTlCLFNBQUpyckQsRUFSb0IyRixHQUN0QixnQ0FSb0MwbEQsT0FPZDFsRDtNQVNoQixTQUFKNE0sRUFQb0I1TSxHQUN0QixnQ0FWb0MwbEQsT0FTZDFsRDtNQU9oQix5QkFKSnpCLEVBQ0ErRyxFQUNBMlYsRUFDQTVnQixFQUNBdVMsRUFDdUI7SUFTYixTQUFacTVDLGdCdENwbUNMLE9zQ3N0QktwRSxhQXdUQXNEO0lBdUZZLFNBQVplLGdCdENybUNMLE9zQ3V0QktwRSxhQXVUQXFEO0lBd0ZhLFNBQWJnQixpQnRDdG1DTCxPc0N5dEJLcEUsY0FxVEFvRDtJQXlGYyxTQUFkaUIsa0J0Q3ZtQ0wsT3NDMHRCS3BFLGVBb1RBbUQ7SUEwRlcsU0FBWGtCLGV0Q3htQ0wsT3NDMnRCS3BFLFlBbVRBa0Q7SUEyRlksU0FBWm1CLGdCdEN6bUNMLE9zQzBrQktqRyxhQW9jQThFO0lBNEZXLFNBQVhvQixldEMxbUNMLE9zQ3dsQktqRyxZQXNiQTZFO0lBNkZZLFNBQVpxQixnQnRDM21DTCxPc0N1bUJLakcsYUF1YUE0RTtJQThGVyxTQUFYc0Isb0J0QzVtQ0wsT3NDK3JCS25GLFlBK1VBNkQ7SUErRmUsU0FBZnVCLHFCdEM3bUNMLE9zQ21zQktsRixnQkEyVUEyRDtJQWdHWSxTQUFad0Isa0J0QzltQ0wsT3NDd3NCS2xGLGFBc1VBMEQ7SUFpR2MsU0FBZHlCLG9CdEMvbUNMLE9zQzJzQktsRixlQW1VQXlEO0lBa0dhLFNBQWIwQixtQnRDaG5DTCxPc0NpdEJLakYsY0E2VEF1RDtJQW1HYSxTQUFiMkIsaUJ0Q2puQ0wsT3NDOHNCS25GLGNBZ1VBd0Q7SUFvR2MsU0FBZDRCO010Q2xuQ0wsT3NDNHZCS3pFLGVBa1JBNkM7SUFxR1ksU0FBWjZCLGdCdENubkNMLE9zQzR3Qkt4RSxhQWtRQTJDO0lBc0djLFNBQWQ4QixrQnRDcG5DTCxPc0Myd0JLMUUsZUFtUUE0QztJQXVHZ0IsU0FBaEIrQixvQnRDcm5DTCxPc0M2dUJLOUUsaUJBaVNBK0M7SUF3R2MsU0FBZGdDLGtCdEN0bkNMLE9zQ3d1QktoRixlQXNTQWdEO0lBeUdnQixTQUFoQmlDO010Q3ZuQ0wsT3NDc3VCS2xGLGlCQXdTQWlEO0lBMEdtQixTQUFuQmtDO010Q3huQ0wsT3NDbXZCS2hGLG9CQTJSQThDO0lBNEdZLFNBQVptQyxnQnRDMW5DTCxPc0NneEJLN0UsYUE4UEEwQztJQTZHYSxTQUFib0MsaUJ0QzNuQ0wsT3NDeXhCSzdFLGNBcVBBeUM7SUE4R2UsU0FBZnFDO010QzVuQ0wsT3NDb3lCSzdFLGdCQTBPQXdDO0lBZ0hVLFNBQVZzQyxjdEM5bkNMLE9zQ2d6Qks1RSxXQThOQXNDO0lBaUhZLFNBQVp1QyxnQnRDL25DTCxPc0M4eUJLOUUsYUFnT0F1QztJQW1IYSxTQUFid0MsaUJ0Q2pvQ0wsT3NDaTJCS3JFLGNBNktBNkI7SUFvSGEsU0FBYnlDLGlCdENsb0NMLE9zQzhnQ0t6QztJQXNIaUIsU0FBakIwQztNdENwb0NMLE9zQzIxQkt6RSxrQkFtTEErQjtJQXVIaUIsU0FBakIyQyxxQnRDcm9DTCxPc0M4Z0NLM0M7SUF5SGdCLFNBQWhCNEMsb0J0Q3ZvQ0wsT3NDOHpCS2pGLGlCQWdOQXFDO0lBMEhnQixTQUFoQjZDLG9CdEN4b0NMLE9zQzhnQ0s3QztJQTJIaUIsU0FBakI4QztNdEN6b0NMLE9zQ20wQktqRixrQkEyTUFtQztJQTZIb0IsU0FBcEIrQztNdEMzb0NMLE9zQ3MwQktqRixxQkF3TUFrQztJQThIb0IsU0FBcEJnRCx3QnRDNW9DTCxPc0M4Z0NLaEQ7SUFpSUYsU0FERWlEO010QzlvQ0wsT3NDczZCS3BFLDZCQXdHQW1CO0lBb0lGLFNBREVrRDtNdENqcENMLE9zQ3EzQks1RSwrQkF5SkEwQjtJQXNJRixTQURFbUQ7TXRDbnBDTCxPc0NrNEJLNUUsK0JBNElBeUI7SUF5SUYsU0FERW9EO010Q3RwQ0wsT3NDNDRCSzVFLGtDQWtJQXdCO0lBMklGLFNBREVxRDtNdEN4cENMLE9zQys0Qks1RSxrQ0ErSEF1QjtJQThJRixTQURFc0Q7TXRDM3BDTCxPc0N5b0JLM0gsK0JBcVlBcUU7SUFnSkYsU0FERXVEO010QzdwQ0wsT3NDaW9CSzdILCtCQTZZQXNFO0lBa0pGLFNBREV3RDtNdEMvcENMLE9zQ3duQktuSSxrQkFzWkEyRTtJQW9KRixTQURFeUQscUJ0Q2pxQ0wsT3NDOGdDS3pEO0lBc0pGLFNBREUwRCxvQnRDbnFDTCxPc0N5bkJLcEksaUJBcVpBMEU7SUF3SkYsU0FERTJELG9CdENycUNMLE9zQzhnQ0szRDtJQTBKRixTQURFNEQsZXRDdnFDTCxPc0M0bkJLbkksWUFrWkF1RTtJQTBKRixTQU1NNkQsY0FBZ0I5YyxJQUF1QitjLEtBQUtwRTtVQUE1QnFFOztpQkFBUyxRQUFUQSxnQkFBUzNhLGFBQVQ0YSxPQWxhcEIzRztRQWthc0Q7OztZQUl0RCxXQUoyQ3lHLEtBQUtwRTtZQUtoRCxXQUxvQnNFLE9BQTRCdEU7WUFLaEQsYUFMb0JzRTs7VUFFYixrQkFGb0NGLEtBQUtwRTtRQUMxQztJQVBSLFNBZUV3RSxjQUFjeEUsSUFBSW5tRDtNQUNwQiw4QkFEb0JBLEdBQ3BCO2VBR0lrbUQ7UUFDRixnQkFMY0MsSUFLTSxNQUxGbm1ELEVBRWhCdU4sUUFDQUMsV0FEQUQ7UUFHRjtrQkFGRUM7UUFFRixRQUMyQjs7V0FIekJBLGFBRkFqSztVQVFJLDBCQVRZdkQsRUFHaEJ3TjtVQU1JO1lBRUYsU0FDQSxpQkFaVTI0Qzs7NEJBY1YsU0FBVSxlQWRBQSxZQUdaMzRDOztRQWdCSixTQWpCSUQsWUFEQWhLO1FBa0JKLFlBQXFCLGNBQVE7SUFsQzdCLFNBc0NFcW5ELFlBQVl2bkQsT0FBT3duRDtNQUNYLHFCQUNBLHdCQUROaG1EO01BRUosV0FIY3hCLE9BRVY4aUQsSUFGaUIwRTtNQUlyQixlQUZJMUU7TUFETSxJQUlONWlELElBSkFzQjtNQUlNLFlBQU50QixJQUVDLE1BTkRzQixNQUlBdEIsYUFDWSxTQUxac0IsSUFNMkI7SUE3Qy9CLFNBMERFaW1ELHNCQUFzQjNFLElBQUlubkQ7TUFBYSxVQUFiQTtPQUFhLE9BQWJBO2dCQUNHLG9CQURQbW5EO2dCQUVPLG9CQUZQQTtnQkFJTyxzQkFKUEE7Z0JBS08sd0JBTFBBO2dCQU1PLHdCQU5QQTtnQkFRTyxxQkFSUEE7aUJBU08scUJBVFBBOztPQUFpQixPQUFibm5EOztjQUdUK3FCLE9BSFMvcUIsY0FHaEIwdEIsTUFIZ0IxdEI7aUJBdGUxQjRrRCxlQXNlc0J1QyxJQUdaejVCLE1BQU8zQztnQkFJWTs7Y0FHbEJubkIsRUFWZTVEO1VBVUcsY0FWUG1uRDtVQVVPLHFCQVZQQSxJQVVYdmpELEdBQTREO0lBcEV6RSxTQTBFTW1vRCxhQUFXNUUsSUFBSXArQztNQUFNLFVBQU5BO09BMEJTOztPQTFCSCxPQUFOQTs7Y0FTSWxJLEVBVEprSSxPQVNDcUQsRUFURHJEO1VBVW5CLGFBVmVvK0MsSUFTSy82QztVQUNwQiw2QkFWZSs2QyxJQVNRdG1EOzttQkFUSmtJOztZQWFuQixJQURvQ0M7WUFDcEMsYUFiZW0rQztZQWNDLG1CQWREQSxJQWNDLFlBZFo0RSxhQVlnQy9pRDtjQUdBQztVQUNwQyxhQWhCZWsrQztVQWlCSztvQ0FBbUIsWUFqQm5DNEUsYUFlZ0M5aUQ7V0FFaEI7O2lDQWpCTGsrQyxJQWlCVnRqQixPQUFRbW9COzttQkFqQk1qakQ7Ozs7Ozs7Ozs7O2dCQUMrQ0ksSUFEL0NKO2dCQUN1QytCO2dCQUFsQm8yQjs7Ozs7Ozs7OzBCQWtCakJsZ0MsRUFuQkorSCxPQW1CQ2s0Qjs7O21CQW5CRGw0Qjs7Ozs7Ozs7Ozs7Z0JBSzZDNEUsSUFMN0M1RTtnQkFLcUM4NEM7Z0JBQWxCaGY7Ozs7Ozs7OzswQkFnQmpCai9CLEVBckJGbUYsT0FxQkQ2NUI7OzttQkFyQkM3NUI7Ozs7Ozs7Ozs7O2dCQUMrQ0ksSUFEL0NKO2dCQUN1QytCO2dCQUFsQm8yQjs7Ozs7Ozs7OzBCQWtCakJsZ0MsRUFuQkorSCxPQW1CQ2s0Qjs7O21CQW5CRGw0Qjs7Ozs7Ozs7Ozs7Z0JBSzZDNEUsSUFMN0M1RTtnQkFLcUM4NEM7Z0JBQWxCaGY7Ozs7Ozs7OzswQkFnQmpCai9CLEVBckJGbUYsT0FxQkQ2NUI7OztjQUVKeU0sSUF2Qkt0bUMsT0F1QlJnNkIsSUF2QlFoNkI7VUF1QlMsYUF2QmJvK0MsSUF1Qkpwa0I7VUFBaUIsa0JBQWRzTSxJQXZCQzhYOztjQXdCTDhFLElBeEJTbGpELE9Bd0JTLGFBeEJibytDLElBd0JMOEUsS0FBa0Isc0JBeEJiOUU7O2NBeUJLcmtCLElBekJELzVCLE9BeUJGbWpELElBekJFbmpEO1VBeUJTLGFBekJibytDLElBeUJFK0U7VUFBVyxtQkFBUnBwQjtNOUJsd0JoQjtlOEI0dUJKLGFBSGVxa0IsSUFDeUJqbUIsS0FFeEMsd0JBSGVpbUIsSUFDMkNyOEMsS0FBUTNCOztTQU1sRSxhQVBlZytDLElBS3VCdGtCO1NBR0Usd0JBUnpCc2tCLElBS3lDdEYsT0FHaEIsU0FId0JsMEM7ZUFlcEMsYUFwQmJ3NUMsSUFtQktsbUIsS0FDUSx1QkFwQmJrbUIsSUFtQlFubUQ7Z0JBR0ssYUF0QmJtbUQsSUFxQkd2a0IsS0FDVSxxQkF0QmJ1a0IsSUFxQk12akQsR0FLUztJQXBHaEMsU0EwR011b0QsYUFBV2hGLElBQUlwK0M7TUFBTSxVQUFOQTtPQTZCUzs7T0E3QkgsT0FBTkE7O2NBWUlsSSxFQVpKa0ksT0FZQ3FELEVBWkRyRDtVQWFuQixhQWJlbytDLElBWUsvNkM7VUFDcEIsNkJBYmUrNkMsSUFZUXRtRDs7bUJBWkprSTs7WUFnQm5CLElBRG9DQztZQUNwQyxhQWhCZW0rQztZQWlCQyxtQkFqQkRBLElBaUJDLFlBakJaZ0YsYUFlZ0NuakQ7Y0FHQUM7VUFDcEMsYUFuQmVrK0M7VUFvQks7b0NBQW1CLFlBcEJuQ2dGLGFBa0JnQ2xqRDtXQUVoQjs7aUNBcEJMaytDLElBb0JWdGpCLE9BQVFtb0I7O21CQXBCTWpqRDs7Ozs7Ozs7Ozs7Z0JBQytDSSxJQUQvQ0o7Z0JBQ3VDK0I7Z0JBQWxCbzJCOzs7Ozs7Ozs7MEJBcUJqQmxnQyxFQXRCSitILE9Bc0JDazRCOzs7bUJBdEJEbDRCOzs7Ozs7Ozs7OztnQkFLNkM0RSxJQUw3QzVFO2dCQUtxQzg0QztnQkFBbEJoZjs7Ozs7Ozs7OzBCQW1CakJqL0IsRUF4QkZtRixPQXdCRDY1Qjs7O21CQXhCQzc1Qjs7Ozs7Ozs7Ozs7Z0JBQytDSSxJQUQvQ0o7Z0JBQ3VDK0I7Z0JBQWxCbzJCOzs7Ozs7Ozs7MEJBcUJqQmxnQyxFQXRCSitILE9Bc0JDazRCOzs7bUJBdEJEbDRCOzs7Ozs7Ozs7OztnQkFLNkM0RSxJQUw3QzVFO2dCQUtxQzg0QztnQkFBbEJoZjs7Ozs7Ozs7OzBCQW1CakJqL0IsRUF4QkZtRixPQXdCRDY1Qjs7O21CQXhCQzc1Qjs7OztrQkFTc0N1bUMsSUFUdEN2bUMsT0FTOEJxakQsZUFBbEJycEI7Y0FDL0IsYUFWZW9rQixJQVNnQnBrQjtjQUVTLHdCQVh6Qm9rQixJQVNrQ2lGLE9BRVQsV0FGaUI5YztjQWlCM0NELElBMUJLdG1DO1VBMEJTLGFBMUJibytDO1VBMEJtRCx1QkExQm5EQSxJQTBCbUQsV0FBcEQ5WDs7Y0FDSjRjLElBM0JTbGpELE9BMkJTLGFBM0JibytDLElBMkJMOEUsS0FBa0Isc0JBM0JiOUU7O2NBNEJLcmtCLElBNUJELzVCLE9BNEJGbWpELElBNUJFbmpEO1VBNEJTLGFBNUJibytDLElBNEJFK0U7VUFBVyxtQkFBUnBwQjtNOUJyeUJoQjtlOEI0d0JKLGFBSGVxa0IsSUFDeUJqbUIsS0FFeEMsd0JBSGVpbUIsSUFDMkNyOEMsS0FBUTNCOztTQU1sRSxhQVBlZytDLElBS3VCdGtCO1NBR0Usd0JBUnpCc2tCLElBS3lDdEYsT0FHaEIsU0FId0JsMEM7ZUFrQnBDLGFBdkJidzVDLElBc0JLbG1CLEtBQ1EsdUJBdkJia21CLElBc0JRbm1EO2dCQUdLLGFBekJibW1ELElBd0JHdmtCLEtBQ1UscUJBekJidWtCLElBd0JNdmpELEdBS1M7SUF2SWhDLFNBK0lFeW9ELFdBQVN0L0MsRUFBRW82QztVQUFhdjVCO2FsQ21KcEJvVDt3QmtDakpDbW1CLElBQUlwK0M7aUJBQU8sYUFBWG8rQyxJQUFJcCtDLEtBQU8sa0JBRlBnRSxFQUVKbzZDLElBQW9DO2VBRjlCQTs7ZUFBYXY1QjtJQS9JMUIsU0FvSkUwK0IsWUFBVXYvQyxFQUFFbzZDO010QzV6Q2pCLElzQzR6QzhCdjVCLG9CbEM2WnJCeVUsYWtDN1pNdDFCLEVBQUVvNkMsSUFBYXY1QjtJQXBKM0IsU0F1SkUyK0IsVUFBUXBGO01BQU0sb0J0Qy96Q25CO01zQyt6Q21CLHNCdEMvekNuQixPc0N1ekNLa0YsZ0JBUVFsRixVQUF5QjtJQXZKbkMsU0F3SkVxRixXQUFTckY7TUFBTSxvQnRDaDBDcEI7TXNDZzBDb0Isc0J0Q2gwQ3BCLE9zQzR6Q0ttRixpQkFJU25GLFVBQTBCO0lBeEpyQyxTQXlKRXNGLFNBQU83K0IsS0FBTSw0QkFuVGI2NUIsZUFtVE83NUIsSUFBK0I7SUF6SnhDLFNBMEpFOCtCLFVBQVE5K0IsS0FBTSw0QkFuVGQ4NUIsZUFtVFE5NUIsSUFBK0I7SUExSnpDLFNBNEpFKytCLFdBQVM1L0M7TUFDSCxJQURjNmdCLGFBQ2Qsb0JBQ0Usd0JBRE5wckI7TUFDTSxTQUNOd0ssVUFBS2pFO1FBQ1AsYUFGRW8rQyxJQUNLcCtDO1FBRUwsa0JBTE9nRSxFQUtQLHVCQUpBdkssRUFDQTJrRCxLQUc4QjtNQUh4QixtQkFDTm42QyxRQUhrQjRnQjtJQTVKdEIsU0FxS0VnL0IsVUFBUWgvQixLQUFNLDJCQUFjNXNCLEdBQUssT0FBTEEsQ0FBTSxFQUExQjRzQixJQUErQjtJQXJLekMsU0F1S0VpL0IsVUFBVTkvQztNQUNKLElBRGU2Z0IsYUFDZixvQkFDRSx3QkFETnByQjtNQUNNLFNBQ053SyxJQUFFbTZDLElBQUlwK0M7UUFDUixhQURJbytDLElBQUlwK0M7UUFFTixrQkFMUWdFLEVBS1IsdUJBSkF2SyxFQUVFMmtELEtBRTRCO01BSHhCLG1CQUNObjZDLElBREFtNkMsTUFGbUJ2NUI7SUF2S3ZCLFNBZ0xFay9CLFNBQVNsL0IsS0FBTSwwQkFBZTVzQixHQUFLLE9BQUxBLENBQU0sRUFBM0I0c0IsSUFBZ0M7SUFHcEMsUUFyT0w2N0I7SUFxT0ssU0FVTHNELHNDQUFzQzN6QyxNQUNqQ3ZZLEVBQVMrRyxFQUFXMlYsRUFBVTVnQjtNQUNyQyxrQ0FGd0N5YyxNQUNqQ3ZZLEVBQVMrRztNQUNoQixZQUQyQjJWO01BQzNCLFlBRHFDNWdCO01BQ3JDLFFBRXdCO0lBZGpCLFNBaUJMcXdELHNDQUFzQzV6QztNQUN4QyxVQUR3Q0Esd0NBRUc7SUFLM0MsU0FERTZ6QztNdENsM0NMLE9zQ3EyQ0tGO2VBdlZBdEY7SUEwV0YsU0FERXlGO010Q3YzQ0wsT3NDNDJDS0Ysc0NBOVZBdkY7SUEwV0YsU0FVRTBGLFVBQVEzcUQ7TXRDbDRDYixJc0NrNEN3Qm9yQjtlQUNqQjdnQixFQUFFbzZDLElBQUlwK0MsS0FBTSxhQUFWbytDLElBQUlwK0MsS0FBTSxzQkFBVm8rQyxNQUFzRDtNQUM5QyxtQkFEVnA2QyxFQUNVLG9CQUZKdkssS0FBV29yQjtJQVZyQjs7O09BN3BCRTIyQjtPQTZZQW9FO09BOWhCQWhHO09BK2hCQWlHO09BblpBekU7T0E4WUFvRTtPQTdZQW5FO09BOFlBb0U7T0E1WUFuRTtPQTZZQW9FO09BNVlBbkU7T0E2WUFvRTtPQXBhQTVFO09BMGFBa0Y7T0E5YUFwRjtPQTZhQW1GO09BcGFBaEY7T0FzYUFrRjtPQW5hQWpGO09Bb2FBa0Y7T0E5WkFoRjtPQStaQWlGO09BbGFBbEY7T0FtYUFtRjtPQXRXQXZFO09BeVdBMEU7T0F4V0F6RTtPQXVXQXdFO09BdlhBMUU7T0FzWEF5RTtPQXJZQTNFO09Bd1lBOEU7T0FsWUE3RTtPQXFZQWdGO09BaFpBbEY7T0E4WUFnRjtPQWhaQWpGO09BaVpBa0Y7T0F0UkE5RDtPQWdTQXFFO09BL1FBbkU7T0FnUkFvRTtPQXZTQXhFO09BeVNBeUU7T0FyU0F4RTtPQXNTQXlFO09BdlVBaEY7T0F5VUFpRjtPQXRVQWhGO09BdVVBaUY7T0FyVUFoRjtPQXNVQWlGO09BelhBeEY7T0EwV0E2RTtPQWpXQTVFO09Ba1dBNkU7T0EzVUExRTtPQThVQTRFO09BaFZBN0U7T0FpVkE4RTtPQTNWQS9FO09Bd1ZBNkU7T0F0VEF2RTtPQXFVQWlGO09BcFVBaEY7T0FxVUFpRjtPQXBqQkE3SDtPQWtoQkFpRztPQW5nQkFoRztPQW9nQkFpRztPQS9lQTVGO09BMmlCQW1JO09BL2lCQXZJO09BdWlCQW1JO09BdGlCQWxJO09BMGlCQW9JO09BemlCQW5JO09BdWlCQWtJO09BdGlCQWpJO09BMGlCQW1JO09BL1BBOUU7T0F3T0FvRTtPQWxRQXpFO09BMFFBNEU7T0F2UUEzRTtPQXlRQTRFO09BblNBL0U7T0E0UkE0RTtPQS9RQTNFO09BaVJBNEU7T0ExZ0JBeEg7T0FraEJBMkg7T0ExaEJBNUg7T0E0aEJBNkg7T0FuS0E1RDtPQW9CQUs7T0FDQUM7T0FoQkFMO09BV0FHO09BTUFHO09BZUFFO09BOUNBWjtPQVhBRjtPQW1GQWU7T0FHQUM7T0FHQUU7T0FHQUM7T0FLQUU7T0FHQUU7T0FvR0lnRDtPQVNKSztPQXdJQVk7T0FFQUU7T0FDQUM7T0FXQUU7T0FXQUU7T0F4QkFOO09BVEFIO09BS0FDO09BUUFLO09BV0FFO09BbURBTTtPQTlEQVI7T0E4Q0FNO09BS0FDO09BbEJBSDtPQU9BQztJQVlGO1FDanRDSUk7YUFLQUMsVUFBVUM7TUFDWjtRQUNVLElBQUoxcEQsRUFBSSxXQUZFMHBEO1FBRUYsUUFBSjFwRDtRQUFJO2dCQUZFMHBEO1FBRUYsVUFBSjFwRCxFQUZNMHBEO2VBRU4xcEQ7Ozs7VUFPSixRQWRBd3BELFVBY0EsMkJBZEFBO21CQWtCQzthQUdERyxVQUFVRCxJQUNaLE9BRFlBLFlBR1AsVUFIT0EsR0FHSzthQVFmRSxrQkFBa0JGO01BQ1osSUFBSjFwRCxFQUFJLFVBRFkwcEQsSUFDWixHQURZQSx3QkFHcEIsT0FGSTFwRCxDQUVIO2FBR0M2cEQsYUFBYUgsSUFDUixVQURRQSxJQUNSLE9BRFFBLEtBRU47YUFLUEksbUJBQW1CSixJQUFLLGFBQUxBLFNBQXlCO2FBRTVDSyxjQUFjTDtNQUNoQixTQURnQkE7TUFDaEI7Ozs7UUFFNEIsSUFBZk07UUFBZSxPQUFmQSxNQUU4QjthQUd6Q0MsV0FBV1AsSUFDYixPQURhQSx5QkFHUTthQUtuQlEsWUFBWVIsSUFBSyxhQUFMQSxNQUFvQzthQUVoRFMsd0JBQXdCVCxJQUFLLGtCQUFvQzthQXlTbkVVLGFBdlNRVjtNQUNSLGlCQURRQSxNQUVFLGFBRE5XO01BRUosUUFGSUE7TUFFSixRQUhRWDtNQUdSLE9BREk5d0MsR0FHRDthQUtEMHhDLFVBQVV4Z0MsTUFBTTQvQixJQUNsQix3QkFEa0JBLElBQ2xCLE9BRFk1L0IsS0FFUDthQUdIeWdDLFlBQVl6Z0MsTUFBTTQvQixJQUFLLGlCQUFYNS9CLGNBQU00L0IsR0FBNkI7YUFFL0NjLFdBQVcxZ0MsTUFBTTQvQixHQUFHMXBEO01BQ3RCLFNBRG1CMHBELE1BQUcxcEQsR0FDdEIsbUJBRGE4cEIsTUFBTTQvQixHQUVDO1FBR2xCZTthQUVBQyxTQUFPQyxNQUFNbG1EO01BUUc7O2NBbkdoQitrRDs7Ozs7Y0EyRmEva0Q7Y0FRRyxTQVZoQmdtRDtjQUVPRSxNQVVWO2FBR0dDLGNBQVl4dEQ7TUFDZCxzQ0FEY0E7TUFDZCxTQUVJcUg7UUFDRixHQUZFOUQsT0FEQTVIO1FBSUYsSUFBSWlILEVBQUosZ0JBTFk1QyxFQUNWckU7UUFJRjtlQUFJaUgsQ0FFSDtNQU5ILGtCQUVJeUUsS0FLbUI7O0lBR0wsU0FBaEJvbUQsc0J2QzFSUCxPdUNrUU9IO0lBd0JnQixJQXFEZC9wRDtJQXJEYyxTQThDaEJtcUQsa0JBQWtCeHBELElBQUssbUJBQUxBLElBQUssaUJBQXlDO0lBOUNoRCxTQWtEaEJ5cEQsa0JBQWtCenBELElBQU0saUJBQWlCO0lBbER6QixTQW9EaEIwcEQsUUFBUUMsY0FBY04sTUFBTXJwRDtNQUM5QjtlQUtJbUQ7UUFDRixHQUpFMUwsT0FDQTBTLFFBR2dCLElBQVV6TCxFQUFWLGVBTGhCaUMsSUFDQWxKLE1BSWdCLGNBQVVpSDtRQUM1QixHQUhFa3JEO1FBSU8sZUFUbUI1cEQsR0FFMUJXLE1BREF0QjtRQVFPLGFBTFA4SztrQkFDQXkvQyxXQUtpQixXQVZYRCxjQUFvQjNwRDtrQkFHMUJ2SSxTQU84RCxlQVI5RGtKLE9BWUM7TUFiTCxnQkFEd0Iwb0QsTUFNcEJsbUQsS0FTYTtJQXNCakIsSUFJRTBtRCxNQUpGLFFBdkNFSjtJQXVDRixTQU1FSyxhQUFhanFELFFBR2I2b0Q7TUFGRix3QkFFRUE7UUFDUyxJQUFMMW9ELEdBQUssV0FKSUgsUUFHYjZvRDtlQTlDQWdCLFFBTkFGLHFCQW9EQWQsTUFDSTFvRDtNQUZHLE9BSlA2cEQsS0FPK0M7SUFYakQ7SUFjWSxTQUdWRSxnQnZDcFlQLE91Q3lYT0Q7SUFRVTtJQUNJLFNBR2RFLG9CdkNyWVAsT3VDeVhPRjtJQVNjLFNBS2RHLGVBQWFqcUQsSXZDdllwQixPdUM4VU8wcEQsUUFGQUQscUJBMkRhenBELE9BQzBCO0lBTnpCLFNBU2RrcUQsU0FBUzlCO01BQ1gsU0FEV0E7TUFDWDtPQUlpQzs7UUFKakMsa0JBRUUsSUFEYXBvRCxXQUNiLDBCQURhQTtRQUVhLElBQVBtcUQ7UUFBTywwQkFBUEEsTUFDYztJQWRuQixJQWlDWkM7SUFqQ1ksU0FnQ2RDLGFBRUdWLGNBQWMzcEQ7TUFDbEI7UUFBSSxjQURjQSxHQURmb3FEOzs7O1VBS0MsSUFERWhDLEdBQ0YsUUFKQXVCLGlCQUFjM3BEO1VBSWQsZ0JBSmNBLEdBR1pvb0QsSUFKSGdDO1VBS0MsT0FERWhDO1FBM0JQLFdBOEJLO0lBSWlCLFNBQXBCa0M7TXZDOWFQLE91Q2thT0QsYUF0RkFaO0lBa0dvQjthQWN0QmMsVUFBVXp1RCxHQUFJLHNCQUFKQSxFQUEwQjtJQWRkLFNBZ0J0QjB1RCxpQkFBaUI5ckQ7TUFDVCwwQ0FEU0EsR0FDdUM7SUFqQmxDLFNBb0J0QityRCxpQkFBaUJDO01BRWpCLDBDQUZpQkEsU0FLTjtJQXpCVyxTQW9DdEJDO01BQ0Ysa0VBQXdEO0lBckNoQyxTQXdDdEJDO01BQ0YsK0RBQXFEO0lBekM3QixTQWdEdEJDLG1CQUFtQm5zRCxFQUFFb3NEO012QzlkMUIsT3VDNGJLUCxVQStCRix5QkFHcUI3ckQsRUFBRW9zRCxJQUNnQjtJQWpEZixTQWtGdEJDLGdCQUFnQjNDLEdBQUcxcEQ7TUFDWixJQUFMb3NELEdBQUssa0JBRFMxQztNQUNULE9BQUwwQyxPQURpQnBzRCxFQUVOLHdCQUZHMHBELElBR2xCLG1CQUhxQjFwRCxFQUNqQm9zRCxHQUVtQjtJQXJGQyxTQTRFbEJFLFdBV1U1QyxHQVBkMy9DO01BSEYsVUFHRUE7UUFRTyxJQUFMcWlELEdBQUssa0JBRE8xQztRQUNQLGNBQUwwQztpQkFFTSx3QkFITTFDO3dCQUNaMEM7b0JBR00sd0JBSk0xQyxJQUlOLGdCQUpNQTttQkFLVCxzQkFKSDBDO2dCQVJGcmlEOztTQTNCTSxnQkFrQ1EyL0MsSUFqQ1QsU0FpQ1NBO1NBakNUO1dBQXVCO2lCQUQxQjFwRDtZQUMwQjs7Vy9CcUN4QixhK0JsQ0Ysd0JBOEJZMHBEO1dBN0JQOztNQXNCRix1QkFPU0EsR0FQZDMvQyxJQUF5QjtJQWhGSCxTQWlHdEJ3aUQsV0FBVzdDLElBQUssb0NBQUxBLE1BQTRCO0lBakdqQixTQXFHdEI4QyxXQUFXOUM7TUFDUCxJQUdKdHNELEVBSEksYUFET3NzRDtNQUNQLDRCQUdKdHNEOztpQkFBZSxtQ0FBZkE7O2dCQUF3RDtJQXpHbEMsU0FzSHRCcXZEO01BQTZCOzs7aUJBQ3RCO2lCQUNBO2lCQUNBO2lCQUNBO2lCQUNBOztpQkFDTTs7TUFDUiw2QkFBWTtJQTdISyxTQW1JdEJDLGtCQUFrQmpkLEtBQUtpYTtNQUN6QixPQURvQmphO21CQUNoQjcyQixJQU1nQixXQUFPLGFBUEY4d0M7bUJBQ3JCOXdDLElBSWdCLFdBQU8sYUFMRjh3QzttQkFDckI5d0MsSUFHZ0IsV0FBTyxhQUpGOHdDO21CQUNyQjl3QyxJQUtnQixXQUFPLGFBTkY4d0M7b0JBQ3JCOXdDLElBRStCLGFBSFY4d0M7TUFHMkIsSUFLaER4cUQsRUFMZ0Qsc0JBRmhEMFo7TUFFZ0QsU0FLaEQxWjtpQkFDUSxnQkFSUjBaLGNBUXFDLE1BUnJDQSxNQU9BMVo7TUFDNEIsT0FSNUIwWixHQVE2RDtJQTVJekMsU0FvSnRCK3pDLFlBQVlqRCxJQUFxQix5Q0FBckJBLElBQXdDO0lBcEo5QixTQXVMbEJrRCx3QkFBd0I5aUMsTUFBTTQvQjtNdkNybUJ2QyxJdUNxbUJpQzFtQjtNQUM5QjtpQkFEOEJBO1FBRXRCLElBR05oakMsRUFITSxVQUY0QjBwRDtRQUdqQyxHQUhpQ0EsYUFBTjFtQjtRQUk5QixTQUNFaGpDOztZQUlZLHdCQVRnQmdqQyxRQUFNMG1CLElBQU4xbUI7O2tCQUs1QmhqQztXQUNZLHVCQU5nQmdqQyxRQUFNMG1CLEdBS2xDMXBELEdBTDRCZ2pDO1FBV3ZCLE9BWHVCQSxRQVdsQjtJQWxNWSxTQW9RdEI4cEIsMEJBL0R3QmhqQyxNQUFNNC9CO01BQ2hDLFNBRDBCNS9CLGFBQ1I7TUFDVix3QkFGd0I0L0IsSUFFeEIsU0FBSjFwRDtNQUFJLDZCQU1JLG1DQU5SQTtNQUFJLElBR0ZnakMsUUFBUSxXQUxZbFosTUFBTTQvQixHQUU1QjFwRDtNQUdVLCtCQUFSZ2pDLFFBTDBCMG1CLEdBUW9DO0lBN001QyxTQWtPdEJxRCxnQkFBZ0JDLE1BQU1DLE9BQU9KLFFBQU1uRDtNQUdyQyxTQUgrQm1ELGVBR2I7TUFDVixJQUFKOWlELElBQUksa0JBSjZCMi9DO01BS2xDLGNBTHFCdUQsT0FJcEJsakQ7UUFFVSx1QkFOaUI4aUQsUUFBTW5ELEdBSWpDMy9DLEtBbkJnQitmO1FBQ2xCO21CQURrQkE7VUFFVixJQUdOOXBCLEVBSE0sVUFhMkIwcEQ7VUFaaEMsR0FZZ0NBLGFBZmpCNS9CO1VBS1QsY0FVYW1qQyxPQVZwQmp0RDtZQUNZLHVCQU5JOHBCLE1BZWlCNC9CLEdBVmpDMXBELEdBTGdCOHBCO29CQUtoQjlwQjtZQUlZLHdCQVRJOHBCLE1BZWlCNC9CLElBZmpCNS9CO1VBV1gsT0FYV0E7TUF3QlIsMENBTFIvZixJQUpjaWpELE9BU3lEO0lBM09uRCxTQThPdEJHO01BQWtCLHlEQUVSO0lBR1EsU0FBbEJDO012Q2pxQkwsT3VDZ3BCS0wsMkJBWUFJO0lBS2tCLFNBRWxCRTtNQUFpQix5REFFUDtJQUdPLFNBQWpCQztNdkN4cUJMLE91Q2dwQktQLDBCQW1CQU07SUFLaUIsU0FFakJFO01BQWdCOzs7Ozs7TS9CaktaLG1CK0JtS007SUFHYSxTQUF2QkM7TXZDL3FCTCxPdUNncEJLVCxnQ0EwQkFRO0lBS3VCLFNBS3ZCRSxVQUFVM2pDLE1BQU00L0I7TUFDVix3QkFEVUEsSUFDVixTQUFKMXBEO01BQUk7O2dCQUVDLGtCQUhHOHBCLE1BQU00L0IsR0FDZDFwRDs7aUJBR0ssa0JBSkc4cEIsTUFBTTQvQixHQUNkMXBEO01BSUcsT0FMSzhwQixLQUtBO0lBVmEsU0FhdkI0akMsbUNBQW1DNWpDLE1BQU00L0I7TUFDL0IsSUFBUjFtQixRQUFRLFVBRHlCbFosTUFBTTQvQjtNQUMvQixpQ0FBUjFtQixRQUR1QzBtQixHQUVUO0lBZlQsU0EwQ3ZCaUUsb0JBQW9CbGUsS0FBS3hNLFFBQU15bUI7TUFDakMsT0FEc0JqYTtlQUVKLHVCQUZTeE0sUUFBTXltQjtlQUdmLDBDQUhTem1CLFFBQU15bUI7O1NBSnJCLHNCQUllem1CLFFBQU15bUIsSUFuQjNCLG9CQW1CMkJBO1NBbkIzQixVQUNKMXBEO1dBQ1ksSUFBUjhwQixNQUFRLFdBSE1rWixRQW9CYTBtQixHQWxCL0IxcEQ7V0FDWSxTQUFSOHBCO1dBQVEsSUFFUi9mLElBQUksVUFldUIyL0M7V0FkNUIsR0FjNEJBLGFBakIzQjUvQjtXQUlKLFNBRkkvZjs7cUJBSW9CLDBCQU5wQitmLE1BaUIyQjQvQixHQWYzQjMvQyxLQWUyQjIvQztrQ0FmM0IzL0M7Ozs7OztzQkFLcUIsMkJBUHJCK2YsTUFpQjJCNC9CLEdBZjNCMy9DLEtBZTJCMi9DOztXL0JoTjNCO29CK0JvTWdDLGdDQUxoQzUvQixNQWlCMkI0L0IsR0FmM0IzL0MsS0FlMkIyL0M7b0JBVHhCLHdCQVJINS9CLE1BaUIyQjQvQjtTQVIxQixpQ0FaYTFtQixRQW9CYTBtQjtlQUtmLHNCQUxTem1CLFFBQU15bUI7ZUFNZixpQ0FOU3ptQixRQUFNeW1CO2dCQU9mLDRCQVBTem1CLFFBQU15bUIsSUFPYztJQWpEdEIsU0F1RHZCa0UscUJBQXFCOWpDLE1BQU00L0I7TUFDN0IsU0FEdUI1L0I7TUFFZixJQUdOOXBCLEVBSE0sVUFGcUIwcEQ7TUFHMUIsR0FIMEJBLGFBQU41L0I7TUFFZixhQUdOOXBCO01BREY7ZUFKdUI4cEI7ZUFNRyxtQ0FOSEEsTUFBTTQvQixHQUszQjFwRCxHQUwyQjBwRCxHQU9qQjtJQTlEYSxTQWtFdkJtRSxtQkFBbUIvakMsTUFBTTQvQjtNQUMzQixTQURxQjUvQjtNQUViLElBQUo5cEIsRUFBSSxVQUZtQjBwRDtNQUd4QixHQUh3QkEsYUFBTjUvQjtNQUlyQixVQUZJOXBCLHNCQUZpQjhwQjtNQU1nQixxREFOaEJBLE1BQU00L0IsR0FFdkIxcEQsR0FGdUIwcEQsR0FPZjtJQXpFYSxTQW9IdkJvRSxXQUFXN3FCLFFBQU04cUIsVUFBVXJFO01BbkNqQjt1QkFtQ0N6bUIsUUFBZ0J5bUI7T0FuQ2pCLGdDQUFSNS9CLE1BbUN5QjQvQjtlQUN6QjFtQiwwQkFEZStxQjtNQW5DUCxJQXNDUi90RCxFQUFJLFVBSHFCMHBEO01BSTFCLEdBSjBCQSxnQkFDekIxbUIsUUFEZStxQjtNQUtuQixVQUZJL3REO1FBSVU7NEJBTlZnakMsUUFEeUIwbUIsR0FHekIxcEQ7U0FLYyxnQkFEWjZzRCxRQVBha0I7U0FTZ0I7VUFGN0JsQjs7V0FDQW1CLGNBQzZCLHFCQUQ3QkEsWUFSdUJ0RTs7O1FBVTNCLDZCQURJd0QsUUFUdUJ4RCxJQVF2QnNFO01BSUosNkJBWEVockIsUUFEeUIwbUIsSUFBVnFFLFVBWXFCO0lBaElmLFNBbUl2QkUsOEJBQThCbmtDLE1BQU00L0IsR0FBR2hmLE1BQU0vdUM7TUFDL0MsU0FBSTZKLFVBQVV4RjtRQUNaLGFBRFlBO1FBQ1osMkJBRFlBLEVBR1YsYUFIVUEscUJBSUo7TUFKVjtpQ0FEK0NyRTtPQUMvQyxXQURnQ211QjtPQUNoQyxLQUtJbnBCO09BTEo7O1lBT0E1SDtRQUNFO1VBQVEsZ0JBVDRCMndELElBVWxCLGVBQVUsZ0JBVmlCL3RELElBUS9DNUM7VUFFSyxhQURDaUgsWUFDcUMsV0FWRjBxQztVQVVVLFNBSC9DMUgsV0FJaUIsV0FYb0IwSDtVQVk5Qix3QkFMUDFILFdBUGtDMG1CLEdBU2hDMXBEO1VBQUksU0FEVmpIOzs7TUFNQSxPQVBJaXFDLFVBT0U7SUFqSm1CLFNBb0p2QmtyQixlQUFlcGtDLE1BQU1pa0MsVUFBVXJFO01BQ2pDLGVBRGlCNS9CLFVBQ2pCLGFBQWdCLGFBRGlCNC9CO01BQ08sUUFBTTtNQUE5QztPQUNZLGtCQUZLNS9CLE1BQWdCNC9CO09BRXJCLFdBQVIxbUI7T0FBUSxhQUNJLGFBSGlCMG1CO01BR08sUUFBTTtNQUY5QyxJQUlFMXBELEVBREksVUFKMkIwcEQ7TUFJM0IsU0FDSjFwRDs7OztZQTZCWTtnQ0FoQ1ZnakMsUUFGNkIwbUIsR0FLL0IxcEQ7YUE2QlksV0FBUmlqQzthQUFRLGFBQ0ksYUFuQ2V5bUI7WUFtQ1MsUUFBTTtZQUFnQjtxQkFEMUR6bUIsUUFsQzJCeW1CLEdBN1cvQndDOzs7OztrQkFrWEFsc0Q7VUFDWTs4QkFKVmdqQyxRQUY2QjBtQixHQUsvQjFwRDtXQUNZLFdBQVJrdEQ7V0FBUSxhQUNJLGFBUGV4RDtVQU9TLFFBQU07VUFEbEM7V0FFUnlFO1lBQVEsOEJBRlJqQixRQU4yQnhELEdBN1cvQndDO1VBcVhZLFNBQVJpQztnQkFDWSxhQVRlekU7YUFVWDs4QkFWV0E7Y0FVWDs7O2NBQWQwRSxpQkFGRkQsUUFJTyxxQkFKUEEsUUFSMkJ6RTthQWE3QixTQUhJMEU7bUJBR1ksYUFiYTFFO2dCQWNULElBQ2QzL0MsSUFEYyxVQWRTMi9DO2dCQWNULFVBQ2QzL0M7a0JBQ1ksSUFBUnNrRCxRQUFRLFdBTmRELFFBVnlCMUUsR0FldkIzL0M7a0JBQ1ksU0FBUnNrRDs7O3NCQUNZLGFBakJPM0U7OztxQkFrQmYsc0JBbEJlQTtxQkFrQmY7Ozs7Ozt1QkFHWTt3Q0FMaEIyRSxRQWhCU047d0JBZ0JUTzs7OzBCQUtJTixjQUNpQixxQkFEakJBLFlBckJldEU7Ozs7dUNBZ0JuQjRFO3FCQUVJLElBRkpDOztrQkFBUSxJQUZaQyxRQUVJRDs7cUJBRkpDLFFBSkZKO2dCQWVGLFNBWElJO3NCQVdZLGFBekJXOUU7bUJBMEJuQixJQUNKMS9DLElBREksVUExQm1CMC9DO21CQTBCbkIsVUFDSjEvQywwQkFiQXdrRDttQkFZSTtvQkFFUSxtQkFkWkEsUUFkdUI5RSxHQTJCdkIxL0M7b0JBQ1ksV0FBUnlrRDtvQkFBUSxhQUNJLGFBN0JPL0U7bUJBNkJpQixRQUFNO21CQUFnQiwwQ0FEMUQrRSxRQTVCbUIvRTtnQkF5Qm1CLE9BWDFDOEU7YUFEd0MsT0FIMUNKO1VBRHdDLE9BRDFDRDs0QkFISm51RDtNL0IvVEk7UStCZ1dROzRCQXBDVmdqQyxRQUY2QjBtQixHQUsvQjFwRDtTQWlDWSxXQUFSNnNEO1NBQVEsYUFDSSxhQXZDZW5EO1FBdUNTLFFBQU07UUFBZ0I7aUJBRDFEbUQsUUF0QzJCbkQsR0E3Vy9Cd0M7TUFzWkssdUJBQWdCO0lBN0xFLFNBZ012QndDLHFCQUFxQjVrQyxNQUFNaWtDLFVBQVVyRTtNQUN2QyxlQUR1QjUvQixVQUN2QixhQUFnQixhQUR1QjQvQjtNQUNDLFFBQU07TUFBOUM7T0FDWSxnQ0FGVzUvQixNQUFnQjQvQjtPQUUzQixXQUFSMW1CO09BQVEsYUFDSSxhQUh1QjBtQjtNQUdDLFFBQU07TUFGOUMsSUFHUSxZQUorQkEsSUFJL0IsU0FBSjFwRDtNQUFJOztVQUdNOzhCQUxWZ2pDLFFBRm1DMG1CLEdBSW5DMXBEO1dBTWMsZ0JBSFppakMsUUFQdUI4cUI7V0FhTCxxQ0FIbEJDLFlBVmlDdEU7V0FhZixXQUhsQnNFLGNBR0FXO1dBQWtCLFFBTmxCMXJCLFVBU0EyckI7VUFIa0IsMEJBS2xCL0IsUUFsQmlDbkQ7Ozt3Q0FxQnJDLG1CQW5CRTFtQixRQUZtQzBtQjtNQXNCaEMsbUJBQVk7SUF0Tk0sU0F5TnZCbUYsZ0JBQWdCL2tDLE1BQU1pa0MsVUFBVXJFO01BQ2xDLGVBRGtCNS9CLFVBQ2xCLGFBQWdCLGFBRGtCNC9CO01BQ00sUUFBTTtNQUE5QztPQUNZLGtCQUZNNS9CLE1BQWdCNC9CO09BRXRCLFdBQVIxbUI7T0FBUSxhQUNJLGFBSGtCMG1CO01BR00sUUFBTTtNQUY5QyxJQUlFMXBELEVBREksVUFKNEIwcEQ7TUFJNUIsU0FDSjFwRDs7VUFpQ1k7OEJBcENWZ2pDLFFBRjhCMG1CLEdBS2hDMXBEO1dBaUNZLFdBQVJpakM7V0FBUSxhQUNJLGFBdkNnQnltQjtVQXVDUSxRQUFNO1VBQVksNEJBRHREem1CLFFBdENrQjhxQixVQUFVckU7O2dCQUtoQzFwRDtTQUNZOzZCQUpWZ2pDLFFBRjhCMG1CLEdBS2hDMXBEO1VBQ1ksV0FBUjZzRDtVQUFRLGFBQ0ksYUFQZ0JuRDtTQU9RLFFBQU07U0FEbEMsSUFHVjMvQyxJQURJLFVBUjBCMi9DO1NBUTFCLFVBQ0ozL0M7Z0NBMEJBLHFCQTdCRThpRCxRQU5rQmtCLFVBQVVyRTtTQU1wQjtVQUlFLG1CQUpWbUQsUUFONEJuRCxHQVM5QjMvQztVQUNZLFdBQVJtakQ7VUFBUSxhQUNJLGFBWGN4RDtTQVdVLFFBQU07U0FMcEM7VUFNRSw2QkFGUndELFFBVjBCeEQ7VUFZbEIsV0FBUnlFO1VBQVEsYUFDSSxhQWJjekU7U0FhVSxRQUFNO1NBUHBDLElBUVEsY0FkWUEsSUFjWixTQUNkMS9DO1NBRGM7O1lBRUYsSUFBUm9rRCxRQUFRLFdBSlpELFFBWjBCekUsR0FlMUIxL0M7WUFDWSxTQUFSb2tEOzs7Z0JBQ1ksYUFqQlUxRTs7O2VBa0JsQixvQkFsQmtCQTtlQWtCbEI7Ozs7OztpQkFHWTtrQ0FMaEIwRSxRQWhCWUw7a0JBZ0JaTzs7O29CQUtJTixjQUNpQixxQkFEakJBLFlBckJrQnRFOzs7O2lDQWdCdEI0RTtlQUVJLElBRkpEOztZQUFRLElBQVJFOzs7Ozs7d0JBSkpKOzs7U0FOTSxJQVFOSyxpQkFXSyxhQVRERDtTQVNhLFNBWGpCQztlQVlZLGFBMUJjOUU7WUEyQnRCLElBQ0p6L0MsSUFESSxVQTNCc0J5L0M7WUEyQnRCLFVBQ0p6L0MsMEJBZEF1a0Q7WUFhSTthQUVRLG1CQWZaQSxRQWQwQjlFLEdBNEIxQnovQzthQUNZLFdBQVJ3a0Q7YUFBUSxhQUNJLGFBOUJVL0U7WUE4QmMsUUFBTTtZQUFnQiwwQ0FEMUQrRSxRQTdCc0IvRTtTQTBCZ0IsT0FaMUM4RTtNQStCRCxtQkFBWTtJQXRRTSxTQStRdkJNLFlBQVlDLElBQ0RqbEMsTUFEVzQvQjtNdkM5N0IzQixJdUMrN0JnQjFtQjtNQUNYO2lCQURXQTtRQUVILElBQUpoakMsRUFBSSxVQUhjMHBEO1FBSW5CLEdBSm1CQSxhQUNYMW1CO1FBSVQsR0FMVStyQjtVQU1LLElBQVJobEQsSUFOR2dsRDtVQU1LLEdBSGIvdUQsTUFHSytKLFdBQWtCLFVBTGhCaTVCLFFBRFcwbUI7VUFNTCxJQUNFLG1CQU5SMW1CLFFBRFcwbUIsR0FHbEIxcEQsR0FGT2dqQzs7UUFFSDtTQU1KLEtBTkFoakM7U0FNQTtRL0I5YkEsbUIrQnNiT2dqQztRQUVILElBUVEsbUJBVkxBLFFBRFcwbUIsR0FHbEIxcEQsR0FGT2dqQztpQkFXSDtJQTNSZSxTQStSdkJnc0IsVUFBVWxsQyxNQUFNNC9CO01BSVcsa0JBSmpCNS9CLE1BQU00L0IsR0FJVyxrQkFKWEEsSUFJMEM7SUFuU25DLFNBZ1V2QnVGLDBCQUNFeDhDO01BQUosYUFBSUEsMENBVWlCO0lBM1VJLFNBMFZ2Qnk4QyxnQkFBZ0JsRCxRQUFRbGlDLE1BQU00L0I7TUFDaEMsU0FEMEI1L0IsYUFDUixpQkFEQWtpQztNQUVWLElBQUpoc0QsRUFBSSxVQUZ3QjBwRDtNQUc3QixPQUg2QkEsTUE3akI5QixtQ0E2akJnQnNDLFVBRWRoc0QsQ0FFSDtJQUc0QixTQUEzQm12RDtNdkNoaENMLE91Q3lnQ0tEO0lBUTZCLFNBQTdCRTtNdkNqaENMLE91Q3lnQ0tGO0lBUTZCLFNBRTdCRyxvQkFBb0J2bEMsTUFBTTQvQjtNQUN0QixJQW5Ea0I0RixHQW1EbEIseUJBRGdCeGxDLE1BQU00L0I7TUFDdEIsU0FuRGtCNEY7Ozs7Ozs7O2FBaUV0Qjs7O2lCQUNVOzhCQWhCZ0I1RjtrQkFnQmhCLEtBQUoxcEQ7a0JBQUk7Ozs7aUIvQjFoQk4sZ0IrQjBoQkVBLEVBR0csaUJBSEhBLEVBR3FCO2NBQ2xCO2NBQ0E7Y0F4Q0osK0JBSHdCOEY7Y0FFeEIsb0NBRnFCRDthQUVyQixRQURIa0U7Ozs7d0JBTUosWUFOSUE7Ozs7dUJBS0EsbUNBTndCbEUsR0FBR0M7b0JBbHdCM0Iwa0QsV0F3eEJrQjFnQyxjQUFNNC9COzs7Ozs7OztrQkFsREo0RjtXQXVEdEI7OztlQUNVLGdCQU5nQjVGLElBTWhCLFNBRU4xcEQ7ZUFGTSwwQkFHRCxpQkFETEEsSUFDdUI7WUFFbEI7WUFDQTtZQTVESDtzQkFGZ0JzdkQsMkJBQUdHOztjQUFHQzs7O1dBRXRCLFFBREoxdkQ7b0RBUUosWUFSSUE7Ozs7cUJBTUEsbUNBUG9Cc3ZELEdBQUdHLEtBQUdDO2tCQXR1QjFCbEYsV0F3eEJrQjFnQyxjQUFNNC9COzs7MkJBbERKNEY7TS9CeGRsQjtRK0I0Y2lCLFVBWUNBOzs7Ozs7Ozs7Ozs7O2VBdHVCcEI5RSxXQXd4QmtCMWdDLE1BQU00L0I7TUF3QjFCLHdCQTFFc0I0RixHQTBFSjtJQTFCVyxTQThCN0JLLGVBRWlCN2xDLE1BRkk0L0I7TUFFdkIsU0FZSWtHLFVBQVU5bEM7UUFDTixJQUVKOXBCLEVBRkkseUJBRE04cEIsTUFkUzQvQjtRQWVmLGNBRUoxcEQsRUFEUSxZQUZFOHBCLE1BZFM0L0IsSUFpQmQsc0JBQUwxcEQsRUFBOEI7TUFkMUIsSUFFSkEsRUFGSSxrQkFIZTBwRDtNQUdmLFVBRUoxcEQ7UUFEa0I7NkJBRkg4cEIsTUFGSTQvQjtTQVFmLDZCQURNMW1CLFFBUFMwbUI7UUFRZixjQUdKMy9DO2lCQURVLDhCQUFxQixZQUhyQmk1QixRQVBTMG1CO2lCQVlULHFCQUxBMW1CLFFBUFMwbUIsR0FXbkIzL0M7TUFOSyw2QkFBTC9KLEVBY1k7SUFqRGUsU0FxRDdCNnZELGlCQUVpQi9sQyxNQUZNNC9CO01BRXpCLFNBS0lvRyxvQkFBVWhtQztRdkM3a0NqQixJdUM2a0NpQmtaO1FBQ1o7VUFBTSxJQUdKaGpDLEVBSEksMkJBRE1nakMsUUFQVzBtQjtVQVFqQixVQUdKMXBELFNBRlEsWUFGRWdqQyxRQVBXMG1CO29CQVdyQjFwRDtZQUR1QjtpQ0FIYmdqQyxRQVBXMG1CO2FBY2pCLGlDQURXem1CLFFBYk15bUI7WUFjakI7Y0FFZ0IscUJBSEx6bUIsUUFiTXltQjtjQWdCRDs7dUJBUXBCcUc7OztjQVRxQjttQ0FGTjlzQixRQWJNeW1CO2VBb0JqQixtQ0FEU3dELFFBbkJReEQ7Y0FvQmpCO2dCQUNnQixxQkFGUHdELFFBbkJReEQ7Z0JBcUJEOzt5QkFHcEJxRzs7Y0FUcUIsSUFPTixtQkFIRjdDLFFBbkJReEQsT0FPWDFtQjs7WUFHYSxJQU9SLDRCQUpBQyxRQWJNeW1CLElBT1gxbUI7O1VBQ04sSUFHVyxtQkFKTEEsUUFQVzBtQixHQVdyQjFwRCxHQUpVZ2pDO21CQUlxQztNQVRuRCxTQXNCSStzQixvQkFBWWptQztRdkM5bENuQixJdUM4bENtQmtaO1FBQ2Q7VUFBTSxxQ0FEUUEsUUF4QlMwbUI7VUF5QmpCO1lBQ2Usd0JBRlAxbUIsUUF4QlMwbUIsSUF3QlQxbUI7VUFHUDs7bUJBcEJMOHNCLHNCQWlCWTlzQjt3Q0FqQlo4c0IsZUFpQlk5c0IsVUFHUTtNQXpCeEIsU0FLSTRzQixVQUFVOWxDLE92QzdrQ2pCLHVCdUM2a0NPZ21DLGNBQVVobUM7TUFKTixJQUVKOXBCLEVBRkksa0JBSGlCMHBEO01BR2pCLGNBRUoxcEQ7ZUFEa0Isc0JBRkg4cEIsTUFGTTQvQjtlQUtoQixzQkFBTDFwRCxFQXdCWTtJQWxGZSxTQW9HN0Jnd0QsdUJBQXVCdnpELFNBQVN3ekQsV0FBV25tQyxNQUFNNC9CO01BQ25ELFNBQVF3RyxXQUFXbjNELEVBQUVnMkQ7UXZDdG5DeEIsSXVDc25Dc0I1dkQ7UUFDakI7VUFBUSxnQkFGeUN1cUQsSUFFekMsU0FEU3ZxRDtVQUNUO1lBQ1EsYUFIaUN1cUQ7WUFHakM7YUFDYix3QkFKb0JqdEQsU0FFbkJ1RCxHQUVELFVBRkNBLE1BRGUrdUQ7Ozs7O1VBS2pCO1lBQVEsVzlCcGhDVjd3RCxROEI4Z0NpRHdyRCxHQUU3QzFwRCxHQUlNLFFBTE9iO3NCQU1PO01BTjFCLEdBRGtDOHdEO1FBV2hDLElBREtqd0QsRUFWMkJpd0Q7UUFXaEMsV0FYMkNubUMsTUFVdEM5cEI7UUFDTCxhQVhpRDBwRDtRQVkxQztVQUNJLElBQUwwQyxHQUFLLFVBYnNDMUM7VUFhdEMsT0FITjFwRCxNQUdDb3NELEdBRUMsd0JBZjBDMUMsSUFnQjFDLG1CQU5GMXBELEVBR0Nvc0Q7UUFKRTt3QkFUbUN0aUMsU0FnQmI7SUFwSEQsU0F3SDdCcW1DLGdCQUFnQnpHLEdBSWhCbnNEO012QzdvQ0wsR3VDNm9DS0E7V0FIYUgsRUFHYkc7O3dDQUhhSCxFQUdiRztNQUZRLElBQUp4RSxFQUFJLFdBRlEyd0Q7TUFHTiwwQ0FETjN3RCxFQURTcUU7SUF6SGdCLFNBZ0k3Qmd6RCxZQUFZMUcsR0FBRzlzRDtNQUNqQixPQURpQkE7ZUFFQyxPQUZKOHNELGFBR0ksa0JBSEpBLFlBSUssT0FKTEEsTUFJNEI7SUFwSVgsU0F3STdCMkcsaUJBQWlCeG1DO01BQVUsR0FBVkEsU0FFSCxJQUFUQyxNQUZZRCxXQUVILE9BQVRDLE1BREcsTzlCbmpDUjVyQixPOEJvakNtQjtJQTFJVSxTQTZJN0JveUQsMEJBQTBCQztNQUM1QixTQUQ0QkE7TUFFaEI7b0NBRmdCQTtPQUVoQixvQkFBTjUwRDtPQUVVLGNBRlZBLE1BQU0sc0JBQU5BO01BRVUsVUFEVm96RCxJQUNBN25CLFFBQ1E7SUFsSmlCLFNBNEp6QnNwQiw4QkFHSnJuRCxFQUFFNmdCO012Q2hyQ1AsSXVDZ3JDT3FEO01BQU87aUJBQVBBO1FBcUNrQyxrQkFyQ3BDbGtCOztRQUFTLE9BQVBra0I7aUJBS2tDLFVBTGxDQTtpQkFNa0MsVUFObENBO2lCQU9rQyxVQVBsQ0E7aUJBUWtDLFVBUmxDQTtpQkFTa0MsVUFUbENBO2lCQVVrQyxVQVZsQ0E7aUJBV2tDLFVBWGxDQTtpQkFZa0MsVUFabENBO2lCQWFrQyxVQWJsQ0E7aUJBY2tDLFdBZGxDQTtrQkFpQmtDLFdBakJsQ0E7a0JBa0JrQyxXQWxCbENBO2tCQW1Ca0MsV0FuQmxDQTtrQkFnQ2tDLFdBaENsQ0E7O1dBa0MyQixJQURMcDBCLEtBakN0Qm8wQixTQWlDZXh4QixNQWpDZnd4QixTQWtDMkIsZUFBVyxLQUR2Qnh4QjtXQUNZOztvQkFNN0I0MEQsc0NBeENBdG5ELE9BaUN3QmxROztvQkFPeEJ3M0QsK0JBeENBdG5ELE9BaUN3QmxRO2tCQWxCWSxXQWZsQ28wQjtrQkFnQmtDLFdBaEJsQ0E7a0JBMEJrQyxXQTFCbENBOzs7O2FBNEJzQjtjQURvQm4wQixPQTNCMUNtMEI7O2NBMkJnQzRMO2NBQ1Ysa0JBRFVBLE9BQVUvL0I7Y0EzQjFDbTBCOztXQThCc0I7WUFEb0JsMEIsT0E3QjFDazBCOztZQTZCZ0NvTTtZQUNWLGtCQURVQSxPQUFVdGdDO1lBN0IxQ2swQjs7O1dBRUYsSUFET21ILFNBRExuSDtXQUVGLGdCQUFJcWpDO2FBQ0YsU0FBSUMsTUFBTUM7ZUFBZSxrQkFIM0J6bkQsS0FFSXVuRCxPQUNRRSxjQUE4QzthQUF4RCwyQkFBSUQsTUFGQ244QixTQUc2QjtrQkFrQkEsV0F0QmxDbkg7a0JBdUJrQyxXQXZCbENBO2tCQXdCa0MsV0F4QmxDQTs7ZUFtQ2tCajBCLE9BbkNsQmkwQixTQW1DYXR3QixJQW5DYnN3QjtXQXlFVyxVQXRDRXR3QjtZQXNDRixPQXRDRUE7eUJBbkNic3dCLE1BbUNrQmowQjt5QkFuQ2xCaTBCLE1BbUNrQmowQjs7ZUF3Q3BCLGdCQUFJczNEO2lCQUNGLFNBQUlDLE1BQU1DO21CQUFlLGtCQTVFM0J6bkQsS0EyRUl1bkQsT0FDUUUsY0FBOEM7aUJBQXhELDJCQUFJRCxNQXpDY3YzRCxPQTBDVzswQkE3RTdCaTBCLE1BbUNrQmowQjs7WUFzQ1AsT0F0Q0UyRDt5QkFuQ2Jzd0IsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCOztlQXNEZSxJQUFWMkMsUUF0RFZnQjtlQXNEb0I7O3dCQWpEbkMwekQ7b0NBeENBdG5ELEVBeUZ5QnBOLFFBdERMM0M7O3dCQUtwQnEzRCwrQkF4Q0F0bkQsRUF5RnlCcE4sUUF0REwzQzswQkFuQ2xCaTBCLE1BbUNrQmowQjswQkFuQ2xCaTBCLE1BbUNrQmowQjtrQkFmZ0IsV0FwQmxDaTBCLCtCQXFDdUM7SUFwTVosU0F1TTdCb2pDLG9DQUdBdG5ELEVBQUV0TixNQUFNbXVCO012QzN0Q2IsSXVDMnRDT2p1QjtNQUFhO2lCQUFiQTtTQXFCNkI7O2tCQW5FM0J5MEQsZ0NBOENKcm5ELEVBQVE2Z0I7dUNBOUNKd21DLHlCQThDSnJuRCxFQUFRNmdCOztRQUFPLE9BQWJqdUI7aUJBUzZCLFlBVDdCQTtpQkFVNkIsWUFWN0JBO2lCQVc2QixZQVg3QkE7aUJBWTZCLFlBWjdCQTtpQkFhNkIsWUFiN0JBO2lCQWM2QixZQWQ3QkE7aUJBZTZCLFlBZjdCQTtpQkFnQjZCLFlBaEI3QkE7aUJBb0I2QixZQXBCN0JBOztXQXVCTztZQURrQjlDLEtBdEJ6QjhDO1lBc0JvQjFCLElBdEJwQjBCO1lBc0JlbkMsSUF0QmZtQztZQXVCTyxTQUFNLEtBREVuQyxLQUFLUztZQUVNLHNCQUR4QlgsR0FEdUJUO1lBdEJ6QjhDOztrQkFpQjZCLGFBakI3QkE7a0JBa0I2QixhQWxCN0JBO2tCQW1CNkIsYUFuQjdCQTs7V0FFRixJQURVeTRCLFNBRFJ6NEI7V0FFRixnQkFBSTIwRDthQUNGLFNBQUlDLE1BQU1DO2VBQWUsa0JBSDNCem5ELEtBRUl1bkQsT0FDUUUsY0FBOEM7YUFBeEQsaUNBQUlELE1BRkluOEIsU0FERnhLLElBSXNDOztXQUU5QyxJQURrQjBLLFdBTGhCMzRCO1dBTUYsZ0JBQUkyMEQ7YUFDRixTQUFJQyxNQUFNQztlQUFlLGtCQVAzQnpuRCxLQU1JdW5ELE9BQ1FFLGNBQThDO2FBQXhELGlDQUFJRCxNQUZZajhCLFdBTFYxSyxJQVFzQyxFQWdCUTtJQWxPekIsU0E0SnpCNm1DLG9CQUdKMW5ELEVBQUU2Z0I7TXZDaHJDUCx1QnVDNnFDU3dtQyx3QkFHSnJuRCxFQUFFNmdCO0lBL0oyQixTQXVNN0JpbkMsMEJBR0E5bkQsRUFBRXROLE1BQU1tdUI7TXZDM3RDYix1QnVDd3RDS3ltQyw4QkFHQXRuRCxFQUFFdE4sTUFBTW11QjtJQTFNcUIsU0F1YTdCa25DLGVBTUF4SCxHQUFHMS9CLElBQUltbkMsUUFBUTEyRCxJQUFJRSxLQUFLeTJELEtBQUtuVjtNQUFTLFVBQXZCeGhEO2tCQUFJRTs7WUFFWCxXQUZnQnkyRCxLOUJ2MUN4Qmx6RCxnQjhCdTFDQXdyRDtZQUdRLElBQUpuc0QsRUFBSSxXQUhxQjArQyxNQUE3QnlOO1lBSVMsVUFETG5zRCxFQUNLLFdBSlRtc0QsR0FBRzEvQixJQUFJbW5DO1VBd0JQO1FBbEJBLElBRDBCM29ELEVBTFA3TjtRQU1YLFdBTmdCeTJELEs5QnYxQ3hCbHpELFE4QjQxQzBCc0ssRUFMMUJraEQ7UUFNQSxJQUNJM2QsSUFBSSxXQVBxQmtRLE1BQTdCeU47UUFRUyxVQURMM2QsSUFDSyxXQVJUMmQsR0FBRzEvQixJQUFJbW5DOztRQUErQixTQUF2QjEyRDtpQ0FrQmY7bUJBbEJlQTtvQkFBSUU7O2NBVVgsV0FWZ0J5MkQsVTlCdjFDeEJsekQsUThCdTFDQXdyRDtjQVdRLElBQUp4ZCxJQUFJLFdBWHFCK1AsTUFBN0J5TjtjQVlTLFVBREx4ZCxJQUNLLFdBWlR3ZCxHQUFHMS9CLElBQUltbkM7WUFvQlA7Y0FQZ0Q5ekIsSUFiN0IxaUM7VUFjWCxXQWRnQnkyRCxVQWF3Qi96QixJQWJoRHFzQjtVQWVRLElBQUpyZCxJQUFJLFdBZnFCNFAsTUFBN0J5TjtVQWdCUyxVQURMcmQsSUFDSyxXQWhCVHFkLEdBQUcxL0IsSUFBSW1uQztRQXNCUCwrQ0FFMEM7SUFyY2IsU0FxUXpCRSxXQUdKM0gsR0FBRzEvQixJQUFJbW5DO012Q3p4Q1osSXVDeXhDUTlqQztNQUFlO2lCQUFmQTtRQTBKSDs7UUExSmtCLE9BQWZBOztXQUVILElBREtwMEIsS0FERm8wQjtXQUVLLFlBRlJxOEI7V0FFQSxJQUNJMXBELEVBQUksV0FIUjBwRDtXQUlTLFVBREwxcEQsRUFDSyxXQUpUMHBELEdBQ0t6d0QsS0FERWs0RDs7V0FNUCxJQURVajRELE9BTFBtMEI7V0FNSyxpQkFOUnE4QjtXQU1BLElBQ0kzL0MsSUFBSSxXQVBSMi9DO1dBUVMsVUFETDMvQyxJQUNLLFdBUlQyL0MsR0FLVXh3RCxPQUxIaTREOztvQkFBSjlqQzs7OztlQVdZO2dCQUQwQmwwQjtnQkFBWmlEO2dCQUNkLGdDQURjQTtnQkFDZDs7OzBCQUNOMHRCLFlBQVE0L0I7bUJBQUssc0JBRGxCcUYsS0FDS2psQyxNQUFRNC9CLEdBQW9DO2dCQUR0QyxhQUFOL3RELElBRGdDeEM7ZUFDMUI7d0JBWGZ1d0QsR0FhSTZILFNBYkdKLGVBWUhHLE9BcHhCSmxIOzs7OztrQkF1eEIwRGh4RDs7a0JBQVgyekI7a0JBQzNDeWtDOzRCQUFLMW5DLFlBQVE0L0IsSUFBSyx3QkFBYjUvQixNQUFRNC9CLEdBQW9DO2lCQUNuQzswQkFqQmxCQTswQkFpQmtCLFdBRjZCMzhCLE1BQVczekI7MEJBZm5EKzNEOzs7MEJBZ0JISzswQkF4eEJKcEg7O2dCQTJ4QjBEL3dEOztnQkFBWHc3QjtnQkFDM0M0OEI7MEJBQUszbkMsWUFBUTQvQixJQUFLLHdCQUFiNS9CLE1BQVE0L0IsR0FBb0M7ZUFDbkM7d0JBckJsQkE7d0JBcUJrQixXQUY2QjcwQixNQUFXeDdCO3dCQW5CbkQ4M0Q7Ozt3QkFvQkhNO3dCQTV4QkpySDs7V0FneUJBLElBQUlnSCxjQUFLdG5DLFlBQVE0L0IsSUFBSyxxQkFBYjUvQixNQUFRNC9CLEdBQThCO1dBQS9DLHNCQXhCQUEsUUFBT3lILGVBd0JIQyxLQWh5QkpoSDs7O1lBbXlCa0I5d0QsT0EzQmYrekI7WUEyQlU1eUIsSUEzQlY0eUI7WUE0QkNxa0MsZ0JBQUs1bkMsWUFBUTQvQixJQUFLLHdCQUFiNS9CLE1BQVE0L0IsR0FBOEI7a0JBbUkvQ3dILGVBL0pBeEgsR0EyQmtCcHdELE9BM0JYNjNELFFBMkJNMTJELE1BQ1RpM0QsT0FweUJKdEg7O1dBdXlCUTtZQURlN3dELE9BOUJwQjh6QjtZQThCYzF5QixLQTlCZDB5QjtZQThCUzN5QixNQTlCVDJ5QjtZQThCRXh5QixNQTlCRnd5QjtZQStCSyxnQ0FBMkIsY0FEOUJ4eUI7WUFDRztzQkFDQ2l2QixZQUFRNC9CO2VBQUssMkJBenZCWmphLEtBeXZCRDNsQixNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBakM3Q0E7b0JBOEJ1Qm53RDtvQkE5QmhCNDNEO29CQThCS3oyRDtvQkFBS0M7b0JBRWJnM0Q7NkJBenZCV2pJO3NCQUFtQiw0Q0FBeEJqYSxLQUFLaWE7O1dBNHZCUDtZQURpQmx3RCxPQWxDdEI2ekI7WUFrQ2dCdnlCLE9BbENoQnV5QjtZQWtDV3p5QixNQWxDWHl5QjtZQWtDSXJ5QixRQWxDSnF5QjtZQW1DSyxrQ0FBMkIsY0FENUJyeUI7WUFDQztzQkFDQzh1QixZQUFRNC9CO2VBQUssMkJBeHVCVmtJLE9Bd3VCSDluQyxNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBckM3Q0E7b0JBa0N5Qmx3RDtvQkFsQ2xCMjNEO29CQWtDT3YyRDtvQkFBS0U7b0JBRWYrMkQ7NkJBeHVCYW5JO3NCQUFxQiw0Q0FBMUJrSSxPQUFLbEk7O1dBMnVCVDtZQURxQmp3RCxPQXRDMUI0ekI7WUFzQ29CcHlCLE9BdENwQm95QjtZQXNDZXR5QixNQXRDZnN5QjtZQXNDUWx5QixRQXRDUmt5QjtZQXVDSyxrQ0FBMkIsY0FEeEJseUI7WUFDSDtzQkFDQzJ1QixZQUFRNC9CO2VBQUssMkJBN3VCTm9JLE9BNnVCUGhvQyxNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBekM3Q0E7b0JBc0M2Qmp3RDtvQkF0Q3RCMDNEO29CQXNDV3AyRDtvQkFBS0U7b0JBRW5CODJEOzZCQTd1QmlCckk7c0JBQXlCLDRDQUE5Qm9JLE9BQUtwSTs7V0FndkJiO1lBRGlCL3ZELE9BMUN0QjB6QjtZQTBDZ0JqeUIsT0ExQ2hCaXlCO1lBMENXbnlCLE1BMUNYbXlCO1lBMENJL3hCLFFBMUNKK3hCO1lBMkNLLGtDQUEyQixjQUQ1Qi94QjtZQUNDO3NCQUNDd3VCLFlBQVE0L0I7ZUFBSywyQkEvdUJWc0ksT0ErdUJIbG9DLE1BQVE0L0IsR0FBbUM7V0FDUDtvQkE3QzdDQTtvQkEwQ3lCL3ZEO29CQTFDbEJ3M0Q7b0JBMENPajJEO29CQUFLRTtvQkFFZjYyRDs2QkEvdUJhdkk7c0JBQXFCLDhDQUExQnNJLE9BQUt0STs7b0JBbXNCZHI4Qjs7aUJBOEN3Qnh6QixPQTlDeEJ3ekIsU0E4Q2tCOXhCLE9BOUNsQjh4QixTQThDYWh5QixNQTlDYmd5QjtvQkErSkg2akM7c0JBL0pBeEgsR0E4QzJCN3ZELE9BOUNwQnMzRCxRQThDUzkxRCxNQUFLRSxPQS9ickJzekQsZ0JBdFVBbEM7O2lCQTR3QmtCN3lELFFBckRmdXpCLFNBcURTa1ksT0FyRFRsWSxTQXFESTd4QixNQXJESjZ4QjtvQkErSkg2akM7c0JBL0pBeEgsR0FxRGtCNXZELFFBckRYcTNELFFBcURBMzFELE1BQUsrcEMsT0EzZ0JaMm9CLGVBalFBdkI7ZUF5d0J3RDV5RCxRQWxEckRzekIsU0FrRCtDNmtDLE9BbEQvQzdrQyxTQWtEMEMzeEIsTUFsRDFDMnhCO2tCQStKSDZqQztvQkEvSkF4SCxHQWtEd0QzdkQsUUFsRGpEbzNELFFBa0RzQ3oxRCxNQUFLdzJELE9BeGlCbERwRSxXQWpPQW5COzs7WUE4d0JXM3lELFFBdkRScXpCO1lBdURHdnhCLE1BdkRIdXhCO1lBd0RDOGtDO2lDQUFTekk7ZUF6T1A7b0NBeU9PQTtnQkF6T1A7eUJBS0oxcEQ7OytCQUNBLFVBQ0UseUJBRkZBO2VBR0oscUJBUElvZixFQXdPV3NxQyxHQUFpQjtrQkF1RzlCd0gsZUEvSkF4SCxHQXVEVzF2RCxRQXZESm0zRCxRQXVERHIxRCxRQUNGcTJELE9BOXpCSjNGOztXQSswQkEsSUFETXZ5RCxRQXhFSG96QjtXQXlFQSxnQkF6RUhxOEIsU0FBR3I4QixNQXdFR3B6QjtXQUVEOztlQUVnQmdDLFFBNUVsQm94QixTQTRFYWhCLE1BNUViZ0I7V0E2RUgsc0J2Q3QyQ0wsT3VDMGZTaS9CLFdBK3hCSjVDLFVBNEVnQnI5QjtlQTVFYmdCLE1BNEVrQnB4Qjs7O2VBR0ZDLFFBL0VoQm14QixTQStFV3p4QixJQS9FWHl4QjtXQWdGSCxXQWhGQXE4QixHQStFYzl0RDtlQS9FWHl4QixNQStFZ0JueEI7OztlQUlTQyxRQW5GekJreEIsU0FtRmtCeHhCLE1BbkZsQnd4QixTQW1GU3hELFFBbkZUd0Q7V0FvRkssaUJBQWlCLGlCQURieEQsU0FuRlo2L0I7V0FxRlEsSUFBSnRzRCxFQUFJLGFBckZSc3NEO1dBcUZRO2FBRUYsZ0NBRkZ0c0QsRUFGaUJ2QixPQUdqQm01Qjs7OzthQUVrQixlQUZsQkEsTUFFa0IsVUFBUGtLO1dBRUosVUFKUGxLLE1BSU8sV0ExRlgwMEIsR0FtRjRCdnRELFFBbkZyQmcxRDs7ZUEyRnVCOTBELFFBM0YzQmd4QixTQTJGb0J0eEIsUUEzRnBCc3hCLFNBMkZXcEQsVUEzRlhvRDtXQTRGSyxpQkFBaUIsaUJBRFhwRCxXQTNGZHkvQjtXQTZGUSxJQUFKbmtELElBQUksYUE3RlJta0Q7V0E2RlE7YUFHYzswQ0FIbEJua0Q7Y0FHa0I7Y0FDQyw0QkFKbkJBO2NBSW1CO2NBY25CLGtCQWRZdXdCLE1BY0ssVUFBVyxLQXBCVC81QjtjQW1CbkIsaUJBZFkyNUIsTUFjSSxVQW5CRzM1QjtjQUduQnU1QjtjQUFLSDs7OzthQWtCYTs7NkJBQVBpWTtjQWxCWDlYO2NBQUtIO1dBcUJIO3NCQXJCRkcsTUFEQS92QjttQkFzQkUsV0FuSE5ta0QsR0FtSG9CLFdBckJYdjBCLE1BSHFCOTRCLFNBM0Z2QjgwRDtrQkEyRFA7a0JBRUE7O1dBNEU0QjtZQURJNTBELFFBeEk3Qjh3QjtZQXdJYXAxQixlQXhJYm8xQjtZQXlJeUIsOEJBRFpwMUI7V0FDaEIsc0J2Q2w2Q0wsT3VDMGZTcTBELFdBK3hCSjVDO1dBeUk0QixJQXpJekJyOEIsTUF3STZCOXdCOzs7b0JBeEk3Qjh3Qjs7aUJBMkkwQzd3QixRQTNJMUM2d0IseUJBMkkrQmlKO2FBQ2xDLFdBNUlBb3pCO2FBNEltQixXQTVJbkJBO2FBNkljLHNCQUZvQnB6QixNQUFXOTVCLFNBM0kxQzZ3Qjs7ZUE4STBDMXdCLFFBOUkxQzB3Qix5QkE4SStCdUo7V0FDbEMsV0EvSUE4eUI7V0ErSW1CLFdBL0luQkE7V0FnSmMsc0JBRm9COXlCLE9BQVdqNkIsU0E5STFDMHdCOzs7V0FpRUgsSUFET21ILFNBaEVKbkg7V0FpRUgsR0FqRU84akM7YUFtRUs7Y0FESVAsYUFsRVRPO2NBa0VDVCxPQWxFRFM7Y0FtRUssYUFESlQsT0FsRVJoSDthQW9FYSxVQURMbnNELEVBQ0ssV0FwRWJtc0QsR0FnRU9sMUIsU0FFU284QjtXQUlaOztvQkF0RUR2akM7O2FBc0hZO2NBRGlEeHdCO2NBQVp1MUQ7Y0FDckMsa0NBRHFDQTtjQUNyQzs7Y0FDSDthQUNaLCtCQUZJQyxPQUNBcnZCLFFBdkhKMG1CO2FBc0hlLElBR1AsaUJBekhSQSxJQXlIUSxlQUhDbHhCLE1BRHVEMzdCO2FBTXZELFVBRkx5MUQsSUFFSyxXQTNIVDVJLEdBMEhJNkksV0ExSEdwQjtXQTZISyxJQUFScm5DLE1BQVE7V0FDWiw4QkFESUEsTUE3SEo0L0I7V0E2SFksSUFFUi9zQyxJQUFJLGFBL0hSK3NDO1dBZ0lTLFVBREwvc0MsSUFDSyxXQWhJVCtzQyxRQUFPeUg7O1dBa0lLO1lBRGVyMEQsUUFqSXhCdXdCO1lBaUllendCLFFBaklmeXdCO1lBa0lTLGtCQWxJWnE4QixHQWlJa0I5c0Q7V0FFTCxVQURUbW5CLE1BQ1MsV0FuSWIybEMsR0FpSTJCNXNELFFBaklwQnEwRDs7V0FxSVAsWUFySUc5akMsU0FxSUssc0JBcklScThCO1dBc0lTLFVBREwxL0MsSUFDSyxXQXRJVDAvQyxHQW9JZTFzRCxRQXBJUm0wRDs7V0FtSnFCO1lBRFJ4eUIsUUFsSmpCdFI7WUFrSll0d0IsSUFsSlpzd0I7WUFtSnlCLHVDQURidHdCLElBQUs0aEM7WUFDUTtZQUNoQixtQkFwSlorcUIsR0FtSnFCdnlCLE9BbkpkZzZCO1dBb0pLLFlBQ1ksSUFBYnFCLG9CQUFhLE9BQWJBO1dBQ0Y7O1dBdkZULDhEQTJGRztJQWxhMEIsU0E0YzdCQyxPQUFPL0ksR0FBR2dKO1VBQWlCLzJELGFBQUxxdUI7ZUFDaEIyb0MsTUFDRjExRCxFQUFFZ3lDO1lBQUZ4RCxNQUFFbW5CO1FBQVE7YUFBUkE7WUFDaUI7YUFBWmx4RCxFQURMa3hEO2FBQ0VyMUQsRUFERnExRDthQUNpQixlQURuQm5uQixJQUNJbHVDO2FBREprdUM7YUFBRW1uQixPQUNLbHhEOztVQUNGLE9BRkwrcEMsSUFFTTtlQUVSdGlDLEVBQUVnb0QsUUFBUWwwRDtRQUNaLFlBUE95c0Q7UUFPUDtVQUNlLHVCQVJSQSxHQUFlMS9CLElBTWxCbW5DO2NBR0EwQjs7Ozs7Ozs7Ozs7OztlQUNpQjN6QixJQURqQjJ6Qjs7Z0JBRUE7a0JBQVksSUFESzN6QixJQUNFLGtCQUFrQixjQVhkdmpDOztVL0JwOUJ2QiwwQitCNjlCQWszRDs7MEJBSWEsSUFBUjVqQixhQUFRLGFBUExoeUMsRUFPSGd5QztRQUNNLElBQVA0akI7UUFBTyxrQkFkTEgsR0FBSGhKLEdBY0NtSixJQUFnQjthQTlUcEJoQyxvQkFzVEYxbkQsRUFOb0I2Z0I7SUE1Y08sU0FpZTdCOG9DLE9BQU9wSixHQUFHMS9CLEtBQU0sY0FBVDAvQixHQXpXUHlHLGdCQXlXVW5tQyxJQUFvQztJQWplakIsU0FtZTdCK29DLFFBQVEzMUQsRUFBRXMxRCxHQUFHMW9DLEtBQWMsNEJBQW5CNXNCLEdBQUVzMUQsR0FBRzFvQyxJQUE2QztJQW5lN0IsU0FvZTdCZ3BDLE9BQU81MUQsRUFBRTRzQjtNQUFjLDRCQUFoQjVzQixHQTVXUCt5RCxnQkE0V1NubUMsSUFBMEQ7SUFwZXRDLFNBc2U3QmlwQyxNQUFNanBDLEtBQU0sY0Fob0NWbWhDLE1Ba3hCRmdGLGdCQThXTW5tQyxJQUErQztJQXRleEIsU0EyZTdCa3BDLGNBR0V4SixHQUFHeUosT0FBT2wyRDtNQUNKLGlCOUJ6NUNSaUIsUThCdzVDRXdyRDtNQUVRLElBQU4vdEQsSUFBTSxhQUZSK3REO01BRVE7UUFFSixpQ0FGRi90RCxJQUZDdzNELFFBR0RucEM7Ozs7UUFFa0IsZUFGbEJBLElBRWtCLFVBQVBrVjtNQUNmLGtCQU5ZamlDLEVBR1Irc0IsSUFHRTtJQXBmdUIsU0F1ZjdCb3BDLGNBR0VoMkQsRUFBRSsxRCxPQUFPbDJEO01BQW1CLG1DQUE1QkcsR0FBRSsxRCxPQUFPbDJELEVBQW9EO0lBMWZsQyxTQTBnQjdCbzJELG1CQUFtQmoyRCxFQUFFNHNCO01BWnZCLElBQUk5cUIsRUFBSixzQkFZcUI5QjtNQUNyQixjQUE0Q0csR0FBSyxPQUFMQSxDQUFNO01BWjFDLElBQUpxQixFQUFJLFNBREpNO01BRUosU0FESU47TUFBSSxJQUNSLEtBRklNLFVBRUo7O1lBQ0FuRztRQUNFO2NBQUlpSCxFQUFKLGdCQVFtQjVDLEVBVHJCckU7VUFDRSxVQUFJaUgsRUFDYSxTQUpmcEI7VUFLRixTQUxFQSxFQUdFb0I7VUFBSixTQURGakg7OztNQUtBLFNBUEk2RjthQVJGdzBELGNBZUYsU0FQSXgwRCxHQVdtQm9yQixTQUM0QjtJQTNnQnBCLFNBOGdCN0JzcEMsVUFBVWwyRDtNQUNaLGNBQXFDRyxHQUFLLE9BQUxBLENBQU07TUFBcEMsb0NBQVEsSUFESEgsc0JBQ2dDO0lBL2dCYixTQW1oQjdCbTJELFFBQVFqeUQsR0FBR294RCxHQUFHMW9DLEtBQWMsZ0NBQXBCMW9CLElBQUdveEQsR0FBRzFvQyxJQUFvRDtJQW5oQnJDLFNBb2hCN0J3cEMsT0FBT2x5RCxHQUFHMG9CO01BQWEsZ0NBQWhCMW9CLElBNVpQNnVELGdCQTRaVW5tQyxJQUFnRTtJQXBoQjdDOzs7O1FBMXBCM0JtaEM7UUFhQUU7UUFDQUM7UUFNQUU7UUFQQUg7UUFDQUM7UUF0SEFWO1FBV0FDO1FBNkdBVTtRQTFMQTFCO1FBT0FDO1FBRUFDO1FBaUtBb0I7O09BMm5DRjJIO09BR0FFO09BRUFDO09BMUJBUjtPQXVCQU07T0FRQUc7T0FZQUU7T0FtQkFDO09BSUFDO09BTUFFO09BREFEO0lBbmhCNkI7UUM1L0I3QkU7YUFHQUMsbUJBQW1CM3pELEtBQ2pCMlk7TUFDVSxJQUFWakosS0FBVSxhQURWaUo7TUFFSixpQ0FIcUIzWSxLQUVqQjBQLEtBQzBCOzJCQU41QmdrRCxTQUdBQzs7b0JDQUt2MkIsR0FDUCxJQUFJdzJCLElBQUosZ0NBQUlBLElBQ0k7UUFZTkMsd0JBVUFDLHNCQU9BQztpQ0Flb0IxMkQ7TUFDdEIsMENBRHNCQSxXQUN0Qjs7WUFDQXJFO1FBQ0U7VUFBZ0MseUJBSFpxRSxFQUV0QnJFO1VBQ2tDLGlCQUY5Qm1KO1VBRThCLFNBRGxDbko7OztNQUlBLFVBTEltSjtNQUFKLElBT0k2eEQsaUJBUEE3eEQ7TUFTSixPQUZJNnhELEdBRUs7SUF5Q2dCO0tBcENXQzs7S0FJQUM7O0tBR0RDOztLQWdCakNDLG9CQXJEQUw7S0ErREFNO0tBR3VCO2FBSW5CRSxTQUFTNTFELEdBQ2YsV0FEZUEsRUFFZixVQUZlQSw2QkFFTztJQU5HLFNBUXZCNjFELFVBQVVDO01BQ1o7O1dBRFlBO09BQ1osd0JBQ0k3ekQscUJBVkYwekQ7TUFZRixpQkFESUksZ0JBREE5ekQ7TUFESixXQUlzQixTQUhsQkE7TUFHSixpQkFGSTh6RDtNQUZKLElBSUEsS0FISTl6RCxZQUdKOztZQUNBNUg7UUFBd0I7VUFBeUI7aUJBQWpEQTtXQUFpRCxzQkFOckN5N0QsV0FNWno3RDtVQUF3QixpQkFIcEIwN0Q7VUFHNkMsU0FBakQxN0Q7OztNQUNBLFVBeEZFODZELG9CQW9GRVksdUNBVzBCO0lBdEJMLFNBd0J2QkMsU0FBTzVuRCxNQUFNNm5EO01BQ2YsYUFEUzduRCxvQkFDVCxLQUFJOG5ELFdBRFdEO01BQ2Y7UUFDNEIsSUFDdEJFLFNBRHNCLGVBRmJGLFNBeEJiTjtRQTRCQSxPQUpPdm5ELFdBR0grbkQsV0FGRkQ7UUFHRixXQURJQztRQURzQjs7O01BakI1QixXQXFCRTtJQTlCdUI7YUE0Q3ZCRyxXQUFXQztNQUNiLElBQUl6YSxNQURTeWE7TUFFYixTQUZhQSxNQUNUemE7TUFDSixPQURJQSxLQUVDO0lBL0NvQixTQWlEdkIwYSxpQkFBaUJELE1BQU1sMUQ7TUFDekI7UUFDRSw4QkFGdUJBLEtBQU5rMUQ7Ozs7VUFJTCxJQUFSRSxNQUFRLFdBSktGO1VBS1EsK0JBTEZsMUQsS0FJbkJvMUQsTUFKYUY7VUFNUyw4QkFGdEJFLFFBSmFGO1VBTVMsT0FGdEJFO1FBUk4sV0FXTztJQXhEa0IsU0EwRHZCQyxrQkFBa0JILE1BQU1JO01BQ2hCLDRCekNwTGIsT3lDMEtLSCxpQkFTa0JELGFBQU1JLE1BQ2M7SUEzRGYsU0E2RHZCQyxXQUFXTCxNQUFNRSxNQUFNSTtNQUN6QjtNQUNHLDJCQUZnQkosTUFBTkY7Z0JBNUJiLFNBNEJhQSxNQUFNRTtnQkE1Qm5CLGlCQTRCYUYsU0FBTUU7O2dCQUFNSTtnQkFBWk4saUJBQU1FLE1BQU1JLFNBQVpOLFlBS2lEO0lBbEVyQyxTQW9FdkJPLFdBQVdQLE1BQU1FO01BQ25CO1FBQUksZUFEZUEsTUFBTkY7Ozs7Z0JBRUssaUJBRkxBLFNBQU1FO21CQUVvQjtJQXRFZCxTQXdFdkJNLFVBQVE3b0QsS0FDVixPQURVQSxZQUNxQixRQURyQkEsSUFDc0M7SUF6RXZCLFNBMkV2QjhvRCxPQUFPVCxNQUFNVSxLQUFLQyxXQUFXQztNQUNwQjt3QkFESUY7T0FFRSx1QkFGR0M7T0FHRix3QkFIYUM7T0FJVjs7eUJ6Q3hNeEIsT3lDMEtLWCxpQkEwQk9ELGFBRUxjO09BR2tCOzt5QnpDek16QixPeUMwS0tiLGlCQTBCT0QsYUFHTGU7TUFFa0I7OztVQUxiZixvQ0FJTGdCLGVBSEFIO09BREtiO01BQ0UsSUFJVyxrQkFMYkE7TUFLYSxjQU9ia0IsSUFBSTFsQixLQUFLMmxCO1FBQ1QsV0FEQUQsSUFYTEwsUUFZNEIsbUJBRHZCSyxJQUFJMWxCLEtBQUsybEIsWUFDZ0Q7TUFGaEU7O01BTUY7aUJBQ09HLElBQUlwQjtVQUNLLGlDQURUb0IsSUFBSXBCLE1BSFBrQjtVQUlZLFNBSFpDO1VBR1k7WUFHRCw2QkFKSm5CLE1BbEJGRjs7Ozs7VUFxQkQsaUNBSEdFO1VBR0gsUUFFVztRQXBCZmE7UUFFQUU7TUFvQko7aUJBQ09LLElBQUlwQjtVQUNLLGlDQURUb0IsSUFBSXBCLE1BWFBrQjtVQWFhLGlDQUZObEIsUUFWUG1CO1VBWWEsUUFBOEI7UUExQjNDUDtRQUVBRTtNQXFCSixXQVZJSTtNQVVKLFdBVElDO01BTEYsSUFjRixZQXpCU3JCO01BaUNOOzs7aUJBQ09zQixJQUFrQkM7VUFBdkIsSUFBT0wsSUFBRkksT0FDQyxXQURDSixJQTlCUkYsZ0JBOEJ3Qk8sTUFBbEJELElBQWtCQyxHQUNnQzs7O01BRnpELFFBSUk7SUFoSGtCLFNBa0h2QkMsTUFBTXhCO01BRU47Z0JBRk1BO09BRU47Ozs7OztNQUV1QixjQUpqQkE7TUFNTDs7O2lCQUNPNzNELEVBQUUyRDtVQUFnQiw2QkFBaEJBLEVBUEprMEQ7VUFPb0IsMEJBQWhCbDBELE9BQUYzRCxFQUE0QztRQU5WczVEO1FBQXdCZjtNQUtqRSxXQUxFVTtNQUtGLFdBTFdDO01BQ1osU0FGTXJCO01BWUw7OztpQkFDT3NCLElBQWtCQztVQUF2QixJQUFPTCxJQUFGSSxPQUNDLFdBRENKLElBWjRDUCxZQVk1QlksTUFBbEJELElBQWtCQyxHQUM0Qjs7UUFiaENHO01BV3JCLFFBSW9CO0lBbElFLFNBb0l2QkMsU0FBUzNCO01BQ1gsSUFBSXphLE1BRE95YSxTQUNYLFdBQUl6YSxjQUFKLE9BQUlBLEtBRUM7SUF2SW9CLFNBeUl2QnFjLGFBQWE1QixNQUFNbDFEO01BQ3JCO1FBQUksNkJBRGlCQSxLQUFOazFEOzs7O1VBR0QsSUFBUnphLE1BQVEsU0FIQ3lhO1VBSVYsd0JBSmdCbDFEO1dBQU5rMUQsV0FJb0IsbUJBSmRsMUQsS0FHZnk2QyxNQUhTeWE7VUFLYixPQUZJemE7UUFQTixXQVNPO0lBOUlrQixTQWdKdkJzYyxTQUFTbHFELEtBQ1Isa0JBRFFBLGNBQzRCO0lBakpkLFNBbUp2Qm1xRCxzQkFBc0I5QixNQUFNK0IsTUFBTUM7TUFDeEI7d0JBRGtCRDtPQUNsQixPQUFSRTtPQUFRLE1BRHdCRDtPQUN4QixtQkFDUkUsU0FBZ0NDO09BRHhCLEtBQ1JEO09BRFE7O1lBR1poNEQ7UUFDRTtVQUFXOzs2QkFMVzgxRCxNQUtZLGlCQUpoQ2lDLFFBR0ovM0Q7VUFDRSxpQkFGRWtELElBQ0psRDtVQUNhLFNBRGJBOzs7TUFIWSxJQU1aLEtBTG9DaTRELGNBS3BDOzs7UUFDRTtVQUFrQjtnQkFEcEJyK0QsSUFMSW8rRDtXQU1nQixrQkFSSWxDLE1BUWUsaUJBUkhnQyxLQU9wQ2wrRDtVQUNFLGlCQUxFc0o7VUFLZ0IsU0FEcEJ0Sjs7O01BR0EsT0FQSXNKLEdBT0Q7SUE3SnNCLFNBK0p2QmcxRCxhQUFhcEMsTUFBTWwxRDtNQUNyQjtRQUFJLDZCQURpQkEsS0FBTmsxRDs7OzttQkFDNkM7SUFoS25DLFNBa0t2QnFDLGNBQWNyQyxNQUFNSTtNQUNaLDRCekM1UmIsT3lDd1JLZ0MsYUFHY3BDLGFBQU1JLE1BQ2M7SUFuS1gsU0FxS3ZCa0MsZ0JBQWdCdEMsTUFBTWg0RCxHQUN4QixjQUR3QkEsRUFBTmc0RCxVQUNsQixRQUEyQztJQXRLbEIsU0FtTHZCdUMsYUFBYUM7TUFDZixHQURlQSw0QkFDbUI7TUFFdkI7c0NBSElBO09BSUgsZ0JBRFJ4YTtNQUVKO2lCQUNPbGtELEVBQUV3OUQ7VUFDTCxJQUFJSixLQUREcDlEO1VBRXVCLCtCQUZyQnc5RCxJQUNESixJQUhKbEI7VUFLMEIsOEJBRnRCa0IsTUFISmxCO1VBSzBCLFFBQXdDO1FBVHZEd0M7TUFLZixPQURJeEMsS0FPQztJQTlMb0IsU0FnTXZCeUMsV0FBV3pDO01BQ2IscUJBMUpFRixvQkF5SldFO01BRVMsZUFGVEE7TUFHVztlQUhYQTtxQkFHVyxpQkFIWEEsdUNBR2tEO0lBbk10QyxTQXFNdkIwQyxTQUFTQyxJQUFJWCxLQUFLckIsV0FBV0Msa0JBQStCbDBDO1VBQUwzSyxhQUFWNmdEO01BQy9DLE9BRFdELElBQUlYLEtBQUtyQixXQUFXQztNQUMvQixJQUNJbmxELEtBRjBEaVIsSUFHaEQsV0FIaUNrMkMsUUFBcENELElBQThDNWdELEtBR2YsV0FISzZnRCxRQUFwQ0Q7TUFJWCxNQUpXQTtNQUNYO09BR0E7T0FNSyxjQVYwQi9CO09BUTVCOzs7b0JBQ09pQyxJQUEyQixrQkFUMUJGLElBUzBCLGlCQVQxQkEsSUFTREUsSUFBK0Q7O09BRmxDLGNBUHhCYjtNQU9MOzttQkFMTnZtRDs7aUJBS00scUJ6Q3JVYixPeUN3UksybUQsYUFzQ1NPOztJQXJNYyxTQWlOdkJHLFdBQVdDLFVBQVVDO01BQ1gsdUJBRENELFdBRUUsb0JBRlFDLFdBQ25CaEQ7TUFFSixXQUZJQTtNQUdILHFCQUZHaUQsWUFGbUJELFdBRW5CQyxXQUVxRDtJQXJOaEMsU0F5TnZCQyxpQkFBaUJILFVBQVVDLFdBQVdHO01BQzVCLHVCQURPSixXQUVKLG9CQUZjQyxXQUN6QmhEO01BRUosV0FGSUE7TUFFSixnQkFINkJnRDtNQUc3QixnQkFESUM7TUFDSixRQUUrQjtJQTlOTixTQWdPdkJHLFlBQVlDO01BQ2QsU0FBSUMsYUFBaUIsb0NBRFBELElBQzZDO01BQTNELFVBQUlDLG9CQUN1QztJQWxPbEIsU0FzT3ZCQyxjQUFjdkQ7TUFFaEIsSUFBSTVtRCxJQUFKLG1CQUZnQjRtRDtNQUtoQixTQUxnQkE7TUFLaEIsc0JBSEk1bUQsSUFHZ0I7SUEzT0ssU0E2T3ZCb3FELGtCQUFrQkMsTUFBTXpEO01BQzFCLEdBRG9CeUQ7TUFDd0IsSUFFdENycUQsSUFGc0MsbUJBRGxCNG1EO01BTXhCLFNBTndCQTtNQU14QixzQkFISTVtRCxJQUlIO0lBcFBzQixTQXNQbkJzcUQsT0FBT3RxRDtNekMvV2hCOzs7Y3lDa1hRblAsYUFBSGpDO1VBQVEsV0FBUkEsRUFIV29SO3NCQUdSblA7O1FBREs7SUF4UGUsU0EyUHZCMDVELGlCQUFpQnZxRCxJQUFJNG1EO01BQ3ZCLFVBRHVCQSxTQUN2QixXQUFJNEQ7TUFBSixZQUVFLE9BSGlCeHFELElBQ2Z3cUQsV0FFYztJQTlQTyxTQWdRdkJDLHFCQUFxQkosTUFBTXJxRCxJQUFJNG1EO01BQ2pDLEdBRHVCeUQsYUFBTXJxRDtNQUNhLElBQ3BDd3FELE1BRjJCNUQ7TUFDUyxTQUNwQzRELE1BQ2dCLE9BSE94cUQsSUFFdkJ3cUQ7TUFDZ0MsT0FIVHhxRCxHQUsxQjtJQXJRc0IsU0F1UXZCMHFELG1DQUFtQ0wsTUFBTXpEO01BQzNDLEdBRHFDeUQ7TUFFekIsSUFBTnJxRCxJQUFNLGNBRitCNG1EO01BR3pDLGlCQURJNW1ELElBRnFDNG1EO01BR3pDLE9BREk1bUQsR0FHSDtJQTVRc0IsU0F1U3ZCMnFELFdBRUs1d0Q7TUFGTSxHQUVOQSxzQkFESSw2QkFDaUI7SUF6U0gsU0E4U3ZCNndELFdBQVd2NkQsRUFBRXc2RCxLQUFLdmhEO01BQ3BCLHVCQUFJdFYsS0FBSjtZQURhM0Q7WUFHYjNGO1FBQ0U7bUJBRkUySTtVQUVlLDJCQUpKdzNELEtBR2ZuZ0U7VUFDRSxTQURGQTthQUhhMkYsTUFHYjNGOztNQUZBLFNBQ0kySTtNQWxCa0IsR0FnQkZpVyxRQWRILHdCQWVidFY7TUFoQk8sNkJBc0JSO0lBclRzQixTQTBVdkI4MkQsY0FBY0MsS0FuQklGO01Bb0JkLElBcEJtQkcsU0FvQm5CLFdBRFVEO01BQ1YsR0FwQm1CQztRQXNCdkIsUUF0QmtCSCx3QkFBRm5nRSxNQUFPNGU7O1FBQ3pCO2tCQURrQjVlO1lBRWxCLHlCQUZvQm1nRSxLQUFGbmdFLFVBR0V1Z0UsU0FISzNoRDtZQUl2QjtjQXZCVSxHQXNCUTJoRDttQ0FEaEJ4dkI7a0JBR00sSUFMZXl2QixTQUtmLFdBRlVEO2tCQUVWLEdBTGVDO29CQVFqQixRQVJVeGdFLGdCQUFPNGU7a0JBTVY7Z0JBbkJGLEdBZ0JPMmhEO2tCQWRILFNBY0dBOztrQkFkSCxJQVhDdjRELEtBd0JkK29DO2tCQXhCa0IsR0F5QkZ3dkI7b0JBdkJILGNBRkN2NEQsU0FhaEJrNEQsV0FTZ0JsZ0UsVUFBRW1nRSxLQXRCRm40RDtrQkFDUDtnQkFTQTtjQU5BO1VBbUJHLE9BRFc0VztNQXdCdkIsa0JBeEJrQnVoRCw2QkFtQkpFLEtBSzhCO0lBL1VyQixTQWtZdkJJLFVBQVV2RTtNQUNKLElBQUp2MkQsRUFBSSxXQURJdTJEO01BQ0osVUFBSnYyRDs7O2lCQUU4QixpQkFIdEJ1MkQsMENBQ1J2MkQ7OztZQUNBOEksSUFFVSxXQUpGeXREO01qQ2NOLGtCaUNaRnp0RCxJQURBOUk7TUFLSixpQkFOWXUyRCxTQUVSenREO01BSUosT0FKSUEsR0FLSDtJQXpZd0IsU0E2ZHZCaXlELFlBQVl4RSxNQUFNUjtNQUNwQixRQURvQkEsbUJBQ3BCOztXQXhEb0IxN0QsT0F3RGhCNEg7VUFFRjtnQkExRGtCNUg7V0EwRGxCLHVCQUhrQjA3RDtXQXREcEI7O2NBQWM7dUJBRE0xN0Q7Y0FDTix3QkFzRE0wN0QsdUJBdERnQjtXQUM5QjtvQkFtREppRjs7O2NBbER3Qjs7ZUF1RFFDLE1BN0lsQixTQUFKcDhELEd6QzVjZixnQnlDNGM0QjhRLEtBQVEsT0FBckI5USxDQUFzQixHQUF0QkE7OztjQXVGVTs7ZUFzRFlvOEQsTUE1SWxCLFNBQU5qN0QsR3pDN2NiLGdCeUM2YzRCMlAsS0FBTyxPQUFQQSxJQUFmM1AsTUFBNEMsR0FBNUNBOzs7Y0F1Rlk7O2VBQWtCO2VBcUROaTdEO2dCQTFJbEMsU0FEVXRvRCxFQUFFM1MsR3pDOWNmLGdCeUMrY1kyUCxLQUNQLE9BRE9BLElBRENnRCxPQUFFM1MsTUFFbUQ7a0JBRnJEMlMsRUFBRTdKOzs7Y0F1RlU7O2VBb0RZbXlEO2dCQXhJbEIsU0FBTGo3RDttQnpDamRkLGdCeUNpZDRCMlAsS0FBTyxrQkFBUEEsT0FBZDNQLE9BQWMyUCxJQUFxQjtrQkFBbkMzRzs7O2NBcUZXOztlQW1EWWl5RDtnQkF2SWxCLFNBQU5qN0QsR3pDbGRiLGdCeUNrZDRCMlAsSUFBSTlRLEdBQUssSUFBeEJtQixTQUFtQm5CLEVBQUssUUFBd0I7a0JBQWhEcThEOzs7Y0FxRlk7O2VBQWtCO2VBa0RORDtnQkF0SWhCLFNBQU4xOEQsRUFBRU0sR3pDbmRqQixnQnlDbWQ4QjhRLEtBQVEsa0JBQXZCcFIsRUFBRU0sRUFBd0I7a0JBQTFCTixFQUFFOHVDOzs7Y0FxRlE7O2VBQWtCO2VBaURONHRCO2dCQXJJaEIsU0FBUjE4RCxFQUFFeUI7bUJ6Q3BkZixnQnlDb2Q4QjJQLEtBQU8sa0JBQXhCcFIsRUFBaUJvUixJQUFmM1AsT0FBZ0Q7a0JBQWxEK3NDLElBQUVvdUI7OztjQXNGQTs7ZUFBbUI7ZUFBa0I7ZUErQ2ZGO2dCQW5JbEMsU0FEVTE4RCxFQUFFb1UsRUFBRTNTO21CekNyZGpCLGdCeUNzZFkyUDtxQkFDUCxrQkFGUXBSLEVBQ0RvUixJQURHZ0QsT0FBRTNTLE9BRXFEO2tCQUZ6RGd0QyxJQUFFaDZCLElBQUVvb0Q7OztjQXVGUTs7ZUFBa0I7ZUE2Q05IO2dCQWpJaEIsU0FBUDE4RCxFQUFFeUI7bUJ6Q3hkaEIsZ0J5Q3dkOEIyUDtxQkFBUyxrQkFBekJwUixFQUF5QixXQUFUb1IsT0FBZDNQLE9BQWMyUCxLQUF5QjtrQkFBekN1OUIsSUFBRW11Qjs7O2NBc0ZEOztlQUFrQjtlQUFrQjtlQTJDZEo7Z0JBaElSLFNBQVIxOEQsRUFBRU0sRUFBRUM7bUJ6Q3pkekIsZ0J5Q3lkc0M2USxLQUFRLGtCQUF6QnBSLEVBQUVNLEVBQUVDLEVBQTBCO2tCQUE5Qnd1QyxJQUFFRSxJQUFFMXVDOzs7Y0F3RlY7O2VBQWtCO2VBQWtCO2VBd0NkbThEO2dCQS9IUixTQUFWMThELEVBQUVNLEVBQUVtQjttQnpDMWR2QixnQnlDMGRzQzJQLEtBQU8sa0JBQTFCcFIsRUFBRU0sRUFBaUI4USxJQUFmM1AsT0FBa0Q7a0JBQXRENnRDLElBQUVGLElBQUUydEI7OztjQTBGUjs7ZUFBa0I7ZUFBa0I7ZUFBbUI7ZUFxQ2pDTDtnQkExSGxDLFNBRGdCMThELEVBQUVNLEVBQUU4VCxFQUFFM1M7bUJ6QzlkekIsZ0J5QytkWTJQO3FCQUNQLGtCQUZjcFIsRUFBRU0sRUFDVDhRLElBRFdnRCxPQUFFM1MsT0FFK0M7a0JBRnJEK3RDLElBQUV3dEIsSUFBRXI5QyxJQUFFczlDOzs7Y0F5RlY7O2VBQWtCO2VBQWtCO2VBa0NkUDtnQkE5SFQsU0FBUjE4RCxFQUFFTSxFQUFFbUI7bUJ6QzNkeEIsZ0J5QzJkcUMyUDtxQkFBVyxrQkFBNUJwUixFQUFFTSxFQUEwQixXQUFYOFEsT0FBYjNQLE9BQWEyUCxLQUEyQjtrQkFBNUNxK0IsSUFBRXl0QixJQUFFQzs7O2NBK0ZUOztlQUFrQjtlQUFrQjtlQStCZFQ7Z0JBN0hWLFNBQVIxOEQsRUFBRXlCLEVBQUVuQjttQnpDNWR2QixnQnlDNGRvQzhRLEtBQU8sa0JBQXhCcFIsRUFBaUJvUixJQUFmM1AsT0FBRW5CLEVBQWdEO2tCQUFwRDg4RCxJQUFFQyxJQUFFQzs7O2NBaUdSOztlQUFrQjtlQUFtQjtlQUFrQjtlQTRCakNaO2dCQXZIbEMsU0FEZ0IxOEQsRUFBRW9VLEVBQUUzUyxFQUFFbkI7bUJ6Q2plekIsZ0J5Q2tlWThRO3FCQUNQLGtCQUZjcFIsRUFDUG9SLElBRFNnRCxPQUFFM1MsT0FBRW5CLEVBRStDO2tCQUZyRGk5RCxJQUFFQyxJQUFFQyxLQUFFQzs7O2NBK0ZWOztlQUFrQjtlQUFrQjtlQXlCZGhCO2dCQTVIVCxTQUFSMThELEVBQUV5QixFQUFFbkI7bUJ6QzdkeEIsZ0J5QzZkcUM4UTtxQkFBUyxrQkFBMUJwUixFQUEwQixXQUFUb1IsT0FBZjNQLE9BQWUyUCxLQUFiOVEsRUFBd0M7a0JBQTVDcTlELElBQUVDLEtBQUVDOzs7Y0FzR1Q7O2VBQWtCO2VBc0JJbkI7Z0JBckhYLFNBQU5qN0QsRUFBRW5CO21CekNwZXRCLGdCeUNvZW1DOFE7cUJBQU8sa0JBQVBBLE9BQWYzUCxPQUFlMlAsSUFBYjlRLEVBQStDO2tCQUFqRHc5RCxLQUFFQzs7O2NBaUdQOztlQUFrQjtlQW9CSXJCO2dCQW5IbEMsU0FEZWo3RCxFQUFFMGdCO21CekNyZXBCLGdCeUNzZVkvUTtxQkFBTyxrQkFBUEEsT0FETTNQLE9BQ04yUCxRQURRK1EsT0FDaUQ7a0JBRG5ENjdDLEtBQUU3N0M7OztjQWtHTDs7ZUFBa0I7ZUFBa0I7ZUFrQmR1NkM7Z0JBakhsQyxTQURlajdELEVBQUUyUyxFQUFFK047bUJ6Q3ZldEIsZ0J5Q3dlWS9RO3FCQUFPLGtCQUFQQSxPQURNM1AsT0FDTjJQLFFBRFFnRCxPQUFFK04sT0FFZ0Q7a0JBRnBEODdDLEtBQUVDLElBQUU1NkM7OztjQW1HUDs7ZUFBa0I7ZUFlSW81QztnQkE5R2xDLFNBRGdCajdELEVBQUUwZ0I7bUJ6QzFlckIsZ0J5QzJlWS9RO3FCQUFpQyxvQkFBakNBLE9BRFMrUSxPQUNUL1E7cUJBQWlDLGtCQUFqQ0EsT0FETzNQLE9BQ1AyUCxTQUFpRDtrQkFEMUMrc0QsS0FBRWw2Qzs7O2NBa0dOOztlQUFrQjtlQUF5QixZQVV6Qyt6QztlQUdvQjBFO2dCQTVHbEMsU0FEYXY2QyxFQUFFN2hCLEVBQUV5QzttQnpDNWVwQixnQnlDNmVZcU87cUJBQU8seUNBREQ5USxFQUFGNmhCLEtBQUU3aEIsRUFBRXlDLEVBQ3VDO2tCQUQzQ3E3RCxJQUFFQyxJQUFFdDdEOzs7Y0FrR0w7O2VBQWtCO2VBQXdCLGNBUXhDaTFEO2VBR29CMEU7Z0JBMUdsQyxTQURXdjZDLEVBQUUxZ0IsRUFBRXNCO21CekM5ZWxCLGdCeUMrZVlxTztxQkFDUCxTQURPQSxJQURJM1A7cUJBRVgsOENBRlMwZ0IsVUFBSXBmLEVBR2U7a0JBSG5CdTdELElBQUVDLEtBQUV6eEQ7OztjQWtHSDs7ZUFBa0I7ZUFBa0I7ZUFDN0IsY0FLTGtyRDtlQUdvQjBFO2dCQXRHbEMsU0FEV3Y2QyxFQUFFL04sRUFBRTNTLEVBQUVzQjttQnpDbGZwQixnQnlDbWZZcU87cUJBQ1AsU0FET0EsSUFESWdELE9BQUUzUztxQkFFYiw4Q0FGUzBnQixVQUFNcGYsRUFLZTtrQkFMckJ5N0QsSUFBRUMsSUFBRUMsS0FBRTN4RDs7O2NBaUdMOztlQUFrQjtlQUF5QixjQUd6Q2lyRDtlQUdvQjBFO2dCQWhHbEMsU0FEWXY2QyxFQUFFMWdCLEVBQUVzQjttQnpDeGZuQixnQnlDeWZZcU87cUJBQ0csb0JBREhBLE9BREszUCxPQUNMMlA7cUJBQ0csOENBRkErUSxVQUFJcGYsRUFFeUM7a0JBRjdDNDdELElBQUVDLEtBQUU1eEQ7O2VBaUdrQjB2RCxNQUxoQ0Q7VUFNQSxXQUpZekUsTUFHUkUsTUFBNEJ3RTtVQUNoQzs7UUExRFksU0E0RFY7SUFuZXFCLFNBMGV2Qm1DO01BQ0YsVUE5ZUUxSCxlQXlDQVUsZ0JBQ0FDLGtCQXFjdUQ7SUE1ZWhDOzs7O09BNEN2QkM7T0E2RkE2QjtPQVVBRTtPQVlBTTtPQUdBQztPQWpIQXBDO09BU0FFO09BVUFJO09BUEFGO09BZ2FBbUU7T0FsWkEvRDtPQXVDQWU7T0FtREFjO09BbExBcEQ7T0FnTUFxRDtPQWFBRTtPQUtBQztPQVlBSTtPQVFBSTtPQU9BRTs7T0FNQUc7T0FPQUM7T0FjQUc7T0FLQUU7T0FPQUM7T0FtRUFJO09BN1pBdkY7T0E2akJBa0k7SUExZXVCOzs7Ozs7Ozs7S0MvRk47ZUFBakJDO0tBQWlCO2FBS2pCRztNQUFrQixZQUxsQkgsZUFLa0Isc0JBQXFDO0lBTHRDLFNBT2pCSSxNQUFNbjhEO01BQ1Isd0JBTkVnOEQsY0FDQUM7UUFLc0MsSUFDbENHLFVBRGtDLHNCQUx0Q0g7UUFPQSxLQVJBRCxZQU9JSSxZQU5KSDtRQU9BLFlBRElHO01BSU4sZUFYRUosVUFDQUMsVUFJTWo4RDtNQU1SO2NBQ1c7SUFkUSxTQWdCakJxOEQ7TUFDTSxJQUFKai9ELEVBQUksV0FmTjQrRCxZQUNBQztNQWNNLFlBakJORjtNQWlCTSxPQUFKMytELENBQXFFO0lBakJ0RCxTQXFCakJrL0QsV0FBV0M7TUFDRyxJQUFaQyxVQUFZO01BQ2hCO2lCQUFlcC9ELEdBQUssb0NBRGhCby9ELFVBQ1dwL0QsUUFBb0M7UUFGdENtL0Q7TUFFYixTQUNJRSxpQkFBaUJDO1FBQ25CO1VBQUksc0NBSEZGLFVBRWlCRTs7OztVQURELFdBR0s7TUFIekIsU0FJSUMsaUJBQWlCMzhEO1FBQ1gsSUFBSjVDLEVBQUksU0FEVzRDO1FBQ1g7VUFDSixzQ0FQRnc4RCxVQU1FcC9EOzs7K0NBRStCLDBCQUYvQkE7VUFISixXQUs4RDtNQVBoRSxTQWlGSXcvRCxrQkFBbUI5M0M7UUFDckI7VUFBTSxpQkFEZUE7VUFDZjs7dUNBRUYsS0FIaUJBLE1BR3FCO1VBQ1Msa0NBQWYsaUJBQWlCO01BckZ2RCxTQTRFSSszQyxjQUFlLzNDO1FBQ1gsaUJBRFdBO1FBQ1g7O1VsQzJZRjtZa0N6WUEsS0FIYUEsTUFHeUIscUNBSHpCQTtRQUlWLHlCQUpVQSxLQUljO01BaEZqQyxTQTRESWc0QyxPQWMwQjEvRDtRQWI1QjtVQUFNLGlCQWFzQkE7VUFidEI7Ozs7Y2xDMlpGLGVrQ3JaQSxLQU93QkEsR0FQYywrQkFPZEE7OztnQkFUeEIsS0FTd0JBO2dCQVRjO2dCQUsxQztrQkFBTSxtQkFJc0JBO2tCQUp0Qjs7OztpREFFRixLQUV3QkEsR0FGYzs7Ozt3QkFFdEMsS0FBd0JBLEdBQWMsK0JBQWRBO2tCQUN1QixrQ0FBZjs2QkFaaEMsS0FXd0JBLEdBWGM7VUFLSyxnQ0FBZixpQkFBaUI7TUFwRW5ELFNBK0NJMi9ELE9BQVFqNEM7UUFDVjtVQUFNLGlCQURJQTtVQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WWxDd2FGLGVrQ3BhQSxLQUxNQSxNQUtnQztVQUM5QiwyQkFBa0IsZ0JBQWdCO01BckRoRCxTQXNESWs0QyxXQUlNNS9EO1FBSEYsaUJBR0VBO1FBSEY7OztZQUVGLEtBQ0lBLEdBQWMsZ0JBQWlCLFVBQVcsMEJBQTFDQTtRQUNpQjtRQUFpQjtzQkFEbENBLEVBQ3FEO01BM0QvRCxTQXlDSXVyQixNQUFPN0Q7UUFDVDtVQUFNLGlCQURHQTtVQUNIOzs7Ozs7Ozs7O1lsQzhhRixla0MzYUEsS0FKS0EsTUFJaUM7VUFDOUIsMkJBQWtCLGdCQUFnQjtNQTlDaEQsU0FTUW00QyxxQkF5RkVuNEM7UUF4RlI7VUFBTSxpQkF3RkVBO1VBeEZGOzs7Ozs7Ozs7Ozs7O29CQXlCRixLQStESUE7b0JBOURjO29CQW1EdEI7c0JBQU0sbUJBV0VBO3NCQVhGOzt3Q0FDUyxLQVVQQSxtQkFWTzs7MEJBRVgsS0FRSUE7MEJBUko7NEJBRU0sSUFERi9hLElBQ0UsT0FNRithOzs7OzswQkFIYyxNQUpkL2E7O3dCQUtJLEtBRUorYTt3QkFGMEM7O3NCQUMzQzs7b0JBeEVILEtBeUVJQTtvQkF6RUo7c0JBMEVFLG1CQURFQTtzQkFDRjs7O3dCQUVGLEtBSElBO3dCQUdKOzBCQUNVLGdCQUpOQTs7OzswQkFRRDs0QkFoRkM5a0I7O3dCQStFSSxLQVBKOGtCLFVBeEVBOWtCOzs7OztvQkFJUSxtQkFvRVI4a0I7b0JBcEVROzJDQUNHLEtBbUVYQSxNQW5FVyxhQUxYOWtCO29CQU1HOztvQkFNRyxLQTRETjhrQjtvQkE1RE07OzZCQTJGWnE0Qyx3QkEvQk1yNEM7a0RBK0JOcTRDLGlCQS9CTXI0QzsyQkE3RE0sS0E2RE5BLE1BN0RNLGtCQTZETkE7Ozs7OzsyQkF0RkosS0FzRklBOzs7Ozs7Ozs7OztvQkE1RUosS0E0RUlBLE1BM0VjLGdCQUFpQiwwQkEyRS9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WWxDc1hKO3FCa0NqYlEsS0EyREpBLE1BM0Q2Qjs7ZUF6QmpDLEtBb0ZJQSxNQW5GYyxnQkFBaUIseUJBbUYvQkE7O2VBL0VKLEtBK0VJQSxNQTlFYyxnQkFBaUIsMEJBOEUvQkE7VUExREQsU0FBSTtNQXhDYixTQWlJSXE0QyxzQkFBZXI0QztRQUNYLGlCQURXQTtRQUNYOztXQUVGLEtBSGFBO1dBR3lCLFFBSHpCQTtXQUd5Qjs7b0JBM0hwQ200Qyx1QkF3SFduNEM7eUNBeEhYbTRDLGdCQXdIV240QztRQUlMLCtCQUFzQjtNQXJJcEMsU0FTUXU0QyxXQXlGRXY0QyxNMUNuSmIsdUIwQzBEV200QyxlQXlGRW40QztNQWxHVixTQTJHSW80QyxPQUFRcDRDO1FBQ0osaUJBRElBO1FBQ0o7Ozs7OztzQkFDUSxLQUZKQSxNQUVJO3NCQUNBLEtBSEpBLE1BR0k7c0JBQ0EsS0FKSkEsTUFJSTs7OzthQUVWLEtBTk1BO2FBT00sbUJBUE5BO2FBT007OztpQkFFUixLQVRFQTtpQkFVVSxtQkFWVkE7aUJBVVU7OztxQkFFUixLQVpGQTtxQkFZRTs7Ozs7Ozs7OztpQkFJRzthQUVKO1VBRUMsS0FwQkZBO1VBb0JFO1FBQ0wsZUFBb0I7TUFoSTdCLFNBc0lJczRDLFFBV21CdDRDO1ExQ2xNMUI7UTBDd0xLO1VBQU0saUJBVWVBO1VBVmY7Ozs7O2dCQUNRLEtBU09BO2dCQUpmLG1CQUllQTtnQkFKZjt3Q0FDUSxLQUdPQSxNQUgrQixRQUcvQkE7a0JBRlQsS0FFU0E7O2dCQURkOzs7Z0JBUE8sS0FRT0E7Z0JBQ3JCO2tCQUFNLG1CQURlQTtrQkFDZjs7b0NBQ1EsS0FGT0EsTUFFUDtvQ0FDQSxLQUhPQTtvQkFJVCxLQUpTQTs7a0JBS2Q7WUFaSyxLQU9TQTs7VUFOZCxnQkFBb0I7TUEzSTdCLGdCQXdKSXpqQjtRQUFTLHFCQUFpQjBpQixPQUFVLGtCQUFwQzFpQixNQUFvRCxFQUFDO0lBL0t0QyxxQkFxQmpCaTdEO0lBckJpQjs7TTFDMUJ0QixJMkNzRVN0bUIseUIzQ3RFVDtlMkN3RVNwOEIsT0FBU2d4QixJQUFxQ3NMO1FBQ2hELEdBRFd0TDtTQUFTLFFBQVRBLGNBQVNxQzs7YUFBVGtKLE9BQVM7WUFQQTU0QztRQUNwQjtnQkFNZ0QyNEMsZ0JBUDVCMzRDOzthQUdmLFFBSGVBO2FBT1Q0NEM7V0FFZTs4QkFKeEJIO1lBSXdCLGtCQUp4QkEscUJoQi9DSjN5QixpQmdCK0NJMnlCO1lBSUUzQyxLQUFzQjs7ZUFBdEJBO1VBQzhDLDJCQVY5QjkxQyxLQVNoQjgxQyxLQVRnQjkxQyxHQVVrRDtlQUVwRWdrQixNQUFNNUg7UUFDUjtnQkFEUUEsZ0JBQ1IsS0FDSWhaLFlBREo7O2NBRUE1SDtVQUNFOzZCQUpNNGdCLEtBR1I1Z0I7WUFDRSxTQURGQTs7O2dCQUVJO2VBRUZ3dEIsTUFBTTVNO1FBQ1IsSUFBSWhaLElBRElnWjtRQUNSLE9BQUloWixRQURJZ1o7aUJBR04sTUFITUE7a0NBTUksZUFOSkEsVUFPTDtlQUVEaWdDLEtBQUtscEM7UUFBSSxTQUFKQSxRQUFJLEtBQUpBLFFBQW9CLFlBQXBCQTtRQUFvQixVQUFwQkEsdUJBQXVDO2VBRTVDNG1DLFVBQVUzOUIsRUFBRTJqRCxNQUNkLE9BRGNBLFFBQUYzakQsd0JBQ3VCO2VBRWpDNGpELE1BQU01akQ7UUFDUixTQUFRNCtCO1UzQ25HZjtVMkNtRzJCOztrQkFHTHQvQyxnQkFBSCtHO2NBQWtCLG1CQUFsQkEsb0JBSVEsVUFKTC9HO2NBQ1QsT0FMRTBnQjswQkFJTzFnQjs7WUFEVCxTQUs2QjtRQVBuQyxNQURRMGdCLEtBQ1IsS0FTSWxILHFCQVRKOztjQVVBMVo7VUFDRTtZQUFTLG1CQUFVLGlCQUZqQjBaLEVBQ0oxWjtZQUNFLGlCQUZFMFosRUFDSjFaO1lBQ1csU0FEWEE7OztnQkFFSTtlQXNCRnl0QixPQUFPN007UUFDVCxVQURTQSxLQUNULE1BQUlrOUIsaUJBQUosTUFDSUM7UUFFSixNQUpTbjlCO1FBQ1Q7U0FHQSxLQURJbzlCO1NBQ0osV0FGSUQsb0JBRktuOUI7UUFLcUQ7Y0FDeERxOUIsTUFEd0QsZUFGMUREO1VBRTBELE9BQ3hEQztVQUR3RDs7O2NBR3BDO29CQUVILzlDLGNBQU42bUIsY0FBTnc5QztnQkFDSCxjQURlcmtFO2dCQUVKLElBQVBtK0MsS0FBTyxVQVpWejlCLEVBVUUyakQ7Z0JBRzhCLE9BUG5DdG1CLE1BTU1JOzswQkFGRGttQixLQUFNeDlDLEtBR3dCLGlCQVBuQ2szQixNQU1NSTtjQUhHLFFBSXVDO1dBUlEsS0FIMUROO1dBRzBEOztnQkFTNUQvOUM7WUFDRTs0QkFBYyxpQkFkZDg5QyxNQWFGOTlDO2NBQ0UsU0FERkE7OztVQVQ0RDs7O1FBdkMxQyxXQW1EakI7ZUFFRDhoQixJQUFJbEIsRUFBRW13QixJQUFJMkc7UUFDRDs4QkFETDkyQixLQUFFbXdCO1NBRUEsWUFGRm53QixFQUNGMmpEO1NBRVksMEJBSFJ4ekIsSUFBSTJHO1NBSXVCLFVBSC9CNnNCLEtBRUFHLFVBQytCLGlCQUo3QjlqRCxLQUVGNWdCO1FBR0osaUJBTE00Z0IsS0FFRjVnQixZQUVBeStDO1FBQ0osT0FMTTc5QjtRQUNLLFNBRExBO1FBS04sWUFFMkMsT0FQckNBLE9BTzZDO2VBRWpEcUMsT0FBT3JDLEVBQUVtd0I7UUFDQSxJQUFQd3pCLEtBQU8sZ0JBREYzakQsS0FBRW13QjtRQUNBLFNBQ0g0ekI7VTNDbktmO1UyQ21LK0I7O2tCQUVSajVELGdCQUFIekUsYUFBSjI5RDtpQkFITEwsU0FHS0s7Z0JBQ1MsMEJBREwzOUQsRUFKRjhwQztnQkFLTzt5QkFDRCxPQU5SbndCLGFBTVEsT0FGRGxWO3lCQUdjLFVBSHJCazVELEdBQUkzOUQsRUFHaUIsY0FIZHlFOzBCQU9OLE9BWERrVix5QkFJT2xWO2NBVW1CLFVBVjFCazVELEdBQUkzOUQsRUFVc0IsY0FWbkJ5RTtZQURILFNBV3lDO1FBQzlDO3FCQWZDa1YsRUFDTDJqRDtTQWVVLG1CQUFjLGlCQWhCbkIzakQsS0FlTDVnQjtRQUNVLHdCQWhCTDRnQixLQWVMNWdCLGdCQUNrQztlQTBCcENrbEIsS0FBS3RFLEVBQUVtd0I7UUFDRTs4QkFESm53QixLQUFFbXdCO1NBR2tCLGVBSHBCbndCLEVBcEJZMmpEO1NBdUJELHlCQUhYM2pEOzs7O2dCQWpCTzFnQixjQUFIK0csV0FBSjI5RDtlQUhZTCxTQUdaSztjQUNTLDBCQURMMzlELEVBaUJGOHBDO2NBaEJPOztpQkFFSSw0QkFIVDlwQztpQkFHUyxZQUtBLElBQUx5UyxhQUFLLE9BQUxBO2lCQUxLLFVBSE54Wjs7Ozs7O1VBRFYsZ0JBcUJ5QztlQXNCM0NzbEIsU0FBUzVFLEVBQUVtd0I7UUFDRjs4QkFEQW53QixLQUFFbXdCO1NBR2tCLGVBSHBCbndCLEVBcEJZMmpEO1NBdUJELHlCQUhYM2pEOzs7O2dCQWpCRzFnQixjQUFIK0csV0FBSjI5RDtlQUhnQkwsU0FHaEJLO2NBQ1MsMEJBREwzOUQsRUFpQkU4cEM7Y0FoQkc7O2lCQUVJLElBS1ZyM0IsRUFMVSxnQkFIVHpTO2lCQUdTLEdBS1Z5UztpQkFMVSxVQUhOeFo7Ozs7OztVQURWLFNBcUI2QztlQUUvQzBnRCxTQUFTaGdDLEVBQUVtd0I7UUFDRixJQUFQd3pCLEtBQU8sZ0JBREEzakQsS0FBRW13QjtRQUNGLFNBQ0hxTztVM0MzT2Y7VTJDMk9nQzs7a0JBRVhsL0MsZ0JBQUgrRyxhQUFKMjlEO2lCQUhITCxTQUdHSztnQkFDUywwQkFETDM5RCxFQUpFOHBDO2dCQUtHOzttQkFDVyw0QkFGaEI5cEM7bUJBRWdCO3FCQUdQLElBQUx5UyxhQUFRLFVBQVJBLEVBQVEsZUFMVHhaO21CQUVhLFlBRmJBOzs7Ozs7WUFESCxTQWFZO1FBQ0EsbUJBakJaMGdCLEVBQ1AyakQ7UUFnQlcsdUNBakJKM2pELHFCQWlCNkI7ZUFHdEN5K0IsUUFBUXorQixFQUFFbXdCLElBQUkyRztRQUNMLElBQVA2c0IsS0FBTyxnQkFERDNqRCxLQUFFbXdCO1FBQ0QsU0FDSDh6QjtVM0MvUGY7VTJDK1BnQzs7a0JBRVRuNUQsZ0JBQUh6RSxhQUFKMjlEO2lCQUhMTCxTQUdLSztnQkFDUywwQkFETDM5RCxFQUpEOHBDO2dCQUtNLHNCQUNELGdCQUZKOXBDLEVBSkQ4cEMsSUFBSTJHO2dCQUtFLFlBREZoc0M7Ozs7WUFESCxnQkFNNEI7UUFFakMsZ0JBWEVrVixFQUNOMmpELE1BVUksbUJBWEUzakQsS0FXTjVnQjtRQUFJO1VBR04sd0JBRkVtRzs7OztZQUljLElBQVp1K0QsVUFBWSxnQkFoQk4zekIsSUFBSTJHO1lBaUJkLGlCQWpCUTkyQixLQVdONWdCLGVBVkF1a0UsS0FlRUcsVUFKRnYrRDtZQUtGLE9BakJReWE7WUFnQlEsU0FoQlJBO1lBaUJSLFlBRTJDLE9BbkJuQ0E7VUFsQmUsV0FxQzRCO2VBRW5Eb0MsSUFBSXBDLEVBQUVtd0I7UUFDRzs4QkFETG53QixLQUFFbXdCO1NBV2MsZUFYaEJud0IsRUFDRjJqRDtTQVVVLHlCQVhSM2pEOztRQUVrQjs7Z0JBR1YxZ0IsY0FBSCtHLFdBQUoyOUQ7c0JBSkhMO2NBS1ksMEJBREx0OUQsRUFMSDhwQztjQU1RO3dCQURGN3dDOzs7O1VBRFYsU0FPbUM7ZUFFckM0a0UsT0FBSzVnRSxFQUFFMGM7UUFDVCxRQURTQSxLQUNULEtBUUloSCx1QkFSSjs7Y0FTQTVaOztVQUNFO1lBQVUsNkJBRlI0WixJQUNKNVo7WUFUb0I7O2dCQUlGO2lCQURIRTtpQkFBSCtHO2lCQUNNLHNCQUROQTtpQkFDbUIsd0JBRG5CQTtnQkFDbUI7O3VCQUVWeVMsYUFBUnRKO21CQUFhLFdBUG5CbE0sRUFPTWtNLEVBQVFzSjs7Ozs7O2dCQUZILFVBREh4Wjs7dUJBTWZGOzs7O1FBckJ3QixRQXVCcEI7ZUFFRnNrQixLQUFLcGdCLEVBQUUwYyxFQUFFako7UUFDWCxRQURTaUosS0FDVCxVQURXakosTUFDWCxLQVVJaUMsdUJBVko7O2NBWUE1Wjs7VUFDRTs7a0JBRkVzUDthQUVnQixxQkFIaEJzSyxJQUVKNVo7YUFaa0I2RjthQUFFc0Q7WUFDbEI7aUJBRGdCdEQ7Z0JBS1c7aUJBRGQzRixLQUpHMkY7aUJBSU5vQixFQUpNcEI7aUJBS1csc0JBRGpCb0I7aUJBQzhCLHdCQUQ5QkE7Z0JBQzhCOzs7bUJBRW5CeVM7bUJBQVJ0SjttQkFQSy9HLE9BT1EsV0FSckJuRixFQVFRa00sRUFBUXNKLEVBUEh2UTs7Ozs7O2dCbkMyTmxCLGtCbUMzTmtCRTtnQkFLUyxJQUxYeEQsRUFJSDNGLEtBSktpSjs7Y0FXaEJtRyxZQVhnQm5HO3VCQVlwQm5KOzs7O1FBR0EsT0FKSXNQLFNBSUM7ZUFFSHF3QyxtQkFBbUJ6N0MsRUFBRTBjO1FBQ3ZCLFNBQVE0K0I7VTNDaFVmO1UyQ2dVMkI7O2NBSVI7ZUFESXQvQztlQUFIK0c7ZUFBSjI5RDtlQUNHLHNCQURDMzlEO2VBQ1ksd0JBRFpBO2NBQ1k7O2lCQUlULElBREt5UyxhQUFSdEosV0FDRyxtQkFUS2xNLEVBUVJrTSxFQUFRc0o7aUJBQ0w7bUJBSUYsSUFER3FyRDttQkFDSCxnQkFURDk5RCxFQUlBbUosRUFJSTIwRDttQkFFUyxVQVZqQkgsR0FBSTM5RCxFQVVhLFVBVlYvRztpQkFLQSxZQUxBQTs7Y0FDSixZQURJQTs7WUFEVixTQVdtQztRQWJ6QyxNQUR1QjBnQixLQUN2QixLQWVJbEgscUJBZko7O2NBZ0JBMVo7VUFDRTtZQUFTLG1CQUFVLGlCQUZqQjBaLEVBQ0oxWjtZQUNFLGlCQUZFMFosRUFDSjFaO1lBQ1csU0FEWEE7OztnQkFFSTtlQUVGb08sT0FBT3dTLEdBQUksT0FBSkEsSUFBVTtlQUViay9COzs7O1lBRWdCOzs7O3FCQUFUOW5DOztVQURGO2VBR1QrbkMsTUFBTW4vQjtRQUNSO2NBRFFBO1NBQ1I7U0FDRTs7cUJBQXFCeUYsRUFBRXhnQixHQUFXLFdBQWJ3Z0IsRUFBYSxnQkFBWHhnQixHQUE4QjtTQUFyRCxxQkFERW02QztTQUNGLEtBRk1wL0I7UUFJUjttQkFDTy9hO1lBQ00sSUFBSk0sRUFBSSxnQkFETk47WUFFVyxPQUpkbzZDLE1BR0s5NUMsU0FDUyxpQkFKZDg1QyxNQUdLOTVDLGlCQUNzQjs7UUFIL0IsVUFKUXlhLHFCQUNKby9CLElBRUFDLE1BU3dCO2VBRXRCK2tCOzs7O2dCQUVPOWtFLGdCQUFIK0c7WUFBYyxtQkFBZEE7Y0FDTixnREFEUy9HOzs7VUFERjtlQUtUK2tFLFlBQVlya0Q7UUFDZDs7Y0FEY0E7U0FDZDtTQUVFOztxQkFBcUJ5RixFQUFFeGdCLEdBQVcsV0FBYndnQixFQUFhLHNCQUFYeGdCLEdBQW9DO1NBQTNELHFCQURFbTZDO1NBQ0YsS0FIWXAvQjtRQUtkO21CQUNPL2E7WUFDTSxJQUFKTSxFQUFJLHNCQUROTjtZQUNNLFVBTlRzSSxVQU1LaEk7WUFFUyxPQUxkODVDLE1BR0s5NUMsU0FFUyxpQkFMZDg1QyxNQUdLOTVDLGlCQUVzQjs7UUFKL0IsVUFKSWdJLFFBRFV5UyxnQkFFVm8vQixJQUVBQyxNQVV3QjtlQUUxQno1QixPQUFPaEs7UUFHVCxJQUFJMmpDLFNBSEszakM7UUFHVCxTQUVRaEwsSUFBSXhSLEVBQUVvZ0Q7Y0FBRmg2QyxNQUFFaTZDO1VBQVU7ZUFBVkE7Y0FNSTtlQURGMzBDLEtBTEYyMEM7ZUFLRHA1QyxFQUxDbzVDO2VBTUksc0JBRExwNUM7ZUFDa0Isd0JBRGxCQTtjQUNrQjs7cUJBRU44ZixnQkFBVmdxQjtpQkFDb0I7NEJBRHBCQSxJQUFVaHFCO3dDM0MzWWhDLE8yQ21ZZXZWLElBQUlwTCxJQUtJc0Y7Y0FDRSxJQU5KMjBDLE9BS0UzMEM7O1lBSFYsR0FGTXRGLFFBRlIrNUM7WUFNZ0I7cUNBTmhCQSxTQUVRLzVDO2FBSVEsSUFKUkE7O2FBQUVpNkM7cUJBVUw7UUFaVDs4QjNDallQLE8yQ21ZZTd1QyxvQkFZRztlQUVUK3VDLFlBQVlsNkI7UUFBZ0IsZ0JBQWhCQTtRQUFnQixvQjNDalpyQztRMkNpWnFDLHNCM0NqWnJDLE9XNEJTN2Esb0JnQ3FYc0M7ZUFFdENnMUMsY0FBY242QjtRQUFnQixnQkFBaEJBO1FBQWdCLG9CM0NuWnZDO1EyQ21adUMsc0IzQ25adkMsT1c0QlM3YSxvQmdDdVh3QztlQUV4QzRhLFFBQVE1SixJQUFJeGM7UUFDZDs7bUJBQVMscUNBREN3YyxJQUNLcE0sRUFBRXBJLEVBQWtCO2lCQURyQmhJLEVBQ3VCO2VBRW5DMGdELFlBQVlsa0MsSUFBSXhjO1FBQ2xCOzttQkFBUyx5Q0FES3djLElBQ0NwTSxFQUFFcEksRUFBc0I7aUJBRHJCaEksRUFDdUI7ZUFFdkNzbUIsT0FBT3RtQixHQUNDLElBQU53YyxJQUFNLGFBQ1YsWUFESUEsSUFES3hjLEdBRVQsT0FESXdjLEdBRUQ7O2NBdFZEcUU7Y0FLQTJIO2NBT0FnRjtjQVNBcXpCO2NBMkRBLytCO2NBU0FtQjtjQTBDQWlDO2NBeUJBTTtjQUtBbzdCO2NBb0JBdkI7Y0FxQkFyOEI7Y0FhQThoRDtjQWdDQW5sQjtjQWxCQXI3QjtjQXVDQWxXO2NBTUEyeEM7Y0FvQ0F2NUI7Y0FtQkErNUI7Y0FFQUM7Y0FFQXA2QjtjQUdBczZCO2NBR0FwNkI7Y0F6VEFrK0M7Y0E0UUFTO2FBbUVGQyxnQkFBd0IsMkJBQWU7YUFFdkNDLFFBQVMvcUQsR0FBbUMseUJBQW5DQSxJQUF1RDthQUNoRWdyRCxhQUFjaHJELEdBQW1DLHlCQUFuQ0EsSUFBNEQ7YUFDMUVpckQsUUFBU2pyRCxFQUFjaEssR0FBZSx5QkFBN0JnSyxJQUFjaEssRUFBOEM7YUFDckVrMUQsVUFBV2xyRCxHQUFzQix5QkFBdEJBLElBQTBDO2FBQ3JEbXJELFVBQVduckQsR0FBc0IseUJBQXRCQSxJQUEwQzthQUVyRG9yRCxTQUFVdjFELEdBQWVGLElBQzNCLHlCQURZRSxLQUFlRixPQUNBO2FBRXpCMDFELFdBQVVyckQsR0FBbUMseUJBQW5DQSxFQUFzRDthQUNoRXNyRCxjQUFldHJELEdBQW1DLDBCQUFuQ0EsRUFBMkQ7YUFDMUV1ckQsU0FBVXZyRCxFQUFjVixHQUFlLDBCQUE3QlUsRUFBY1YsRUFBNkM7YUFDckVrc0QsV0FBWXhyRCxHQUFzQiwwQkFBdEJBLEVBQXlDO2FBQ3JEeXJELFdBQVl6ckQsR0FBc0IsMEJBQXRCQSxFQUF5QzthQUNyRDByRCxVQUFXNzFELEdBQWNGLElBQXNCLDBCQUFwQ0UsR0FBY0YsR0FBNEM7O2VBTWpFOFEsT0FBT3pRLEVBQUVzSjtRQUNILElBQUp6UyxFQUFJLFlBQ1IsU0FESUEsRUFET3lTLEdBR1gsUUFGSXpTLEVBREttSixHQUdULE9BRkluSixDQUdIO1VBQ0NpSDtlQUNBbEIsTUFBTS9GLEVBQUVtSjtRQUdKLGtCQUhFbko7UUFHRixVQUdGLElBREdvSixhQUNBLHVCQU5HRCxFQUtIQztRQURHLFFBRTBEO2VBR2xFMDFELGFBQWE5K0QsRUFBRW1KLEVBQUVzSjtRQUNuQixXQURlelMsR0FFZixRQUZlQSxFQUFFbUosR0FFakIsZ0JBRmVuSixFQUFJeVMsRUFHUDs7a0JBbEJWbUgsT0FLQTNTLEtBQ0FsQixNQWpCSnk0RCxXQVRBTixRQW1DSVksYUEvQkpSOztNM0N2YlAsSTJDaWVhdjREO2VBQ0FrQixLQUFNb3NDLEtBQVk5MUMsR0FBSSx1QkFBSkEsRUFBWTs7K0JBRDlCd0ksTUFDQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaGRWczJEO09BQ0FTOztlQWlkTXBrRCxPQUFPaWdDLElBQUssNEJBQUxBLEdBQTRCOztjQUFuQ2pnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQWxkTjJqRDtjQUNBUzthQXlkSWUsZ0JBQTZCLDJCQUFlO2FBRTVDQyxTQUFVN3JELEdBQXlDLHlCQUF6Q0EsSUFBNkQ7YUFDdkU4ckQsY0FBZTlyRCxHQUNULHlCQURTQSxJQUNnQjthQUMvQityRCxTQUFVL3JELEVBQW1CaEssR0FDL0IseUJBRFlnSyxJQUFtQmhLLEVBQ0E7YUFDN0JnMkQsV0FBWWhzRCxHQUEyQix5QkFBM0JBLElBQStDO2FBQzNEaXNELFdBQVlqc0QsR0FBMkIseUJBQTNCQSxJQUErQzthQUUzRGtzRCxTQUFVbHNELEdBQXlDLHlCQUF6Q0EsSUFBNkQ7YUFDdkVtc0QsY0FBZW5zRCxHQUNULHlCQURTQSxJQUNnQjthQUMvQm9zRCxTQUFVcHNELEVBQW1CaEssR0FDL0IseUJBRFlnSyxJQUFtQmhLLEVBQ0E7YUFDN0JxMkQsV0FBWXJzRCxHQUEyQix5QkFBM0JBLElBQStDO2FBQzNEc3NELFdBQVl0c0QsR0FBMkIseUJBQTNCQSxJQUErQzthQUczRHVzRCxVQUFXMTJELEdBQWlCRixJQUM5Qix5QkFEYUUsS0FBaUJGLE9BQ0g7YUFDekI2MkQsVUFBVzMyRCxHQUFpQkYsSUFDOUIseUJBRGFFLEtBQWlCRixPQUNIO2FBQ3pCODJELFdBQVk1MkQsR0FBbUJGLElBQ2pDLHlCQURjRSxLQUFtQkYsT0FDTjthQUV6QisyRCxXQUFVMXNELEdBQXdDLHlCQUF4Q0EsRUFBMkQ7YUFDckUyc0QsZ0JBQWUzc0QsR0FDVCwwQkFEU0EsRUFDZTthQUM5QjRzRCxXQUFVNXNELEVBQW1CVixHQUMvQiwwQkFEWVUsRUFBbUJWLEVBQ0Q7YUFDNUJ1dEQsYUFBWTdzRCxHQUEyQiwwQkFBM0JBLEVBQThDO2FBQzFEOHNELGFBQVk5c0QsR0FBMkIsMEJBQTNCQSxFQUE4QzthQUMxRCtzRCxZQUFXbDNELEdBQWdCRixJQUF3QiwwQkFBeENFLEdBQWdCRixHQUE4Qzs7ZUFRckU4USxhQUFlbkg7UUFDVCxJQURLbWxDLFlBQUhGLFlBQ0Y7UUFDUixXQURJMTNDLEVBRGF5UztRQUdqQixTQUZJelMsRUFETTAzQztRQUdLLFNBRlgxM0MsRUFEUzQzQztRQUdFLE9BRlg1M0M7ZUFJRmlILEtBQUtvc0M7UUFDVztTQURGdUU7U0FBSEY7U0FDSyxzQkFEWHJFLEtBQVN1RTtRQUNoQix3QkFET3ZFLEtBQU1xRTtlQUVYM3hDLE1BQU0vRjtRQUNGLElBRFE0M0MsWUFBSEYsWUFDTCxlQURFMTNDLEdBQ1UsaUJBRFZBO1FBQ1U7O2VBRURtZ0UsZ0JBQVZDO1dBQ0Esb0JBSkkxb0IsR0FHSjBvQixTQUNtQixpQkFKWnhvQixHQUdHdW9CO1dBRWdCO1FBSFQ7ZUFLdEJqQyxRQUFRbCtEO1FBQ0osbUJBRElBLEdBQ1EsaUJBRFJBO1FBQ1E7eUJBRUQ0M0MsY0FBVkYsNEJBQVVFO1FBRE8sUUFDZTtlQUNyQ2tuQixhQUFhOStELFFBQVV5UztZQUFKbWxDLFlBQUhGO1FBQ2xCLGFBRGUxM0M7UUFFZixTQUZlQSxFQUFHMDNDO1FBRUgsU0FGQTEzQyxFQUFNNDNDO1FBRU4sa0JBRkE1M0MsRUFBVXlTO2VBSXZCNnJELFVBQVV0K0Q7UUFBSSxvQkFBSkEsR0FBSSxZQS9DbEJ5L0QsV0ErQ2N6L0QsT0FBZ0M7O2tCQXRCMUM0WixPQUtBM1MsS0FFQWxCLE1BdEJKODVELFdBNkJJM0IsUUFJQVksYUFJQVI7O00zQzNpQlgsSTJDeWpCZXY0RDtlQUNBa0IsS0FBTW9zQyxLQUFZOTFDLEdBQUksd0JBQUpBLEVBQWE7VUFOL0J3SixzQkFLQWhCLE1BQ0FrQjtlQUxBc0osT0FBTThpQyxLQUFZOTFDLEdBQUksd0JBQUpBLEVBQWE7OytCQUQvQndKLFFBQ0F3Sjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW5pQlpndEQ7T0FDQVM7O2VBeWlCTXBrRCxPQUFPaWdDLElBQUssNEJBQUxBLEdBQTRCOztjQUFuQ2pnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQTFpQk4yakQ7Y0FDQVM7YUFpakJJcUMsU0FBTzNoRSxHQUFnQix5QkFBaEJBLEVBQStCO2FBQ3RDNGhFLFNBQVFuM0QsR0FBcUIseUJBQXJCQSxFQUFvQzthQUU1Q28zRCxVQUFTcHRELEVBQWN6VSxHQUE2Qix5QkFBM0N5VSxFQUFjelUsRUFBaUQ7YUFDeEU4aEUsZUFBY3J0RCxFQUFjelUsR0FDdEIseUJBRFF5VSxFQUFjelUsRUFDRzthQUMvQitoRSxVQUFTdHRELEVBQWN6VSxFQUFReUssR0FDakMseUJBRFdnSyxFQUFjelUsRUFBUXlLLEVBQ0Y7YUFDN0J1M0QsWUFBV3Z0RCxFQUFjelUsR0FBZ0IseUJBQTlCeVUsRUFBY3pVLEVBQW9DO2FBQzdEaWlFLFlBQVd4dEQsRUFBY3pVLEdBQWdCLHlCQUE5QnlVLEVBQWN6VSxFQUFvQzthQUU3RGtpRSxXQUFVNTNELEdBQWU2M0QsR0FBUy8zRCxHQUFlZzRELEdBQVM1aEU7TUFDNUQseUJBRFk4SixHQUFlNjNELEdBQVMvM0QsR0FBZWc0RCxHQUFTNWhFLEVBQy9CO2FBRTNCNmhFLFdBQVU1dEQsR0FBbUMseUJBQW5DQSxFQUFzRDthQUNoRTZ0RCxnQkFBZTd0RCxHQUFtQywwQkFBbkNBLEVBQTJEO2FBQzFFOHRELFdBQVU5dEQsRUFBY1YsR0FBZSwwQkFBN0JVLEVBQWNWLEVBQTZDO2FBQ3JFeXVELGFBQVkvdEQsR0FBc0IsMEJBQXRCQSxFQUF5QzthQUNyRGd1RCxhQUFZaHVELEdBQXNCLDBCQUF0QkEsRUFBeUM7YUFDckRpdUQsWUFBV3A0RCxHQUFjRixJQUFzQiwwQkFBcENFLEdBQWNGLEdBQTRDOztlQU1qRThRLE9BQU96USxFQUFFc0o7UUFDSCxJQUFKelMsRUFBSSxTQURDbUo7UUFFVCxXQURJbkosRUFET3lTO1FBQ0gsSUFDUixLQUZTdEoscUJBRVQ7O2NBQ0FwUTtVQUNFO3NCQUhFaUgsRUFFSmpILEVBQ2MsaUJBSkxvUSxFQUdUcFE7WUFDRSxTQURGQTs7O1FBR0EsT0FMSWlILENBS0g7ZUFDQ2lILEtBQUtvc0MsS0FBS2xxQztRQUNaLGlCQURZQSxxQkFDWjs7Y0FDQXBRO1VBQ0U7cUJBRkU0Z0IsS0FFZSxzQkFIUHhRLEVBRVpwUTtZQUNPLHdCQUhBczZDO1lBR0wsU0FERnQ2Qzs7O1FBR0EsT0FKSTRnQixJQUlGO2VBQ0E1VCxNQUtzQi9GLEVBQUZtSjtRQUp0QixRQUlzQkEsYUFIWCxlQUdhbko7UUFIYixHQURQVyxRQUNBYztRQURKLElBSUUsSUFKRWQsWUFJc0I1SDtRQUN0QjtrQkFEc0JBO1lBR2Qsb0JBSFlpSCxFQUFFakg7WUFHZDtjQUdGLGdCQUFXLHNCQU5Db1EsRUFBSXBRO2NBTWIsd0JBREFzb0UsS0FFRSxRQVBXdG9FO2NBUVg7WUFKQztVQUhFLFNBU087ZUFFdkJtbEUsUUFBUWwrRDtRQUNBLElBQU5XLElBQU0sU0FEQVg7UUFDQSxTQUFOVztRQUFNLFVBR0YsVUFKRVg7UUFJRjtVQUdGLGlDQU5GVyxJQUtLMmdFLElBQ0gsSUFORjNnRSxZQU1pQjVIO1VBQ2I7b0JBRGFBO2NBR0wsc0JBVk5pSCxFQU9Xakg7Y0FHTDtnQkFHRixJQURHc29FO2dCQUNILGlCQU5LaGhFLEVBQUV0SCxZQUtKc29FO2dCQUNILFFBTk90b0U7O2NBSUQ7WUFIRSxVQURIc0g7UUFGUCxRQVlRO2VBQ2xCeStELGFBQWE5K0QsRUFBRW1KLEVBQUVzSjtRQUNuQixhQURlelM7UUFDZixTQURpQm1KLHFCQUNqQjs7Y0FDQXBRO1VBQ0U7c0JBSGFpSCxFQUVmakgsRUFDYyxpQkFIR29RLEVBRWpCcFE7WUFDRSxTQURGQTs7O1FBR0Esa0JBTGVpSCxFQUFJeVMsRUFLUDtlQUNWNnJELFVBQVV0K0Q7UUFHSCxpQkFIR0EsV0FDSWpIO1FBQ2Q7bUJBRGNBO1VBQ2Q7OztZQUFVLHFCQUZBaUgsRUFDSWpIO1lBQ0osYUFESW9HO1lBQ0o7VUFEWixZQUVzQjs7a0JBekRwQnlhLE9BT0EzUyxLQU1BbEIsTUF4QkpnN0QsV0F5Q0k3QyxRQWtCQVksYUFNQVI7O00zQ25wQlgsSTJDNnBCYXY0RDtlQUNBa0IsS0FBTW9zQyxLQUFZOTFDLEdBQUksdUJBQUpBLEVBQVk7OytCQUQ5QndJLE1BQ0FrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTVvQlZzMkQ7T0FDQVM7O2VBNm9CTXBrRCxPQUFPaWdDLElBQUssNEJBQUxBLEdBQTRCOztjQUFuQ2pnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQTlvQk4yakQ7Y0FDQVM7Ozs7O1FBOFpJQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUdBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQzs7OztRQTJDQUU7UUFFQUM7UUFDQUM7UUFFQUM7UUFFQUM7UUFDQUM7UUFFQUM7UUFDQUM7UUFFQUM7UUFFQUM7UUFDQUM7UUFHQUM7UUFFQUM7UUFFQUM7UUFHQUM7UUFDQUM7UUFFQUM7UUFFQUM7UUFDQUM7UUFDQUM7Ozs7UUF1REFHO1FBR0FFO1FBQ0FDO1FBRUFDO1FBRUFDO1FBQ0FDO1FBRUFDO1FBR0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDOzs7OztVM0N2bEJQOzs7YU1vQ0tHLGlCQUFpQkMsV0FBV3JwRSxpQkFBaUI0SDtNQVU1QyxxQkFWNENBLG9CQUFqQjVIO01BWXpCLDhCQVowQzRILGNBQzlCckI7TUFDZjtnQkFEZUE7VUFFUCxjQUhTOGlFLFdBQTRCemhFLEtBQzlCckIsSUFFZ0IsUUFGaEJBO1VBR1YsTUFIVUEsVUFJSmdKLElBSkloSjtVQUtmO29CQURXZ0o7Y0FFSCxjQVBTODVELFdBQTRCemhFLEtBS2xDMkg7c0JBRW9CLE1BUGMzSCxLQUtsQzJILGFBQUVjLElBQUZkO2NBR04sUUFITUE7O1lBQ0csYUFOK0IzSCxPQUtoQ3lJO1FBSEMsYUFGK0J6SSxVQVlUO2FBTXBDMGhFLGdCQUFnQkQsV0FBV3JwRSxpQkFBaUI0SDtNQWMzQyxxQkFkMkNBLG9CQUFqQjVIO01BZ0J4Qiw4QkFoQnlDNEgsY0FDekJyQjtNQUNuQjtnQkFEbUJBO1VBRVgsY0FIUThpRSxXQUE0QnpoRSxLQUN6QnJCLElBRVksUUFGWkE7Y0FJWmdKLElBSlloSjtVQUtuQjtvQkFET2dKO2NBRUMsY0FQUTg1RCxXQUE0QnpoRSxLQUtyQzJIO29CQUlZbXlELElBSlpueUQ7Z0JBS1A7MEJBRG1CbXlEO29CQUVYLGNBWFEySCxXQUE0QnpoRSxLQVN6Qjg1RDtzQkFFWSxRQUZaQTtvQkFHZCxhQVp1Qzk1RCxPQVN6Qjg1RDtrQkFDTCxhQVY4Qjk1RDtjQVF2QyxRQUhFMkg7O1lBQ08sT0FOYXZQO1FBRWIsYUFGOEI0SCxVQWdCSjthQU10Q3loRSxXQUFXcGtFLEVBQUVyRSxHQUFJLDhCQUFOcUUsRUFBRXJFLE1BQWU7YUFDNUIyb0UsWUFBWWhqRTtNQUFJO2tDQUFKQTtPQUFJLHFCQUF1QixnQkFBM0JBO2lCQUF1QzthQUNuRGlqRSxZQUFZampFO01BQ2QscUJBRGNBO01BQ2Q7O29DQURjQTtzQkFFNkIscUJBQWhCLE1BRmJBO1FBRXFDOztxQ0FGckNBO3VCQUdhLDJCQUhiQTs7Ozs7TUFESSxXQUltQzthQUNuRGtqRSxhQUFhN2hFLEtBQUs4aEU7TUFDcEI7a0NBRG9CQSxTQUNwQixzQkFEZTloRTtPQUNmOztVQUNBOztjQUZlQTtrRUFBSzhoRTs7OztNQUhwQixXQU0yQzs7TUFFdkM7Ozs7O0lBQ00sU0ErRVJDLE1Bdkp1QjFrRTtNQUMzQiw0QkFEMkJBLEdBRW5CLFdBREo4QjtNQUVKLFNBRElOO01BREosSUFFQSxLQUZJTSxVQUVKOztZQUNBbkc7UUFDRTtVQUFHLDBCQUxzQnFFLEVBSTNCckU7V0FFTyxXQUpINkYsRUFGWXRHOztXQU9ULFNBTEhzRyxFQUtzQixnQkFQQ3hCLEVBSTNCckU7VUFHK0IsU0FIL0JBOzs7TUFLQSxTQVBJNkY7TUFPSixnQkFQSUE7SUF1RVcsU0FBWG1qRTtNTnpGUCxPTW9DS1IsaUJBd0NFQyxXQUhBcnBFO0lBaUJVLFNBQVY2cEU7TU4xRlAsT01zREtQLGdCQXNCRUQsV0FIQXJwRTtJQWlCVSxTQU9WOHBFLGFBQVc3a0UsRUFBRXJFO01BQUksc0JBQU5xRSxFQUFFckUsR0FBSSxZQUFJaUg7TUFBSjs7O3VCQUFJQTtpQkFBMkM7SUFQdEQsU0FRVmtpRSxjQUFZeGpFO01BQ2Q7a0NBRGNBO09BQ2QscUJBQXdCLGdCQURWQTs7Ozs4QkFFYSxnQkFGYkE7Ozs7K0JBR2EsZ0JBSGJBOzs7OztpQkFHMEI7SUFYNUIsU0FZVnlqRSxjQUFZempFO01BQ2QsdUJBRGNBO01BQ2Q7O29DQURjQTtzQkFFNkIscUJBQWhCLE1BRmJBO1FBRXFDOztzQ0FGckNBO3dCQUc2QixxQkFBaEIsTUFIYkE7VUFHc0M7O3dDQUh0Q0E7MEJBSTZCLHFCQUFoQixNQUpiQTtZQUlzQzs7eUNBSnRDQTsyQkFLYSwyQkFMYkE7Ozs7Ozs7OztNQUhkLFdBUXNEO0lBakIxQyxTQWtCVjBqRSxlQUFhcmlFLEtBQUs4aEU7TUFDckIsK0JBRHFCQSxTQUNyQixzQkFEZ0I5aEU7TUFDaEI7T0FDUzs7O1dBRk9BOytEQUFLOGhFOztRQUlPLHVCQUpQQTthQUlwQixvQ0FGSXprRTs7O01BUEosV0FTdUQ7SUF0QjNDO01Bd0JSLG1DQURGaWxFOzs7OzthQUVBQyxRQUFNbGxFO01BQ1IsNEJBRFFBLEdBRUEsV0FESjhCO01BRUosU0FESU47TUFDSixTQWlCSTJqRSxPQUFPN2pFO1FBQUk7Y0FBSkE7Y0FBSTRNO1VBQW1CO3FCQWxCOUIxTTtZQWtCOEIsU0FBbkIwTTtlQUFKNU0sTUFBSTRNOztRQW5CZixRQW1COEQ7TUFqQjlELFNBQ1FrM0QsZUFBS3pwRTtRTnZIbEIsSU11SGtCb0c7UUFDWDthQURXQSxRQUhURCxTQUlZLFNBSFpOO1VBSUksSUFHSm9CLEVBSEksZ0JBTkE1QyxFQUlLK0I7VUFFTCxVQUdKYTtZQUZROzs7cUJBR1J5aUUsdUJBTlN0akU7MENBTVRzakUsZ0JBTlN0akU7b0JBS1RhO1lBRFE7OztxQkFFUnlpRSx1QkFOU3RqRTswQ0FNVHNqRSxnQkFOU3RqRTtVQUtELFNBUFJQLEVBT0FvQjtVQUhJLElBR0ksSUFMQ2I7bUJBSytCO01BTjVDLFNBT0lzakUsZ0JBQVEvakUsRUFBRTNGO1lBQUZ5TyxNQUFFckk7UUFDWjthQURZQSxRQVRWRCxHQVdBLFNBVkFOLE1BVUEsY0FGUTRJO1VBS0YsMEJBZkZwSyxFQVVNK0I7VUFLSjtZQUNJLFlBTkZxSTtZQU1rQixTQWQxQjVJO1lBYzBCLFNBTmhCTztZQU1nQjttREFadEJxakU7OztZQWFNLFFBUEFyakUsWUFPQSxJQVBGcUksb0JBQUVySTtVQVFBLE9BUkZxSTtVQVFFO2lEQWROZzdELGlCQU1NcmpFO3dDQU5OcWpFLFVBTU1yakUsTUFTVDtNQWhCTCxTQUNRc3VDLEtBQUsxMEMsR052SGxCLHVCTXVIYXlwRSxTQUFLenBFO01Ba0JiO3NCQXBCSTZGLEVBcUJhO2FBT2Y4akUsZUFBZXRsRTtNQUxqQixvQ0FLaUJBO01BTGpCO09BSWtDOzhCQUNqQkE7UUFMRDtRRTZYWjt5QkZ6WHVDLGdCQUMxQkE7Ozs7UUFFTyxlQUZQQSxJQUVaLHNCQUZZQTtRQUVYLGdCQUZXQTtNQUdaLGlCQUhZQSxFQUdMO2FBQ1Z1bEUsVUFBUXZsRTtNQUNVOzRCQURWQTtPQUNVOztPQUNWLG9CQXREUjZrRSxhQUhBMXBFLG1CQXdEVXFxRTtNQUNGLFdBRExDLE1BQ0RDLElBQ087YUFDVEMsV0FBUzNsRTtNQUNVLHlCQURWQSxHQUNVOzhCQXpEbkI2a0UsYUFIQTFwRSxtQkE0RFdxcUUsS0FDb0M7SUFhcEMsU0FBWEk7TU54S1AsT01vQ0t6QixpQkE2REVVLGFBOERBdnBFO0lBVVUsU0FBVnVxRTtNTnpLUCxPTXNES3hCLGdCQTJDRVEsYUE4REF2cEU7SUFVVTs7O09BR1h3cUUsbUJBbkdDL3FFO09BbUdpQmdyRSxrQkFsR2pCL3FFO09Ba0drQ2dyRSxVQWpHbEMvcUU7T0FpRzJDZ3JFLGFBaEczQzdCO09BaUdEOEIsY0FoR0M1QjtPQWdHWTZCLGNBL0ZaNUI7T0ErRnlCNkIsZUEzRnpCNUI7T0EyRnVDNkI7T0FBZUMsUUFOdEQ1QjtPQU02RDZCLFdBcEY3RDVCO09BcUZENkIsVUFwRkM1Qjs7Ozs7O1NBSUF6cEU7U0FDQUM7U0FDQUM7U0FDQXdwRTtTQUNBQztTQUlBQztTQU1BQztTQUtBQztTQUVBQztTQXNDQVM7U0FKQUo7Ozs7OztRQVVBanFFO1FBQ0FDO1FBQ0FDO1FBaEVBcXBFO1FBQ0FDO1FBSUFDO1FBTUFDOztRQTJEQU47UUFDQWtCO1FBQ0FDOztJRWdXRTs7TUY3VkhDO01BQWtCQztNQUFpQkM7TUFBU0MsYUEzRTNDcEI7TUE0RURxQixjQTNFQ3BCO01BMkVZcUIsY0F2RVpwQjtNQXVFeUJxQixlQWpFekJwQjtNQWlFdUNxQjtNQUFlQztNQUFPQztNQUM5REM7YUFrQkRDLFNBQU83QixRQUFReHZCO01BQ2pCLElBQUl0ekMsRUFBSixzQkFEUzhpRTtNQUNULFNBQUk5aUU7WUFDUSxhQUZIOGlFLFFBQ0w5aUU7ZUFHVyxJQUpOOGlFLFFBSU0sSUF4QnVCb0IsVUFvQnJCNXdCO01BR1osV0FISXd2QixRQUFReHZCLFNBSWdCO2FBRS9Cc3hCLFlBQVkvakUsS0FBSzhoRTtNQUNuQixJQUFJbmpFLEVBQUosc0JBRGNxQixRQUNkLHNCQURtQjhoRTtNQUNuQixZQUFJbmpFLEVBQ2tELE1BRnhDcUIsT0FDVnJCLEdBQ1UscUNBQTJEO2FBRXZFcWxFLGNBQWNoa0U7TUFDaEIsOEJBRGdCQSxjQU1HMkw7TUFDakI7Z0JBRGlCQTtjQUNMLGFBUEUzTCxLQU1HMkw7V0FFVCwwQkFSTTNMLEtBTUcyTDthQUVXLFFBRlhBLFlBTEYzUzthQUNmO3VCQURlQTtxQkFDSCxhQUZFZ0gsS0FDQ2hIO2tCQUVQLDBCQUhNZ0gsS0FDQ2hIO29CQUVhLFFBRmJBO2tCQUdWLDZCQUpTZ0gsUUFNRzJMO2VBSmtCO1dBTzlCLFFBSFlBOztRQUNrQixTQUlGO2FBRWpDczRELFVBQVVqa0U7TUFDSixJQUFKYixFQUFJLGNBRElhO01BQ0osYUFBSmIsU0FDa0IsTUFGVmEsS0FFVSxzQkFGVkEsUUFDUmIsUUFDNEQ7YUFFOUQra0UsZUFBZWxrRTtNQUNULElBQUpiLEVBQUksY0FEU2E7TUFDVCxhQUFKYjtlQUNVO2VBQ1QsTUFIWWEsT0FHWixzQkFIWUEsUUFDYmIsTUFFMkM7YUFFN0NnbEUsaUJBQWlCbmtFO01BQ1gsSUFBSmIsRUFBSSxjQURXYTtNQUNYLGFBQUpiLEVBRGVhLEtBRUssTUFGTEEsT0FFSyxzQkFGTEEsUUFDZmIsTUFDOEQ7UUFLaEVpbEUsMkJOdk9MO2FNeU9LQyxlQUFlQyxTQUFTajdCLE9BQU9DO01BQ2pDO3lCQUhFODZCO09BR0Y7cUJBSEVBLHVCcUJoTkE5Z0QsaUJyQmdOQThnRDtPQUdRO01BQ00sZ0JBRkNFLFNBRUQseUJBRlVqN0IsT0FDdEJrN0IsSUFENkJqN0IsUUFFNEI7UUFHM0RrN0IseUJBakV5Q2Q7YUFtRXpDZSxrQkFBa0JwbkUsR0FBSSwyQkFBSkEsRUFBSSxRQUEwQjthQUNoRHFuRSx5QkFBdUIsT0FIdkJGLHdCQUc2QzthQUU3Q0csVUFBWTk1QixJQUFtQ3hCLE9BQU9DO01BQ3hELEdBRGN1QjtPQUFXLFFBQVhBLGdCQUFXcUM7O1dBQVhvM0IsU0FMWkU7TUFNRixTQUFRSSxTQUFTL25FO1FOcFBwQixJTW9Qb0I2bUM7UUFDZjtVQUFXLElBQVAxakMsS0FBTyxlQUZDc2tFLFNBQW1DajdCLE9BQU9DO1VBRTNDO1lBRTRELHVCQUEzRCxjQUZSdHBDO2dCQUlDc1I7OztjQUNILFdBTmFveUIsZ0JBS1ZweUI7Y0FDa0MsY0FOeEJveUI7O2tCQUtWcHlCLEdBQ3dEO01BTi9ELGtCQU9hO2FBRVh3ekQsZUFBaUJqNkIsY0FDbUN4QixPQUFPQztNQUM3RCxHQUZtQnVCLElBQU8sUUFBUEEsWUFBT3FDLGFBQVBwdEM7TUFFbkIsUUFGaUQsa0JBQVJrbEUsTUFBUUQsZUFBUkM7TUFFekM7T0FEOEIsa0JBQVhWLFNBQVdXOztXQUFYWCxTQWhCakJFO01BaUJGLFNBQVFJLFNBQVMvbkU7UU4vUHBCLElNK1BvQjZtQztRQUNmO1VBQVcsSUFBUDFqQyxLQUFPLGVBRk1za0UsU0FBbUNqN0IsT0FBT0M7VUFFaEQ7WUFHUixZQUhDdHBDLEtBR0QsNEJBTmNGLFFBQXNCa2xFLE1BR25DaGxFOztnQkFJQ3NSOzs7Y0FDSCxXQU5hb3lCLGdCQUtWcHlCO2NBQ2tDLGNBTnhCb3lCOztrQkFLVnB5QixHQUN3RDtNQU4vRCxrQkFPYTs7OztPQTFGVjZ4RDtPQUFrQkM7T0FBaUJDO09Bb0JwQ1M7T0FuQkNQO09BQWFDO09BQWFDO09BeUIzQk07T0FpQkFFO09BU0FFO09BTEFEO09BOUMrRE47T0FDOURDO09BcUVEYztPQVVBRztPQVpBSjtPQURBRDtPQW5FeUNmO09BQWVDOzthQ3JKeER1QixNQUFJMW5FLEVBQUVDLEdBQUksWUFBTkQsT0FBRUMsS0FBRkQsT0FBRUMsS0FBNEM7YUFFbEQwbkUsTUFBSTNuRSxFQUFFQyxHQUFJLFlBQU5ELE9BQUVDLEtBQUZELE9BQUVDLEtBQTRDO2FBRWxEMm5FLElBQUk1bkUsR0FBSSxjQUFKQSxZQUFrQzthQUV0QzZuRSxLQUFLN25FLEdBQUksWUFBSkEsWUFBK0I7YUFFcEM4bkUsSUFBSTluRSxFQUFFQztNQUFJLFlBQU5ELE9BQUVDLE9BQUZELE9BQUVDLEtBQUZELE9BQUVDLE9BQUZELE9BQUVDLEtBQ3lDO2FBRS9DOG5FLElBQUkvbkUsRUFBRUM7TUFDUixZQURRQSxTQUNSLFNBRFFBO1FBRU4sTUFGTUEsWUFFTixFQUZNQSxPQUVGa0UsSUFGRWxFO1FBRU4sYUFGSUQsT0FFQW1FLElBRkFuRSxRQUdBa1YsR0FIQWxWLE9BRUFtRSxJQUZBbkUsUUFHQWtWO01BSUosUUFQTWpWLFlBT04sSUFQTUEsT0FPRmllLE1BUEVqZTtNQU9OLGFBQUlpZSxNQVBBbGUsZUFRQW9WLEtBREE4SSxNQVBBbGUsZUFRQW9WLElBRTZCO2FBRWpDNHlELElBQUlob0UsR0FBSSxXQTFCUnpFLE1BMEJJeUUsRUFBYTthQUVqQmlvRSxNQUFNam9FLEdBQUksT0FBSkEseUJBQWdDO2FBRXRDa29FLEtBQUtsb0U7TUFFUCxlQUZPQSxNQUVQLFdBRk9BO01BRVAsR0FBSW1FLGVBQXVCM0k7TUFFdEIsR0FGc0JBLGVBQXZCMkk7TUFHQyxHQUhzQjNJLEtBQXZCMkksR0FJRixJQUFJcWdCLEVBSnFCaHBCLElBQXZCMkksRUFJcUIsT0FKckJBLElBSXFCLGVBQW5CcWdCO01BSk4sSUFNTTJqRCxJQU5GaGtFLElBQXVCM0k7TUFNRixPQU5FQSxJQU1GLGVBQW5CMnNFLFVBQXNDO2FBRTFDcHRELElBQUkvYSxHQUFJLGtCQUFKQSxVQUFtQjthQUV2Qm9vRSxNQUFNam5FLEVBQUUyQixHQUFXLHFCQUFYQSxLQUFGM0IsRUFBOEIsU0FBNUIyQixLQUFGM0IsRUFBMEM7YUFFaERrbkUsS0FBS3JvRTtNQUNQLEdBRE9BO01BRUYsZUFGRUEsTUFFRixXQUZFQTtNQUVGLEdBQ3dCeEUsS0FBdkIySTtPQUVhO1VBRlUzSSxJQUF2QjJJO1FBQ0F3eUIsRUFHQSxVQUpBeHlCLEtBSVcsc0JBQW9CLGVBRDNCcWdCOztPQUVHO1lBTFByZ0IsSUFBdUIzSTtRQUN2Qm03QixFQU1BLFVBUHVCbjdCLEtBT1osaUJBRFAyc0UsTUFDeUIsZUFEekJBO01BR1IsU0FaS25vRSxpQkFJRDIyQixRQUpDMzJCLE9BSUQyMkI7TUFGRCxJQUVDMnhDLFVBSkN0b0UsS0FJRDIyQjt3QkFEdUJuN0IsSUFDdkJtN0IsTUFXSDthQUVENHhDLElBQUl2b0U7TUFDTixJQUFJOFQsRUFBSixTQURNOVQsTUFDMEIsWUFBNUI4VCxJQUE0QixTQUQxQjlULE1BQ0Y4VCxJQUFnRCxTQUQ5QzlULE1BQ3dEO2FBRTVEd29FLElBQUl4b0U7TUFBOEIsb0JBQTlCQSxXQUF1QixxQkFBUixLQUFmQSxTQUErQzthQUVuRHlvRSxJQUFJem9FLEVBQUVDLEdBQVEsZUFBUkEsRUFBZSxJQUFqQkQsSUFBeUI7Ozs7T0FuRTdCMUU7T0FDQUM7T0FDQUM7T0FNQW9zRTtPQUVBQztPQU5BSDtPQUVBQztPQU1BRztPQWVBRTtPQVpBRDtPQThCQU07T0FoQkFKO09BRUFDO09BVUFudEQ7T0FFQXF0RDtPQW1CQUc7T0FHQUM7T0FFQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0dqRUE3K0Q7T0FJQTNIOzs7T0FGQTZIO09BTUE5SDtPQUlBK0g7T0FRQUs7T0FlQU07O09BUEEzSTtPQUVJc0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lrQ2xDTSxJQUFWcStELFFBQVU7YUFFVkMscUJBQXFCanBFLEdBQ3ZCLE9BSEVncEUsUUFHYyxXQURPaHBFLE1BQ0s7SUFIaEIsU0FrQlJrcEUsU0FBUXZEO01BQ1A7UUFDYSxxQkFGTkEsTUFHUixLQURJd0Q7UUFPSiwwQ0FMSWp6RDtRQUtKLE9BTElBO01BT0csVW5DNlBUelQsU21DelBHO0lBakNPLFNBdUNSMm1FLFdBQVlDLEtBQUtuekQsRUFBR296RDtNQUN0Qjs7aUJBQ0U7MEJBRllELEtBQUtuekQsS0FBR296RCxXQUVrQixFQUFDO0lBekMvQixTQStDUkMsZUFBZ0JGLEtBQUtuekQ7TUFDdkI7O2lCQUNFLEdBRnFCQSxLQUVKO2lCQUNqQiwwQ0FIZ0JtekQsS0FBS256RDtpQkFJckIsVUFKcUJBO2lCQUlyQjt5QkFDZ0IsRUFBQztJQXBEVCxjQWtCUmd6RCxTQXFCQUUsV0FRQUc7SUEvQ1EsU0E0RFJDLE9BQU1IO1VBQXNCRixpQkFBZk07YUExRGZSOztpQkE0REUsR0FGYVEsT0FFRTtpQkFDZjs7MEJBSE1KLEtBQXNCRixRQUlWO0lBaEVWLGdCQTREUks7SUE1RFEsU0F1RVZFLG1DQUFvQ0o7TUFDdEM7O2lCQUNFLGlEQUZvQ0EsV0FFVSxFQUFDO0lBekVyQzs7U0FBVk4sd0JBdUVBVTtJQXZFVTs7S0N5Q1ZDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0E3M0I7YUFFQTgzQjs7ZUFDVztlQUNBO2VBQ0k7ZUFDRTtlQUNEO2VBQ0U7ZUFDVDtlQUNBO2VBQ0Y7ZUFDTTtnQkFDQTtnQkFDQTtnQkFDTCxTQUFDO1FBS1RDLFdBQ0FDO2FBWUVDLEtBQUt0bkU7TUFDUCx1QkFET0EsR0FDUCxpQkFBSTNCLEtBQUosS0FBSUEsVUFBSjs7WUFFQTNGO1FBQW9CO1VBQVMsNkJBSHRCc0gsRUFHUHRIO1VBQW9CLGlCQURoQjBaLEVBQ0oxWjtVQUE2QixTQUE3QkE7OztNQUNBLE9BRkkwWixDQUVIO2FBT0NtMUQsY0FBY2g3RDtNQUMyQztpQkFEM0NBO09BQzJDO09BQXpCO3dDN0NwSHZDO002Q29ISyxtQ0FBb0IsYUFESkEsV0FDc0Q7b0JBWnBFKzZELEtBV0FDO2FBcUJBQyxTQUFPQyxLQUFLQyxRQUNkLHNCQURTRCxLQUFLQyxXQUNrQjthQUM5QkMsSUFBSXA3RCxLQUFNLG1DQUFOQSxRQUEyQjthQUMvQnE3RCxJQUFJcjdEO01BQU07NEI3QzNJakIsbUM2QzJJV0EsZUFBMkI7YUFPL0JzN0QsZ0JBQWN0N0Q7TUFBeUIsdUNBQXpCQSxLQUFtQzthQUtqRHU3RCxTQUFTTCxLQUFLQyxPQUFPaG5FO01BQ2YsSUFBSlYsRUFBSSxTQURHeW5FLEtBQUtDLFFBRWhCLGVBREkxbkUsR0FEbUJVLEdBRXZCLE9BRElWLENBRUg7YUFLQytuRSxTQUFPTixLQUFLQyxPQUFPTTtNQUNyQixzQkFEU1AsS0FBS0MsVUFBT00sS0FDYzthQWFqQ0MsZ0JBQWMxN0Q7TUFDaEIsdUJBRGdCQTtNQUNoQixtQ0FBb0IsYUFESkEsV0FDMkI7YUFHekMyN0QsTUFBZ0Jsb0UsRUFBMEIzQjtNQUN0QyxpQ0FEWTJCO01BQ1osbUJBQ1MsY0FGR0EsS0FBMEIzQixJQUd2QixjQUhIMkIsS0FBMEIzQixHQUc0QjthQUd0RThwRSxTQUFrQlYsS0FBTUMsT0FBa0Jqb0Q7TUFDbkM7bUJBRFdnb0QsS0FBTUMsT0FBa0Jqb0Q7T0FDbkMsVUFEaUJpb0Q7T0FPMUIsS0FQNENqb0Q7T0FPNUM7OztRQUFzQzs7WUFObEMyb0QsR0FNSjF2RSxJQUxJMkgsUUFLMEQsaUJBUGxCb2YsS0FPNUMvbUI7VUFBc0MsU0FBdENBOzs7TUFDQSxPQVBJMHZFLEVBT0Y7YUFLQUMsVUFBT1osS0FBS0MsT0FBT1ksS0FBS0M7TUFDMUIsc0JBRFNkLEtBQUtDLFVBQU9ZLEtBQUtDLE1BQ2dCO2FBZXhDQyxnQkFBY2o4RDtNQUNoQix1QkFEZ0JBLEtBQ2hCLG1CQURnQkE7TUFDaEI7MkNBQW9CLGFBREpBLGlCQUN5QzthQU92RGs4RCxXQUFXem9FLEVBQUUzQixHQUFJLHFCQUFOMkIsS0FBRTNCLEdBQStCO2FBQzVDcXFFLFlBQVkxb0UsRUFBRTNCLEdBQUkscUJBQU4yQixLQUFFM0IsR0FBZ0M7YUFHOUNzcUUsV0FBa0JsQixLQUFNQyxPQUFrQmpvRDtNQUM1QztZQUQ0Q0E7T0FDNUMsV0FBSTZvRCxPQUM0QyxpQkFGSjdvRDtPQUduQyxhQUhXZ29ELEtBQU1DLE9BQ3RCWSxLQUNBQztPQUNLLFVBSGlCYjtPQVMxQixLQVJJWTtPQVFKOzs7UUFDRTtjQUFJTSxJQUFKLGlCQVYwQ25wRCxLQVM1Qy9tQjtVQUNFLEdBQUlrd0UsbUJBUkZMO1dBVUE7VUFGRixJQUUrRCxLQVY3REEsYUFVNkQ7O2dCQUMvRHQ5RDtZQUNFOztnQkFYQW05RCxHQU1KMXZFLElBTEkySCxRQVNGNEssSUFURTVLLFFBVWtDLGlCQUpoQ3VvRSxJQUdKMzlEO2NBQ0UsU0FERkE7OztVQUhBLFNBREZ2Uzs7O01BUUEsT0FkSTB2RSxFQWNGO2FBS0FTLFVBQU9wQixLQUFLQyxPQUFPWSxLQUFLQyxLQUFLTztNQUMvQixzQkFEU3JCLEtBQUtDLFVBQU9ZLEtBQUtDLEtBQUtPLE1BQ2lCO2FBaUI5Q0MsZ0JBQWN4OEQ7TUFDaEI7a0NBRGdCQTtPQUNoQixtQkFEZ0JBO09BQ2hCLG1CQURnQkE7TUFDaEI7OzZDQUFvQixhQURKQTtvQkFDc0Q7YUFPcEV5OEQsYUFBYWhwRSxFQUFFM0IsRUFBRTBnQixHQUFJLHFCQUFSL2UsS0FBRTNCLEVBQUUwZ0IsR0FBa0M7YUFDbkRrcUQsY0FBY2pwRSxFQUFFM0IsRUFBRTBnQixHQUFJLHFCQUFSL2UsS0FBRTNCLEVBQUUwZ0IsR0FBbUM7YUFDckRtcUQsYUFBYWxwRSxFQUFFM0IsR0FBSSxxQkFBTjJCLEtBQUUzQixHQUErQjthQUM5QzhxRSxjQUFjbnBFLEVBQUUzQixHQUFJLHFCQUFOMkIsS0FBRTNCLEdBQWdDO2FBR2hEK3FFLFdBQWtCM0IsS0FBTUMsT0FBa0Jqb0Q7TUFDNUM7WUFENENBO09BQzVDLFdBQUk2b0QsT0FDNEMsaUJBRko3b0Q7T0FHNUM7Y0FESThvRDs7VUFDb0QsaUJBQVIsaUJBSEo5b0Q7T0FJbkMsYUFKV2dvRCxLQUFNQyxPQUN0QlksS0FDQUMsS0FDQU87T0FDSyxVQUppQnBCO09BVTFCLEtBVElZO09BU0o7OztRQUNFO2NBQUlNLElBQUosaUJBWDBDbnBELEtBVTVDL21CO1VBQ0UsR0FBSWt3RSxtQkFURkw7V0FXQTtVQUZGLElBRXlELEtBWHZEQSxhQVd1RDs7Z0JBQ3pEdDlEO1lBQ0U7a0JBQUlvK0QsSUFBSixpQkFKRVQsSUFHSjM5RDtjQUNFLEdBQUlvK0QsbUJBWkpQO2VBY0U7Y0FGRixJQUV5RCxLQWR6REEsYUFjeUQ7O29CQUN6RGhnRTtnQkFDRTs7b0JBZkZzL0Q7b0JBTUoxdkUsSUFMSTJIO29CQVNGNEssSUFURTVLO29CQWFBeUksSUFiQXpJO29CQWM4QyxpQkFKMUNncEUsSUFHSnZnRTtrQkFDRSxTQURGQTs7O2NBSEEsU0FERm1DOzs7VUFIQSxTQURGdlM7OztNQWFBLE9BbkJJMHZFLEVBbUJGO2FBV0ZrQixtQkFBbUJ0cEU7TUFDbEIsOEJBRGtCQTs7ZUFFaEIsNENBQXlDO2FBQzVDdXBFLG1CQUFtQnZwRTtNQUNsQiw4QkFEa0JBOztlQUVoQiw0Q0FBeUM7YUFDNUN3cEUsbUJBQW1CeHBFO01BQ2xCLDhCQURrQkE7O2VBRWhCLDRDQUF5QzthQUM1Q3lwRSxtQkFBbUJ6cEU7TUFDbEIsOEJBRGtCQTs7ZUFFaEIsNENBQXlDO2FBSzVDMHBFLFVBQVUxcEUsR0FBSSx1QkFBSkEsTUFBa0I7YUFDNUIycEUsVUFBVTNwRSxFQUFFc29FLE1BQU8sdUJBQVR0b0UsS0FBRXNvRSxNQUF5QjthQUNyQ3NCLFVBQVU1cEUsRUFBRXNvRSxLQUFLQyxNQUFPLHVCQUFkdm9FLEtBQUVzb0UsS0FBS0MsTUFBOEI7YUFDL0NzQixVQUFVN3BFLEVBQUVzb0UsS0FBS0MsS0FBS087TUFBTyx1QkFBbkI5b0UsS0FBRXNvRSxLQUFLQyxLQUFLTyxNQUFtQzs7OztPQWhSekR2QztPQUNBQztPQVNBUztPQUNBQztPQVRBVDtPQUNBQztPQUNBQztPQUNBQztPQUdBRztPQUZBRjtPQUNBQztPQUVBRTtPQUdBMzNCO09BRUE4M0I7T0FrQkFDO09BQ0FDOztVQTRDRUcsK0JBVUFLLGdCQVJBRixJQUNBQyxJQVlBRTtVQVFBQywrQkFjQUUsZ0JBSUFDLE1BTUFDOztRQWFBRTs7UUFnQkFHO1FBUUFDO1FBQ0FDO1FBR0FDOztRQXNCQUU7O1FBa0JBRTtRQVFBQztRQUNBQztRQUNBQztRQUNBQztRQUdBQztPQWtDRkU7T0FHQUM7T0FHQUM7T0FHQUM7O09BT0FDO09BQ0FDO09BQ0FDO09BQ0FDOztVN0MzVUw7Ozs7Ozs7STZDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDa0pLQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzZaRUM7Ozs7Ozs7Ozs7Ozs7OztLQXpERkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQzllS0MsUUFGZ0NDLElBQU0sT0FBTkEsRUFBUTthQUd4Q0MsUUFGNEJDLElBQU0sT0FBTkEsRUFBUTthQUdwQ0MsT0FDQ0MsSUhYWCxPR1dXQSxTQUFtRDthQUNwREMsSUFDQ0MsR0FDRUM7TUFFc0IsZ0JBRnRCQSxJQUVzQixnREFBOEI7YUFDdkRDLFNBQ0NDLElBQ0VDO01BRXVCLHFCQUFhO01BQWIsZ0RBQXFDO2FBQy9EQyxTQUNDQyxJQUNFQyxJQUNFQztNQUV1QixZQUNsQixlQUF1QixnQkFETCxRQUM4QjthQUMxREMsWUFDQ0MsSUFDRUMsS0FFdUIsZUFBZ0IsZ0JBQWhCLFFBQXlDO2FBQ25FQyxNQUNDQyxLQUFxQyxvQkFBYzs7O1NBM0JwRHBCLFFBQ0FFLFFBQ0FFLE9BRUFFLElBS0FHLFNBS0FHLFNBT0FJLFlBS0FHO2FBUUFFLFVBRmdDQyxLQUFPLE9BQVBBLEdBQVU7YUFHMUNDLFVBRjRCQyxLQUFPLE9BQVBBLEdBQVU7YUFHdENDLFlBQ0NDLElBQ1NDO01BSXFCLElBQWxCQztNQUNHLFNBQVA7TUFBTyxHQUxORCxLQVFJLElBREdFLElBUFBGLE9BU00sU0FERjtNQUxxQyx1Q0FDdENDLElBT0M7a0JBZmRQLFVBQ0FFLFVBQ0FFO2FBb0JBSyxVQUZnQ0MsS0FBTyxPQUFQQSxHQUFVO2FBRzFDQyxVQUY0QkMsS0FBTyxPQUFQQSxHQUFVO1FBR3ZDQyw4QkFDQUM7YUFDQ0MsY0FDQ0MsS0FBc0Msd0JBQW9CO2FBQzNEQyxjQUNDQyxLQUFzQyx3QkFBb0I7YUFDM0RDLE9BSVFDLElBRkxDO01BS3lCLElBRFZDO01BQ1UsY0FFUEMsS0FDSyxTQURMQSxLQUNLLFFBQXVDO01BRm5ELGdDQU5YRjtNQUdnQyx3QkFEM0JELElBRVVFLElBTUk7YUFDdEJFLFNBQ0NDLElBQ0VDLEtBRXVCLG9CQUZ2QkEsUUFFcUQ7YUFDeERDLFVBQ0NDLElBQ0VDLEtBRXVCLG9CQUZ2QkEsUUFFcUQ7YUFDeERDLFNBQ0NDLElBQ0VDLEtIakdiLE9HZ0dXRCxZQUNFQyxJQUNnRTthQUNuRUMsT0FDQ0MsSUFDRUMsS0FDNkIsa0JBRDdCQSxJQUMrRDthQUNsRUMsT0FDQ0MsSUFDRUMsS0h6R2IsT0d3R1dELFdBR3FDLHFCQUZuQ0MsS0FFMEQ7YUFDN0RDLEtBQ0NDLEtBQXNDLGlCQUFhOzs7O09BN0NwRC9CO09BQ0FFO09BQ0RFO09BQ0FDO09BQ0NDO09BRUFFO09BRUFFO09BYUFLO09BS0FHO09BS0FHO09BSUFHO09BSUFHO09BS0FHO2FBUUFFLFVBRmdDQyxLQUFPLE9BQVBBLEdBQVU7YUFHMUNDLFVBRjRCQyxLQUFPLE9BQVBBLEdBQVU7YUFHdENDLFNBQ0NDLEtBRXdDLDBCQUZ4Q0EsSUFFbUU7YUFDcEVDLFdBRXlCLHlCQUF1QzthQUNoRUMsTUFDQ0MsS0FFcUMsMEJBQ2hDLGVBQXlCO2FBQy9CQyxTQUNDQyxLSG5JWCxPR21JV0EsYUFBNEQ7YUFDN0RDLFFBQ0NDLEtIcklYLE9HcUlXQSxZQUEyRDthQUM1REMsY0FDQ0MsS0h2SVgsT0d1SVdBLGlCQUFnRTthQUNqRUMsVUFDQ0MsS0h6SVgsT0d5SVdBLGNBQTZEO2FBQzlEQyxpQkFDQ0MsS0gzSVgsT0cySVdBLHFCQUMyRDthQUM1REMsWUFDQ0MsS0g5SVgsT0c4SVdBLGdCQUErRDthQUNoRUMsVUFDQ0MsS0hoSlgsT0dnSldBLGNBQTZEO2FBQzlEQyxZQUNDQyxLSGxKWCxPR2tKV0EsZ0JBQStEO2FBQ2hFQyxTQUNDQyxLSHBKWCxPR29KV0EsYUFBNEQ7YUFDN0RDLG9CQUNDQyxLSHRKWCxPR3NKV0EsdUJBQzZEO2FBQzlEQyxhQUNDQyxLSHpKWCxPR3lKV0EsZ0JBQStEO2FBQ2hFQyxZQUNDQyxLSDNKWCxPRzJKV0EsZUFBOEQ7YUFDL0RDLGtCQUNDQyxLSDdKWCxPRzZKV0Esb0JBQW1FO2FBQ3BFQyxjQUNDQyxLSC9KWCxPRytKV0EsaUJBQWdFO2FBQ2pFQyxxQkFDQ0MsS0hqS1gsT0dpS1dBLHdCQUM4RDthQUMvREMsZ0JBQ0NDLEtIcEtYLE9Hb0tXQSxtQkFBa0U7YUFDbkVDLGNBQ0NDLEtIdEtYLE9Hc0tXQSxpQkFBZ0U7YUFDakVDLGdCQUNDQyxLSHhLWCxPR3dLV0EsbUJBQWtFO2FBQ25FQyxTQUNDQyxLSDFLWCxPRzBLV0EsYUFBNEQ7YUFDN0RDLFNBQ0NDLElBQ0VDLEtBQzRCLFlBRDVCQSxLQUM0QixRQUFtQzthQUNsRUMsY0FDQ0MsSUFDRUMsS0FFdUIsZ0JBRnZCQSxLQUV1QixRQUF1QzthQUNqRUMsVUFDQ0MsSUFDRUMsS0FDNEIsYUFENUJBLEtBQzRCLFFBQW9DO2FBQ25FQyxpQkFDQ0MsSUFDRUMsS0FFdUIsb0JBRnZCQSxLQUV1QixRQUEyQzthQUNyRUMsWUFDQ0MsSUFDRUMsS0FFdUIsZUFGdkJBLEtBRXVCLFFBQXNDO2FBQ2hFQyxVQUNDQyxJQUNFQyxLQUM0QixhQUQ1QkEsS0FDNEIsUUFBb0M7YUFDbkVDLFlBQ0NDLElBQ0VDLEtBRXVCLGVBRnZCQSxLQUV1QixRQUFzQzthQUNoRUMsU0FDQ0MsSUFDRUMsS0FDNEIsWUFENUJBLEtBQzRCLFFBQW1DO2FBQ2xFQyxhQUNDQyxJQUNFQyxLQUV1QixlQUZ2QkEsS0FFdUIsUUFBc0M7YUFDaEVDLGtCQUNDQyxJQUNFQyxLQUV1QixtQkFGdkJBLEtBRXVCLFFBQTBDO2FBQ3BFQyxjQUNDQyxJQUNFQyxLQUV1QixnQkFGdkJBLEtBRXVCLFFBQXVDO2FBQ2pFQyxxQkFDQ0MsSUFDRUM7TUFFdUIsdUJBRnZCQSxLQUV1QixRQUNJO2FBQzlCQyxnQkFDQ0MsSUFDRUMsS0FFdUIsa0JBRnZCQSxLQUV1QixRQUF5QzthQUNuRUMsY0FDQ0MsS0FDRUMsS0FFd0IsaUJBRnhCQSxLQUV3QixRQUF1QzthQUNsRUMsZ0JBQ0NDLEtBQ0VDLE1BRXdCLG1CQUZ4QkEsTUFFd0IsUUFBMEM7YUFDckVDLFNBQ0NDLEtBQ0VDLE1BQzZCLGFBRDdCQSxNQUM2QixRQUFvQzthQUNwRUMsZUFDQ0M7TUFDdUMsNkNBQXFCO2FBQzdEQyxjQUNDQyxNQUN1Qyw0Q0FBb0I7YUFDNURDLGNBQ0NDLE1BQ3VDLDRDQUFvQjthQUM1REMsaUJBQ0NDO01BQ3VDLCtDQUF1QjthQUMvREMsWUFDQ0MsTUFBaUQseUNBQWlCO2FBQ25FQyxlQUNDQztNQUN1Qyw2Q0FBcUI7YUFDN0RDLGNBQ0NDLE1BQ3VDLDRDQUFvQjs7OztPQXRKNUQ1RztPQUNBRTtPQUNBRTtPQUlBRTtPQUdBQztPQUtBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUdBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUdBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUdBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQUlBRztPQUtBRztPQUlBRztPQUtBRztPQUtBRztPQUlBRztPQUtBRztPQUlBRztPQUtBRztPQUtBRztPQUtBRztPQU1BRztPQUtBRztPQUtBRztPQUtBRztPQUlBRztPQUdBRTtPQUdBRTtPQUdBRTtPQUdBRTtPQUVBRTtPQUdBRTthQVNBRSxVQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxVQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBR3hDQyxLQUNDQyxNQUFnRCx5QkFBaERBLFVBQXdEO2FBQ3pEQyxLQUNDQyxNQUFnRCx5QkFBaERBLFVBQXdEO2dCQUx6RFAsVUFDQUUsVUFDQUUsS0FFQUU7YUFRQUUsVUFGZ0NDLE1BQVEsT0FBUkEsSUFBWTthQUc1Q0MsVUFGNEJDLE1BQVEsT0FBUkEsSUFBWTthQUd4Q0MsTUFDQ0MsTUFDaUQsaUNBRGpEQSxXQUMwRDt3QkFKM0RMLFVBQ0FFLFVBQ0FFO2FBU0FFLFVBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFVBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHeENDLE9BQTJCQyxNSDFTckMsT0cwU3FDQSxXQUF1QzthQUNsRUMsZ0JBQ0NDLE1BQXVDLDhCQUF1QjthQUMvREMsT0FDQ0MsTUFBZ0QseUJBQWhEQSxVQUF3RDthQUN6REMsV0FDQ0MsS0FDRUMsS0FDRUMsS0FDRUM7TUFFd0IsZUFDbkIsb0JBSlBELFNBQ0VDLE1BRXdCLFFBRW9DO2FBQ25FQyxTQUNDQyxNSHpUWCxPR3lUV0EsWUFBd0Q7YUFDekRDLFNBQ0NDLE1IM1RYLE9HMlRXQSxZQUF3RDthQUN6REMsT0FDQ0MsTUg3VFgsT0c2VFdBLFVBQXdEO2FBQ3pEQyxPQUNDQyxNSC9UWCxPRytUV0EsVUFBd0Q7YUFDekRDLFNBQ0NDLE1IalVYLE9HaVVXQSxZQUF3RDthQUN6REMsU0FDQ0MsTUhuVVgsT0dtVVdBLFlBQXdEO2FBQ3pEQyxXQUNDQyxNSHJVWCxPR3FVV0EsY0FBMEQ7YUFDM0RDLFdBQ0NDLE1IdlVYLE9HdVVXQSxjQUEwRDthQUMzREMsUUFDQ0MsTUh6VVgsT0d5VVdBLFlBQXdEO2FBQ3pEQyxRQUNDQyxNQUE4QyxPQUE5Q0EsZUFBd0Q7YUFDekRDLFNBQ0NDLE1BQThDLE9BQTlDQSxnQkFBeUQ7YUFDMURDLFVBQ0NDLE1BQThDLE9BQTlDQSxpQkFBMEQ7YUFDM0RDLE1BQ0NDLE1IalZYLE9HaVZXQSxVQUFzRDthQUN2REMsS0FDQ0MsTUFBZ0QseUJBQWhEQSxVQUF3RDthQUN6REMsTUFDQ0MsTUFBZ0QseUJBQWhEQSxTQUF1RDthQUN4REMsUUFDQ0MsTUh2VlgsT0d1VldBLFdBQXlEO2FBQzFEQyxRQUNDQyxNSHpWWCxPR3lWV0EsV0FBeUQ7YUFDMURDLGNBQ0NDO01BQzBDLGtDQUQxQ0Esa0JBQzBEO2FBQzNEQyxLQUF5QkMsTUg3Vm5DLE9HNlZtQ0EsU0FBcUM7YUFDOURDLE9BQ0NDLE1BQWdELHlCQUFoREEsWUFBMEQ7Ozs7T0F2RDNEdEQ7T0FDQUU7T0FDQUU7T0FDQUU7T0FFQUU7T0FFQUU7T0FTQUs7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FFQUU7T0FHQUU7T0FDQUU7YUFRQUUsVUFGZ0NDLE1BQVEsT0FBUkEsSUFBWTthQUc1Q0MsVUFGNEJDLE1BQVEsT0FBUkEsSUFBWTthQUd4Q0MsT0FDQ0MsTUh6V1gsT0d5V1dBLFdBQXlEO2FBQzFEQyxNQUNDQyxNSDNXWCxPRzJXV0EsVUFBd0Q7YUFDekRDLEtBQ0NDLE1IN1dYLE9HNldXQSxTQUF1RDthQUN4REMsTUFDQ0MsTUgvV1gsT0crV1dBLFVBQXdEO2FBQ3pEQyxJQUNDQyxNSGpYWCxPR2lYV0EsUUFBc0Q7YUFDdkRDLE9BQ0NDLE1IblhYLE9HbVhXQSxXQUF5RDtnQkFiMURmLFVBQ0FFLFVBQ0FFLE9BRUFFLE1BRUFFLEtBRUFFLE1BRUFFLElBRUFFO2FBUUFFLFVBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFVBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHeENDLEVBQ0NDLE1IN1hYLE9HNlhXQSxNQUFvRDthQUNyREMsRUFDQ0MsTUgvWFgsT0crWFdBLE1BQW9EO2FBQ3JEQyxTQUNDQyxNSGpZWCxPR2lZV0EsV0FBeUQ7YUFDMURDLFFBQ0NDLE1IbllYLE9HbVlXQSxVQUF3RDttQkFUekRYLFVBQ0FFLFVBQ0FFLEVBRUFFLEVBRUFFLFNBRUFFO2FBUUFFLFVBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFVBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHekNDLElBQUlDLE1BQU1DLEtBQUtDLE9INVl4QixPRzRZYUYsTUFBTUMsUUFDaUIsZ0JBQXdCO2FBQ2xERSxVQUNDQyxLQUNFQyxNSGhaYixPRytZV0QsYUFDeUMsZUFBdUI7YUFDakVFLFdBQ0NDLEtBQ0VDLE1IblpiLE9Ha1pXRCxjQUMwQyxlQUF1QjthQUNsRUUsZUFDQ0MsS0FDRUM7TUh0WmIsT0dxWldELGtCQUVvQyxlQUF1QjthQUM1REUscUJBQ0NDLEtBQ0VDO01IMVpiLE9HeVpXRCx1QkFFeUMsZUFBdUI7YUFDakVFLFdBQ0NDLEtBQ0VDLE1IOVpiLE9HNlpXRCxjQUMwQyxlQUF1QjthQUNsRUUsVUFDQ0MsS0FDRUMsTUhqYWIsT0dnYVdELGFBQ3lDLGVBQXVCO2FBQ2pFRSxXQUNDQyxLQUNFQyxNSHBhYixPR21hV0QsY0FDMEMsZUFBdUI7YUFDbEVFLFNBQ0NDLEtBQ0VDLE1IdmFiLE9Hc2FXRCxZQUN3QyxlQUF1QjthQUNoRUUsUUFDQ0MsS0FDRUMsTUgxYWIsT0d5YVdELFdBQ3VDLGVBQXVCO2FBQy9ERSxVQUNDQyxLQUNFQyxNSDdhYixPRzRhV0QsYUFDeUMsZUFBdUI7YUFDakVFLFdBQ0NDLEtBQ0VDLE1IaGJiLE9HK2FXRCxjQUMwQyxlQUF1QjthQUNuRUUsSUFBSXBDLE1BQU1DLE1BQWdELHlCQUF0REQsTUFBTUMsTUFBc0Q7Ozs7T0F2Qy9ETjtPQUNBRTtPQUNERTtPQUVDSTtPQUdBRztPQUdBRztPQUlBRztPQUlBRztPQUdBRztPQUdBRztPQUdBRztPQUdBRztPQUdBRztPQUdBRztPQUdERzthQU9DQyxVQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxVQUY0QkMsTUFBUSxPQUFSQSxJQUFZOzthQUl4Q0MsV0FDQ0MsS0FDRUMsTUFFd0IsMEJBRnhCQSxLQUUrRDthQUNsRUMsU0FDQ0MsS0FDRUMsTUFFd0IscUJBRnhCQSxTQUV1RDthQUMxREMsYUFDQ0MsS0FDRUMsTUFDNkIsaUJBRDdCQSxNQUM2QixRQUFrQzthQUNsRUMsY0FDQ0MsS0FDRUMsS0FDRUM7TUFFd0Isa0JBSDFCRCxLQUNFQyxNQUV3QixRQUNhO2FBQzFDQyxjQUNDQyxLQUNFQyxLQUNFQztNQUV3QixrQkFIMUJELEtBQ0VDLE1BRXdCLFFBQ2E7YUFDMUNDLGFBQ0NDLEtBQ0VDLE1BQzZCLGlCQUQ3QkEsTUFDNkIsUUFBa0M7YUFDbEVDLFlBQ0NDLE1BQXVDLE9BQXZDQSxlQUFxRDthQUN0REMsV0FDQ0MsTUFBdUMsT0FBdkNBLGNBQW9EO2FBQ3JEQyxhQUNDQyxNQUF1QyxPQUF2Q0EsZ0JBQXNEO2FBQ3hEQyxvQkFBb0JoRjtNQUtqQixZQUxpQkEsYUFDVGtGO01BQ1g7UUFBRyxjQURRQTtRQUdMLGFBSmNsRixFQUNUa0Y7UUFHc0IsWUFKYmxGLGFBQ1RrRjtpQkFJTzthQUNqQkUsZ0JBQ0NDLE1BQ3FDLCtCQUFzQjthQUM1REMsbUJBRUNDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BSytEO2dCQUwvREE7T0FHNkI7O3FCQUNRQyxNQUNHLGtCQU4xQ0YsS0FNMEMsb0JBREhFLE1BQ3VCO01BSHBDLHNCQUNuQjtNQURtQixRQUlJO2FBQ25DQyxXQUNDQyxNQUFnRCx5QkFBaERBLGVBQTZEO2FBQzlEQyx5QkFDQ0MsS0FDRUM7TUFFd0IsbUNBQ25CO01BRG1CLHlCQXBFM0I5QyxlQXFFa0M7YUFDbEMrQyxjQUNDQyxLQUNFQztNQUV3Qix5QkFDbkIsb0JBQTBCO2FBQ2xDQyxjQUNDQyxLQUNFQztNQUV3QiwyQ0FDbkIsaUJBQTBCO2FBQ2xDQyxpQkFDQ0MsS0FDRUM7TUFFd0IscUJBQ25CLGlCQURtQixRQUNPO2FBQ2xDQyxjQUNDQyxLQUNFQyxLQUNFQztNQUV3QixrQkFDbkIsZ0JBQXdCLGlCQURMLFFBQytCO2FBQzVEQyx5QkFDQ0M7TUFDbUMscUVBQThCO2FBQ2xFQyxpQkFDQ0M7TUFBZ0QsMERBQWdCO2FBQ2pFQyxVQUNDQyxNQUF1Qyx5QkFBa0I7YUFDMURwRyxNQUNDcUcsTUFBZ0QseUJBQWhEQSxXQUF5RDthQUMxREMsVUFDQ0MsS0FDRUMsTUhsaUJiLE9HaWlCV0QsYUFDeUMsZUFBdUI7YUFDakVFLE9BQ0NDLE1BQXVDLHNCQUFlO2FBQ3ZEQyxRQUNDQyxNQUNpRCxpQ0FEakRBLFdBQzBEO2FBQzNEQyxlQUNDQyxNSHppQlgsT0d5aUJXQSxrQkFBOEQ7YUFDL0RDLFFBQ0NDLE1BQThDLE9BQTlDQSxnQkFBeUQ7YUFDMURDLFlBQ0NDLEtBQ0VDLE1IOWlCYixPRzZpQldELG1CQUNFQyxJQUE4RDthQUNqRUMsV0FDQ0MsTUFBZ0QseUJBQWhEQSxlQUE2RDthQUM5REMsZUFDQ0MsS0FDRUM7TUhuakJiLE9Ha2pCV0QsaUJBRW1DLGVBQXVCO2FBQzNERSxZQUNDQyxNQUF1QyxPQUF2Q0EsZUFBcUQ7YUFDdERDLFVBQ0NDLE1BQWdELHlCQUFoREEsY0FBNEQ7YUFDN0RDLGVBQ0NDLEtBQ0VDO01BRXdCLDBCQUFtQixvQkFGM0NBLFVBRWtFO2FBQ3JFakksTUFDQ2tJLE1BQTZDLDJCQUE3Q0EsV0FBc0Q7YUFDdkRDLGVBQ0NDLEtBQ0VDO01IbGtCYixPR2lrQldELGlCQUVtQyxlQUF1QjthQUMzREUsaUJBQ0NDLEtBQ0VDO01IdGtCYixPR3FrQldELG1CQUVxQyxlQUF1QjthQUM3REUsZUFDQ0MsS0FDRUM7TUgxa0JiLE9HeWtCV0QsaUJBRW1DLGVBQXVCO2FBQzNERSxXQUNDQyxNQUFnRCx5QkFBaERBLGVBQTZEO2FBQzlEQyxhQUNDQyxNSC9rQlgsT0cra0JXQSxnQkFBNEQ7YUFDN0RDLGNBQ0NDLE1IamxCWCxPR2lsQldBLGlCQUE2RDthQUM5REMsYUFDQ0MsTUhubEJYLE9HbWxCV0EsZ0JBQTREO2FBQzdEQyxjQUNDQyxNSHJsQlgsT0dxbEJXQSxpQkFBNkQ7YUFDOURDLFFBQ0NDLE1IdmxCWCxPR3VsQldBLFVBQXNEO2FBQ3ZEQyxTQUNDQyxNSHpsQlgsT0d5bEJXQSxXQUF1RDthQUN4REMsV0FDQ0MsTUgzbEJYLE9HMmxCV0EsY0FBNEQ7YUFDN0RDLGVBQ0NDLEtBQ0VDLE1IOWxCYixPRzZsQldELGlCQUNFQyxJQUFpRTthQUNwRUMsTUFDQ0MsTUFBdUMscUJBQWM7YUFDdERDLGdCQUNDQyxNSGxtQlgsT0drbUJXQSxtQkFBK0Q7YUFDaEVDLGNBQ0NDLE1IcG1CWCxPR29tQldBLGlCQUE2RDthQUM5REMsb0JBQ0NDLEtBQ0VDLE1Idm1CYixPR3NtQldELHNCQUNFQyxJQUMwRDthQUM3REMsa0JBQ0NDLEtBQ0VDLE1IM21CYixPRzBtQldELG9CQUNFQyxJQUN3RDs7OztPQXBMM0RySTtPQUNBRTs7T0FFQUU7T0FLQUc7T0FLQUc7T0FJQUc7T0FPQUk7T0FPQUk7T0FJQUc7T0FFQUU7T0FFQUU7T0FFREU7T0FNQ0k7T0FHQUU7T0FZQU07T0FFQUU7T0FNQUc7T0FNQUc7T0FNQUc7T0FNQUc7T0FPQUk7T0FHQUU7T0FFQUU7T0FFQW5HO09BRUFzRztPQUdBRztPQUVBRTtPQUdBRTtPQUVBRTtPQUVBRTtPQUdBRztPQUVBRTtPQUlBRztPQUVBRTtPQUVBRTtPQUtBL0g7T0FFQW1JO09BSUFHO09BSUFHO09BSUFHO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BR0FHO09BRUFFO09BRUFFO09BRUFFO09BSUFHO2FBVUFHLFdBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFdBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHeENDLGVBQ0NDLEtBQ0VDO01BRXdCLDRCQUNuQjtNQURtQixrQ0FDTzthQUNsQ0Msa0JBQ0NDLEtBQ0VDLEtBQ0VDO01BRXdCLDhCQUNuQixnQkFBd0I7TUFETCxrQ0FDK0I7YUFDNURDLGlCQUNDQyxLQUNFQztNQUV3Qiw2QkFDbkI7TUFEbUIsa0NBQ087YUFDbENDLGFBQ0NDLEtBQ0VDO01BRXdCLDBCQUNuQjtNQURtQixnQ0FDTzthQUNsQ0Msa0JBQ0NDLEtBQ0VDO01BRXdCLDZCQUNuQjtNQURtQix5Q0FDTzthQUNsQ0MsMkJBQ0NDLEtBQ0VDO01BRXdCLHFDQUNuQjtNQURtQix5Q0FDTzthQUNsQ0MsS0FDQ0MsTUFBK0MsNkJBQS9DQSxVQUF1RDthQUN4REMsT0FDQ0MsTUFBZ0QseUJBQWhEQSxZQUEwRDthQUMzREMsV0FDQ0MsS0FDRUMsTUhocUJiLE9HK3BCV0QsY0FDMEMsZUFBdUI7YUFDbEVFLFVBQ0NDLEtBQ0VDLE1IbnFCYixPR2txQldELGFBQ3lDLGVBQXVCO2FBQ2pFRSxLQU9ZQyxLQUpFQyxLQUNLQztNQU1jLElBRFZDO01BQ1UsR0FQbkJGLE1BVVUsSUFER0csS0FUYkgsUUFXWSxVQURGO01BSUwsR0FiQUMsTUFlSyxJQURHRyxLQWRSSCxRQWdCTyxVQURGO01BWGMsZ0JBRDFCRixLQUVXRztNQURlLFFBZVY7YUFDNUJHLE1BQ0NDLEtBQ0VDLE1BRXdCLFdBQVcsaUJBQVgsUUFBcUM7YUFDaEVDLFFBQ0NDLEtBQ0VDLE1BRXdCLGFBQWEsaUJBQWIsUUFBdUM7YUFDbEVDLE1BQ0NDLE1BQXVDLHFCQUFjO2FBQ3REQyxhQUNDQyxLQUNFQztNQUV3Qix3QkFDbkIsb0JBQTBCO2FBQ2xDQyxlQUNDQyxLQUNFQztNQUV3Qiw0QkFDbkI7TUFEbUIsa0NBQ087Ozs7T0FoR2xDckQ7T0FDQUU7T0FDQUU7T0FNQUc7T0FPQUk7T0FNQUc7T0FNQUc7T0FNQUc7T0FNQUc7T0FFQUU7T0FFQUU7T0FHQUc7T0FHQUc7T0F3QkFPO09BS0FHO09BS0FHO09BRUFFO09BTUFHO2FBWUFHLFdBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFdBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHeENDLFNBQ0NDLE1IN3RCWCxPRzZ0QldBLFdBQXVEO2FBQ3hEQyxLQUNDQyxNQUF1QyxvQkFBYTthQUNyREMsUUFDQ0MsTUFBdUMsdUJBQWdCO2FBQ3hEQyxHQUNDQyxLQUNFQztNQUNGLGdCQURFQTtPQUl5QixTQUp6QkEsUUFJaUJFOztPQUNLLFNBTHRCRixRQUlpQkUsT0FDSztNQUhFLFFBRVBBO01BRk8sUUFHd0I7YUFDbkRFLGNBQ0NDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BRXdCLGtCQUo1QkYsS0FLYyxnQkFBd0IsaUJBRFYsUUFDb0M7YUFDbkVHLFdBQ0NDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BRXdCLGVBSjVCRixLQUtjLGdCQUF3QixpQkFEVixRQUNvQzs7OztPQS9CbkV2QjtPQUNBRTtPQUNBRTtPQUVBRTtPQUVBRTtPQUVBRTtPQVFBTTtPQVFBSzthQWNBSyxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxXQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBR3hDQyxnQkFFd0QsK0NBQVE7YUFDaEVDLFNBQ0NDLE1BQ00sK0JBQ04sZUFBdUI7YUFDeEJDLEtBQ0NDLE1BQWdELHlCQUFoREEsVUFBd0Q7YUFDekRDLFNBQ0NDLEtBQ0VDLE1IN3dCYixPRzR3QldELFlBQ3dDLGVBQXVCO2FBQ2hFRSxTQUNDQyxNQUFnRCx5QkFBaERBLGNBQTREO2FBQzdEQyxhQUNDQyxLQUNFQyxNSGx4QmIsT0dpeEJXRCxnQkFDNEMsZUFBdUI7YUFDcEVFLFlBRXdELCtDQUFRO2FBQ2hFQyxTQUNDQyxNQUNNLCtCQUNOLGVBQXVCO2FBQ3hCQyxTQUNDQyxNQUFnRCx5QkFBaERBLGNBQTREO2FBQzdEQyxhQUNDQyxLQUNFQyxNSDl4QmIsT0c2eEJXRCxnQkFDNEMsZUFBdUI7YUFDcEVFLEtBQ0NDLE1BQWdELHlCQUFoREEsVUFBd0Q7YUFDekRDLFNBQ0NDLEtBQ0VDLE1IbnlCYixPR2t5QldELFlBQ3dDLGVBQXVCO2FBQ2hFRSxTQUNDQyxNQUFnRCx5QkFBaERBLGNBQTREO2FBQzdEQyxhQUNDQyxLQUNFQyxNSHh5QmIsT0d1eUJXRCxnQkFDNEMsZUFBdUI7YUFDcEVFLFNBQ0NDLE1BQWdELHlCQUFoREEsWUFBMEQ7YUFDM0RDLFdBQ0NDLEtBQ0VDLE1IN3lCYixPRzR5QldELGNBQzBDLGVBQXVCO2FBQ2xFRSxPQUNDQyxLQUNFQyxNQUV3QixZQUFZLGlCQUFaLFFBQXNDO2FBQ2pFQyxPQUtVQyxLQUhBQztNQU1xQixJQURWQztNQUNVLEdBTnJCRCxNQVNZLElBREdFLEtBUmZGLFFBVWMsY0FGQ0U7TUFKYSxrQkFENUJILEtBRVdFO01BRGlCLFFBU1o7YUFDMUJFLFFBQ0NDLEtBQ0VDLE1BRXdCLGFBQWEsaUJBQWIsUUFBdUM7Ozs7T0F2RWxFbEQ7T0FDQUU7T0FDQUU7T0FHQUM7T0FJQUU7T0FFQUU7T0FHQUc7T0FFQUU7T0FHQUc7T0FHQUM7T0FJQUU7T0FFQUU7T0FHQUc7T0FFQUU7T0FHQUc7T0FFQUU7T0FHQUc7T0FFQUU7T0FHQUc7T0FLQUc7T0FnQkFLO2FBV0FHLFdBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFdBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFNeENDLGlCQUZrREMsTUFBUSxPQUFSQSxJQUFZO2FBRzlEQyxpQkFGOENDLE1BQVEsT0FBUkEsSUFBWTthQUcxREMscUJBRUNDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BSytEO2dCQUwvREE7T0FHNkI7O3FCQUNRQyxNQUNHLGtCQU4xQ0YsS0FNMEMsb0JBREhFLE1BQ3VCO01BSHBDLHNCQUNuQjtNQURtQixRQUlJO2FBQ25DQyxTQUNDQyxNQUFnRCw4QkFBaERBLGNBQTREO2FBQzdEQyxXQUNDQyxLQUNFQztNSHIyQmIsT0dvMkJXRDs7YUFHRTtpQ0FBMkIsa0JBRjNCQyxPQUVrQyxFQUFFO2FBQ3ZDQyxhQUNDQyxLQUNFQyxLQUNFQztNQUV3QjtlQUNuQjttQ0FBMkIsa0JBSmxDRCxPQUl5QztlQUh2Q0MsS0FHaUU7YUFDdEVDLFlBQ0NDLEtBQ0VDLEtBQ0VDO01BRXdCO2VBQ25CO21DQUEyQixrQkFKbENELE9BSXlDO2VBSHZDQyxLQUdpRTthQUN0RUMsY0FDQ0MsS0FDRUMsTUFFd0Isa0JBRnhCQSxNQUV3QixRQUNPO2FBQ2xDQyx3QkFDQ0MsS0FDRUM7TUFFd0I7UUFDbkI7cUJBQXNCQyxNQUFRLGtCQUhuQ0QsS0FHMkJDLEtBQW1DO01BRHRDLFFBQzJDO2FBQ3RFQyxPQVlnQkMsS0FOUkMsS0FDR0MsS0FDTUMsS0FDQ0M7TUFNbUIsSUFEVkM7TUFDVSxHQVQ3QkosTUFhb0IsSUFER0ssS0FadkJMLFFBY3NCLFVBREY7TUFJTCxHQWhCWkMsTUFrQmlCLElBREdLLEtBakJwQkwsUUFtQm1CLFVBREY7TUFJTCxHQXJCTkMsTUF1QlcsSUFER0ssS0F0QmRMLFFBd0JhLFVBREY7TUFJTCxHQTFCTEMsTUE0QlUsSUFER0ssS0EzQmJMLFFBNkJZLGNBRkNLO01BdkJXLHVCQUQxQlQsS0FFV0ssS0EyQks7YUFDaENLLE1BQ0NDLEtBQ0VDLE1BRXdCLFdBQVcsaUJBQVgsUUFBcUM7YUFDaEVDLGdCQUNDQztNQUV1QixvQ0FGdkJBLG9CQUV5QzthQUMxQ0MsY0FDQ0M7TUFFdUIsb0NBRnZCQSxrQkFFdUM7YUFDeENDLFlBQ0NDLE1IMTdCWCxPRzA3QldBLGVBQTZEO2FBQzlEQyxhQUNDQyxNSDU3QlgsT0c0N0JXQSxnQkFBOEQ7YUFDL0RDLGNBQ0NDLE1IOTdCWCxPRzg3QldBLGdCQUE0RDthQUM3REMsY0FDQ0MsTUhoOEJYLE9HZzhCV0EsZ0JBQTREO2FBQzdEQyxVQUNDQyxLQUNFQyxLQUNFQyxNQUV3QixjQUgxQkQsS0FDRUMsTUFFd0IsUUFDeUI7YUFDdERDLFVBQ0NDLEtBQ0VDLEtBQ0VDLE1BRXdCLGNBSDFCRCxLQUNFQyxNQUV3QixRQUN5QjthQUN0REMsUUFDQ0MsTUFBK0MsNkJBQS9DQSxhQUEwRDthQUMzREMsU0FDQ0MsTUFBZ0QsOEJBQWhEQSxjQUE0RDthQUM3REMsbUJBQ0NDLEtBQ0VDO01BRXdCLCtCQUNuQixzQkFITEE7TUFFd0IsZ0NBQ007Ozs7T0ExSWpDMUU7T0FDQUU7T0FJQUU7T0FDQUU7T0FDQUU7T0FZQU07T0FFQUU7T0FLQUc7T0FPQUk7T0FPQUk7T0FNQUc7T0FNQUk7T0EwQ0FXO09BS0FHO09BSUFFO09BSUFFO09BRUFFO09BRUFFO09BRUFFO09BRUFFO09BT0FJO09BT0FJO09BRUFFO09BRUFFO2FBU0FHLGVBQ0NDO01BRStCLFNBQXRCLHNCQUZUQTtNQUUrQix3Q0FBaUI7YUFDakRDLGlCQUNDQztNQUUrQixTQUF0QixzQkFGVEE7TUFFK0IsMENBQW1CO2tCQVBuREgsZUFJQUU7YUFPQUUsUUFDQ0MsTUFDTywwQkFDTCxnQkFBeUI7YUFDNUJDLFVBQ0NDO01BRXFDLGdEQUZyQ0EsTUFFMkQ7Z0JBUDVESCxRQUlBRTthQTRCQUUsV0FGZ0NDLE1BQVEsT0FBUkEsSUFBWTthQUc1Q0MsV0FGNEJDLE1BQVEsT0FBUkEsSUFBWTthQUd4Q0MsdUJBQzZELGlDQUFNO2FBQ25FQyxZQUNDQztNQUEyQyxJQXJCM0NDLEtBcUJBRDtNQXBCRixPQURFQzswQkFHSyxnQkFDQSxpQkFDQSxTQWdCb0Q7YUFDMURDLE9BQ0NDLE1BQWdELHlCQUFoREEsWUFBMEQ7YUFDM0RDLGFBQ0NDLEtBQ0VDO01IamhDYixPR2doQ1dEOzthQUdFO2lDQUEyQixrQkFGM0JDLE9BRWtDLEVBQUU7YUFDdkNDLGFBQ0NDLEtBQ0VDO01BRXdCLGdCQUFnQixtQkFGeENBLE9BRXdCLFFBQXNDO2FBT2pFQyxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxXQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBR3hDQyxjQUV5RCxxQ0FBTTthQUMvREMsT0FDQ0MsS0FDRUMsS0FDRUM7TUFFd0IsVUFDbkIsZ0JBQXdCLGlCQURMLFFBQytCO2FBQzVEQyxLQUNDQyxLQUNFQyxNQUM2QixVQUFVLGlCQUFWLFFBQW9DO2FBQ3BFQyxtQkFDQ0MsS0FDRUMsS0FDRUM7TUFFd0Isc0JBQ25CLGdCQUF3QixpQkFETCxRQUMrQjthQUM1REMsb0JBQ0NDLEtBQ0VDO01BRXdCLGdDQUNuQjtNQURtQixnREFDTzthQUNsQ0MsbUJBQ0NDLEtBQ0VDO01BRXdCLHNCQUNuQixpQkFEbUIsUUFDTzthQUNsQ0MscUJBQ0NDLEtBQ0VDO01IcGtDYixPR21rQ1dELDJCQUNFQyxJQUM0RDthQTJCL0RDLE9BQ0NDLE1Iam1DWCxPR2ltQ1dBLFdBQXVEO2FBQ3hEQyxjQUNDQztNQUFpRCxJQXJCakRDLEtBcUJBRDtNQXBCRixPQURFQzs7ZUFHSztlQUNBO2VBQ0E7ZUFDQTtnQkFDQSxTQWMwRDthQUNoRUMsY0FDQ0MsTUFBZ0QseUJBQWhEQSxrQkFBZ0U7YUFDakVDLHVCQUNDQyxLQUNFQztNSHhtQ2IsT0d1bUNXRDs7YUFHRTtpQ0FBMkIsa0JBRjNCQyxPQUVrQyxFQUFFO2FBT3ZDQyxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxXQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBd0J4Q0MsU0FDQ0MsS0FDYUM7TUFJa0IsSUFBbkJDO01BQ0csVUFBUDtNQUFPLEdBTEZEO1FBUUEsSUFER0UsS0FQSEY7UUFTRSxVQUNLLHNDQUhKRTtNQUpxQywwQ0FDekNELEtBUUU7YUFDZkUsT0FDQ0MsS0FDRUMsTUFDNkIsVUFBVSxpQkFBVixRQUFvQzthQUNwRUMsUUFNWUMsS0FKSEMsS0FDSUM7TUFNb0IsSUFEVkM7TUFDVSxHQVB4QkYsTUFVZSxJQURHRyxLQVRsQkgsUUFXaUIsVUFGQ0c7TUFLUixHQWJORixNQWVXLElBREdHLEtBZGRILFFBZ0JhLFVBREY7TUFYZSxpQkFEM0JGLEtBRVdHO01BRGdCLFFBZVg7YUFDNUJHLFlBQ0NDLE1BQWdELHlCQUFoREEsZ0JBQThEO2FBQy9EQyxnQkFDQ0MsS0FDRUM7TUh0ckNiLE9HcXJDV0Qsa0JBRW9DLGVBQXVCO2FBQzVERSxjQUNDQztNQUFpRCxJQWhFakRDLEtBZ0VBRDtNQS9ERixPQURFQzs7ZUFHSyxnQkFDQSxnQkFDQSxpQkFDQSxTQTBEMEQ7YUFDaEVDLHFCQUVDQyxLQUNFQyxLQUNFQyxLQUNFQztNQUsrRDtnQkFML0RBO09BRzZCOztxQkFDUUMsTUFDRyxrQkFOMUNGLEtBTTBDLG9CQURIRSxNQUN1QjtNQUhwQyxzQkFDbkI7TUFEbUIsUUFJSTs7YUFNL0JDLE9BQ0NDLE1BQStCLHNCQUEvQkEsVUFBcUQ7SUFHekM7O0tBRXhCO2FBTU9HLGNBRjRDQyxNQUFRLE9BQVJBLElBQVk7SUFKL0QsU0FPT0MsY0FGd0NDLE1BQVEsT0FBUkEsSUFBWTtJQUwzRCxTQVdPQyxlQUY4Q0MsTUFBUSxPQUFSQSxJQUFZO0lBVGpFLFNBWU9DLGVBRjBDQyxNQUFRLE9BQVJBLElBQVk7SUFWN0QsU0E4Qk1DLFlBQWNDLElBQWNDO01BQzlCLEdBRGdCRCxJQUFPLFFBQVBBLGFBQU9FLGFBQVBDO01BRndCOzs4QkFFVkYscUNBQWRFO01BRndCLHlCQXRCckNaLG1CQXlCdUM7SUEvQjlDLFNBZ0NPYSxZQUNDQztNQUMrQywrQ0FEL0NBLGtCQUNpRTtJQWxDekUsU0FtQ09DLGVBRUNDLEtBQ0VDO01BQ0YsZUFERUE7T0FJcUIsU0FKckJBLGFBSWFDOztPQURLLFNBSGxCRCxhQUdrQjthQUpwQkQscUJBSzJDO0lBMUNuRCxTQTJDT0ksaUJBRUNDLEtBQ0VDO01BQ0YsZUFERUE7T0FJcUIsU0FKckJBLGFBSWFDOztPQURLLFNBSGxCRCxhQUdrQjthQUpwQkQsdUJBSzJDO0lBbERuRCxTQW1ET0ksZUFDQ0MsS0FDRUMsTUh0d0NiLE9HcXdDV0QsaUJBQ0VDLElBQzZEO0lBdER2RSxTQXVET0MsdUJBRUNDLEtBQ0VDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BRThCLGlDQUxwQ0gsS0FDRUMsS0FDRUMsS0FDRUMsS0FJb0Q7SUFqRXBFLFNBa0VPQyxlQUNDQyxLQUNFQyxLQUNFQztNQUUrQixrQkFIakNELEtBSThCLGlCQURHLFFBQ3NCO0lBeEVqRSxTQXlFT0UsV0FDQ0MsTUFBNkMseUJBQWtCO0lBMUV2RSxTQTJFT0MsV0FDQ0MsTUFBNkMseUJBQWtCO0lBNUV2RSxTQTZFT0MsSUFFQ0MsS0FDRUMsS0FDRUMsS0FDRUMsS0FDRUMsS0FDRUM7TUFFOEIsU0FOdENKLEtBQ0VDLEtBQ0VDLEtBQ0VDLEtBQ0VDLE1BRThCLFFBR0Q7SUF6Ri9DLFNBMEZPQyxRQUNDQyxLQUNFQyxLQUNFQyxNQUU4QixZQUhoQ0QsS0FDRUMsTUFFOEIsUUFDdUI7SUFoR2pFLFNBaUdPQyxRQUNDQyxLQUNFQyxLQUNFQyxNQUU4QixZQUhoQ0QsS0FDRUMsTUFFOEIsUUFDdUI7SUF2R2pFLFNBd0dPQyxLQUNDQyxNQUE2QyxvQkFBYTtJQXpHbEUsU0EwR09DLE9BQ0NDLE1BQTZDLHNCQUFlO0lBM0dwRSxTQTRHT0MsWUFDQ0MsS0FDRUMsS0FDRUMsS0FDRUMsS0FDRUM7TUFFOEIsZ0JBTHBDSCxLQUNFQyxLQUNFQyxLQUNFQyxNQUU4QixRQUVzQjtJQXJIcEUsU0FzSE9DLFVBQ0NDLEtBQ0VDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BRThCLGNBTHBDSCxLQUNFQyxLQUNFQyxLQUNFQyxNQUU4QixRQUVzQjtJQS9IcEUsU0FnSU9DLFNBQ0NDLEtBQ0VDLE1IbjFDYixPR2sxQ1dELFlBRW9DLGVBQXVCO0lBbkluRSxTQW9JT0UsVUFDQ0MsS0FDRUMsS0FDRUMsS0FDRUM7TUFFOEIsY0FDekIsZ0JBSlBELEtBQ0VDLE1BRThCLFFBRUQ7SUE1STNDLFNBNklPQyxZQUNDQyxLQUNFQyxLQUNFQyxLQUNFQztNQUU4QixnQkFDekIsZ0JBSlBELEtBQ0VDLE1BRThCLFFBRUQ7SUFySjNDLFNBMkpXQyxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO0lBekp2RCxTQTRKV0MsV0FGNEJDLE1BQVEsT0FBUkEsSUFBWTtJQTFKbkQsU0E2SldDLFFBQ0NDLE1ILzJDZixPRysyQ2VBLFVBQXdEO0lBOUpwRSxtQkEySldMLFdBQ0FFLFdBQ0FFO0lBN0pYLFNBZ0tPRSxhQUNDQyxLQUNFQztNQUU4QiwwQkFDekI7TUFEeUIsc0NBQ0M7SUFyS3pDLFNBc0tPQyxPQUNDQyxLQUNFQyxNQUU4QixZQUY5QkEsTUFFOEIsUUFDQTtJQTNLeEMsU0E0S09DLFVBQ0NDLEtBQ0VDLEtBQ0VDLE1BRThCLGVBSGhDRCxLQUNFQyxNQUU4QixRQUN1QjtJQWxMakUsU0FtTE9DLE1BQ0NDLEtBQ0VDLEtBQ0VDLE1BRThCLFdBSGhDRCxLQUNFQyxNQUU4QixRQUN1QjtJQXpMakUsU0EwTE9DLFdBQ0NDLEtBQ0VDLEtBQ0VDLEtBQ0VDLEtBQ0VDO01BRThCLGVBTHBDSCxLQUNFQyxLQUNFQyxLQUNFQyxNQUU4QixRQUVzQjtJQW5NcEUsU0F1TU9DLGFBR1csZ0NBQThDO0lBMU1oRSxtQkF1TU9BO0lBdk1QLFNBaU5PQyxJQUNDQyxLQUFZQyxNQUF1QyxTQUF2Q0EsTUFBdUMsUUFBZ0I7SUFFakMsSUFBdkNDO2FBTUlDLFNBQ0NDLE1BRStDLGlDQUYvQ0EsS0FHNEI7YUFPN0JDLFlBQ0NDLE1BRThDLGdDQUY5Q0EsS0FHa0M7YUFDbkNDLE1BQ0NDLEtBQ0VDLEtBQ0VDO01BQ0Ysb0JILzdDYjtNR2c4Q3VDLFNBQ25CLHVCQUpQRCxNQUNFQztNQUV3QixRQUN5QzthQU90RUMsUUFDUUMsS0FDSUM7TUFFRSxJQUFQQyxLQUFPO1NBSE5GLE1BS1csSUFBUkcsS0FMSEgsUUFLVztNQUVoQixHQU5TQyxNQU9PLElBQVJHLEtBUENILFFBT087TUFFaEIsT0FQSUMsSUFPYzthQUlyQkcsU0FHQ0MsS0FDV0M7TUFJb0IsSUFBbkJDO01BQW1CLGNBSVJDLE1BQ0YsSUFDZUMsS0FGYkQsUUFDRixPQUNlQyxJQUNhO01BTHZDLFVBQ0ssdUJBUmZKO01BT1UsR0FOQ0MsTUFjRSxJQURHSSxLQWJMSixRQWNTLFVBREpJO01BVmdDLHFDQUNwQ0gsS0FZRTthQUlmSSxRQUNDQztNQUVvQyxxREFGcENBLE1BRzJCO2FBQzVCQyxPQUNDQztNQUVvQyw0QkFDL0IsaUJBRCtCLFFBQ0w7cUJBVGhDSCxRQUtBRTthQWFJRSxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxXQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBR3hDQyxVQUNDQyxNSHBnRGYsT0dvZ0RlQSxhQUF5RDthQUMxREMsUUFDQ0MsTUh0Z0RmLE9Hc2dEZUEsVUFBd0Q7YUFDekRDLGdCQUNDQztNQUNzQyx5QkFEdENBLG1CQUN1RDthQUN4REMseUJBQ0NDLE1IM2dEZixPRzJnRGVBLDBCQUM4RDs7OztPQVgvRFg7T0FDQUU7T0FDQUU7T0FFQUU7T0FFQUU7T0FHQUU7YUFTQUUsV0FGZ0NDLE1BQVEsT0FBUkEsSUFBWTthQUc1Q0MsV0FGNEJDLE1BQVEsT0FBUkEsSUFBWTthQUd4Q0MsU0FDQ0MsTUFBOEMsNEJBQTlDQSxhQUF5RDthQUMxREMsU0FDQ0MsTUFBOEMsNEJBQTlDQSxhQUF5RDswQkFMMURQLFdBQ0FFLFdBQ0FFLFNBRUFFO2FBK0NBRSxXQUZnQ0MsTUFBUSxPQUFSQSxJQUFZO2FBRzVDQyxXQUY0QkMsTUFBUSxPQUFSQSxJQUFZO2FBR3hDQyxJQUNDQyxNSHprRGYsT0d5a0RlQSxNQUFvRDthQUNyREMsSUFDQ0MsTUgza0RmLE9HMmtEZUEsTUFBb0Q7YUFDckRoNUIsR0FDQ2k1QixNSDdrRGYsT0c2a0RlQSxPQUFxRDthQUN0REMsR0FDQ0MsTUgva0RmLE9HK2tEZUEsT0FBcUQ7YUFDdERyNUIsR0FDQ3M1QixNSGpsRGYsT0dpbERlQSxPQUFxRDthQUN0REMsR0FDQ0MsTUhubERmLE9HbWxEZUEsT0FBcUQ7YUFDdERDLGNBQ0NDO01BQ3lDLElBaEQ3Q0MsS0ErQ0lEO01BOUNOLE9BREVDOztlQUdLO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtnQkFDQSxTQW9DdUQ7YUFDekRDLHdCQUNDQztNQUNzQyx5QkFEdENBLHlCQUM2RDs7OztPQW5COURsQjtPQUNBRTtPQUNBRTtPQUVBRTtPQUVBLzRCO09BRUFrNUI7T0FFQXA1QjtPQUVBdTVCO09BRUFFO09BR0FHO2FBU0FFLFdBRmdDQyxNQUFRLE9BQVJBLElBQVk7YUFHNUNDLFdBRjRCQyxNQUFRLE9BQVJBLElBQVk7YUFHeENDLGdCQUNDQyxNSG5tRGYsT0dtbURlQSxrQkFBOEQ7YUFDL0RDLFdBQ0NDLEtBQ0VDO01BRXdCLHNCQUZ4QkEsTUFFd0Isa0NBQW9DO2FBQy9EQyxtQkFDQ0MsS0FDRUMsS0FDRUM7TUFFd0Isc0JBQ25CLHNCQUpQRCxNQUNFQyxNQUV3QixRQUMyQjthQUN4REMsYUFDQ0MsS0FDRUMsS0FDRUM7TUFFd0IsaUJBQ25CLHNCQUpQRCxNQUNFQyxNQUV3QixRQUMyQjthQUN4REMsY0FDQ0MsS0FDRUMsTUFFd0IsZ0JBRnhCQSxNQUV3QixRQUNJO2FBQy9CQyxZQUNDQyxLQUNFQztNQUV3QixnQkFDbkIsc0JBSExBLE9BRXdCLFFBQ007Ozs7T0FsQ2pDdEI7T0FDQUU7T0FDQUU7T0FFQUU7T0FLQUc7T0FPQUk7T0FPQUk7T0FNQUc7YUFZQUcsV0FGZ0NDLE1BQVEsT0FBUkEsSUFBWTthQUc1Q0MsV0FGNEJDLE1BQVEsT0FBUkEsSUFBWTthQUd4Q0MsY0FDQ0M7TUFDeUMsaUNBRHpDQSxpQkFDd0Q7YUFDekRDLHlCQUNDQztNQUV1QixpQ0FGdkJBLDJCQUVnRDthQUNqREMsdUJBQ0NDO01BRXVCLGlDQUZ2QkEseUJBRThDO2FBQy9DQyxrQ0FDQ0M7TUFFdUIsaUNBRnZCQSxtQ0FFd0Q7YUFDekRDLGtCQUNDQztNQUcwQjt3Q0FBa0M7YUFDN0RDLGtCQUNDQyxLQUNFQyxLQUNFQztNQUV3Qix3Q0FIMUJELEtBQ0VDO01BRXdCLGtDQUM2QjthQUMxREMsa0JBQ0NDLEtBQ0VDLEtBQ0VDO01BRXdCLHdDQUgxQkQsS0FDRUM7TUFFd0Isa0NBQzZCO2FBQzFEQyxrQkFDQ0MsS0FDRUMsS0FDRUM7TUFFd0Isd0NBSDFCRCxLQUNFQztNQUV3QixrQ0FDNkI7YUFDMURDLGtCQUNDQyxLQUNFQyxLQUNFQztNQUV3Qix3Q0FIMUJELEtBQ0VDO01BRXdCLGtDQUM2Qjs7OztPQWpEMUQ3QjtPQUNBRTtPQUNBRTtPQUdBRTtPQUlBRTtPQUlBRTtPQUlBRTtPQUtBRTtPQU9BSTtPQU9BSTtPQU9BSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBN3FCSjlUO1FBQ0FFO1FBQ0FFO1FBRUFDO1FBRUFHO1FBRUFFO1FBS0FHOztRQVdBRztRQUNBRTtRQUNBRTtRQUdBQztRQU9BSTtRQUlBRztRQU9BSTtRQU1BRztRQU1BRztRQThCQUc7UUFFQUU7UUFFQUc7UUFFQUU7O1FBV0FHO1FBQ0FFO1FBc0JBRTtRQWVBSztRQUlBRztRQXVCQU87UUFFQUU7UUFJQUc7UUFFQUc7V0FpQklNO09BSVJFO09BQ0FDOztRQU9JQztRQUNBRTtRQUlBRTtRQUNBRTtRQWtCREU7UUFFQ0s7UUFHQUU7UUFRQUs7UUFRQUs7UUFJQUc7UUFXQU07UUFPQUk7UUFFQUU7UUFFQUU7UUFhQU87UUFPQUk7UUFPQUk7UUFFQUU7UUFFQUU7UUFVQU07UUFVQU07UUFJQUc7UUFTQUs7O1FBbUJBVztRQU1BRztRQU1BRztRQU9BSTtRQU9BSTs7VUF1QkFPO09BR0pHO1VBTUlDO1VBV0FFLFlBS0FFO1VBYUFJLFFBZUFNOzs7Ozs7OzthRno4Q0h1RyxLQUFLQyxLQUFNLGVBQU5BLElBQWM7YUFDbkJDLE1BQU1DLEdBQUksZ0JBQUpBLEVBQVc7YUFDakJDLElBQUlDLEVBQUVydEIsR0FBSSxjQUFOcXRCLEVBQUVydEIsRUFBYzs4QkFGcEJndEIsS0FDQUUsTUFDQUU7YUFvQ0ZFLFFBQVFMLEtBQU0sYUFBTkEsS0FBeUI7YUFDakNNLFdBQVdOLEtBQU0sYUFBTkEsS0FBNEI7YUFDdkNPLGNBQWNQLEtBQU0sY0FBTkEsS0FBK0I7YUFDN0NRLFFBQVFSLEtBQU0sYUFBTkEsS0FBeUI7YUFDakNTLFFBQVFULEtBQU0sYUFBTkEsS0FBeUI7YUFDakNVLFNBQVNWLEtBQU0sYUFBTkEsS0FBMEI7YUFDbkNXLGVBQWVYLEtBQU0sYUFBTkEsS0FBK0I7YUFDOUNZLGlCQUFpQlosS0FBTSxhQUFOQSxLQUFpQzthQUNsRGEsT0FBT2IsS0FBTSxhQUFOQSxLQUF3QjthQUMvQmMsWUFBWWQsS0FBTSxhQUFOQSxLQUE2QjthQUN6Q2UsVUFBVWYsS0FBTSxhQUFOQSxLQUEyQjthQUdyQ2dCLFNBQVNDLEVBQUVDLEdBQUksVUFBTkQsS0FBRUMsR0FBMEI7YUFDckNDLFNBQVNGLEVBQUVDLEdBQUksVUFBTkQsS0FBRUMsR0FBdUI7YUFDbENFLFVBQVVILEVBQUVDLEdBQUksVUFBTkQsS0FBRUMsR0FBd0I7YUFDcENHLFdBQVdKLEVBQUVDLEdBQUksVUFBTkQsS0FBRUMsR0FBeUI7YUFDdENJLFFBQU1MLEVBQUVDLEdBQUksVUFBTkQsRUFBRUMsRUFBZ0I7YUFDeEJLLEtBQUtOLEVBQUVDLEdBQUksVUFBTkQsRUFBRUMsRUFBb0I7YUFDM0JNLFNBQVNQLEVBQUVDLEdBQWtCLFVBQXBCRCxFQUFvQixzQkFBbEJDLEdBQWtDO2FBQzdDTyxXQUFXUixFQUFFQyxHQUFrQixVQUFwQkQsRUFBb0Isc0JBQWxCQyxHQUFvQztJQUNoQzs7S0FDTDthQUVaVSxRQUFPN3VCLEdBQUksMkJBQUpBLEdBQW9DO0lBRi9CLFNBR1o4dUIsT0FBTTl1QixHQUFJLHNCQUFKQSxHQUErQjtJQUN2QixJQUFkK3VCLFlBQWM7YUFDZEMsUUFBTWh2QixHQUFJLHVCQUFKQSxHQUFnQztJQUR4QixTQUVkaXZCLFNBQVNqdkIsR0FBSSwwQkFBSkEsR0FBaUM7SUFGNUIsU0FJZGt2QixVQUFVbHZCLEVBQUVtdkI7TUFDZDtRQUNjOztRQUFtRCxRQUFNO01BQXJFLElBREVDLGNBQ0YsZ0NBRllEO01BRVosR0FERUM7UUFJRjs7bUJBR01DO1lBSEcsU0FHSEE7Ozs7aUJBREUsSUFENEJDO2lCQUNFOzs0REFERkEsRUFOMUJ0dkI7WUFTRixPQURGcXZCLENBRUg7UUFMSCx1Q0FMWUY7TUFZWixrQkFaVW52QixHQUFFbXZCLE1BWUs7SUFoQkgsU0FtRGRJLEtBQU94USxJQUFheVE7TUFBTSxHQUFuQnpRLElBQUssUUFBTEEsV0FBS0UsYUFBTC91QixZQUFtQixVQUFuQkEsSUFBYXMvQixJQUFxQjtJQW5EM0IsU0EwRGRDLElBQU0xUSxJQUFTMlEsSUFBS3gvQixTQUFjaTlCO01BQ3BDLEdBRFFwTyxJQUFLLFFBQUxBLFVBQUtFLGFBQUwwUTtNQUNSLFFBRGdDLGtCQUFKTixFQUFJTyxlQUFKUDtNQUM1QixHQURzQm4vQixRQUd1QmcrQixFQUh2QmgrQixPQUd1QjIvQixtQkFINUJIO2dCQUc0QkcsSUFIckNGLEdBQVNELElBQVdMLEVBQVFsQyxFQVFqQztJQWxFYSxTQXFFZDJDLFFBQVFKLElBQUt4L0IsSUFBS20vQixFQUFFbEMsR0FBSSxjQUR4QjE5QixRQUNRaWdDLElBQUt4L0IsSUFBS20vQixFQUFFbEMsRUFBZ0M7SUFyRXRDLFNBdUVkNEMsSUFBSzcvQixJQUFLbS9CLEVBQUVsQyxHQUFJLHFCQUFYajlCLElBQUttL0IsRUFBRWxDLEVBQXVCO0lBdkVyQixTQXdFZDZDLE1BQU85L0IsSUFBS20vQixFQUFFbEMsR0FBSSx1QkFBWGo5QixJQUFLbS9CLEVBQUVsQyxFQUF5QjtJQXhFekIsU0F5RWQ4QyxTQUFVLy9CLElBQUttL0IsRUFBRUMsR0FBd0Isc0JBQS9CcC9CLElBQUttL0IsS0FBMEIsT0FBeEJDLE1BQStCO0lBekVsQyxTQTJFZFksU0FBUzdDLEVBQ0Y4QztNRDFKWixPQzBKWUE7O1NBR3lCLElBRHJCQyxXQUZKRCxxQkFHeUIsZ0JBSnZCOUMsRUFHRStDO1NBQ3FCLFVBSHpCRDs7U0FDd0IsSUFEckJFLGFBQUhGLFFBQ3dCLGdCQUZ0QjlDLEVBQ0NnRDtTQUNxQixVQUR4QkY7Z0JBSUYsT0FKRUE7SUE1RU8sU0FrRmRHLE1BQU12UixJQUFjc08sRUFBRW5vQjtNQUFRLEdBQXhCNlosSUFBTSxRQUFOQSxXQUFNRSxhQUFOL3VCO01BQXdCLFVBQXhCQSxJQUFjbTlCLEVBQUVub0IsTUFBMkI7SUFsRm5DLFNBbUZkcXJCLEtBQU94UixJQUFlc08sRUFBRW1EO01BQU0sR0FBdkJ6UixJQUFNLFFBQU5BLFdBQU1FLGFBQU4vdUI7TUFBdUIsVUFBdkJBLElBQWVtOUIsRUFBRW1ELElBQXdCO0lBbkZsQyxTQW9GZEMsT0FBUzFSLFNBQTBCMFE7TUFBTSxHQUFoQzFRLElBQUssUUFBTEEsV0FBS0UsYUFBTC91QjtNQUFnQyxRQUFWLGtCQUFKbS9CLEVBQUlPLGVBQUpQO01BQWMsVUFBaENuL0IsSUFBMEJ1L0IsSUFBUkosRUFBK0M7SUFwRjVELFNBc0ZkcUIsU0FBUzNSLElBQVE0UjtNQUFRLEdBQWhCNVIsSUFBSSxRQUFKQSxTQUFJRSxhQUFKMlI7TUFBdUIsVUFBZkQsTUFBZSxrQkFBdkJDLEdBQWtDO0lBdEY3QixTQStGZEMsSUFBS1YsS0FBTVcsT0FBUUMsWUFDckIsVUFET1osS0FBTVcsT0FBUUMsS0FDRDtJQWhHSixTQWtHZEMsV0FBWWIsS0FBTVcsT0FBUUM7TUFDNUIsY0FFZUosTUFBTTFEO1FBQWMsNkJBSGY2RCxPQUdMSCxNQUFNMUQsS0FBZ0M7TUFEN0MscUJBRk1rRCxXQUFjWSxLQUt4QjtJQXZHWSxTQTRHZEUsWUFBWTNCO01BQUk7O2dCQUFNLG1CQUFvQixJQUFMakMsV0FBVSxxQkFBVkEsRUFBekJpQztnQkFBZ0QsUUFBSSxFQUFDO0lBNUduRCxTQTZHZDRCLGNBQWNDO01BQUk7O2dCQUFNLG1CQUE0QixJQUFMOUQsV0FBVSxxQkFBVkEsRUFBakM4RDtnQkFBd0QsUUFBSSxFQUFDO0lBN0c3RCxTQThHZEMsYUFBYTlCO01BQUk7O2dCQUFNLG1CQUFxQixJQUFMakMsV0FBVSxxQkFBVkEsRUFBMUJpQztnQkFBaUQsUUFBSSxFQUFDO0lBOUdyRDs7Ozs7T0ExQmRoQztPQUNBQztPQUNBQztPQUNBQztPQUtBSztPQUpBSjtPQUdBRztPQUZBRjtPQUNBQztPQUdBRztPQUNBQztPQUdBQztPQUNBRztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUlBRztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQVRBUDtPQUNBQztPQWdIQXFDO09BQ0FDO09BQ0FFO09BcERBM0I7T0FXQUs7T0FsQkFQO09Bd0JBVztPQU9BSTtPQUNBQztPQUNBRTtPQWJBVjtPQUNBQztPQUNBQztPQWFBUztPQVNBRztPQUdBRztJQWxHYzthQzdEWkssU0FBU0MsS0FBTSxPQUFOQSxNQUFrQjthQUl2QkMsSUFBa0VDOztNQUFsRTs4QkFDWSxJQUFQdkUsV0FBTyxzQkFBUEE7O1VBQ00sYUFBVSxvQkZ2QmhDLE9FcUJXc0UsSUFBa0VDO1VBRTdDLHVDQUFmckU7OztXQUNFc0U7V0FBSHBFOzs7MkJBQXNCcnRCLEdBQU8sK0JBQTdCcXRCLEVBQXNCcnRCLEdBQVk7dUJBQWxDcXRCOztlQUFHb0U7O1FBRVYsd0JBTG9FRDtRQU1yRDs7Z0JBRUxFLGNBQU5DO1lBQ0ssY0FETEEsTUFIQUw7d0JBR01JOztVQUQ4RTs7V0FBcEI7V0FBakQ7NkNBS2I7YUFpQlJFLEtBQU1DLEtBQUtDLEtBQU0sVUFBTkEsSUFBTEQsS0FBc0I7YUFFNUJFLFdBQVdULEtBQU0sT0FBTkEsTUFBb0I7YUE4QmpDVSx1QkFBdUI5c0I7TUZsRjVCLElFdUV1QitzQixLQVdLL3NCO01BVnpCO1FBQUcsY0FEaUIrc0I7YUFhaEJDLE9BWEYsdUJDdW9DQzdUOztVRHJvQzBCO3NDQ29vQzFCRCxPRHhvQ2lCNlQ7V0FJRDtXQUNHLDBCQURoQkU7V0FDZ0IsbUJBQTJCLHFCQUQzQ0E7VUFDaUUsR0FBakVDO1lBQzhDLGdDQU5oQ0g7WUFNRSxrQ0FORkE7aUJBYWhCQyxPQWJnQkQ7Ozs7O1VDZytDZDtZRHY5Q1ksa0NBVEVBO1FBY0w7eUNBRFhDO1NBRVUsK0JBSldodEI7U0FLaEIsc0JBRkxvdEI7U0FFbUMsc0JBRG5DQztRQUNtQyxHQUFuQ3RKLEtBQThCRztVQUVELGdDQUw3QjhJLFVBRzhCOUksS0FBOUJIO1VBRTZCLDhCQUw3QmlKO1FBQ1c7U0FNSix3QkFOUEk7U0FNa0Msd0JBTGxDQztTQUtrQyxLQUFMRSxPQUEzQkQ7UUFBZ0M7VUFFSCxnQ0FUL0JOLFVBTzZCTyxPQUEzQkQ7VUFFNkIsOEJBVC9CTjtvQkFTcUU7YUFZdkVRLFFBS1FsQjtNQUxFLE9BS0ZBO2VBSkcsT0FJSEE7ZUFITSxPQUdOQTtlQUZFLE9BRUZBO2VBREcsT0FDSEE7Z0JBQUssT0FBTEEsWUFBYzthQUV0Qm1CLFNBS1FuQjtNQUxHLE9BS0hBO2VBSkcsT0FJSEE7ZUFITSxPQUdOQTtlQUZFLE9BRUZBO2VBREcsT0FDSEE7Z0JBQUssT0FBTEEsU0FBVzthQVduQm9CO01BQVk7ZUFDQSxJQUFMNXlCLFdBQUs7ZUFDSCxJQUFMNG9CLGFBQUssT0FBTEE7ZUFFTyxJQUFMNkksYUFBSyxPQUFMQTtnQkFESSxJQUFMb0IsYUFBSyxXQUFMQSxJQUN1QjthQUU1QkM7TUFBaUI7ZUFDTCxJQUFMeEQsV0FBSyxPQUFMQTtlQUNFLElBQUx0dkIsV0FBSyw2QkFBTEE7ZUFFTyxJQUFMNG9CLGFBQUssNkJBQUxBO2dCQURJLElBQUw2SSxhQUFLLDZCQUFMQSxLQUN1QjthQUU1QnNCLFVBQVVDLEdBQUdDO01BQ2YsU0FEWUQsT0FBR0M7TUFDZjs7O2VBRFlEOztvQkFBR0M7aUJBR0twakMsR0FITG9qQyxTQUdObGpDLEdBSEdpakMsK0JBR0hqakMsR0FBV0Y7OztvQkFITG9qQztpQkFJREMsS0FKQ0QsU0FJVEUsS0FKTUgsYUFJTkcsU0FBUUQ7OztvQkFKQ0Q7aUJBTUdHLEtBTkhILFNBTVBJLEtBTklMLGFBTUpLLFFBQVVEOzs7b0JBTkhIO2lCQUtDSyxLQUxETCxTQUtSTSxLQUxLUCxhQUtMTyxTQUFTRDs7TUFYRyxXQWFQO2FBRVZFLE1BQU1DLEtBQUt2dUIsT0FDTSxVQURYdXVCLEtBQ1csUUFETnZ1QixhQUMyQjthQUV0Q3d1QixNQUFNckcsR0FDRCxxQkNzakNKalAsT0R2akNLaVAsS0FDRCxRQUErQjthQUVwQ3NHLGlCQUFpQjdCO01GM0p0Qjs7O2tCRTZKUzs7c0JBRUs7d0JBQUksZ0NBSklBLEtBS0k7NEJBQVA4Qjs7d0JBQXNDLHVDQUF0Q0E7d0JBQXNDLDZDQUF3Qjs7Z0JBSzFFLHNCQUFpQiw4QkFWRjlCLElBVW1CO2FBT3BDK0IsaUJBQWlCL0IsSUFBSTFCO01BQ3ZCO1FBQ0U7O1dBRWEsSUFESWpDLFdBQUhELFdBQ0QsMEJBSkk0RCxJQUdINUQ7V0FDRDtZQUMyQixtQkFGdkJDLFFBRUQsc0JBTEMyRCxLQUdINUQ7Ozs7O1dBS1IsSUFEUTRGLGFBQUhqRSxhQUNMO1dBQ2dDLE9BQXJCLHNCQVRBaUMsV0FPTmpDO2lCQVNGOztlQUhTa0UsYUFBSEM7eUNBYkVsQyxJQWFGa0MsSUFBR0QsS0FJakI7TUFoQkgsdUNBRHVCM0QsV0FrQlg7YUFRTjZELEtBQW1EM0MsSUFBSW1DO01BQzdELE9BRDZEQTs7U0FHekQsSUFESWpFLElBRnFEaUU7U0FHdEMsVUFIc0NBLEtBR3RDLHVCQ3VnQ3BCcFYsV0R4Z0NLbVI7O1NBa0JDO1VBSFcwRSxTQWpCeUNUO1VBaUIvQnJELFdBakIrQnFEO1VBaUI5Qy9ELElBakI4QytEO1VBaUJsRDlELEdBakJrRDhEO1VBb0JwRDs2QkFIRTlEO2FBR1csdUJDcy9CbkJ0UixXRHovQllxUjthQUlKLHVCQ3EvQlJyUixXRHovQlFzUixHQUFJRDtVQU1hLG9CRjdOL0IsT0VzTVN1RSxLQUFtRDNDO1VBdUJ0QywyQ0FOQzRDO1VBTUQ7b0JBQ0F0RDthQUE4QixpQkFBOUJBLEdBQThCLDZCQUx6Q3VELFdBS29EO1NBQXhELGdDQURJQztTQUVKLGlCQU5JRCxNQUZzQi9EO1NBUTFCLFVBekJ5RHFELEtBbUJyRFUsTUFJQUM7O1NBakJRLElBRE5sdkIsTUFMbUR1dUIsUUFLdERwRyxFQUxzRG9HLFFBTTdDLGFBTnlDbkMsSUFLL0Nwc0I7U0FFWSxVQVB1Q3V1QixLQU92QyxRQURkdHVCLFNBRERrb0IsRUFDQ2xvQjs7YUFHR3FyQixJQVRrRGlELFFBU3JEWSxJQVRxRFo7U0FVOUMsYUFWOENBLEtBVTlDLEtBVjBDbkMsSUFVaEMsV0FEakIrQyxJQUFHN0Q7O1NBaEpUO1VBbUphSCxhQVo4Q29EO1VBWW5EaEUsSUFabURnRTtVQXZJM0Q7OztlQXVJdURuQzs7U0F2SXZEO1dBQVFROzs7O2lDQUVKd0M7Ozs7O2NBRmdCO1NBQXBCO1dBQ0l2QztvQkFBV3dDO2FBQUk7Z0NBRFh6QztjQUNXOztpQkFEWEE7O2FBQ21CLDRCQUFaeUMsRUFBOEI7U0FFN0M7V0FESUQ7OztrQkFYZWhELE9BVWZTOzs7a0JBUFksSUFEUkwsWUFBTkMsWUFDYyxpQkFEZEEsR0FGaUJMLElBNEpYN0I7a0JBekpRLFVBQ0EsSUFBTHBDLFdBQUssT0FBTEE7a0JBREssVUFEUnFFOztnQkFEQTs7U0FRUjtVQUdBLGtCQURJNEM7VUFDSjs7YUFESUE7O1NBbUpGLGlCQURJRSxTQURPbkU7U0FFWCxVQWR5RG9ELEtBYXJEZSxPQWEwQjthQUdoQ0MsV0FBVzFpQyxVQUFVMmlDLEtBQUs5ekIsSUFBSTdQLE1BQU00akMsR0FBR0M7TUFDekM7UUFBcUIsOERBQU1FLEdBQVFELEdBQWlDO01BQXpEOztPQUNGLGdCQURMRSxLQURrQ0o7T0FFWixnQkFEdEJJLEtBRHFDSDtPQUc1Qk07T0FBR0M7TUFDZDtXQURXRDs7YUFBR0M7c0RBSU1OO1lBQWlCLDZCQUFqQkE7Y0FFaEIsV0FUMEI5akMsZ0JBR25CbWtDO1lBYTBCLHdCQVRqQkw7Y0FXaEIsV0FsQnNCajBCLElBT05pMEIsV0FKTk07WUF3Qkgsa0JBM0JVVCxjQTZCZixXQTdCb0I5ekIsSUFPTmkwQjtnQkFKVEssVUFBR0M7O1VBVVYsV0FiMEJwa0M7Y0FHbkJta0MsVUFBR0M7OztjQWlCSUMsTUFqQkpELHdCQWlCSEUsZ0JBQUpDO1VBRUgsV0F0QnNCMTBCLElBb0JuQjAwQixLQUFJRDtjQWpCQUgsT0FBR0MsS0FpQklDOztRQWZOLFNBNEJKO2FBR0pHLE9BQU9sSTtNRnZRaEI7OztVRTBRYSxJQURGcUUsY0FBTkMsY0FDUSxpQkFIR3RFLEVBRVhzRTtVQUNRLFVBRU0sSUFBTDN4QixXQUFVLFVBQVZBLEVBQVUsT0FMUnF0QixFQUVMcUU7VUFDRSxZQURGQTs7UUFEQTtJQU9SLElBREU4RDtJQUNGLFNBRUVDLGdCQUFnQjNELElBQUk0RCxHQUFHQztNQUN6QixTQUFJQztRQUFRLHVCQUFzQnpILFdBQUhELDBCQUFHQztRQUF5RCxRQUFJO01BQS9GLFNBQ0l2dEIsSUFBSXN0QixFQUFFQztRQUNSLDBCQURNRDtrQkFBRUM7V0FFaUIsSUFBUG1CLEVBRlZuQjtXQUVpQixxQkFBUG1CLEVBQVcsdUJBSmJ3QztRQU1MLDhCQU5LQSxJQUVWNUQ7UUFJSztTQUMyQixtQkFMOUJDLFFBS00sc0JBUEUyRCxLQUVWNUQ7OztRQURJLFdBTXlDO01BTnJELFNBUUluOUIsTUFBTW05QjtRQUFJLGlCQUFRLDZCQVRKNEQsS0FTUjVELFNBQTRDO01BTXBELGdCQWRFMEgsTUFEcUJEO01BVXpCLFdBckpFN0MsZUFNQUMsVUF1SUVueUIsSUFPQTdQLE1BS0YsT0FiRTZrQyxNQURrQkY7TUFVdEIsU0FPSUc7UUFBUyx1QkFBbUIxSCxXQUFIRCw2QkFBR0M7UUFBbUUsUUFBSTtNQVB2RyxTQVFJcEksTUFBSW1JLEVBQUVDO1FBQXNELG1CQUF0REE7UUFBMEMsT0FBckIsc0JBbEJiMkQsV0FrQlY1RCxTQUFxRTtNQVI3RSxTQVNJNEgsUUFBTTVIO1FBQTBDLE9BQXJCLHNCQW5CYjRELFdBbUJSNUQsS0F0QlJzSCxlQXNCNkU7TUFNN0UsZ0JBUkVLLE9BakJxQkY7TUFvQnpCO1FBL0pFN0MsZUFNQUMsVUF1SkVoTixNQUNBK1AsUUFLRixPQVBFRCxPQWpCa0JIO01Bb0J0QixTQU9Jdkc7UUFBUSx1QkFBdUJoQixXQUFIRCwwQkFBR0M7UUFBd0QsUUFBSTtNQVAvRixTQVFJNEgsTUFBSTdILEVBQUVDLEdBQUksOEJBNUJJMkQsSUE0QlY1RCxFQUFFQyxFQUFpQztNQVIzQyxTQVNJNkgsUUFBTTlILEdBQUksOEJBN0JJNEQsSUE2QlI1RCxFQUFrQztNQU0xQyxnQkFSRWlCLE1BM0JxQndHLElBa0N2QixZQVBFeEcsTUEzQmtCdUcsSUFrQ3BCO2lDQUhLcEcsR0FBSyxPQUFMQSxDQUFNLE9BSFR5RyxNQUNBQyxrQkFNZTtJQXJDbkIsU0F1Q01uRSxLQUNGUCxJQUFJWSxPQUFPK0QsSUFBSXhDO01BR3VCLEdBSHZCQSxTQUd1QixTQUgzQndDOzs7OzttQkFBSXhDO2dCQU15Q3lDLEdBTnpDekMsUUFNdUIzQixJQU4zQm1FLE9BTWFFO1lBQ3JCLHdCQURxQkEsR0FBZ0NELElBQ3ZDLHVCQURxQnBFLElBQWtCb0U7WUFDVixVQVAvQnpDLEtBTXVCM0I7OztrQkFOM0JtRTs7bUJBQUl4QztnQkEwQmlCUyxTQTFCckIrQixPQTBCZ0I5QixNQTFCaEI4QjtZQTBCZ0QsNkJBMUI1Q3hDO2dCQTBCK0QsMEJBMUIvREE7ZUFvQ0k7eURBVmFTO2dCQVdiLHlDQXJDSlQ7Z0JBd0NGO3FCQUpUMkM7ZUFJUztxQkFDYkc7aUJBQ0U7bUJBQVE7b0JBQUoxRztxQkFBZ0IsU0FBVSxpQkFONUJ1RyxhQUtKRzttQkFFRSw2QkFIRUQsT0FFRXpHLElBRE4wRzttQkFDVSxTQURWQTs7O2VBTG1CO2dCQWFuQiwrQkFaSUY7Z0JBWUosS0FBSUc7Z0JBQUo7O3FCQUNBQztpQkFDRTttQkFBUSxJQUFKdkksRUFBZ0IsaUJBZGxCbUksYUFhSkk7bUJBQ1U7cUJBQ0YsdUNBWkpILE9BV0VwSTs7Ozs7bUJDNnJDSjtxQkR6ckNJLGlCQU5Gc0ksUUFDSkMsZ0JBSUlDO3FCQUVFLDhCQWhCRkosT0FXRXBJO21CQUFJLFNBRFZ1STs7O2VBZG1COztnQ0F3QlZFO21CQUVxQixpQkFBUyxpQkExQm5DUCxhQXdCS087bUJBRXFCLDZCQXBDSHhDLFdBb0M4QjtlQUh6RCxtQ0FuQkltQztlQUplO2dCQXVCbkI7Z0JBU2U7cUJBL0JYRDtlQStCVztxQkFDZk07aUJBQ0U7dUJBQUlHLElBQUosaUJBckJFTixRQW9CSkc7bUJBRTBELFFBRHBERztvQkFhZ0M7MkNBOUNsQ1QsYUFnQ0pNO3FCQUdNL0Y7c0JBV0E7d0JBbkZOVSxJQTBCMkI2QyxNQXlEUixpQkEvQ2ZpQyxhQWtDRVU7O3dCQUVBbEcsRUFJQSxLQTVFTlUsSUE0RWUsaUJBdkNYK0UsYUFnQ0pNO21CQWNzRCxRQWJoREc7cUJBZ0NBLEdBakNOSCxPQWhDSU47K0JBaUNFUyxTQWxDRlY7O3NCQW1FUTs0QkFsQ1pPOzt3QkFrQ1ksaUJBdERSSCw2QkFxQkVNOzs7O3NCQWtDd0I7NEJBcEMxQkQ7dUJBb0MwQixhQWhDeEJqRzt1QkEyQkFtRyxLQUtHOzswQkFMSEE7OzttQkFPSixHQVBJQTtxQkFRMkMsU0F2QzdDRixRQXdDMEIsYUFwQ3hCakc7cUJBb0NGLHNCQWxGdUJ1RDttQkFvRmpCLGtCQXRDSnZEO21CQXNDSSxjQXRDSkEsRUFMRmdHO21CQUdGLFNBREZEOzs7ZUFqQ21CLElBOEVmdkMsV0EvQ0F3QztlQWtESixnQkEzRjJCekMsY0ExQlpWO2VBcUhmLFVBckhlQSxLQTBCWVUsTUF3RnZCQzs7O2tCQWxIV1g7V0FXSCxJQUR3QnVELEdBVnJCdkQsUUFVVXBHLEVBVlZvRyxRQVVId0QsR0FWRGhCLE9BV0MsV0FYWjNFLElBQUlZLE9BVVErRSxHQUF3QkQ7V0FFbEIsVUFaSHZELEtBWUcsUUFEZHZ1QixPQURxQm1vQixFQUNyQm5vQjs7O2tCQVhPK3dCOzttQkFBSXhDO2dCQWNtRWtDLEdBZG5FbEMsUUFjeUR5RCxHQWR6RHpELFFBY0YwRCxLQWRGbEIsT0FjaUNQLFdBQVYwQjtzQkFBc0NGLE1BQTVCeEIsT0FBc0NDLFVBR2hGLE1BakJhbEMsS0FjRjBEO1lBS0EsYUFuQkUxRCxLQW1CRixLQW5CYm5DLElBQUlZLE9BY1NpRixLQUtvQixXQUx1Q0QsR0FBVXZCOzs7a0JBZHZFTTs7bUJBQUl4Qzs7YUFxQndGNEQsS0FyQnhGNUQ7YUFxQnVFNkQsS0FyQnZFN0Q7YUFxQjZEOEQsS0FyQjdEOUQ7YUFxQjJDaEUsSUFyQi9Dd0c7YUFxQjBDdUI7YUFBakJDO2FBQVZDO1lBQ3ZCLHFCQUR1QkEsS0FBa0RIOzJCQUF4Q0UsU0FBa0RILE9BQ25ELFdBRHVCN0gsT0FBNEI2SDs7Z0JBRXRGLGdCQUYwRDdILE9BQUwrSCxLQUFrREgsTUFFdkcsVUF2QmU1RCxLQXFCMkNoRTtNQW9HbEQsV0F6SFI2QixJQUFlbUMsTUEwSDBCLGFBMUg5QndDLEtBMEhrQixhQUR6QmoyQjtNQUNKLHNCQTFISWt5QjtNQTBISixPQURJbHlCLENBRUg7SUFuS0wsU0F5S00yM0IsYUFBcUd6Rjs7TUFBckc7Ozs7V0FFSzBGO1dBQUh2Szs7O2dDQUEyQnJ0QixHQUFZLG9DQUF2Q3F0QixFQUEyQnJ0QixHQUFpQjs7c0NBQTVDcXRCOzttQkFBR3VLOztnQkFDVywrQkFBYkM7aUJBRnNDLDJCQUQ0RDNGLFFBRzVEO0lBNUsvQyxTQWtMTTRGLFlBQStEQyxLQUFLakc7TUFFbkM7a0NBRm1DQTtPQUVwRTs7UUFFVSxJQUFUcUM7UUFBZ0IsR0FBaEJBLFVBQWdCLFFBSjhDNEQ7VUFLakUsaUNBQVcvM0IsR0FBSyxPQUFMQSxDQUFNLE9BTGdEKzNCO1FBSXJELElBS1Y3RixPQUZVLFlBUHFENkYsS0FPcEMsdUJBSDFCNUQ7UUFHUyxHQUVWakM7Ozs7YUFDRSxJQUQrQmdDO2FBQy9CO2VBQVk7OEJBQWV0RCxHQUFLLGVBQUxBLE9BTjVCdUQsU0FNaUQ7Z0JBQXBDLGtDQURtQkQ7Ozs7ZUFHeEI7K0JBSFRoQyxPQUdJdEI7bUJBR0Y7b0JBQ0c7UUFSTztNQUxSLFFBY0g7SUFuTVAsU0FxTUVvSCxZQUFZekQ7TUFTQTtpQ0FUQUE7T0FRRCwwQkFSQ0E7T0FPRiwwQkFQRUE7T0FNRiwwQkFORUE7T0FLSCwwQkFMR0E7T0FJSCx5QkFKR0E7T0FHUix5QkFIUUE7TUFFUiw4QkFGUUEsc0NBVWI7SUEvTUQsU0E4TkV6QyxJQUFJOXhCLEdBQUksT0FBSkEsSUFBUztJQTlOZixTQStORWk0QixRQUFRajRCLEdBQUksT0FBSkEsSUFBYTtJQS9OdkIsU0F3T0VrNEIsSUFBSUMsR0FBSSxhQUFKQSxLQURKeG9DLFNBQytCO0lBeE9qQyxTQXlPRXlvQyxTQUFPRCxHQUFJLFVBRlh4b0MsWUFFT3dvQyxLQUE4QjtJQXpPdkMsU0EwT0VFLE1BQU1DO01BQ1IsY0FFdUMvRCxHQUFLLE9BQUxBLElBQWM7TUFBN0I7NENBSGhCK0Q7T0FHSTtvQkFEd0IvRCxHQUFLLE9BQUxBLElBQVc7TUFBMUIseUNBRmIrRDtNQUVDLGdEQUVSO0lBOU9ELElBaVBFQyxVQVZBNW9DO0lBdk9GLFNBbVBFNm9DLFNBQVNqRSxHQUFjLHFCQUFkQSxLQUZUZ0UsZUFFdUIsUUFBa0I7SUFuUDNDLFNBcVBFRSxNQUE4QjFaO01BQTFCOzs7Ozs7U0FBMEJBLElBQU0sUUFBTkEsV0FBTUUsYUFBTjJaLElBZDlCanBDO01BY0k7T0FFSSxlQUZzQmlwQyxPQUo5Qkw7T0FPYyxpQ0N5c0JibGE7T0R6c0JhO2dDQUV5Qiw0QkFBWTtPQUZyQyxJQURad2E7T0FDWTs7a0JBSWlCL0csSUFBSWtILEtBQU8sa0JBRnhDRCxzQkFFNkJqSCxJQUFJa0gsSUFBa0M7O09BQy9ELE9BREoxSCxJQUNhLFdBUGtCUCxLQUF2QjRIO09BT0osU0FQSUE7T0FPSixXQUFKMzRCO09BQUk7O2VBUUpvNUIsYUFBYS9MLEdBQUksb0JBQUpBLEVBRGI4TCxnQkFDaUIsUUFBZ0M7TUFSN0MsU0FTSkU7UUFLRjtRQUNlOzZCQXRCa0J0SSxLQVMvQko7U0FjTSxPQWpCTlcsSUFKQXdILFVBUUFHLFdBWUVLO1FBQ0ksYUFBSnQ1QjtRQURXLElBR1htdEIsRUFBSSwwQkFYTmdNO1FBV007c0JBRU85TCxHQUFLLGtCQUFMQSxJQUFTO1FBRmhCLHVDQUFKRixFQUV1QjtNQXBCckIsU0F1QkE4SyxRQUFRaEw7UUFDb0M7MEJBL0J6QjZELE9BU3ZCSCxTQXFCWTFEO1NBQ29DOzttQkFBN0NzTTtRQUVMLElBaENFVixTQTZCSVosUUFDb0JDO1FBQXdCLGFBbEJoRGdCO1FBb0JGO2tCQXBCRUEsc0JBcUIwQixzQkN3cUIzQjlhLE9EMXJCQ2liO3FCQXFCQztNQUcwQixnQkFqQzNCcjVCO01BaUNKLHNCQXRDSTg0QjtNQXNDSixTQUlJVSxRQUFRUjtRQUNELElBQUxTLEdBQUssb0JBRENUO1FBQ0Q7VUFFbUI7bUNBSGxCQTtXQUdFOzs7Y0ZwakJqQjs7Y0VnbEIyQjs7Ozs7OzswQkFHc0I1STs7Ozs7Ozs7Ozs7O2tCQ285QnhDO29CRGg5Qkksc0JBbENnQmpELEVBOEJvQmlEO29CQTdCeEM7OENBSkFxSjs7Ozs7Ozs7Ozs7a0NBR29CdE07Ozs7OztxQ0FxQmNFOzhDQUFnQixXQUFoQkEsRUFBbUIsWUF6Qi9DMkw7Ozs7Ozs7OztpQ0FJYzdMOzs7OzttQ0FoRlo7b0NBc0dzQmtIO29DQXRHdEIseUJBNEVGMkU7b0NBN0VDLHlCQTZFREE7b0NBOUVBLHlCQThFQUE7OztzQ0EwQndDLFdBQWhCM0UsT0F6RzFCLHFCQStFRTJFOzs7Ozs7Ozs7Z0NBSWM3TDs7Ozs7O21DQUVNeU07NENBQWUsV0FBZkEsSUFBa0IsdUJBSDFDRjs7Ozs7Ozs7OytCQUNrQnZNOzs7Ozt5Q0FvQm1CLHdCQUFiRjs7bUNBUkwsSUFEWXlFLEdBWGJ2RSxLQVlDLGtDQWJuQnVNO21DQWNFLHVCQWRGQSxJQUxKaHFDLHFCQWtCVW1xQzttQ0FBYSxJQVpEMU0sRUFXYXVFOzs7Ozs7Ozs4QkFYYnZFOzs7Ozs7aUNBa0JZMk07MENBQWdCLFdBQWhCQSxJQUFtQixZQXRCN0NkOzs7Ozs7Ozs7NkJBSWM3TDs7Ozs7b0NBdUJrQjRNO2dDQUFXLG9CQTNCM0NmOzZDQTJCMkUsV0FBM0NlLElBQThDLFlBM0I5RWY7Ozs7Ozs7OzRCQUljN0w7Ozs7OzsrQkFpQk02TTt3Q0FBZ0IsV0FBaEJBLElBQW1CLFlBckJ2Q2hCOzs7Ozs7Ozs7MkJBSWM3TDs7Ozs7OztnQ0FlYThNO3lDQUFnQixXQUFoQkEsSUFBbUIsdUJBaEJsRFA7Ozs7O2dDQWlCaUNRO3lDQUFnQixXQUFoQkEsSUFBbUIsdUJBakJwRFI7Ozs7Ozs7OzswQkFDa0J2TTs7Ozs7b0NBbUJpQiwwQkFBYmdOOzs4QkFkSDsrQkFES0M7K0JBQ0wsb0NBTm5CVjsrQkFRUSwrQkFSUkEsSUFMSmhxQzsrQkFhWTs7O2dDQUMwQztrQ0FBOUMsdUJBVEpncUMsSUFMSmhxQztrQ0FXVTJxQzs4QkFHMEQsR0FGMURDOzRDQUlpQixXQU5DRixJQUNsQkM7Ozs7Ozs7Ozs7MkJBTFlsTixHQXdCSixRQXhCSUE7O3dCQW9DRixJQUFQcU4sZUFBZSw4QkFBZkE7a0NBSlB0STs7Z0JBT0EsU0FBRTtVQUdSLFVBQVUsWUFoRlYrRyxXQXFDSVM7VUFBc0I7V0E2Q3ZCLHNCQS9DREQ7V0ErQ0MsV0FBZ0Isa0JBL0NqQkE7VUErQzRCO1dBQzVCOzs7ZUFDUSxzQkFwRlZSLFdBcUNJUztlQStDTTs7Ozs7cUJBTUY7Ozs7eUJBQ0U7Ozs7OztpQ0FDdUMsSUFBVHhEO2lDQUFTLHdCQUFUQSxHQUFlLHVCQXZEbkR3RDt5Q0F1RHdFLHVCQXZEeEVBLElBdURvQ3hEOzs7OytCQUNPLElBQVB1RSxZQUFPLDhCQXhEM0NmLElBd0RvQ2U7eUJBQ3JCLFFBQ1I7cUJBTEgsc0NBRG1Ecks7ZUFRaEQsUUFBRTtZQWRYLElBaEZGOEksa0JBZ0cwQixhQWhCcEI3TCxHQWdCd0M7Ozs7VUFFOUM7Y0FER3VHOztVQUNrRCxzQ0FEbERBO1VBQ2tELHVDQWxFbkQ2RixRQWtFMkU7TUF2RWpGLFNBMEVJaUIsZUFBZWhCLElBQUlpQjtRQUNULHNCQXpHVjFCLFdBd0dlUztRQUNMOzs7OztrQkFDdUN0SixrQkFBMUN3SyxzQkFBMEN4SztjQUNoQzs7OztvQkFFRSwyQkFBUnlLO2tCQUQ0QixJQUFwQkMsY0FBTDNDLFNBQXlCLGFBSnBCd0MsU0FJTHhDO2tCQUF5QixLQUFnQjRDLGFBQXBDRDtrQkFBb0IsWUFBZ0JDOzs7O2tCQU12QyxJQUFQOU4sZUFBZSwwQkFSakIyTixPQVFFM047Z0JBREc7UUFJUixRQUNEO01BeEZQLHdCQTBFSXlOO01Ba0JKLHVCQWxJSTVCLHNCQTBDQVU7TUF5RkosdUJBbklJVix5QkEwQ0FVO01BMEZKLHVCQXBJSVYsc0JBMENBVTtNQTJGSix1QkFySUlWLHVCQTBDQVU7TUE0RkosdUJBdElJVixzQkEwQ0FVO01BNkZKLHVCQXZJSVYscUJBMENBVTtNQThGSix1QkF4SUlWLDBCQTBDQVU7TUErRkosdUJBeklJVix3QkEwQ0FVO01BZ0dKLHVCQTFJSVYsNEJBMENBVTtNQWlHSixJQTVJSVgsU0E2QklaLFFBOUJZUztNQTZJcEIsVUEzSUlJLFVBNEJJYixRQWdIa0I7SUFwWTFCOzs7VUE5UEk1RztVQWlDQU8sS0FFQUc7T0FtY0ZtRztPQUNBRTtPQUNBQztPQUhBMW9DO09BWUE2b0M7T0FFQUM7T0F2QkEzRztPQUNBbUc7SUEvTkY7VUYvUUg7Ozs7Ozs7SUdBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ29DSytDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQU1BQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQXZCQUMsc0JBQWlCLHFDQUVEO2FBRWhCQztNQUFtQjtlQUNWO2VBQ0Q7ZUFDRTtlQUNEO2dCQUNBLGlCQUFPO2FBcUJoQkMsZUFBZUM7TUFlZjtrQ0FmZUE7Ozs7O2dCQUlDQyxjQUFOQyxTQUFMQzs7Ozs7a0JBQ0lDOzs7O1lBSUY7d0JBTEdGLEVBQU1EO2FBS1Q7cUJBSkVHOzs7O1VBS1MsbURBQVJDOztRQU8rQzs7O1lBQVU7bURBQU1FLEVBQUdELEVBQW9DO1NBQXZEO1NBQXBCO1FBQXJDO1FBQXlEO1NBQXpEO21CQUU2QkEsRUFBRUU7WUFBUSxjQUFlRCxFQUFFRTtjQUN6QyxVQUR5Q0E7ZUFvQmxDLFlBcEJnQ0YsRUFBekJEOztnQkFDZCxTQUR5Q0csTUFFaEMsSUFBTEMsRUFGcUNELEtBRWhDLGFBQUxDLEdBRm1DSCxFQUF6QkQ7b0JBV0FLLE9BWDJCRixLQVdqQ0csS0FYaUNILEtBV3BDSSxJQVhvQ0o7NkJBV3BDSSxLQVhrQ04sRUFBekJELEVBV05NLEtBQU1ELGNBaUJYO1lBNUJxQix1Q0FBUkgsS0E4Qlo7U0EvQlIsbUNBbEJJUjtTQWtCSjs7U0FtQ1ksdUJBbkNyQmM7U0FtQ3FCLE9BbkNyQkE7U0E2Q0k7U0FDRSxtQ0FERixpQkFWSkMsTUFDQUM7U0FVTTttQkFDT0c7WUFBTCxNQUFLQSxNQUFMLEVBQUtBO1lBQ0QsaUJBQVYsaUJBaERGTCxPQStDaUJSLFVBQUhDOzs7WUFDRixrQ0FEQ1ksR0FGYkYsRUFLQztRQUhIOztVQUlVLCtCQU5SQSxVQUNBQztVQU1xQjs0Q0FQckJEO1dBT3FCOztXQUNWOztnQ0FyRFhILE9Bb0RZTSxvQkFBUkM7O1dBQ08sUUFBUEM7V0FBTyxLQUFQQTtVQUFPO1lBSUw7O2tCQUpGQTthQU1JLHNCQU5KQTthQUtJLG9CQUxKQTtZQUlFLGdDQURJWjtZQUtKLDZCQWZOUSxJQVVVUixLQUhOWTtVQURpQjtVQWR2QixJQWNjRixrQkFoQlpKO1dBTXVCO2dCQVVYSTs7O2NBVjBCLGlCQUFkLGlCQTFDeEJOLHFCQW9ESU87Ozs7O1VBQWlCO2NBQWpCQSxrQkFqQkpOO1dBTXVCO2dCQVduQk07OztjQVg4QjtpQkFBVixpQkF6Q3hCUCxPQW9EWU07Ozs7O1VBQVM7aUJBQVRBO1dBWlc7Z0JBWVhBOzs7Y0FaMEIsaUJBQWQsaUJBeEN4Qk4scUJBb0RJTzs7Ozs7VUFBaUI7aUJBQWpCQTtXQWJtQjtnQkFhbkJBOzs7Y0FiOEI7aUJBQVYsaUJBdkN4QlAsT0FvRFlNOzs7OztVQUFTOzs7cUJBQ2pCRSxLQUNBQztlRC9IWCxnQkNrSmVDO2lCQVJPLFNBUVBBLEtBUk8sS0FRUEEsS0FSTyxLQVFQQTtpQkFSTyxhQVFQQTs7Ozs2QkFwQkpGOzZCQW9CSUU7OzZCQXBCSkY7NkJBb0JJRTs7NkJBbkJKRDs2QkFtQklDOzs7NkJBTEMseUNBdkJUUDs0QkFTSU07K0JBbUJJQyxPQXBCSkYsUUFvQklFLE9BcEJKRixRQW9CSUUsT0FuQkpEOzsyQkF3QkM7Y0F6QkRELEtBQ0FDO1VBVUY7b0JBZ0JEO2FBRUhFLEtBQU9DLFFBQW9DQyxTQUFTQyxNQUFNNUI7TUFFNUQsR0FGUzBCLElBQVksUUFBWkEsbUJBQVlHLGFBQVpDO01BRVQsT0FGcUMsaUJBQVJFLFFBQVFELGVBQVJDO01BRTdCLElBQUlDO01BQUosYUFFb0NDLElBQUkxQjtRQUNsQixtQkFBa0MyQjtVQUFsQjtvQkFBa0JBLDJCQUFaRSxZQUFLRDtVQUFYLE1BQWtCRDthQUwvQ0w7WUFXd0MsSUFBUmpCLElBWGhDaUI7WUFXd0MsU0FBUmpCLFFBRFB5Qjs7OztVQUxJO1dBU1IsTUFUY0Q7V0FTZCxNQVZNSDtXQWdCMkIsb0NBVjdCSTtXQVM2QixzQ0FqQjNETDtXQWdCMkQscUNBaEIzREE7V0FlMkQsaUNBRjdCTztXQUM2QixvQ0FGN0JEO1dBRU87V0FPc0I7V0FBTDtXQUVWLG1DQVZkQztXQVNjLHNDQVZkRDtXQVNRO29CQWxCRUYsZUFrQlZLLFFBUEFELEtBWGVMLFFBeUJ2QjtRQXpCSCwyQ0FEaUI1QjtRQUNqQixxQ0E0QkE7TUE5Qkw7MENBSDBDUjtPQUcxQzs7bUJBa0NvQjRDLElBQUlYO1FBQWEsa0NBQWJBO1FBQWEsNEJBQWpCVyxRQUFnQztNQUFwRDtzREFyQzBDNUM7T0E4Q0E7T0FBdkI7T0FBbEIsNkJBOUMwQjJCO09BOEN2QztPQURNO09BQVI7T0FIc0Q7T0FBcEMsMENBTGxCa0I7T0FLQSx5Q0F2Q0FGO09BcUN5Qiw2QkF4Q3lCZjtPQXdDMUM7T0FBUjs7V0F4Q3lCSTtPQXVDUjswREFTbEI7Ozs7T0FsTERuQztPQUlBQztPQWFBSDtPQU5BRDtPQVlBRTtPQU9BRztPQW9HQTBCOztVRDNKTDs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUNDS3FCLGdCQUFnQkM7TUFDbEIsU0FBUUMsSUFBSUM7UUFDVixHQURVQSxJQUNWLHNCQUZnQkY7VUFHRixhQUZKRSxXQUVMLDBCQUhXRixFQUNORTtRQUdMLFFBQUU7TUFIVCxhQUtPO2FBRUxDLGdCQUFnQkM7TUFFTjs7T0FEWixxQ0FEa0JBO01BQ2xCLDRDQUVtQjthQUVqQkMsa0JBQWtCQyxJQUFJQztNQUN4QixHQUR3QkEsT0FFakJDLEVBRmlCRCxLQUV0QkUsRUFGc0JGLHVDQUFKRCxJQUVsQkcsRUFBS0Q7TUFDQyxvREFBOEI7YUFrQmxDRSxJQUFJQztNRG5DWCxxQkNvQ29CLE9BRFRBLFlBRVcsT0FGWEEsYUFHUSxPQUhSQTthQUtKQyxJQUFJQyxFQUFFRjtNQUdHLG9CQUhMRSxFQUFFRixNQUVNLGdCQUZSRSxFQUFFRjtNQUNJLHFCQURORSxFQUFFRixnQkFJVDthQUVHRyxLQUFLRCxFQUFFRixFQUFFSTtNQUdBLG9CQUhKRixFQUFFRixLQUFFSSxNQUVHLGdCQUZQRixFQUFFRixLQUFFSTtNQUNDLHFCQURMRixFQUFFRixLQUFFSSxnQkFJWjthQUVHQyxLQUFLTCxHQUFJLFVBQUpBLE1BSVI7YUFFR007TUFBZ0I7ZUFDSDtlQUNFO2dCQUNILG9CQUFVO2lCQTFCdEJQLElBS0FFLElBTUFFLEtBTUFFLEtBTUFDO2FBb0NGQyxnQkFBZ0JDLE9BQU9DO01BQ25CLHVDQURtQkEsWUFBUEQ7TUFDWjs7O1NBQ2dCRTtTQUFSQztTQUFOQztTQUNrQkMsWUFIREo7U0FHVkssVUFIVUw7U0FHakJNLE1BSGlCTjtjQUdqQk0sV0FEY0w7Y0FBUkMsV0FDWUU7Y0FBbEJFO2NBREFILFNBQ09FOztnQkFIVUw7OzttQkFHakJNO2dCQURBSDtnQkFBTUQ7TUFXSixPQWJlRixRQWFQO2FBRWhCTyxnQkFBZ0JDO01BQ2xCLGFBRGtCQSwwQkFDbEIsS0FEa0JBOzs7OztVQUVDLElBQVAxQjtVQUFPLElBQVBBLGFBQU8sc0JBRkQwQjtZQUdlO2tDQUhmQSxTQUVOMUI7YUFDQTt3QkFEQUE7YUFFUTt1QkFEWjJCO2lCRGhIWCw2QkM4RktYLGdCQWtCTVc7O2FBQ0U7Ozs7bUNBTzhDO2FBRXREQyxzQkFBdUJDO01BR3ZCO29CQURLQyxJQUFJQztRQUFNLFNBQU5BO1FBQU0sY0FBaUJDLEVBQUVDLEdBQUssYUFBOUJGLE1BQXlCRSxHQUFGRCxFQUF3QjtRQUF6QyxnQ0FBVkYsU0FBa0U7TUFEekUsOENBRHlCRDtNQUN6QiwrQ0FJcUI7YUFFbkJLLGdCQUFnQjdCO01BQ2xCLFNBQUlELElBQUk0QixFQUFnQkM7WUFBSUUsTUFBSkYsS0FBWkcsTUFBSko7UUFDSCw2QkFET0ksTUFBZ0JELE9BQXBCSCxFQUFnQkM7TUFTcEIsK0JBVmM1QjtNQVVkLGNBSmEyQixHQUFLLHlCQUxsQjVCLElBS2E0QixLQUVXO01BRXhCLHFDQUF5QjtJQWtCakI7OztLQURHOztLQVBIO0tBREc7O2FBZ0JiTSxPQUFPeEI7TURwS1o7OztVQ3FLYztnQkFERkE7V0FDRSxLQURGQTtXQUNFO3FCQUdvQkk7Y0FBWSxVQUFaQSw0Q0FRYTtVQVRwQjtnQkFZZix1QkFmQUo7O1VBZ0JLLFNBaEJMQTtVQWdCSywyQ0FoQkxBO1VBZ0JLLElBQ0FkO1VBQU8sSUFBUEEsYUFBTyxzQkFqQlpjO1lBa0IyQjtrQ0FsQjNCQSxRQWlCS2Q7YUFDQztrQkFsQk5jO2FBa0JNLEtBbEJOQTthQXFCc0Isb0JEekxsQyxPQzhGS0UsZ0JBd0ZTVztZQUdXO3VCQUpSM0I7b0JBSVE7O1VBRUgsWUF2QlZjOztVQTBCRTtnQkExQkZBO1dBMEJFLEtBMUJGQTtXQTBCRSxLQTFCRkE7V0EwQkU7OztVQUtLO2dCQS9CUEE7V0ErQk8sS0EvQlBBO1dBK0JPLEtBL0JQQTtXQStCTzs7aUJBZUQsT0E5Q05BOzs7Z0JBb0NlLElBQVh5QixpQkFBVyxVQXBDZnpCLGdCQW9DSXlCOztVQUNnQjs7Z0JBckNwQnpCO1dBcUNvQixLQXJDcEJBO1dBcUN1RCxvQkR6TW5FLDZCQ3lNb0JJO1dBQW1DO29CQXJDM0NKOztVQTBDa0Q7V0FKdEMwQjtXQUFOQztnQkF0Q04zQjs7V0EwQ2tEO1dBREc7OztjQUgvQzJCO2NBQU1EO2NBR3lDLHdCQUh6Q0E7Ozs7O1VBR3lDLFVBekNyRDFCO0lBaEJNLFNBaUViNEIsT0FBT0MsSUFBSUM7TUFHbUI7bUNBSHZCRDtPQUV1QjtPQUZiO09BRWE7MkJBRmtCLE9BQXJDQyxHQUF3QztNQUFyQjs2Q0FJQTtJQXJFakIsU0F1RWJDLFlBQWFoQjtNQUNNLElBQWpCaUIsZUFBaUIsc0JBRE5qQjtNQUNNLG9CRDVOeEI7TUM2TjJCOztPQUFWLDhCQURWaUI7T0FDVTtNQUNhLG9CRDlOOUIsT0NjSzNDO01BK01ZO29CQUVrQk0sR0FBSyxjQUFMQSxDQUE4QjtNQUZoRCxJQUFWc0MsUUFBVTswQkFJb0JDO1FBQWY7OztTQUNFLDJCQUxqQkQsUUFJOEJDO1NBRUoscUNBUDFCRixlQUs4QkU7U0FHb0MseUJBSHBDQTtTQUcrQjtTQUF6QixxQ0FIZkM7U0FHSjtpQkFISUEsZUFHYkcsT0FIaUJ0QjtRQUdSO1VBQ0k7Ozs7O2FBSGJvQixTQUdvQ0c7V0FLUDtXQURBLHNDQUh2QkM7V0FFdUIsb0NBSFZMO1dBRVU7V0FBbkI7V0FPcUIsOEJBVERSO1dBUUQsb0NBUlZRO1dBT1UsdUNBTnZCSztXQU1JO29CQVBTTCxlQUViTSxLQUtBakQsRUFQaUJ3QixNQVd0QjtRQVpRLDRDQURUcUIsaUJBZ0JMO01BbkJpRTtZQUNwRTtPQUQ2QywwQ0FMbEN0QjtPQUtLO3FEQXVCakI7SUFuR1ksU0FxR2IyQixLQUFLOUI7TUFDUCxTQURPQSxTQUNQLEtBRE9BLFNBbURZLGlDQWxEbkI7TUFrRG1COzZDQUNiZ0M7OztNQXVGZ0Msa0JBdkZoQ0E7TUFuRE47T0FrRk07T0FEQTs7UUFqQmM7aUJBQ0pDLFVBQVVYO1VBTVc7b0NBUEx4QixNQUNOd0I7V0FNSjtXQUFMOztXQUp3Qjs4QkFIZlAsS0FHc0Isb0JBakIxQ2dCLFdBZW9CVDs7O1dBQ1E7V0FBUDswREFLK0I7UUFNMUM7O1NBREE7U0FEQTtTQURXLDhCQVZEUDtTQVVWO3FEQUtMO01BZkE7O09BRmlDO09BQXJCO09BQWI7T0FEa0M7T0FBckI7T0FBYjtPQURrQztPQUFyQjtPQUFiO09BREE7T0FERjtPQURjO09BQWhCO09BRE0sK0JBTE5pQjtlQUtNO1lBekRMaEM7O01BcUJMLGdDQUFJMUIsU0FDZSxnQkFEZkEsRUFDVTREO01BMkNMO01BeENQOztRQUdrQjs7U0FnQk47O3NCQUY2QjlELEdBQUssVUFBTEEsRUFBaUI7U0FBOUI7U0FEQTtTQURBO1NBQW5CO1NBREE7U0FGYztTQUFkO1NBRGM7U0FBZDtTQURxRDtTQUFoQjtTQUFwQjtTQUFqQjs7OztZQU5ROzs7O3VDQUlMO1NBSkg7Z0JBRFc7Ozs7Ozs7T0FrQkQ7OztpQ0F6QmpCRSxFQXlCVSw4QkF6QlZBO2VBeUJZO01BbUJQO09BdkNHO09BQVI7O1lBMUJDMEI7O09BUUw7Ozs7Ozs7TUF5RFM7T0FsREk7O09BSkE7T0FEQTswQkFEa0IsUUFBVTtNQUE1Qjs7O1lBVFJBO01BQ2lCOzsyQkFHSDsyQkFEQTs7VUFFeUM7O1dBQWY7a0JBQTFCOztPQUh5Qix1Q0FBekI7TUFPTjtPQVJpQjs7T0EySDVCO1lBNUhHQTtPQTRISCxLQTVIR0E7T0E0SEgsS0E1SEdBO01BMkhzRSxjQXRDN0NSO1FBQzlCO2FBQUkyQzs7U0FDZTs7VUFBMkIsMEJBQWhDN0Q7VUFEVjZELGVBQ29CO1FBR3hCOztpQkFDb0IsMEJBM0ZmbkM7ZUEwRkRvQzs7Ozs7OztRQWlEZ0Msa0JBakRoQ0E7UUFJRixTQVQ0QjVDLFlBUzVCLEtBVDRCQTtRQVM1QixxQkFBeUQsVUFUN0JBLFNBU29EO1FBQWhGO2lDQVJFMkMsZ0JBSUFDO01BaUM2RCxvREEzSDVEcEM7TUFnR0w7d0JBQUlvQzs7OztNQTJCNkQsSUF2QmpFO29CQVltQnJCO1FBRVksa0NBRlpBLFNBRVksT0FkTixLQXBHcEJmO1FBb0dvQixjQUFpQk0sR0FBSyx5QkFBTEEsS0FZdkJTLEtBWnlDO1FBQW5DOztTQWFTOzhEQUNRO01BSC9COztPQURrRDtPQUFoQjtPQUFwQjtPQUFqQjtPQURHOztRQUxvQjs7Ozs7OytDQUt0QjtNQUxjOztPQUFqQjtPQUQwQztPQUFwQzs7T0FBUjtPQUR5QjtPQUFqQjtPQUFSOztZQU5BcUI7T0FLaUI7O09Bc0JYO09BQVI7T0FETTs2Q0FRUDtJQUVLLElBQU5DLElBQU0sb0JBaFBOMUIsT0F1QkFDLE9BcUZBa0I7SUFvSU0sU0FJSlE7TUFBUyxvQ0FKWEQsS0FNZTswQkFDcUIsZ0NBRmpCRSxRQUVnRDtNQUQ1QztNQUZaO21DQUNRQTtPQVF1Qjs7T0FDUCx1QkFBYkU7O3VCQUNHO01BQXNCLG9DQUR6QkEsZ0JBRVI7SUFFZCw0Q0FkRUg7SUFjRjs7O09BOVlBbkU7T0FRQUk7T0FLQUU7O09BZ0ZBYTtPQWVBUztPQWFBRztPQU9BTTtPQVlBRztPQXVCQUM7T0FpREFJO09BTUFHO09BOEJBVztPQW9JQU87SUFrQkE7VUQvWUwiLCJzb3VyY2VzIjpbIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3N0ZGxpYi5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL21sU3RyaW5nLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaW50NjQuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9pZWVlXzc1NC5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ZzLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnNfZmFrZS5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ZzX25vZGUuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9iaWdhcnJheS5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2JpZ3N0cmluZy5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2pzbGliLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaW8uanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tYXJzaGFsLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvanNsaWJfanNfb2Zfb2NhbWwuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9nYy5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3dlYWsuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9wYXJzaW5nLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvdW5peC5qcyIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ludGVybmFsTW9kLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvbGV4aW5nLmpzIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvcG9seWZpbGwvanNvbjIuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tZDUuanMiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc2VxLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc29ydC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2FycmF5Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9yYW5kb20ubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2Zvcm1hdC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxPTy5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL3NwYWNldGltZS5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS8ub3BhbS80LjA3LjAvbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC8ub3BhbS1zd2l0Y2gvYnVpbGQvb2NhbWwtdmRvbS4wLjEvbGliL3Zkb20ubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvLm9wYW0vNC4wNy4wLy5vcGFtLXN3aXRjaC9idWlsZC9vY2FtbC12ZG9tLjAuMS9saWIvdmRvbV9ibGl0Lm1sIiwiL2hvbWUvYWhtZXRjZXBvZ2x1Ly5vcGFtLzQuMDcuMC8ub3BhbS1zd2l0Y2gvYnVpbGQvb2NhbWwtdmRvbS4wLjEvbGliL2pzX2Jyb3dzZXIubWwiLCIvaG9tZS9haG1ldGNlcG9nbHUvcHJvai93aHktZHZvcmFrL19idWlsZC9kZWZhdWx0L29jYW1sL2tiZGxheW91dC5tbCIsIi9ob21lL2FobWV0Y2Vwb2dsdS9wcm9qL3doeS1kdm9yYWsvX2J1aWxkL2RlZmF1bHQvb2NhbWwvY29kZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBDb3JlXG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIHJhd19hcnJheV9zdWIgKGEsaSxsKSB7XG4gIHZhciBiID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKSBiW2pdID0gYVtpK2pdO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfY29weVxuZnVuY3Rpb24gcmF3X2FycmF5X2NvcHkgKGEpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBiW2ldID0gYVtpXTtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogcmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIHJhd19hcnJheV9jb25zIChhLHgpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCsxKTtcbiAgYlswXT14O1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGw7IGkrKyApIGJbaV0gPSBhW2ktMV07XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9hcHBlbmRfb25lXG5mdW5jdGlvbiByYXdfYXJyYXlfYXBwZW5kX29uZShhLHgpIHtcbiAgdmFyIGwgPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobCsxKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IoOyBpIDwgbDsgaSsrICkgYltpXSA9IGFbaV07XG4gIGJbaV09eDtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfYXBwZW5kX29uZVxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgdmFyIG4gPSBmLmxlbmd0aDtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3X2FycmF5X3N1YihhcmdzLDAsbikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHJhd19hcnJheV9zdWIoYXJncyxuLGFyZ3NMZW4gLSBuKSk7XG4gIGVsc2VcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpeyByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCByYXdfYXJyYXlfYXBwZW5kX29uZShhcmdzLHgpKTsgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfbmV3X3N0cmluZyAobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX2pzX3RvX3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9qc190b19zdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWcgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7IHJldHVybiAoeCBpbnN0YW5jZW9mIEFycmF5KT94WzBdOih4IGluc3RhbmNlb2YgTWxCeXRlcyk/MjUyOjEwMDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5pZiAoIU1hdGguaW11bClcbiAgTWF0aC5pbXVsID1cbiAgZnVuY3Rpb24gKHgseSkge1xuICAgIHkgfD0gMDtcbiAgICByZXR1cm4gKCgoKHggPj4gMTYpICogeSkgPDwgMTYpICsgKHggJiAweGZmZmYpICogeSl8MDtcbiAgfTtcbnZhciBjYW1sX211bCA9IE1hdGguaW11bDtcblxuLy9zbGlnaHRseSBzbG93ZXJcbi8vIGZ1bmN0aW9uIG11bDMyKHgseSkge1xuLy8gICB2YXIgeGxvID0geCAmIDB4ZmZmZjtcbi8vICAgdmFyIHhoaSA9IHggLSB4bG87XG4vLyAgIHJldHVybiAoKCh4aGkgKiB5KSB8MCkgKyB4bG8gKiB5KXwwO1xuLy8gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY2FtbF9zdHJpbmdfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdfDApKSB7XG4gICAgICAgIHZhciB0YSA9IGFbMF07XG4gICAgICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnXG4gICAgICAgIGlmICh0YSA9PT0gMjU0KSB0YT0wO1xuICAgICAgICAvLyBGb3J3YXJkIG9iamVjdFxuICAgICAgICBpZiAodGEgPT09IDI1MCkge1xuICAgICAgICAgIGEgPSBhWzFdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSAmJiBiWzBdID09PSAoYlswXXwwKSkge1xuICAgICAgICAgIHZhciB0YiA9IGJbMF07XG4gICAgICAgICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWdcbiAgICAgICAgICBpZiAodGIgPT09IDI1NCkgdGI9MDtcbiAgICAgICAgICAvLyBGb3J3YXJkIG9iamVjdFxuICAgICAgICAgIGlmICh0YiA9PT0gMjUwKSB7XG4gICAgICAgICAgICBiID0gYlsxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGEgIT0gdGIpIHtcbiAgICAgICAgICAgIHJldHVybiAodGEgPCB0Yik/LTE6MTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0YSkge1xuICAgICAgICAgICAgY2FzZSAyNDg6IHtcbiAgICAgICAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuIHg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyNTE6IHtcbiAgICAgICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyNTU6IHtcbiAgICAgICAgICAgICAgLy8gSW50NjRcbiAgICAgICAgICAgICAgdmFyIHggPSBjYW1sX2ludDY0X2NvbXBhcmUoYSwgYik7XG4gICAgICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiB4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBNbEJ5dGVzIHx8XG4gICAgICAgICAgICAgICAgIChiIGluc3RhbmNlb2YgQXJyYXkgJiYgYlswXSA9PT0gKGJbMF18MCkpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgIT0gXCJudW1iZXJcIiAmJiBhICYmIGEuY29tcGFyZSkge1xuICAgICAgICB2YXIgY21wID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZiAoY21wICE9IDApIHJldHVybiBjbXA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIChzKTtcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKilwKFsrLV0/WzAtOV0rKS9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNFxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs0XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcgKGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHgudG9GaXhlZChwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGNhc2UgMjU1OlxuICAgICAgICAvLyBJbnQ2NFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzFdICsgKG9ialsyXSA8PCAyNCkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHN3aXRjaCAob2JqLnQgJiA2KSB7XG4gICAgICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMob2JqKTtcbiAgICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgICAgZm9yICh2YXIgYiA9IG9iai5jLCBsID0gb2JqLmwsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gb2JqLmwsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5oYXNoICYmIHR5cGVvZiBvYmouaGFzaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBDdXN0b21cbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iai5oYXNoKCkpIHwgMDtcbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICB2YXIgdiA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApO1xuICB2YXIgbG8gPSB2WzFdIHwgKHZbMl0gPDwgMjQpO1xuICB2YXIgaGkgPSAodlsyXSA+Pj4gOCkgfCAodlszXSA8PCAxNik7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBsbyk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBoaSk7XG4gIHJldHVybiBoO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgdmFyIGxvID0gdlsxXSB8ICh2WzJdIDw8IDI0KTtcbiAgdmFyIGhpID0gKHZbMl0gPj4+IDgpIHwgKHZbM10gPDwgMTYpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgbG8pO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgaGkpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHYuYyk7XG4gIH1cbiAgcmV0dXJuIGhcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NCwgY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmdcbnZhciBIQVNIX1FVRVVFX1NJWkUgPSAyNTY7XG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiBIQVNIX1FVRVVFX1NJWkUpIHN6ID0gSEFTSF9RVUVVRV9TSVpFO1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NTpcbiAgICAgICAgLy8gSW50NjRcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpO1xuICAgICAgICBudW0gLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYodiAmJiB2Lmhhc2ggJiYgdHlwZW9mIHYuaGFzaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBDdXN0b21cbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2Lmhhc2goKSk7XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vLy8vLy8vLy8vLy8gU3lzXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKiAwLjAwMTtcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWUgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgcmV0dXJuIG5vdyAqIDAuMDAxIC0gY2FtbF9pbml0aWFsX3RpbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9jb25maWcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9uZXdfc3RyaW5nKFwiVW5peFwiKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX25ld19zdHJpbmcoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiAxOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY21kLnRvU3RyaW5nKCk7XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUubG9nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCk7IHJldHVybiAwfVxuICAgIGNhdGNoIChlKSB7cmV0dXJuIDF9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gbnVsbCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IG5hbWUudG9TdHJpbmcoKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZihnLnF1aXQpIGcucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5leGl0KVxuICAgIGcucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmdcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2ICgpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3ZcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gZy5wcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSByYXdfYXJyYXlfc3ViKGFyZ3YsMixhcmd2Lmxlbmd0aCAtIDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX2pzX3RvX3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfanNfdG9fc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIFswLCBwLCBhcmdzMl07XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHJldHVybiBbXG4gICAgMjU1LFxuICAgICgoKHhbM10gJiAweDAwMDBmZjAwKSA+PiA4KSB8XG4gICAgICgoeFszXSAmIDB4MDAwMDAwZmYpIDw8IDgpIHxcbiAgICAgKCh4WzJdICYgMHgwMGZmMDAwMCkpKSxcbiAgICAoKCh4WzJdICYgMHgwMDAwZmYwMCkgPj4gOCkgfFxuICAgICAoKHhbMl0gJiAweDAwMDAwMGZmKSA8PCA4KSB8XG4gICAgICgoeFsxXSAmIDB4MDBmZjAwMDApKSksXG4gICAgKCgoeFsxXSAmIDB4MDAwMGZmMDApID4+IDgpIHxcbiAgICAgKCh4WzFdICYgMHgwMDAwMDBmZikgPDwgOCkpXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKFwiXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZiAocy5yZXBlYXQpIHJldHVybiBzLnJlcGVhdChuKTsgLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgcmF3X2FycmF5X3N1YihhLGksIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfYXNjaWlcbmZ1bmN0aW9uIGNhbWxfaXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfaXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF90b19qc19zdHJpbmcocykge1xuICBzd2l0Y2ggKHMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChjYW1sX2lzX2FzY2lpKHMuYykpIHtcbiAgICAgIHMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gcy5jO1xuICAgIH1cbiAgICBzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMuYyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sICsgMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCArIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCArIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCArIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF90b19qc19zdHJpbmdcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7cmV0dXJuIGNhbWxfdG9fanNfc3RyaW5nKHRoaXMpfTtcbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSB7XG4gICAgdmFyIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShzLmwpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0gbmV3IEFycmF5KHMubCk7XG4gIH1cbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcgKHMpIHtcbiAgaWYgKChzLnQgJiA2KSAhPSAwIC8qIEJZVEVTICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWNhbWxfaXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX25ld19zdHJpbmcgKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7IHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZmlsbF9ieXRlc1xudmFyIGNhbWxfZmlsbF9zdHJpbmcgPSBjYW1sX2ZpbGxfYnl0ZXNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICAvLyBUT0RPOiBzMSAtPiBzdHJpbmcgdG8gYnl0ZXNcbiAgcmV0dXJuIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gc31cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91Y29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91Y29tcGFyZSh4LHkpIHtcbiAgaWYgKHhbM10gPiB5WzNdKSByZXR1cm4gMTtcbiAgaWYgKHhbM10gPCB5WzNdKSByZXR1cm4gLTE7XG4gIGlmICh4WzJdID4geVsyXSkgcmV0dXJuIDE7XG4gIGlmICh4WzJdIDwgeVsyXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsxXSA+IHlbMV0pIHJldHVybiAxO1xuICBpZiAoeFsxXSA8IHlbMV0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3Vjb21wYXJlXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIGNhbWxfaW50NjRfdWNvbXBhcmUoeCx5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5KSB7XG4gIHZhciB4MyA9IHhbM10gPDwgMTY7XG4gIHZhciB5MyA9IHlbM10gPDwgMTY7XG4gIGlmICh4MyA+IHkzKSByZXR1cm4gMTtcbiAgaWYgKHgzIDwgeTMpIHJldHVybiAtMTtcbiAgaWYgKHhbMl0gPiB5WzJdKSByZXR1cm4gMTtcbiAgaWYgKHhbMl0gPCB5WzJdKSByZXR1cm4gLTE7XG4gIGlmICh4WzFdID4geVsxXSkgcmV0dXJuIDE7XG4gIGlmICh4WzFdIDwgeVsxXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7XG4gIHZhciB5MSA9IC0geFsxXTtcbiAgdmFyIHkyID0gLSB4WzJdICsgKHkxID4+IDI0KTtcbiAgdmFyIHkzID0gLSB4WzNdICsgKHkyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHkxICYgMHhmZmZmZmYsIHkyICYgMHhmZmZmZmYsIHkzICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7XG4gIHZhciB6MSA9IHhbMV0gKyB5WzFdO1xuICB2YXIgejIgPSB4WzJdICsgeVsyXSArICh6MSA+PiAyNCk7XG4gIHZhciB6MyA9IHhbM10gKyB5WzNdICsgKHoyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7XG4gIHZhciB6MSA9IHhbMV0gLSB5WzFdO1xuICB2YXIgejIgPSB4WzJdIC0geVsyXSArICh6MSA+PiAyNCk7XG4gIHZhciB6MyA9IHhbM10gLSB5WzNdICsgKHoyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHtcbiAgdmFyIHoxID0geFsxXSAqIHlbMV07XG4gIHZhciB6MiA9ICgoejEgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHhbMl0gKiB5WzFdICsgeFsxXSAqIHlbMl07XG4gIHZhciB6MyA9ICgoejIgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHhbM10gKiB5WzFdICsgeFsyXSAqIHlbMl0gKyB4WzFdICogeVszXTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkge1xuICByZXR1cm4gKHhbM118eFsyXXx4WzFdKSA9PSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHtcbiAgcmV0dXJuICh4WzNdIDw8IDE2KSA8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbWluX2ludCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19taW5faW50KHgpIHtcbiAgcmV0dXJuIHhbM10gPT0gMHg4MDAwICYmICh4WzFdfHhbMl0pID09IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbWludXNfb25lIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX21pbnVzX29uZSh4KSB7XG4gIHJldHVybiB4WzNdID09IDB4ZmZmZiAmJiAoeFsxXSZ4WzJdKSA9PSAweGZmZmZmZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7XG4gIHJldHVybiBbMjU1LCB4WzFdJnlbMV0sIHhbMl0meVsyXSwgeFszXSZ5WzNdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXXx5WzFdLCB4WzJdfHlbMl0sIHhbM118eVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXV55WzFdLCB4WzJdXnlbMl0sIHhbM11eeVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB4O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKHhbMV0gPDwgcykgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA8PCBzKSB8ICh4WzFdID4+ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFszXSA8PCBzKSB8ICh4WzJdID4+ICgyNCAtIHMpKSkgJiAweGZmZmZdO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LCAwLFxuICAgICAgICAgICAgKHhbMV0gPDwgKHMgLSAyNCkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPDwgKHMgLSAyNCkpIHwgKHhbMV0gPj4gKDQ4IC0gcykpKSAmIDB4ZmZmZl07XG4gIHJldHVybiBbMjU1LCAwLCAwLCAoeFsxXSA8PCAocyAtIDQ4KSkgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB4O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzFdID4+IHMpIHwgKHhbMl0gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdID4+IHMpIHwgKHhbM10gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKHhbM10gPj4gcyldO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzJdID4+IChzIC0gMjQpKSB8ICh4WzNdIDw8ICg0OCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICh4WzNdID4+IChzIC0gMjQpKSxcbiAgICAgICAgICAgIDBdO1xuICByZXR1cm4gWzI1NSwgKHhbM10gPj4gKHMgLSA0OCkpLCAwLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgdmFyIGggPSAoeFszXSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoKHhbMV0gPj4gcykgfCAoeFsyXSA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPj4gcykgfCAoaCA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgMTYpID4+IHMpID4+PiAxNl07XG4gIHZhciBzaWduID0gKHhbM10gPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzJdID4+IChzIC0gMjQpKSB8ICh4WzNdIDw8ICg0OCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFszXSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICBzaWduICYgMHhmZmZmXTtcbiAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgKCh4WzNdIDw8IDE2KSA+PiAocyAtIDMyKSkgJiAweGZmZmZmZixcbiAgICAgICAgICBzaWduICYgMHhmZmZmZmYsIHNpZ24gJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xzbDEgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbHNsMSAoeCkge1xuICB4WzNdID0gKHhbM10gPDwgMSkgfCAoeFsyXSA+PiAyMyk7XG4gIHhbMl0gPSAoKHhbMl0gPDwgMSkgfCAoeFsxXSA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHhbMV0gPSAoeFsxXSA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xzcjEgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbHNyMSAoeCkge1xuICB4WzFdID0gKCh4WzFdID4+PiAxKSB8ICh4WzJdIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgeFsyXSA9ICgoeFsyXSA+Pj4gMSkgfCAoeFszXSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHhbM10gPSB4WzNdID4+PiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VkaXZtb2QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdWNvbXBhcmUsIGNhbWxfaW50NjRfbHNsMSwgY2FtbF9pbnQ2NF9sc3IxXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3N1YlxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VkaXZtb2QgKHgsIHkpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gY2FtbF9vYmpfZHVwKHgpO1xuICB2YXIgZGl2aXNvciA9IGNhbWxfb2JqX2R1cCh5KTtcbiAgdmFyIHF1b3RpZW50ID0gWzI1NSwgMCwgMCwgMF07XG4gIHdoaWxlIChjYW1sX2ludDY0X3Vjb21wYXJlIChtb2R1bHVzLCBkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBjYW1sX2ludDY0X2xzbDEgKGRpdmlzb3IpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBjYW1sX2ludDY0X2xzbDEgKHF1b3RpZW50KTtcbiAgICBpZiAoY2FtbF9pbnQ2NF91Y29tcGFyZSAobW9kdWx1cywgZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnRbMV0gKys7XG4gICAgICBtb2R1bHVzID0gY2FtbF9pbnQ2NF9zdWIgKG1vZHVsdXMsIGRpdmlzb3IpO1xuICAgIH1cbiAgICBjYW1sX2ludDY0X2xzcjEgKGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBbMCxxdW90aWVudCwgbW9kdWx1c107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbmVnLCBjYW1sX2ludDY0X3VkaXZtb2RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KVxue1xuICBpZiAoY2FtbF9pbnQ2NF9pc196ZXJvICh5KSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4WzNdIF4geVszXTtcbiAgaWYgKHhbM10gJiAweDgwMDApIHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgaWYgKHlbM10gJiAweDgwMDApIHkgPSBjYW1sX2ludDY0X25lZyh5KTtcbiAgdmFyIHEgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgeSlbMV07XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gY2FtbF9pbnQ2NF9uZWcocSk7XG4gIHJldHVybiBxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X25lZywgY2FtbF9pbnQ2NF91ZGl2bW9kXG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSlcbntcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyAoeSkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geFszXTtcbiAgaWYgKHhbM10gJiAweDgwMDApIHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgaWYgKHlbM10gJiAweDgwMDApIHkgPSBjYW1sX2ludDY0X25lZyh5KTtcbiAgdmFyIHIgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgeSlbMl07XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gY2FtbF9pbnQ2NF9uZWcocik7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBbMjU1LCB4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmZdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHtcbiAgcmV0dXJuIHhbMV0gfCAoeFsyXSA8PCAyNCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHtcbiAgcmV0dXJuICgoeFszXSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB4WzJdICogTWF0aC5wb3coMiwgMjQpKSArIHhbMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgeCAmIDB4ZmZmZmZmLFxuICAgICAgICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgICAgICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91ZGl2bW9kLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IGNhbWxfaW50NjRfdWRpdm1vZCh4LCB3YmFzZSk7XG4gICAgeCA9IHBbMV07XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocFsyXSkpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0LCBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VkaXZtb2QsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBjYW1sX2ludDY0X3VkaXZtb2QoWzI1NSwgMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmXSwgYmFzZTY0KVsxXTtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChyWzJdID09IDEwICYmIGNhbWxfaW50NjRfdWx0KFsyNTUsIDAsIDAsIDB4ODAwMF0sIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBbMjU1LCBhWzddIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgYVs0XSB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLCBhWzFdIHwgKGFbMF0gPDwgOCldO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7XG4gIHJldHVybiBbeFszXSA+PiA4LCB4WzNdICYgMHhmZiwgeFsyXSA+PiAxNiwgKHhbMl0gPj4gOCkgJiAweGZmLCB4WzJdICYgMHhmZixcbiAgICAgICAgICB4WzFdID4+IDE2LCAoeFsxXSA+PiA4KSAmIDB4ZmYsIHhbMV0gJiAweGZmXTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBbMjU1LCAxLCAwLCAweDdmZjBdO1xuICAgIHJldHVybiAoeCA+IDApP1syNTUsMCwwLDB4N2ZmMF06WzI1NSwwLDAsMHhmZmYwXTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIFsyNTUsIHIxLCByMiwgcjNdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2pzX3RvX3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgZXhwID0gKHhbM10gJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgoeFsxXXx4WzJdfCh4WzNdJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKHhbM10gJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAoeFsxXSprK3hbMl0pKmsrKHhbM10mMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmICh4WzNdICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDE7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgaWYgKHggPCAwLjUpIHsgeCAqPSAyOyBleHAgLT0gMTsgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0geSAtIDE7XG4gIHJldHVybiAoTWF0aC5hYnMoeCk+MT96Oih6PT0wP3g6eCp6L01hdGgubG9nKHkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSAxICsgeCwgeiA9IHkgLSAxO1xuICByZXR1cm4gKHo9PTA/eDp4Kk1hdGgubG9nKHkpL3opO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7XG4gIHZhciB4ID0gTWF0aC5hYnMoeCksIHkgPSBNYXRoLmFicyh5KTtcbiAgdmFyIGEgPSBNYXRoLm1heCh4LCB5KSwgYiA9IE1hdGgubWluKHgseSkgLyAoYT9hOjEpO1xuICByZXR1cm4gKGEgKiBNYXRoLnNxcnQoMSArIGIqYikpO1xufVxuXG4vLyBGSVg6IHRoZXNlIGZpdmUgZnVuY3Rpb25zIG9ubHkgZ2l2ZSBhcHByb3hpbWF0ZSByZXN1bHRzLlxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5MT0cxMEUgKiBNYXRoLmxvZyh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSBNYXRoLmV4cCgteCk7XG4gIHJldHVybiAoeSAtIHopIC8gKHkgKyB6KTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG5pZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuaWYoY2FtbF9jdXJyZW50X2Rpci5zbGljZSgtMSkgIT09IFwiL1wiKSBjYW1sX2N1cnJlbnRfZGlyICs9IFwiL1wiXG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxudmFyIGNhbWxfcm9vdCA9IGNhbWxfY3VycmVudF9kaXIubWF0Y2goL1teXFwvXSpcXC8vKVswXTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpcixNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPShuYW1lIGluc3RhbmNlb2YgTWxCeXRlcyk/bmFtZS50b1N0cmluZygpOm5hbWU7XG4gIGlmKG5hbWUuY2hhckNvZGVBdCgwKSAhPSA0NylcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogaWYobmNvbXAubGVuZ3RoID09IDApIG5jb21wLnB1c2goXCJcIik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QrXCJzdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCtcInN0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX25ld19zdHJpbmcoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSAobmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gKG5hbWUgaW5zdGFuY2VvZiBNbEJ5dGVzKT9uYW1lLnRvU3RyaW5nKCk6bmFtZTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX25ld19zdHJpbmcoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSlcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCkgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBjYW1sX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSA9IGNhbWxfY3JlYXRlX2ZpbGU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX25ld19zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9uZXdfc3RyaW5nKHRoaXMucm9vdCksIGNhbWxfbmV3X3N0cmluZyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUocmVzWzFdKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX3N0cmluZ19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBtbHN0cmluZyA9IGNhbWxfbmV3X3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKG1sc3RyaW5nKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXRcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X2J5dGVzKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpXG59XG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZVxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgcmV0dXJuIGJcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sbikge1xuICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9ieXRlc19zZXRcblxudmFyIEJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlclxuXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShhKTtcbiAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIDAsIDEsIG9mZnNldCk7XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG4vL1xuLy8gTm90ZTsgaW50NjQrY29tcGxleCBzdXBwb3J0IGlmIHByb3ZpZGVkIGJ5IGFsbG9jYXRpbmcgYSBzZWNvbmQgVHlwZWRBcnJheVxuLy8gTm90ZTsgYWNjZXNzb3IgZnVuY3Rpb25zIGFyZSBzZWxlY3RlZCB3aGVuIHRoZSBiaWdhcnJheSBpcyBjcmVhdGVkLiAgSXQgaXMgYXNzdW1lZFxuLy8gICAgICAgdGhhdCB0aGlzIHJlc3VsdHMgaW4ganVzdCBhIGZ1bmN0aW9uIHBvaW50ZXIgYW5kIHdpbGwgdGh1cyBiZSBmYXN0LlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdF92aWV3c1xuLy9SZXF1aXJlczogY2FtbF9iYV92aWV3c1xuZnVuY3Rpb24gY2FtbF9iYV9pbml0X3ZpZXdzKCkge1xuICBpZiAoIWNhbWxfYmFfdmlld3MpIHtcbiAgICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICAgIGNhbWxfYmFfdmlld3MgPSBbXG4gICAgICBbXG4gICAgICAgIGcuRmxvYXQzMkFycmF5LCBnLkZsb2F0NjRBcnJheSwgZy5JbnQ4QXJyYXksIGcuVWludDhBcnJheSxcbiAgICAgICAgZy5JbnQxNkFycmF5LCBnLlVpbnQxNkFycmF5LCBnLkludDMyQXJyYXksIGcuSW50MzJBcnJheSxcbiAgICAgICAgZy5JbnQzMkFycmF5LCBnLkludDMyQXJyYXksIGcuRmxvYXQzMkFycmF5LCBnLkZsb2F0NjRBcnJheSwgZy5VaW50OEFycmF5XSxcbiAgICAgIFtcbiAgICAgICAgMCAvKiBHZW5lcmFsICovLCAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLFxuICAgICAgICAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLCAxIC8qIEludDY0ICovLFxuICAgICAgICAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLywgMiAvKiBDb21wbGV4ICovLCAyIC8qIENvbXBsZXggKi8sIDAgLyogR2VuZXJhbCAqL11cbiAgICBdO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3ZpZXdzXG52YXIgY2FtbF9iYV92aWV3cztcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGEsIGRhdGEyLCBkYXRhX3R5cGUsIGtpbmQsIGxheW91dCwgZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcblxuICAvL1xuICAvLyBGdW5jdGlvbnMgdG8gY29tcHV0ZSB0aGUgb2Zmc2V0cyBmb3IgQyBvciBGb3J0cmFuIGxheW91dCBhcnJheXNcbiAgLy8gZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgaW5kaWNlcy5cbiAgLy9cbiAgZnVuY3Rpb24gb2Zmc2V0X2MoaW5kZXgpIHtcbiAgICB2YXIgb2ZzID0gMDtcbiAgICBpZiAobl9kaW1zICE9IGluZGV4Lmxlbmd0aClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgICBpZiAoaW5kZXhbaV0gPCAwIHx8IGluZGV4W2ldID49IGRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiBkaW1zW2ldKSArIGluZGV4W2ldO1xuICAgIH1cbiAgICByZXR1cm4gb2ZzO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0X2ZvcnRyYW4oaW5kZXgpIHtcbiAgICB2YXIgb2ZzID0gMDtcbiAgICBpZiAobl9kaW1zICE9IGluZGV4Lmxlbmd0aClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IHdyb25nIG51bWJlciBvZiBpbmRpY2VzXCIpO1xuICAgIGZvciAodmFyIGkgPSBuX2RpbXMgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGluZGV4W2ldIDwgMSB8fCBpbmRleFtpXSA+IGRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiBkaW1zW2ldKSArIChpbmRleFtpXSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gb2ZzO1xuICB9XG5cbiAgdmFyIG9mZnNldCA9IGxheW91dCA9PSAwID8gb2Zmc2V0X2MgOiBvZmZzZXRfZm9ydHJhbjtcblxuICB2YXIgZGltMCA9IGRpbXNbMF07XG5cbiAgLy9cbiAgLy8gRWxlbWVudCBnZXQgZnVuY3Rpb25zLlxuICAvL1xuICBmdW5jdGlvbiBnZXRfc3RkKGluZGV4KSB7XG4gICAgdmFyIG9mcyA9IG9mZnNldChpbmRleCk7XG4gICAgdmFyIHYgPSBkYXRhW29mc107XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfaW50NjQoaW5kZXgpIHtcbiAgICB2YXIgb2ZmID0gb2Zmc2V0KGluZGV4KTtcbiAgICB2YXIgbCA9IGRhdGFbb2ZmXTtcbiAgICB2YXIgaCA9IGRhdGEyW29mZl07XG4gICAgcmV0dXJuIFtcbiAgICAgIDI1NSxcbiAgICAgIGwgJiAweGZmZmZmZixcbiAgICAgICgobCA+Pj4gMjQpICYgMHhmZikgfCAoKGggJiAweGZmZmYpIDw8IDgpLFxuICAgICAgKGggPj4+IDE2KSAmIDB4ZmZmZl07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfY29tcGxleChpbmRleCkge1xuICAgIHZhciBvZmYgPSBvZmZzZXQoaW5kZXgpO1xuICAgIHZhciByID0gZGF0YVtvZmZdO1xuICAgIHZhciBpID0gZGF0YTJbb2ZmXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIH1cblxuICB2YXIgZ2V0ID0gZGF0YV90eXBlID09IDEgLyogSW50NjQgKi8gPyBnZXRfaW50NjQgOiAoZGF0YV90eXBlID09IDIgLyogQ29tcGxleCAqLyA/IGdldF9jb21wbGV4IDogZ2V0X3N0ZCk7XG5cbiAgZnVuY3Rpb24gZ2V0MV9jKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBkaW0wKVxuICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgIHJldHVybiBkYXRhW2ldO1xuICB9XG4gIGZ1bmN0aW9uIGdldDFfZm9ydHJhbihpKSB7XG4gICAgaWYgKGkgPCAxIHx8IGkgPiBkaW0wKVxuICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgIHJldHVybiBkYXRhW2kgLSAxXTtcbiAgfVxuICBmdW5jdGlvbiBnZXQxX2FueShpKSB7XG4gICAgcmV0dXJuIGdldChbaV0pO1xuICB9XG5cbiAgdmFyIGdldDEgPSBkYXRhX3R5cGUgPT0gMCAvKiBHZW5lcmFsICovID8gKGxheW91dCA9PSAwID8gZ2V0MV9jIDogZ2V0MV9mb3J0cmFuKSA6IGdldDFfYW55O1xuXG4gIC8vXG4gIC8vIEVsZW1lbnQgc2V0IGZ1bmN0aW9uc1xuICAvL1xuICBmdW5jdGlvbiBzZXRfc3RkX3JhdyhvZmYsIHYpIHtcbiAgICBkYXRhW29mZl0gPSB2O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0X2ludDY0X3JhdyhvZmYsIHYpIHtcbiAgICBkYXRhW29mZl0gPSB2WzFdIHwgKCh2WzJdICYgMHhmZikgPDwgMjQpO1xuICAgIGRhdGEyW29mZl0gPSAoKHZbMl0gPj4+IDgpICYgMHhmZmZmKSB8ICh2WzNdIDw8IDE2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9jb21wbGV4X3JhdyhvZmYsIHYpIHtcbiAgICBkYXRhW29mZl0gPSB2WzFdO1xuICAgIGRhdGEyW29mZl0gPSB2WzJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0X3N0ZChpbmRleCwgdikge1xuICAgIHZhciBvZnMgPSBvZmZzZXQoaW5kZXgpO1xuICAgIHJldHVybiBzZXRfc3RkX3JhdyhvZnMsIHYpO1xuICB9XG4gIGZ1bmN0aW9uIHNldF9pbnQ2NChpbmRleCwgdikge1xuICAgIHJldHVybiBzZXRfaW50NjRfcmF3KG9mZnNldChpbmRleCksIHYpO1xuICB9XG4gIGZ1bmN0aW9uIHNldF9jb21wbGV4KGluZGV4LCB2KSB7XG4gICAgcmV0dXJuIHNldF9jb21wbGV4X3JhdyhvZmZzZXQoaW5kZXgpLCB2KTtcbiAgfVxuXG4gIHZhciBzZXQgPSBkYXRhX3R5cGUgPT0gMSAvKiBJbnQ2NCAqLyA/IHNldF9pbnQ2NCA6IChkYXRhX3R5cGUgPT0gMiAvKiBDb21wbGV4ICovID8gc2V0X2NvbXBsZXggOiBzZXRfc3RkKTtcblxuICBmdW5jdGlvbiBzZXQxX2MoaSwgdikge1xuICAgIGlmIChpIDwgMCB8fCBpID49IGRpbTApXG4gICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgZGF0YVtpXSA9IHY7XG4gIH1cbiAgZnVuY3Rpb24gc2V0MV9mb3J0cmFuKGksIHYpIHtcbiAgICBpZiAoaSA8IDEgfHwgaSA+IGRpbTApXG4gICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgZGF0YVtpIC0gMV0gPSB2O1xuICB9XG4gIGZ1bmN0aW9uIHNldDFfYW55KGksIHYpIHtcbiAgICBzZXQoW2ldLCB2KTtcbiAgfVxuXG4gIHZhciBzZXQxID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IChsYXlvdXQgPT0gMCA/IHNldDFfYyA6IHNldDFfZm9ydHJhbikgOiBzZXQxX2FueTtcblxuICAvL1xuICAvLyBvdGhlclxuICAvL1xuICBmdW5jdGlvbiBudGhfZGltKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBuX2RpbXMpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gICAgcmV0dXJuIGRpbXNbaV07XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsKHYpIHtcbiAgICBpZiAoZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgc2V0X3N0ZF9yYXcoaSwgdik7XG4gICAgaWYgKGRhdGFfdHlwZSA9PSAxIC8qIEludDY0ICovKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICBzZXRfaW50NjRfcmF3KGksIHYpO1xuICAgIGlmIChkYXRhX3R5cGUgPT0gMiAvKiBDb21wbGV4ICovKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICBzZXRfY29tcGxleF9yYXcoaSwgdik7XG4gIH1cbiAgZnVuY3Rpb24gYmxpdChmcm9tKSB7XG4gICAgaWYgKG5fZGltcyAhPSBmcm9tLm51bV9kaW1zKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspXG4gICAgICBpZiAoZGltc1tpXSAhPSBmcm9tLm50aF9kaW0oaSkpXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgICBkYXRhLnNldChmcm9tLmRhdGEpO1xuICAgIGlmIChkYXRhX3R5cGUgIT0gMCAvKiBHZW5lcmFsICovKVxuICAgICAgZGF0YTIuc2V0KGZyb20uZGF0YTIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3ViKG9mcywgbGVuKSB7XG4gICAgdmFyIGNoYW5nZWRfZGltO1xuICAgIHZhciBtdWwgPSAxO1xuXG4gICAgaWYgKGxheW91dCA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5fZGltczsgaSsrKVxuICAgICAgICBtdWwgPSBtdWwgKiBkaW1zW2ldO1xuICAgICAgY2hhbmdlZF9kaW0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChuX2RpbXMgLSAxKTsgaSsrKVxuICAgICAgICBtdWwgPSBtdWwgKiBkaW1zW2ldO1xuICAgICAgY2hhbmdlZF9kaW0gPSBuX2RpbXMgLSAxO1xuICAgICAgb2ZzID0gb2ZzIC0gMTtcbiAgICB9XG5cbiAgICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gZGltc1tjaGFuZ2VkX2RpbV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG5cbiAgICB2YXIgbmV3X2RhdGEgPSBkYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICAgIHZhciBuZXdfZGF0YTIgPSBkYXRhX3R5cGUgPT0gMCAvKiBHZW5lcmFsICovID8gbnVsbCA6IGRhdGEyLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuXG4gICAgdmFyIG5ld19kaW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgIG5ld19kaW1zW2ldID0gZGltc1tpXTtcbiAgICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG5cbiAgICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbShuZXdfZGF0YSwgbmV3X2RhdGEyLCBkYXRhX3R5cGUsIGtpbmQsIGxheW91dCwgbmV3X2RpbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpY2UodmluZCkge1xuICAgIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IFtdO1xuICAgIHZhciBzdWJfZGltcyA9IFtdO1xuICAgIHZhciBvZnM7XG5cbiAgICBpZiAobnVtX2luZHMgPj0gbl9kaW1zKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gICAgaWYgKGxheW91dCA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICAgIGZvciAoOyBpIDwgbl9kaW1zOyBpKyspXG4gICAgICAgIGluZGV4W2ldID0gMDtcbiAgICAgIG9mcyA9IG9mZnNldChpbmRleCk7XG4gICAgICBzdWJfZGltcyA9IGRpbXMuc2xpY2UobnVtX2luZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICAgIGluZGV4W25fZGltcyAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXMgLSBudW1faW5kczsgaSsrKVxuICAgICAgICBpbmRleFtpXSA9IDE7XG4gICAgICBvZnMgPSBvZmZzZXQoaW5kZXgpO1xuICAgICAgc3ViX2RpbXMgPSBkaW1zLnNsaWNlKDAsIG51bV9pbmRzKTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICAgIHZhciBuZXdfZGF0YSA9IGRhdGEuc3ViYXJyYXkob2ZzLCBvZnMgKyBzaXplKTtcbiAgICB2YXIgbmV3X2RhdGEyID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IG51bGwgOiBkYXRhMi5zdWJhcnJheShvZnMsIG9mcyArIHNpemUpO1xuXG4gICAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20obmV3X2RhdGEsIG5ld19kYXRhMiwgZGF0YV90eXBlLCBraW5kLCBsYXlvdXQsIHN1Yl9kaW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2hhcGUodmRpbSkge1xuICAgIHZhciBuZXdfZGltID0gW107XG4gICAgdmFyIG51bV9kaW1zID0gdmRpbS5sZW5ndGg7XG5cbiAgICBpZiAobnVtX2RpbXMgPCAxKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICAgIHZhciBudW1fZWx0cyA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICBuZXdfZGltW2ldID0gdmRpbVtpXTtcbiAgICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICAgIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcblxuICAgIHJldHVybiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGEsIGRhdGEyLCBkYXRhX3R5cGUsIGtpbmQsIGxheW91dCwgbmV3X2RpbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlKGIsIHRvdGFsKSB7XG4gICAgaWYgKGxheW91dCAhPSBiLmxheW91dClcbiAgICAgIHJldHVybiBiLmxheW91dCAtIGxheW91dDtcbiAgICBpZiAobl9kaW1zICE9IGIubnVtX2RpbXMpXG4gICAgICByZXR1cm4gYi5udW1fZGltcyAtIG5fZGltcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKVxuICAgICAgaWYgKG50aF9kaW0oaSkgIT0gYi5udGhfZGltKGkpKVxuICAgICAgICByZXR1cm4gKG50aF9kaW0oaSkgPCBiLm50aF9kaW0oaSkpID8gLTEgOiAxO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDExOlxuICAgICAgdmFyIHgsIHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgIHkgPSBiLmRhdGFbaV07XG5cbiAgICAgICAgLy9maXJzdCBhcnJheVxuICAgICAgICBpZiAoeCA8IHkpXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoeCA+IHkpXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgICAgICBpZiAoIXRvdGFsKVxuICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgaWYgKHggPT0geClcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoeSA9PSB5KVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhMikge1xuICAgICAgICAgIC8vc2Vjb25kIGFycmF5XG4gICAgICAgICAgeCA9IGRhdGEyW2ldO1xuICAgICAgICAgIHkgPSBiLmRhdGEyW2ldO1xuICAgICAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoeCA+IHkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgICAgICAgIGlmICghdG90YWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgaWYgKHggPT0geClcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgaWYgKHkgPT0geSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSA4OlxuICAgIGNhc2UgOTpcbiAgICBjYXNlIDEyOlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNzpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGF0YTJbaV0gPCBiLmRhdGEyW2ldKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGRhdGEyW2ldID4gYi5kYXRhMltpXSlcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBkYXRhMjogZGF0YTIsXG4gICAgZGF0YV90eXBlOiBkYXRhX3R5cGUsXG4gICAgbnVtX2RpbXM6IG5fZGltcyxcbiAgICBudGhfZGltOiBudGhfZGltLFxuICAgIGtpbmQ6IGtpbmQsXG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBzdWI6IHN1YixcbiAgICBzbGljZTogc2xpY2UsXG4gICAgYmxpdDogYmxpdCxcbiAgICBmaWxsOiBmaWxsLFxuICAgIHJlc2hhcGU6IHJlc2hhcGUsXG4gICAgZ2V0OiBnZXQsXG4gICAgZ2V0MTogZ2V0MSxcbiAgICBzZXQ6IHNldCxcbiAgICBzZXQxOiBzZXQxLFxuICAgIGNvbXBhcmU6IGNvbXBhcmVcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV92aWV3c1xuLy9SZXF1aXJlczogY2FtbF9iYV9pbml0X3ZpZXdzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICAvLyBJbml0aWFsaXplIFR5cGVkQXJyYXkgdmlld3NcbiAgY2FtbF9iYV9pbml0X3ZpZXdzKCk7XG5cbiAgLy8gc2V0IHVwIGRpbWVuc2lvbnMgYW5kIGNhbGN1bGF0ZSBzaXplXG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuXG4gIC8vdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG5cbiAgLy8gQWxsb2NhdGUgVHlwZWRBcnJheVxuICB2YXIgdmlldyA9IGNhbWxfYmFfdmlld3NbMF1ba2luZF07XG4gIGlmICghdmlldylcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSk7XG5cbiAgLy8gMm5kIFR5cGVkQXJyYXkgZm9yIGludDY0LCBjb21wbGV4MzIgYW5kIGNvbXBsZXg2NFxuICB2YXIgZGF0YV90eXBlID0gY2FtbF9iYV92aWV3c1sxXVtraW5kXTtcbiAgdmFyIGRhdGEyID0gbnVsbDtcbiAgaWYgKGRhdGFfdHlwZSAhPSAwIC8qIEdlbmVyYWwgKi8pIHtcbiAgICBkYXRhMiA9IG5ldyB2aWV3KHNpemUpO1xuICB9XG5cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YSwgZGF0YTIsIGRhdGFfdHlwZSwga2luZCwgbGF5b3V0LCBkaW1zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBkaW1zID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5udW1fZGltczsgaSsrKVxuICAgIGRpbXNbaV0gPSBiYS5udGhfZGltKGkpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbShiYS5kYXRhLCBiYS5kYXRhMiwgYmEuZGF0YV90eXBlLCBiYS5raW5kLCBsYXlvdXQsIGRpbXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEsIF9kaW0pIHtcbiAgcmV0dXJuIGJhLm51bV9kaW1zO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGRpbSkge1xuICByZXR1cm4gYmEubnRoX2RpbShkaW0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBiYS5udGhfZGltKDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBiYS5udGhfZGltKDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBiYS5udGhfZGltKDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGluZGV4KSB7XG4gIHJldHVybiBiYS5nZXQoY2FtbF9qc19mcm9tX2FycmF5KGluZGV4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBiMSA9IGJhLmdldDEoaTApO1xuICB2YXIgYjIgPSBiYS5nZXQxKGkwKzEpIDw8IDg7XG4gIHJldHVybiAoYjEgfCBiMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBiMSA9IGJhLmdldDEoaTApO1xuICB2YXIgYjIgPSBiYS5nZXQxKGkwKzEpIDw8IDg7XG4gIHZhciBiMyA9IGJhLmdldDEoaTArMikgPDwgMTY7XG4gIHZhciBiNCA9IGJhLmdldDEoaTArMykgPDwgMjQ7XG4gIHJldHVybiAoYjEgfCBiMiB8IGIzIHwgYjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgYjEgPSBiYS5nZXQxKGkwKTtcbiAgdmFyIGIyID0gYmEuZ2V0MShpMCsxKSA8PCA4O1xuICB2YXIgYjMgPSBiYS5nZXQxKGkwKzIpIDw8IDE2O1xuICB2YXIgYjQgPSBiYS5nZXQxKGkwKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQxKGkwKzQpIDw8IDg7XG4gIHZhciBiNiA9IGJhLmdldDEoaTArNSkgPDwgMTY7XG4gIHZhciBiNyA9IGJhLmdldDEoaTArNik7XG4gIHZhciBiOCA9IGJhLmdldDEoaTArNykgPDwgODtcbiAgcmV0dXJuIFsyNTUsIGIxIHwgYjIgfCBiMywgYjQgfCBiNSB8IGI2LCBiNyB8IGI4IF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQxKGkwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoW2kwLCBpMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoW2kwLCBpMSwgaTJdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpbmRleCwgdikge1xuICByZXR1cm4gYmEuc2V0KGNhbWxfanNfZnJvbV9hcnJheShpbmRleCksIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICBiYS5zZXQxKGkwLCB2ICYgMHhmZik7XG4gIGJhLnNldDEoaTArMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICBiYS5zZXQxKGkwLCB2ICYgMHhmZik7XG4gIGJhLnNldDEoaTArMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIGJhLnNldDEoaTArMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIGJhLnNldDEoaTAsIHZbMV0gJiAweGZmKTtcbiAgYmEuc2V0MShpMCsxLCAodlsxXSA+PiA4KSAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzIsIHZbMV0gPj4gMTYpO1xuICBiYS5zZXQxKGkwKzMsIHZbMl0gJiAweGZmKTtcbiAgYmEuc2V0MShpMCs0LCAodlsyXSA+PiA4KSAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzUsIHZbMl0gPj4gMTYpO1xuICBiYS5zZXQxKGkwKzYsIHZbM10gJiAweGZmKTtcbiAgYmEuc2V0MShpMCs3LCB2WzNdID4+IDgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgcmV0dXJuIGJhLnNldDEoaTAsIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgcmV0dXJuIGJhLnNldChbaTAsIGkxXSwgdik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgcmV0dXJuIGJhLnNldChbaTAsIGkxLCBpMl0sIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBkc3QuYmxpdChzcmMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIGluaXQpIHtcbiAgYmEuZmlsbChpbml0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGJhLnN1YihvZnMsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICByZXR1cm4gYmEuc2xpY2UoY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICByZXR1cm4gYmEucmVzaGFwZShjYW1sX2pzX2Zyb21fYXJyYXkodmluZCkpO1xufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuLy9Qcm92aWRlczogYmlnc3RyaW5nX2FsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBCYXNlXG5mdW5jdGlvbiBiaWdzdHJpbmdfYWxsb2MoXyxzaXplKXtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlKDEyLCAwLCBbMCxzaXplXSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBDb3JlX2tlcm5lbFxuZnVuY3Rpb24gYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1Yih2X2JzdHIpIHtcbiAgaWYgKHZfYnN0ci5kYXRhMiAhPSBudWxsKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIH1cblxuICBpZiAodl9ic3RyLmhhc093blByb3BlcnR5KCdfX2lzX2RlYWxsb2NhdGVkJykpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfZGVzdHJveTogYmlnc3RyaW5nIGlzIGFscmVhZHkgZGVhbGxvY2F0ZWRcIik7XG4gIH1cblxuICB2YXIgZGVzdHJveWVkX2RhdGEgPSBuZXcgdl9ic3RyLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKDApO1xuICB2YXIgZGVzdHJveWVkX2JpZ3N0cmluZyA9XG4gICAgICBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRlc3Ryb3llZF9kYXRhLCBudWxsLCB2X2JzdHIuZGF0YV90eXBlLCB2X2JzdHIua2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdl9ic3RyLmxheW91dCwgWzBdKTtcbiAgZGVzdHJveWVkX2JpZ3N0cmluZy5fX2lzX2RlYWxsb2NhdGVkID0gdHJ1ZTtcblxuICAvLyBNdXRhdGUgdGhlIG9yaWdpbmFsIGJpZ3N0cmluZyBpbi1wbGFjZSwgdG8gc2ltdWxhdGUgd2hhdCB0aGUgQyB2ZXJzaW9uIGRvZXNcbiAgT2JqZWN0LmFzc2lnbih2X2JzdHIsIGRlc3Ryb3llZF9iaWdzdHJpbmcpO1xuXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQsIGNhbWxfYmFfZ2V0XzFcbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQmFzZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIodl9ic3RyLCB2X3NyY19wb3MsIHZfc3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIHZhciBjID0gY2FtbF9iYV9nZXRfMSh2X2JzdHIsdl9zcmNfcG9zICsgaSk7XG4gICAgY2FtbF9ieXRlc19zZXQodl9zdHIsdl9kc3RfcG9zICsgaSxjKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuLy9Gcm9tIGNzdHJ1Y3RcbnZhciBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfc3RyaW5nX3N0dWIgPSBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZ1xuLy9SZXF1aXJlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbi8vRnJvbSBjc3RydWN0XG52YXIgY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmcgPSBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldCwgY2FtbF9iYV9zZXRfMVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBCYXNlXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWIodl9zdHIsIHZfc3JjX3Bvcywgdl9ic3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHZfYnN0cix2X2RzdF9wb3MgKyBpLGNhbWxfc3RyaW5nX2dldCh2X3N0cix2X3NyY19wb3MgKyBpKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXQsIGNhbWxfYmFfc2V0XzFcbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQmFzZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIodl9zdHIsIHZfc3JjX3Bvcywgdl9ic3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHZfYnN0cix2X2RzdF9wb3MgKyBpLGNhbWxfYnl0ZXNfZ2V0KHZfc3RyLHZfc3JjX3BvcyArIGkpKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWJcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMSwgY2FtbF9iYV9zZXRfMVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBCYXNlXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHViKHMxLCBpMSwgczIsIGkyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHMyLGkyICsgaSxjYW1sX2JhX2dldF8xKHMxLGkxICsgaSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1dlYWtkZWZcbi8vV2lsbCBiZSBkZWZpbmVkIGluIEJhc2VcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1jbXBfc3R1Yih2X3MxLCB2X3MxX3Bvcywgdl9zMiwgdl9zMl9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsdl9zMV9wb3MgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEodl9zMix2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19maW5kXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1dlYWtkZWZcbi8vV2lsbCBiZSBkZWZpbmVkIGluIEJhc2VcbmZ1bmN0aW9uIGJpZ3N0cmluZ19maW5kKGJzLCBjaHIsIHBvcywgbGVuKXtcbiAgd2hpbGUobGVuID4gMCl7XG4gICAgaWYoY2FtbF9iYV9nZXRfMShicyxwb3MpID09IGNocikgcmV0dXJuIHBvcztcbiAgICBwb3MrKztcbiAgICBsZW4tLTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9qc19vZl9vY2FtbCBsaWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9qc19vZl9vY2FtbCBsaWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbSh0YSwgbnVsbCwgMCwgMTIsIDAsIFt0YS5sZW5ndGhdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsYnMuZGF0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXMgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIHN0ciwgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgdGVtcC5pbm5lckhUTUw9IHM7XG4gIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgdGVtcD1udWxsO1xuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuZnVuY3Rpb24ganNfcHJpbnRfc3Rkb3V0KHMpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIGRlbGV0ZSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfbmV3X3N0cmluZyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUudG9TdHJpbmcoKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUudG9TdHJpbmcoKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIHN0cmluZztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgc3RyaW5nID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBzdHJpbmcgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LHN0cmluZywwLGxlbik7XG4gIH1cbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfbmV3X3N0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LF9mbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2KTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6ICAgICAgICAgMHg4MCxcbiAgUFJFRklYX1NNQUxMX0lOVDogICAgICAgICAgIDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6ICAgICAgICAweDIwLFxuICBDT0RFX0lOVDg6ICAgICAgICAgICAgICAgICAgMHgwMCxcbiAgQ09ERV9JTlQxNjogICAgICAgICAgICAgICAgIDB4MDEsXG4gIENPREVfSU5UMzI6ICAgICAgICAgICAgICAgICAweDAyLFxuICBDT0RFX0lOVDY0OiAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAgICAgICAgICAgICAgIDB4MDQsXG4gIENPREVfU0hBUkVEMTY6ICAgICAgICAgICAgICAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAgICAgICAgICAgICAgMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAgICAgICAgICAgICAgIDB4MDgsXG4gIENPREVfQkxPQ0s2NDogICAgICAgICAgICAgICAweDEzLFxuICBDT0RFX1NUUklORzg6ICAgICAgICAgICAgICAgMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogICAgICAgICAgICAgIDB4MEEsXG4gIENPREVfRE9VQkxFX0JJRzogICAgICAgICAgICAweDBCLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6ICAgICAgICAgMHgwQyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogICAgIDB4MEQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6ICAweDBFLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzogICAgMHgwRixcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6IDB4MDcsXG4gIENPREVfQ09ERVBPSU5URVI6ICAgICAgICAgICAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogICAgICAgICAgMHgxMSxcbiAgQ09ERV9DVVNUT006ICAgICAgICAgICAgICAgIDB4MTJcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sQnl0ZXNSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxCeXRlc1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sQnl0ZXNSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxCeXRlc1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHN3aXRjaChzKSB7XG4gICAgICAgICAgY2FzZSBcIl9qXCI6XG4gICAgICAgICAgICAvLyBJbnQ2NFxuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgXCJfaVwiOlxuICAgICAgICAgICAgLy8gSW50MzJcbiAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIFwiX25cIjpcbiAgICAgICAgICAgIC8vIE5hdGl2ZWludFxuICAgICAgICAgICAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMikgPDwgOCkgfFxuICAgICAgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgfVxuICBpZiAoZ2V0MzIocywgb2ZzKSAhPSAoMHg4NDk1QTZCRXwwKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gIHJldHVybiAoZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTUpIHtcbiAgICAgICAgICAvLyBJbnQ2NFxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykgd3JpdGVyLndyaXRlICg4LCBcIl9qXFwwXCIuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSA0O1xuICAgICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDM7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZbMF0gPCAxNiAmJiB2Lmxlbmd0aCAtIDEgPCA4KVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSk8PDQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLCAoKHYubGVuZ3RoLTEpIDw8IDEwKSB8IHZbMF0pO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSB2Lmxlbmd0aDtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEpIHN0YWNrLnB1c2ggKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgTWxCeXRlcykge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICB3cml0ZXIuZmluYWxpemUgKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgX2ZsKSB7XG4gIC8qIGlnbm9yZXMgZmxhZ3MuLi4gKi9cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIF9mbCkge1xuICAvKiBpZ25vcmVzIGZsYWdzLi4uICovXG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIF9mbCkge1xuICAvKiBpZ25vcmVzIGZsYWdzLi4uICovXG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2KTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHsgcmV0dXJuIHJhd19hcnJheV9zdWIoYSwxLGEubGVuZ3RoLTEpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7IHJldHVybiByYXdfYXJyYXlfY29ucyhhLDApOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0geC50b1N0cmluZygpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tmLnRvU3RyaW5nKCldLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDApe1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3VuZGVmaW5lZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKShhcmd1bWVudHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkpIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAmJiBpIDwgYXJpdHk7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4scmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLHJhd19hcnJheV9jb25zKGFyZ3VtZW50cyx0aGlzKSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsW3RoaXMsYXJndW1lbnRzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbiwgcmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5KSByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCByYXdfYXJyYXlfY29ucyhhcmd1bWVudHMsdGhpcykpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5ICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuICYmIGkgPD0gYXJpdHk7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyBmLmFwcGx5KG51bGwsIHJhd19hcnJheV9jb25zKGFyZ3VtZW50cyx0aGlzKSk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyAocykge3JldHVybiBjYW1sX25ld19zdHJpbmcgKHMpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwocy50b1N0cmluZygpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXCIpO1xuICByZXR1cm4gZXZhbChzLnRvU3RyaW5nKCkpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cIik7XG4gIHJldHVybiBldmFsKHMudG9TdHJpbmcoKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1twWzFdLnRvU3RyaW5nKCldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSSwgYnV0IHdpdGhvdXQgdGhlIHdlYWsgc2VtYW50aWNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246IDwgNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gWzAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqL11cbn1cblxuLy9Qcm92aWRlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBbMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi9dXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBbMCx0LHRtMl07XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZChsb2Msc2hhcGUpIHtcbiAgZnVuY3Rpb24gdW5kZWZfbW9kdWxlIChfeCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmcoY2FtbF9nbG9iYWxfZGF0YS5VbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSwgbG9jKTtcbiAgfVxuICBmdW5jdGlvbiBsb29wIChzaGFwZSxzdHJ1Y3QsaWR4KXtcbiAgICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgICBzd2l0Y2goc2hhcGUpe1xuICAgICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICAgICAgc3RydWN0W2lkeF09e2Z1bjp1bmRlZl9tb2R1bGV9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTovL2xhenlcbiAgICAgICAgc3RydWN0W2lkeF09WzI0NiwgdW5kZWZfbW9kdWxlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAyOi8vY2xhc3NcbiAgICAgICAgc3RydWN0W2lkeF09W107XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IFswXTtcbiAgICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICAgIGxvb3Aoc2hhcGVbMV1baV0sc3RydWN0W2lkeF0saSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMTovL1ZhbHVlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gc2hhcGVbMV07XG4gICAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IFtdO1xuICBsb29wKHNoYXBlLHJlcywwKTtcbiAgcmV0dXJuIHJlc1swXVxufVxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZFxuLy9SZXF1aXJlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGUscmVhbCx4KSB7XG4gIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICBzd2l0Y2goc2hhcGUpe1xuICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICByZWFsLmZ1biA9IHg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6Ly9sYXp5XG4gICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9zdHJpbmcobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIixudWxsLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCxsZW4pe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGNoYW5fbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihsZW48MCkgbGVuID0gY2hhbl9sZW4gLSBjaGFuLm9mZnNldDtcbiAgaWYoY2hhbi5vZmZzZXQgKyBsZW4gPiBjaGFuX2xlbikgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcbiAgcmV0dXJuIGNhbWxfbWQ1X3N0cmluZyhidWYsMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG52YXIgY2FtbF9tZDVfc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgZnVuY3Rpb24gbWQ1KGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgdmFyIGkgPSBsZW5ndGg7XG4gICAgYnVmZmVyW2kgPj4gMl0gfD0gMHg4MCA8PCAoOCAqIChpICYgMykpO1xuICAgIGZvciAoaSA9IChpICYgfjB4MykgKyA4OyhpICYgMHgzRikgPCA2MCA7aSArPSA0KVxuICAgICAgYnVmZmVyWyhpID4+IDIpIC0gMV0gPSAwO1xuICAgIGJ1ZmZlclsoaSA+PiAyKSAtMV0gPSBsZW5ndGggPDwgMztcbiAgICBidWZmZXJbaSA+PiAyXSA9IChsZW5ndGggPj4gMjkpICYgMHgxRkZGRkZGRjtcblxuICAgIHZhciB3ID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzZdO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgdmFyIGEgPSB3WzBdLCBiID0gd1sxXSwgYyA9IHdbMl0sIGQgPSB3WzNdO1xuXG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA3LCAweEQ3NkFBNDc4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE3LCAweDI0MjA3MERCKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgM10sIDIyLCAweEMxQkRDRUVFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA1XSwgMTIsIDB4NDc4N0M2MkEpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTcsIDB4QTgzMDQ2MTMpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNywgMHg2OTgwOThEOCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDldLCAxMiwgMHg4QjQ0RjdBRik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTFdLCAyMiwgMHg4OTVDRDdCRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA3LCAweDZCOTAxMTIyKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE3LCAweEE2Nzk0MzhFKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxNV0sIDIyLCAweDQ5QjQwODIxKTtcblxuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krIDZdLCA5LCAweEMwNDBCMzQwKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE0LCAweDI2NUU1QTUxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDUsIDB4RDYyRjEwNUQpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEwXSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDRdLCAyMCwgMHhFN0QzRkJDOCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA1LCAweDIxRTFDREU2KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAzXSwgMTQsIDB4RjRENTBEODcpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA4XSwgMjAsIDB4NDU1QTE0RUQpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krIDJdLCA5LCAweEZDRUZBM0Y4KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgN10sIDE0LCAweDY3NkYwMkQ5KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNCwgMHhGRkZBMzk0Mik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDhdLCAxMSwgMHg4NzcxRjY4MSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTRdLCAyMywgMHhGREU1MzgwQyk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA0LCAweEE0QkVFQTQ0KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgN10sIDE2LCAweEY2QkI0QjYwKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxMF0sIDIzLCAweEJFQkZCQzcwKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAwXSwgMTEsIDB4RUFBMTI3RkEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAzXSwgMTYsIDB4RDRFRjMwODUpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNCwgMHhEOUQ0RDAzOSk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krMTJdLCAxMSwgMHhFNkRCOTlFNSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDJdLCAyMywgMHhDNEFDNTY2NSk7XG5cbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDYsIDB4RjQyOTIyNDQpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTUsIDB4QUI5NDIzQTcpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA1XSwgMjEsIDB4RkM5M0EwMzkpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDNdLCAxMCwgMHg4RjBDQ0M5Mik7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTBdLCAxNSwgMHhGRkVGRjQ3RCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA2LCAweDZGQTg3RTRGKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxNV0sIDEwLCAweEZFMkNFNkUwKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsxM10sIDIxLCAweDRFMDgxMUExKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgNF0sIDYsIDB4Rjc1MzdFODIpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTUsIDB4MkFEN0QyQkIpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA5XSwgMjEsIDB4RUI4NkQzOTEpO1xuXG4gICAgICB3WzBdID0gYWRkKGEsIHdbMF0pO1xuICAgICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICAgIHdbMl0gPSBhZGQoYywgd1syXSk7XG4gICAgICB3WzNdID0gYWRkKGQsIHdbM10pO1xuICAgIH1cblxuICAgIHZhciB0ID0gbmV3IEFycmF5KDE2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICB0W2kgKiA0ICsgal0gPSAod1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHMsIG9mcywgbGVuKSB7XG4gICAgLy8gRklYOiBtYXliZSB3ZSBzaG91bGQgcGVyZm9ybSB0aGUgY29tcHV0YXRpb24gYnkgY2h1bmsgb2YgNjQgYnl0ZXNcbiAgICAvLyBhcyBpbiBodHRwOi8vd3d3Lm15ZXJzZGFpbHkub3JnL2pvc2VwaC9qYXZhc2NyaXB0L21kNS5qc1xuICAgIHZhciBidWYgPSBbXTtcbiAgICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICB2YXIgYiA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID1cbiAgICAgICAgICBiLmNoYXJDb2RlQXQoaikgfCAoYi5jaGFyQ29kZUF0KGorMSkgPDwgOCkgfFxuICAgICAgICAgIChiLmNoYXJDb2RlQXQoaisyKSA8PCAxNikgfCAoYi5jaGFyQ29kZUF0KGorMykgPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGIuY2hhckNvZGVBdChpICsgb2ZzKSA8PCAoOCAqIChpICYgMykpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgICAgdmFyIGEgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9IGFbal0gfCAoYVtqKzFdIDw8IDgpIHwgKGFbaisyXSA8PCAxNikgfCAoYVtqKzNdIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBhW2kgKyBvZnNdIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShtZDUoYnVmLCBsZW4pKTtcbiAgfVxufSAoKTtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFuaWVsIEMuIEJ1ZW56bGkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuXG5sZXQgZXJyX25vX3ByZWQgPSBcIlUrMDAwMCBoYXMgbm8gcHJlZGVjZXNzb3JcIlxubGV0IGVycl9ub19zdWNjID0gXCJVKzEwRkZGRiBoYXMgbm8gc3VjY2Vzc29yXCJcbmxldCBlcnJfbm90X3N2IGkgPSBmb3JtYXRfaW50IFwiJVhcIiBpIF4gXCIgaXMgbm90IGFuIFVuaWNvZGUgc2NhbGFyIHZhbHVlXCJcbmxldCBlcnJfbm90X2xhdGluMSB1ID0gXCJVK1wiIF4gZm9ybWF0X2ludCBcIiUwNFhcIiB1IF4gXCIgaXMgbm90IGEgbGF0aW4xIGNoYXJhY3RlclwiXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgbWluID0gMHgwMDAwXG5sZXQgbWF4ID0gMHgxMEZGRkZcbmxldCBsb19ib3VuZCA9IDB4RDdGRlxubGV0IGhpX2JvdW5kID0gMHhFMDAwXG5cbmxldCBib20gPSAweEZFRkZcbmxldCByZXAgPSAweEZGRkRcblxubGV0IHN1Y2MgdSA9XG4gIGlmIHUgPSBsb19ib3VuZCB0aGVuIGhpX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1heCB0aGVuIGludmFsaWRfYXJnIGVycl9ub19zdWNjIGVsc2VcbiAgdSArIDFcblxubGV0IHByZWQgdSA9XG4gIGlmIHUgPSBoaV9ib3VuZCB0aGVuIGxvX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1pbiB0aGVuIGludmFsaWRfYXJnIGVycl9ub19wcmVkIGVsc2VcbiAgdSAtIDFcblxubGV0IGlzX3ZhbGlkIGkgPSAobWluIDw9IGkgJiYgaSA8PSBsb19ib3VuZCkgfHwgKGhpX2JvdW5kIDw9IGkgJiYgaSA8PSBtYXgpXG5sZXQgb2ZfaW50IGkgPSBpZiBpc192YWxpZCBpIHRoZW4gaSBlbHNlIGludmFsaWRfYXJnIChlcnJfbm90X3N2IGkpXG5leHRlcm5hbCB1bnNhZmVfb2ZfaW50IDogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB0b19pbnQgOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX2NoYXIgdSA9IHUgPCAyNTZcbmxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xubGV0IHRvX2NoYXIgdSA9XG4gIGlmIHUgPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyAoZXJyX25vdF9sYXRpbjEgdSkgZWxzZVxuICBDaGFyLnVuc2FmZV9jaHIgdVxuXG5sZXQgdW5zYWZlX3RvX2NoYXIgPSBDaGFyLnVuc2FmZV9jaHJcblxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBQZXJ2YXNpdmVzLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBuZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19uZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIG1pbiAoMiAqIEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlcikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG4gPiBuZXdsZW5cbiAgICAgIHRoZW4gZmFpbHdpdGggXCJMZXhpbmcubGV4X3JlZmlsbDogY2Fubm90IGdyb3cgYnVmZmVyXCI7XG4gICAgICBsZXQgbmV3YnVmID0gQnl0ZXMuY3JlYXRlIG5ld2xlbiBpblxuICAgICAgKCogQ29weSB0aGUgdmFsaWQgZGF0YSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBuZXdidWYgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKTtcbiAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDwtIG5ld2J1ZlxuICAgIGVuZDtcbiAgICAoKiBSZWFsbG9jYXRpb24gb3Igbm90LCB3ZSBoYXZlIHNoaWZ0ZWQgdGhlIGRhdGEgbGVmdCBieVxuICAgICAgIHN0YXJ0X3BvcyBjaGFyYWN0ZXJzOyB1cGRhdGUgdGhlIHBvc2l0aW9ucyAqKVxuICAgIGxldCBzID0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgICBsZXhidWYubGV4X2Fic19wb3MgPC0gbGV4YnVmLmxleF9hYnNfcG9zICsgcztcbiAgICBsZXhidWYubGV4X2N1cnJfcG9zIDwtIGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIDwtIDA7XG4gICAgbGV4YnVmLmxleF9sYXN0X3BvcyA8LSBsZXhidWYubGV4X2xhc3RfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gcyA7XG4gICAgbGV0IHQgPSBsZXhidWYubGV4X21lbSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC0xIGRvXG4gICAgICBsZXQgdiA9IHQuKGkpIGluXG4gICAgICBpZiB2ID49IDAgdGhlblxuICAgICAgICB0LihpKSA8LSB2LXNcbiAgICBkb25lXG4gIGVuZDtcbiAgKCogVGhlcmUgaXMgbm93IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgQnl0ZXMuYmxpdCBhdXhfYnVmZmVyIDAgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9idWZmZXJfbGVuIG47XG4gIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuXG5cbmxldCB6ZXJvX3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAxO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAwO1xufVxuXG5sZXQgZnJvbV9mdW5jdGlvbiBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSB6ZXJvX3BvcztcbiAgICBsZXhfY3Vycl9wID0gemVyb19wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gIGZyb21fZnVuY3Rpb24gKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IHplcm9fcG9zO1xuICAgIGxleF9jdXJyX3AgPSB6ZXJvX3BvcztcbiAgfVxuXG5sZXQgbGV4ZW1lIGxleGJ1ZiA9XG4gIGxldCBsZW4gPSBsZXhidWYubGV4X2N1cnJfcG9zIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3BvcyBsZW5cblxubGV0IHN1Yl9sZXhlbWUgbGV4YnVmIGkxIGkyID1cbiAgbGV0IGxlbiA9IGkyLWkxIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuXG5cbmxldCBzdWJfbGV4ZW1lX29wdCBsZXhidWYgaTEgaTIgPVxuICBpZiBpMSA+PSAwIHRoZW4gYmVnaW5cbiAgICBsZXQgbGVuID0gaTItaTEgaW5cbiAgICBTb21lIChCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlbilcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBOb25lXG4gIGVuZFxuXG5sZXQgc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBpID0gQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGlcblxubGV0IHN1Yl9sZXhlbWVfY2hhcl9vcHQgbGV4YnVmIGkgPVxuICBpZiBpID49IDAgdGhlblxuICAgIFNvbWUgKEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpKVxuICBlbHNlXG4gICAgTm9uZVxuXG5cbmxldCBsZXhlbWVfY2hhciBsZXhidWYgaSA9XG4gIEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wb3MgKyBpKVxuXG5sZXQgbGV4ZW1lX3N0YXJ0IGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcC5wb3NfY251bVxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2NudW1cblxubGV0IGxleGVtZV9zdGFydF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcFxubGV0IGxleGVtZV9lbmRfcCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgbmV3X2xpbmUgbGV4YnVmID1cbiAgbGV0IGxjcCA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgbGNwIHdpdGhcbiAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgcG9zX2JvbCA9IGxjcC5wb3NfY251bTtcbiAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGIubGV4X2N1cnJfcCA8LSB7bGIubGV4X2N1cnJfcCB3aXRoIHBvc19jbnVtID0gMH07XG4gIGxiLmxleF9idWZmZXJfbGVuIDwtIDA7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0IChGbG9hdF9mLCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gPSAtNlxuICAoKiBGb3IgJWggYW5kICVIIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gbWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgLT4gJ2knXG4gIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X28gfCBJbnRfQ28gLT4gJ28nXG4gIHwgSW50X3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9mY29udiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfcGYgfCBGbG9hdF9zZiAtPiAnZicgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZSAtPiAnZSdcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAtPiAnRScgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZyAtPiAnZydcbiAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyAtPiAnRycgfCBGbG9hdF9GIC0+ICdGJ1xuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIC0+ICdoJyB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+ICdIJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9wZiB8IEZsb2F0X3BlIHwgRmxvYXRfcEVcbiAgfCBGbG9hdF9wZyB8IEZsb2F0X3BHIHwgRmxvYXRfcGggfCBGbG9hdF9wSCAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfc2YgfCBGbG9hdF9zZSB8IEZsb2F0X3NFXG4gIHwgRmxvYXRfc2cgfCBGbG9hdF9zRyB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRVxuICB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+XG4gICAgKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZvcm1hdHRpbmdfbGl0LiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtYXR0aW5nLiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+IHN0cmluZyA9XG4gIGZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIkB7XCI7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbik7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPiBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZvcm0gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgaWYgZmNvbnYgPSBGbG9hdF9GIHRoZW4gXCIlLjEyZ1wiIGVsc2VcbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPSBmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG5cbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPSBmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG5cbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID0gZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgblxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9IGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgblxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT5cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X3BoIHwgRmxvYXRfcEggLT4gJysnXG4gICAgICB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgbGV0IHN0ciA9IGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICAgIGJlZ2luIG1hdGNoIGZjb252IHdpdGhcbiAgICB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgc3RyXG4gICAgfCBfIC0+IHN0clxuICAgIGVuZFxuICB8IF8gLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGlmIGZjb252IDw+IEZsb2F0X0YgdGhlbiBzdHIgZWxzZVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+XG4gICAgICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIlxuICAgICAgfCBGUF9pbmZpbml0ZSAtPlxuICAgICAgICBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgICAgfCBGUF9uYW4gLT4gXCJuYW5cIlxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayBvIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIG8gYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgbyBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga29jIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayBrb2MgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBvIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGtvYyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsga29jIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgbyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIG8gYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIG8gKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBvIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgbyBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIG8gYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgbyBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYuXG4gIChiIC0+IGYpIC0+IGIgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIHggXyAtPiBrIHgpIG8gKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmLlxuICAoYiAtPiBmKSAtPiBiIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGIgLT4gZikgLT4gYiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayAoKSBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrICgpIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9IGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb25zIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgYW5kIGNoZWNrX29wZW5fYm94IDogdHlwZSBhIGIgYyBkIGUgZiAuIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gdW5pdCA9XG4gIGZ1biBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIEVuZF9vZl9mb3JtYXQpIC0+IChcbiAgICAgIHRyeSBpZ25vcmUgKG9wZW5fYm94X29mX3N0cmluZyBzdHIpIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICgoKiBFbWl0IHdhcm5pbmc6IGludmFsaWQgb3BlbiBib3ggKikpXG4gICAgKVxuICAgIHwgXyAtPiAoKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9IGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIChcbiAgICAgICAgICBjaGVja19vcGVuX2JveCBzdWJfZm10O1xuICAgICAgICAgIE9wZW5fYm94IHN1Yl9mb3JtYXQpIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIHNwYWNlIHN5bWIgPVxuICBtYXRjaCBwbHVzLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsICdmJyAtPiBGbG9hdF9mICB8IGZhbHNlLCBmYWxzZSwgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ2YnIC0+IEZsb2F0X3NmIHwgZmFsc2UsICB0cnVlLCAnZScgLT4gRmxvYXRfc2VcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ2YnIC0+IEZsb2F0X3BmIHwgIHRydWUsIGZhbHNlLCAnZScgLT4gRmxvYXRfcGVcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0UnIC0+IEZsb2F0X0UgIHwgZmFsc2UsIGZhbHNlLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRScgLT4gRmxvYXRfc0UgfCBmYWxzZSwgIHRydWUsICdnJyAtPiBGbG9hdF9zZ1xuICAgIHwgIHRydWUsIGZhbHNlLCAnRScgLT4gRmxvYXRfcEUgfCAgdHJ1ZSwgZmFsc2UsICdnJyAtPiBGbG9hdF9wZ1xuICAgIHwgZmFsc2UsIGZhbHNlLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRycgLT4gRmxvYXRfc0dcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0cnIC0+IEZsb2F0X3BHXG4gICAgfCBmYWxzZSwgZmFsc2UsICdoJyAtPiBGbG9hdF9oXG4gICAgfCBmYWxzZSwgIHRydWUsICdoJyAtPiBGbG9hdF9zaFxuICAgIHwgIHRydWUsIGZhbHNlLCAnaCcgLT4gRmxvYXRfcGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0gnIC0+IEZsb2F0X3NIXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdIJyAtPiBGbG9hdF9wSFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgIHRydWUsICB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8ICB0cnVlLCBmYWxzZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludGVycyA9IHJlZiBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB0b19zdHJpbmcgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggdHJ5IGhkIHggd2l0aCBfIC0+IE5vbmUgd2l0aFxuICAgICAgICB8IFNvbWUgcyAtPiBzXG4gICAgICAgIHwgTm9uZSAtPiBjb252IHRsKVxuICAgIHwgW10gLT5cbiAgICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICAgIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICAgICAgICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICAgICAgICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgICAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpIGluXG4gIGNvbnYgIXByaW50ZXJzXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2UgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuZW5kXG5cbmV4dGVybmFsIHJhd19iYWNrdHJhY2VfbGVuZ3RoIDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgcHJpbnRlcnMgOj0gZm4gOjogIXByaW50ZXJzXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBOb25lXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBTb21lIGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayBPYmouYWJzdHJhY3RfdGFnIDApXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtieXRlcnVuL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBQZXJ2YXNpdmVzLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICBtYXRjaCAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgZmx1c2ggc3RkZXJyXG4gICAgfCBTb21lIGhhbmRsZXIgLT5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgaGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgICAgICB3aXRoIGV4bicgLT5cbiAgICAgICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbYnl0ZXJ1bi9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgVW5peCA9IHN0cnVjdFxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSA9IHN1ZmZcbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubGV0IChjdXJyZW50X2Rpcl9uYW1lLCBwYXJlbnRfZGlyX25hbWUsIGRpcl9zZXAsIGlzX2Rpcl9zZXAsXG4gICAgIGlzX3JlbGF0aXZlLCBpc19pbXBsaWNpdCwgY2hlY2tfc3VmZml4LCB0ZW1wX2Rpcl9uYW1lLCBxdW90ZSwgYmFzZW5hbWUsXG4gICAgIGRpcm5hbWUpID1cbiAgbWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICB8IFwiV2luMzJcIiAtPlxuICAgICAgKFdpbjMyLmN1cnJlbnRfZGlyX25hbWUsIFdpbjMyLnBhcmVudF9kaXJfbmFtZSwgV2luMzIuZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19kaXJfc2VwLFxuICAgICAgIFdpbjMyLmlzX3JlbGF0aXZlLCBXaW4zMi5pc19pbXBsaWNpdCwgV2luMzIuY2hlY2tfc3VmZml4LFxuICAgICAgIFdpbjMyLnRlbXBfZGlyX25hbWUsIFdpbjMyLnF1b3RlLCBXaW4zMi5iYXNlbmFtZSwgV2luMzIuZGlybmFtZSlcbiAgfCBcIkN5Z3dpblwiIC0+XG4gICAgICAoQ3lnd2luLmN1cnJlbnRfZGlyX25hbWUsIEN5Z3dpbi5wYXJlbnRfZGlyX25hbWUsIEN5Z3dpbi5kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19yZWxhdGl2ZSwgQ3lnd2luLmlzX2ltcGxpY2l0LCBDeWd3aW4uY2hlY2tfc3VmZml4LFxuICAgICAgIEN5Z3dpbi50ZW1wX2Rpcl9uYW1lLCBDeWd3aW4ucXVvdGUsIEN5Z3dpbi5iYXNlbmFtZSwgQ3lnd2luLmRpcm5hbWUpXG4gIHwgXyAtPiAoKiBub3JtYWxseSBcIlVuaXhcIiAqKVxuICAgICAgKFVuaXguY3VycmVudF9kaXJfbmFtZSwgVW5peC5wYXJlbnRfZGlyX25hbWUsIFVuaXguZGlyX3NlcCxcbiAgICAgICBVbml4LmlzX2Rpcl9zZXAsXG4gICAgICAgVW5peC5pc19yZWxhdGl2ZSwgVW5peC5pc19pbXBsaWNpdCwgVW5peC5jaGVja19zdWZmaXgsXG4gICAgICAgVW5peC50ZW1wX2Rpcl9uYW1lLCBVbml4LnF1b3RlLCBVbml4LmJhc2VuYW1lLCBVbml4LmRpcm5hbWUpXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2NvbnYgPVxuICB8IEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGICAgICAgICAgICAgICAqKVxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggICgqICAlSCB8ICUrSCB8ICUgSCAgKilcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFBlcnZhc2l2ZXMgPSBzdHJ1Y3RcbigqIHR5cGUgJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2EgKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBhc21ydW4vZmFpbC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gcmVmIGZsdXNoX2FsbFxuXG5sZXQgYXRfZXhpdCBmID1cbiAgbGV0IGcgPSAhZXhpdF9mdW5jdGlvbiBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfYWxyZWFkeV9yYW4gPSByZWYgZmFsc2UgaW5cbiAgZXhpdF9mdW5jdGlvbiA6PVxuICAgIChmdW4gKCkgLT4gXG4gICAgICBpZiBub3QgIWZfYWxyZWFkeV9yYW4gdGhlbiBiZWdpbiBmX2FscmVhZHlfcmFuIDo9IHRydWU7IGYoKSBlbmQ7XG4gICAgICBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuZW5kXG5cbmluY2x1ZGUgUGVydmFzaXZlc1xuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbnQzMiAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICA9IEludDY0XG5tb2R1bGUgTGF6eSAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICA9IExpc3Rcbm1vZHVsZSBMaXN0TGFiZWxzICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgID0gTWFyc2hhbFxubW9kdWxlIE1vcmVMYWJlbHMgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBOYXRpdmVpbnQgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgPSBPb1xubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQcmludGV4YyAgICAgPSBQcmludGV4Y1xubW9kdWxlIFByaW50ZiAgICAgICA9IFByaW50ZlxubW9kdWxlIFF1ZXVlICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgID0gUmFuZG9tXG5tb2R1bGUgU2NhbmYgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZXEgICAgICAgICAgPSBTZXFcbm1vZHVsZSBTZXQgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTb3J0ICAgICAgICAgPSBTb3J0XG5tb2R1bGUgU3BhY2V0aW1lICAgID0gU3BhY2V0aW1lXG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFdlYWsgICAgICAgICA9IFdlYWtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93biB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQncyBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCByZWMgY2hvcCBrIGwgPVxuICBpZiBrID0gMCB0aGVuIGwgZWxzZSBiZWdpblxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgXzo6dCAtPiBjaG9wIChrLTEpIHRcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGVuZFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlX3JldiBzMSBzMiBbXVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSBzb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlIHMxIHMyIFtdXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIHNvcnQgbGVuIGxcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezYgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbigqIHRoaXMgaXMgW2FwcGVuZCBzZXEgKGZsYXRfbWFwIGYgdGFpbCldICopXG5hbmQgZmxhdF9tYXBfYXBwIGYgc2VxIHRhaWwgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIENvbnMgKHgsIGZsYXRfbWFwX2FwcCBmIG5leHQgdGFpbClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB8fCAoYyA+PSAnXFwxOTInICYmIGMgPD0gJ1xcMjE0JylcbiAgfHwgKGMgPj0gJ1xcMjE2JyAmJiBjIDw9ICdcXDIyMicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2UgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgfHwgKGMgPj0gJ1xcMjI0JyAmJiBjIDw9ICdcXDI0NicpXG4gIHx8IChjID49ICdcXDI0OCcgJiYgYyA8PSAnXFwyNTQnKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBtaW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiIGVsc2VcbiAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gbWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPiBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCIgZWxzZVxuICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIlxuXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXJnaW5nIGFuZCBzb3J0aW5nICopXG5cbm9wZW4gQXJyYXlcblxubGV0IHJlYyBtZXJnZSBvcmRlciBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGgxIDo6IHQxIC0+XG4gICAgICBtYXRjaCBsMiB3aXRoXG4gICAgICAgIFtdIC0+IGwxXG4gICAgICB8IGgyIDo6IHQyIC0+XG4gICAgICAgICAgaWYgb3JkZXIgaDEgaDJcbiAgICAgICAgICB0aGVuIGgxIDo6IG1lcmdlIG9yZGVyIHQxIGwyXG4gICAgICAgICAgZWxzZSBoMiA6OiBtZXJnZSBvcmRlciBsMSB0MlxuXG5sZXQgbGlzdCBvcmRlciBsID1cbiAgbGV0IHJlYyBpbml0bGlzdCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2VdIC0+IFtbZV1dXG4gICAgfCBlMTo6ZTI6OnJlc3QgLT5cbiAgICAgICAgKGlmIG9yZGVyIGUxIGUyIHRoZW4gW2UxO2UyXSBlbHNlIFtlMjtlMV0pIDo6IGluaXRsaXN0IHJlc3QgaW5cbiAgbGV0IHJlYyBtZXJnZTIgPSBmdW5jdGlvblxuICAgICAgbDE6OmwyOjpyZXN0IC0+IG1lcmdlIG9yZGVyIGwxIGwyIDo6IG1lcmdlMiByZXN0XG4gICAgfCB4IC0+IHggaW5cbiAgbGV0IHJlYyBtZXJnZWFsbCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2xdIC0+IGxcbiAgICB8IGxsaXN0IC0+IG1lcmdlYWxsIChtZXJnZTIgbGxpc3QpIGluXG4gIG1lcmdlYWxsKGluaXRsaXN0IGwpXG5cbmxldCBzd2FwIGFyciBpIGogPVxuICBsZXQgdG1wID0gdW5zYWZlX2dldCBhcnIgaSBpblxuICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciBqKTtcbiAgdW5zYWZlX3NldCBhcnIgaiB0bXBcblxuKCogVGhlcmUgaXMgYSBrbm93biBwZXJmb3JtYW5jZSBidWcgaW4gdGhlIGNvZGUgYmVsb3cuICBJZiB5b3UgZmluZFxuICAgaXQsIGRvbid0IGJvdGhlciByZXBvcnRpbmcgaXQuICBZb3UncmUgbm90IHN1cHBvc2VkIHRvIHVzZSB0aGlzXG4gICBtb2R1bGUgYW55d2F5LiAqKVxubGV0IGFycmF5IGNtcCBhcnIgPVxuICBsZXQgcmVjIHFzb3J0IGxvIGhpID1cbiAgICBpZiBoaSAtIGxvID49IDYgdGhlbiBiZWdpblxuICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSBsc3IgMSBpblxuICAgICAgKCogU2VsZWN0IG1lZGlhbiB2YWx1ZSBmcm9tIGFtb25nIExPLCBNSUQsIGFuZCBISS4gUmVhcnJhbmdlXG4gICAgICAgICBMTyBhbmQgSEkgc28gdGhlIHRocmVlIHZhbHVlcyBhcmUgc29ydGVkLiBUaGlzIGxvd2VycyB0aGVcbiAgICAgICAgIHByb2JhYmlsaXR5IG9mIHBpY2tpbmcgYSBwYXRob2xvZ2ljYWwgcGl2b3QuICBJdCBhbHNvXG4gICAgICAgICBhdm9pZHMgZXh0cmEgY29tcGFyaXNvbnMgb24gaSBhbmQgaiBpbiB0aGUgdHdvIHRpZ2h0IFwid2hpbGVcIlxuICAgICAgICAgbG9vcHMgYmVsb3cuICopXG4gICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsbztcbiAgICAgIGlmIGNtcCAodW5zYWZlX2dldCBhcnIgaGkpICh1bnNhZmVfZ2V0IGFyciBtaWQpIHRoZW4gYmVnaW5cbiAgICAgICAgc3dhcCBhcnIgbWlkIGhpO1xuICAgICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsb1xuICAgICAgZW5kO1xuICAgICAgbGV0IHBpdm90ID0gdW5zYWZlX2dldCBhcnIgbWlkIGluXG4gICAgICBsZXQgaSA9IHJlZiAobG8gKyAxKSBhbmQgaiA9IHJlZiAoaGkgLSAxKSBpblxuICAgICAgaWYgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyIGhpKSlcbiAgICAgICAgIHx8IG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciBsbykgcGl2b3QpXG4gICAgICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiU29ydC5hcnJheVwiKTtcbiAgICAgIHdoaWxlICFpIDwgIWogZG9cbiAgICAgICAgd2hpbGUgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyICFpKSkgZG8gaW5jciBpIGRvbmU7XG4gICAgICAgIHdoaWxlIG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciAhaikgcGl2b3QpIGRvIGRlY3IgaiBkb25lO1xuICAgICAgICBpZiAhaSA8ICFqIHRoZW4gc3dhcCBhcnIgIWkgIWo7XG4gICAgICAgIGluY3IgaTsgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgKCogUmVjdXJzaW9uIG9uIHNtYWxsZXIgaGFsZiwgdGFpbC1jYWxsIG9uIGxhcmdlciBoYWxmICopXG4gICAgICBpZiAhaiAtIGxvIDw9IGhpIC0gIWkgdGhlbiBiZWdpblxuICAgICAgICBxc29ydCBsbyAhajsgcXNvcnQgIWkgaGlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHFzb3J0ICFpIGhpOyBxc29ydCBsbyAhalxuICAgICAgZW5kXG4gICAgZW5kIGluXG4gIHFzb3J0IDAgKEFycmF5Lmxlbmd0aCBhcnIgLSAxKTtcbiAgKCogRmluaXNoIHNvcnRpbmcgYnkgaW5zZXJ0aW9uIHNvcnQgKilcbiAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnIgLSAxIGRvXG4gICAgbGV0IHZhbF9pID0gKHVuc2FmZV9nZXQgYXJyIGkpIGluXG4gICAgaWYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyIChpIC0gMSkpIHZhbF9pKSB0aGVuIGJlZ2luXG4gICAgICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciAoaSAtIDEpKTtcbiAgICAgIGxldCBqID0gcmVmIChpIC0gMSkgaW5cbiAgICAgIHdoaWxlICFqID49IDEgJiYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKSB2YWxfaSkgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgIWogKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKTtcbiAgICAgICAgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgdW5zYWZlX3NldCBhcnIgIWogdmFsX2lcbiAgICBlbmRcbiAgZG9uZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG4oKiBub3RlOiB0aGlzIHR5cGUgZGVmaW5pdGlvbiBpcyB1c2VkIGluICdieXRlcnVuL2RlYnVnZ2VyLmMnICopXG5cbmV4dGVybmFsIHRvX2NoYW5uZWw6IG91dF9jaGFubmVsIC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxuZXh0ZXJuYWwgdG9fYnl0ZXM6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGJ5dGVzXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzXCJcbmV4dGVybmFsIHRvX3N0cmluZzogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gc3RyaW5nXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19idWZmZXJfdW5zYWZlOlxuICAgICAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXCJcblxubGV0IHRvX2J1ZmZlciBidWZmIG9mcyBsZW4gdiBmbGFncyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC50b19idWZmZXI6IHN1YnN0cmluZyBvdXQgb2YgYm91bmRzXCJcbiAgZWxzZSB0b19idWZmZXJfdW5zYWZlIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzXG5cbigqIFRoZSBmdW5jdGlvbnMgYmVsb3cgdXNlIGJ5dGUgc2VxdWVuY2VzIGFzIGlucHV0LCBuZXZlciB1c2luZyBhbnlcbiAgIG11dGF0aW9uLiBJdCBtYWtlcyBzZW5zZSB0byB1c2Ugbm9uLW11dGF0ZWQgW2J5dGVzXSByYXRoZXIgdGhhblxuICAgW3N0cmluZ10sIGJlY2F1c2Ugd2UgcmVhbGx5IHdvcmsgd2l0aCBzZXF1ZW5jZXMgb2YgYnl0ZXMsIG5vdFxuICAgYSB0ZXh0IHJlcHJlc2VudGF0aW9uLlxuKilcblxuZXh0ZXJuYWwgZnJvbV9jaGFubmVsOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIGZyb21fYnl0ZXNfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlc1wiXG5leHRlcm5hbCBkYXRhX3NpemVfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX21hcnNoYWxfZGF0YV9zaXplXCJcblxubGV0IGhlYWRlcl9zaXplID0gMjBcbmxldCBkYXRhX3NpemUgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZGF0YV9zaXplXCJcbiAgZWxzZSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzXG5sZXQgdG90YWxfc2l6ZSBidWZmIG9mcyA9IGhlYWRlcl9zaXplICsgZGF0YV9zaXplIGJ1ZmYgb2ZzXG5cbmxldCBmcm9tX2J5dGVzIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGxlbiA9IGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnMgaW5cbiAgICBpZiBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIChoZWFkZXJfc2l6ZSArIGxlbilcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgICBlbHNlIGZyb21fYnl0ZXNfdW5zYWZlIGJ1ZmYgb2ZzXG4gIGVuZFxuXG5sZXQgZnJvbV9zdHJpbmcgYnVmZiBvZnMgPVxuICAoKiBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGlzIHNhZmUgaGVyZSwgYXMgdGhlIHByb2R1Y2VkIGJ5dGVcbiAgICAgc2VxdWVuY2UgaXMgbmV2ZXIgbXV0YXRlZCAqKVxuICBmcm9tX2J5dGVzIChCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZmYpIG9mc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuXG5sZXQgbWFyc2hhbCAob2JqIDogdCkgPVxuICBNYXJzaGFsLnRvX2J5dGVzIG9iaiBbXVxubGV0IHVubWFyc2hhbCBzdHIgcG9zID1cbiAgKE1hcnNoYWwuZnJvbV9ieXRlcyBzdHIgcG9zLCBwb3MgKyBNYXJzaGFsLnRvdGFsX3NpemUgc3RyIHBvcylcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB4ID1cbiAgbGV0IHggPSByZXByIHggaW5cbiAgbGV0IHNsb3QgPVxuICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgIGVsc2UgeFxuICBpblxuICBsZXQgbmFtZSA9XG4gICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICBpblxuICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogZXh0ZW5zaW9uX2NvbnN0cnVjdG9yKVxuICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxubGV0IFtAaW5saW5lIGFsd2F5c10gZXh0ZW5zaW9uX25hbWUgKHNsb3QgOiBleHRlbnNpb25fY29uc3RydWN0b3IpID1cbiAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGV4dGVuc2lvbl9pZCAoc2xvdCA6IGV4dGVuc2lvbl9jb25zdHJ1Y3RvcikgPVxuICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gMlxuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxubGV0IGluZmluaXR5ID0gUGVydmFzaXZlcy5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFBlcnZhc2l2ZXMubmVnX2luZmluaXR5XG5sZXQgbmFuID0gUGVydmFzaXZlcy5uYW5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gUGVydmFzaXZlcy5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBQZXJ2YXNpdmVzLm1pbl9mbG9hdFxubGV0IGVwc2lsb24gPSBQZXJ2YXNpdmVzLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gUGVydmFzaXZlcy5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gUGVydmFzaXZlcy5zdHJpbmdfb2ZfZmxvYXRcbnR5cGUgZnBjbGFzcyA9IFBlcnZhc2l2ZXMuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0xKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBlbHQgLT4gdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSArJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezYgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxubGV0IHJhaXNlX3VuZGVmaW5lZCA9IE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgVW5kZWZpbmVkKVxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgICgqIGRvIHNldF9maWVsZCBCRUZPUkUgc2V0X3RhZyAqKVxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSBPYmouZm9yd2FyZF90YWc7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAoKiBkbyBzZXRfZmllbGQgQkVGT1JFIHNldF90YWcgKilcbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciByZXN1bHQpO1xuICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSAoT2JqLmZvcndhcmRfdGFnKTtcbiAgcmVzdWx0XG5cblxuKCogW2ZvcmNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlXG4gICB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHMgYXJndW1lbnQuICBUaGlzIGZ1bmN0aW9uIGlzXG4gICBoZXJlIGZvciB0aGUgc2FrZSBvZiBjb21wbGV0ZW5lc3MsIGFuZCBmb3IgZGVidWdnaW5nIHB1cnBvc2UuICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxuKCogbGV0IGZvcmNlID0gZm9yY2UgKilcblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IGxhenlfZnJvbV9mdW4gPSBmcm9tX2Z1blxuXG5sZXQgbGF6eV9mcm9tX3ZhbCA9IGZyb21fdmFsXG5cbmxldCBsYXp5X2lzX3ZhbCA9IGlzX3ZhbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPlxuICAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgIGlmIGIubGVuID09IDAgdGhlbiBzLmRhdGEgPC0gU2VtcHR5XG4gICAgICBlbHNlIChzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kKVxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7IGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBsZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBsZW4gaW5cbiAgd2hpbGUgYi5wb3NpdGlvbiArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgYi5wb3NpdGlvbiArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlblxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbiBsZXQgYWRkX3V0Zl84X3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICBhZGRfY2hhciBiIChDaGFyLnVuc2FmZV9jaHIgdSlcbiB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4QzAgbG9yICh1IGxzciA2KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMyA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMztcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEUwIGxvciAodSBsc3IgMTIpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDNcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhGMCBsb3IgKHUgbHNyIDE4KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMylcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy5ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHJlYWQgdXAgdG8gW2xlbl0gYnl0ZXMgZnJvbSBbaWNdIGludG8gW2JdLiAqKVxubGV0IHJlYyBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW4gPVxuICBpZiBsZW4gPiAwIHRoZW4gKFxuICAgIGxldCBuID0gaW5wdXQgaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICAgIGlmIG4gPSAwIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIGFkZF9jaGFubmVsX3JlYyBiIGljIChsZW4tbikgICAoKiBuIDw9IGxlbiAqKVxuICApXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW5cblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLmdldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMuZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gbyBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBvIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBiIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIGIgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnICgpIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgKCkgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCIgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPSBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPSBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSkgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBzdHJpbmdfb2ZfaW50IHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gUGVydmFzaXZlcy5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFBlcnZhc2l2ZXMuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKSAqLiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gUGVydmFzaXZlcy5mbG9hdCByXG4gIGFuZCBuID0gUGVydmFzaXZlcy5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG9sZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaF91bml2X3BhcmFtXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGguc2l6ZSA8LSAwO1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgZG9uZVxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4gaCBrZXkgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBpbnBsYWNlIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgICAgZG9uZTtcbiAgZW5kXG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSAzXG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSAob2xkX2hhc2hfcGFyYW0gMTAgMTAwIGtleSkgbW9kIChBcnJheS5sZW5ndGggaC5kYXRhKVxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICAgIGxldCBhZGRfc2VxID0gYWRkX3NlcVxuICAgIGxldCByZXBsYWNlX3NlcSA9IHJlcGxhY2Vfc2VxXG4gICAgbGV0IG9mX3NlcSA9IG9mX3NlcVxuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbigqKiBudW1iZXIgb2YgYWRkaXRpb25hbCB2YWx1ZXMgaW4gYSB3ZWFrIHBvaW50ZXIgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5leHRlcm5hbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gLT4gdW5pdCA9IFwiY2FtbF93ZWFrX3NldFwiXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhclxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gbWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgYnVja2V0KSAocHJldl9sZW4gKyBhZGRpdGlvbmFsX3ZhbHVlcyk7XG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgaGJ1Y2tldCkgcHJldl9sZW47XG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBtaW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxudHlwZSBzaXplXG5cbmV4dGVybmFsIHNpemVfb2ZfaW50IDogaW50IC0+IHNpemUgPSBcIiVpZGVudGl0eVwiXG5cbmV4dGVybmFsIGludF9vZl9zaXplIDogc2l6ZSAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgaW50ICogaW50ICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHRhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHRhZyA9IHN0cmluZ1xuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRvIGRlZmluZSB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsIHdlIGZpcnN0IGRlZmluZSBwb2x5bW9ycGhpYyBxdWV1ZXMsXG4gICB0aGVuIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLlxuKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOiBwb2x5bW9ycGhpYyBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSAnYSBxdWV1ZV9lbGVtID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHtcbiAgICAgIGhlYWQgOiAnYTtcbiAgICAgIG11dGFibGUgdGFpbCA6ICdhIHF1ZXVlX2VsZW07XG4gICAgfVxuXG5cbnR5cGUgJ2EgcXVldWUgPSB7XG4gIG11dGFibGUgaW5zZXJ0IDogJ2EgcXVldWVfZWxlbTtcbiAgbXV0YWJsZSBib2R5IDogJ2EgcXVldWVfZWxlbTtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6IHF1ZXVlIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgZWxlbV9zaXplIDogc2l6ZTtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gcXVldWVcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZWxlbWVudCBpcyAobGVmdF90b3RhbCwgcXVldWUgZWxlbWVudCkgd2hlcmUgbGVmdF90b3RhbFxuICAgaXMgdGhlIHZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiBlbnF1ZXVlZC4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0gU2Nhbl9lbGVtIG9mIGludCAqIHBwX3F1ZXVlX2VsZW1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fc3RhY2sgPSBwcF9zY2FuX2VsZW0gbGlzdFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSBGb3JtYXRfZWxlbSBvZiBib3hfdHlwZSAqIGludFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9mb3JtYXRfc3RhY2sgPSBwcF9mb3JtYXRfZWxlbSBsaXN0XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3RhZ19zdGFjayA9IHRhZyBsaXN0XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHZhcmlvdXMgc3RhY2tzLiAqKVxuICBtdXRhYmxlIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX3N0YWNrO1xuICBtdXRhYmxlIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9zdGFjaztcbiAgbXV0YWJsZSBwcF90Ym94X3N0YWNrIDogdGJveCBsaXN0O1xuICBtdXRhYmxlIHBwX3RhZ19zdGFjayA6IHBwX3RhZ19zdGFjaztcbiAgbXV0YWJsZSBwcF9tYXJrX3N0YWNrIDogcHBfdGFnX3N0YWNrO1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIFF1ZXVlcyBhdXhpbGlhcmllcy4gKilcblxubGV0IG1ha2VfcXVldWUgKCkgPSB7IGluc2VydCA9IE5pbDsgYm9keSA9IE5pbDsgfVxuXG5sZXQgY2xlYXJfcXVldWUgcSA9IHEuaW5zZXJ0IDwtIE5pbDsgcS5ib2R5IDwtIE5pbFxuXG5sZXQgYWRkX3F1ZXVlIHggcSA9XG4gIGxldCBjID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gTmlsOyB9IGluXG4gIG1hdGNoIHEgd2l0aFxuICB8IHsgaW5zZXJ0ID0gQ29ucyBjZWxsOyBib2R5ID0gXzsgfSAtPlxuICAgIHEuaW5zZXJ0IDwtIGM7IGNlbGwudGFpbCA8LSBjXG4gICgqIEludmFyaWFudDogd2hlbiBpbnNlcnQgaXMgTmlsIGJvZHkgc2hvdWxkIGJlIE5pbC4gKilcbiAgfCB7IGluc2VydCA9IE5pbDsgYm9keSA9IF87IH0gLT5cbiAgICBxLmluc2VydCA8LSBjOyBxLmJvZHkgPC0gY1xuXG5cbmV4Y2VwdGlvbiBFbXB0eV9xdWV1ZVxuXG5sZXQgcGVla19xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gXzsgfTsgXyB9IC0+IHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG5sZXQgdGFrZV9xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gdGw7IH07IF8gfSBhcyBxIC0+XG4gICAgcS5ib2R5IDwtIHRsO1xuICAgIGlmIHRsID0gTmlsIHRoZW4gcS5pbnNlcnQgPC0gTmlsOyAoKiBNYWludGFpbiB0aGUgaW52YXJpYW50LiAqKVxuICAgIHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlICh7IGxlbmd0aCA9IGxlbjsgX30gYXMgdG9rZW4pID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyBsZW47XG4gIGFkZF9xdWV1ZSB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgY2xlYXJfcXVldWUgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZnNldCB3aWR0aCA9XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBtaW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnRcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIDAgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIHdpZHRoID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgRm9ybWF0X2VsZW0gKGJsX3R5LCB3aWR0aCkgOjogXyAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICAobWF0Y2ggYmxfdHkgd2l0aFxuICAgICAgIHwgUHBfZml0cyAtPiAoKSB8IFBwX2hib3ggLT4gKClcbiAgICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPlxuICAgICAgICAgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aClcbiAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICAoKiBXaGVuIGNhbGxpbmcgcHBfc2tpcF90b2tlbiB0aGUgcXVldWUgY2Fubm90IGJlIGVtcHR5LiAqKVxuICBtYXRjaCB0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCB7IGVsZW1fc2l6ZSA9IHNpemU7IGxlbmd0aCA9IGxlbjsgdG9rZW4gPSBfOyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIGludF9vZl9zaXplIHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcztcbiAgICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCBvZmZzZXQgPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJsX3R5cGUgPVxuICAgICAgYmVnaW4gbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0c1xuICAgICAgZW5kIGluXG4gICAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtXG4gICAgICBGb3JtYXRfZWxlbSAoYmxfdHlwZSwgb2Zmc2V0KSA6OiBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayA8LSBsc1xuICAgIHwgW10gLT4gKCkgKCogTm8gbW9yZSBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gdGJveCA6OiBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gbHNcbiAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFidWxhdGlvbiBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBQcF90Ym94IHRhYnMgOjogXyAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgfCBbXSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IFBwX3Rib3ggdGFicyA6OiBfIC0+XG4gICAgICBsZXQgcmVjIGZpbmQgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgeCA6OiBsIC0+IGlmIHggPj0gbiB0aGVuIHggZWxzZSBmaW5kIG4gbFxuICAgICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZCBpblxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCB4IDo6IF8gLT5cbiAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgdHJ5IGZpbmQgaW5zZXJ0aW9uX3BvaW50ICF0YWJzIHdpdGhcbiAgICAgICAgICAgIHwgTm90X2ZvdW5kIC0+IHhcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGluc2VydGlvbl9wb2ludCBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChvZmZzZXQgKyBuKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAodGFiICsgb2ZmKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IEZvcm1hdF9lbGVtIChfLCB3aWR0aCkgOjogXyAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayAobiwgb2ZmKSAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBGb3JtYXRfZWxlbSAodHksIHdpZHRoKSA6OiBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIG4gZWxzZVxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICBlbmRcbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBzdGF0ZS5wcF9tYXJrX3N0YWNrIDwtIHRhZ19uYW1lIDo6IHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgdGFnX25hbWUgOjogdGFncyAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICAgIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gdGFnc1xuICAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFNpemUgaXMga25vd24gd2hlbiBub3QgbmVnYXRpdmUuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS5cblxuICAgTm90ZTogW2FkdmFuY2VfbG9vcF0gbXVzdCBiZSB0YWlsIHJlY3Vyc2l2ZSB0byBwcmV2ZW50IHN0YWNrIG92ZXJmbG93cy4gKilcbmxldCByZWMgYWR2YW5jZV9sb29wIHN0YXRlID1cbiAgbWF0Y2ggcGVla19xdWV1ZSBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwge2VsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW59IC0+XG4gICAgbGV0IHNpemUgPSBpbnRfb2Zfc2l6ZSBzaXplIGluXG4gICAgaWYgbm90XG4gICAgICAgICAoc2l6ZSA8IDAgJiZcbiAgICAgICAgICAoc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwgc3RhdGUucHBfc3BhY2VfbGVmdCkpXG4gICAgdGhlbiBiZWdpblxuICAgICAgaWdub3JlICh0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlKTtcbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSAoaWYgc2l6ZSA8IDAgdGhlbiBwcF9pbmZpbml0eSBlbHNlIHNpemUpIHRvaztcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIGFkdmFuY2VfbG9vcCBzdGF0ZVxuICAgIGVuZFxuXG5cbmxldCBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICB0cnkgYWR2YW5jZV9sb29wIHN0YXRlIHdpdGhcbiAgfCBFbXB0eV9xdWV1ZSAtPiAoKVxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cbigqIEJ1aWxkaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLiAqKVxubGV0IG1ha2VfcXVldWVfZWxlbSBzaXplIHRvayBsZW4gPVxuICB7IGVsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW47IH1cblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgbGV0IGxlbiA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIChtYWtlX3F1ZXVlX2VsZW0gc2l6ZSAoUHBfdGV4dCBzKSBsZW4pXG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChzaXplX29mX2ludCBsZW4pIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IHNjYW5fc3RhY2tfYm90dG9tID1cbiAgbGV0IHFfZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX3RleHQgXCJcIikgMCBpblxuICBbU2Nhbl9lbGVtICgtMSwgcV9lbGVtKV1cblxuXG4oKiBDbGVhcmluZyB0aGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5sZXQgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSA9IHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gc2Nhbl9zdGFja19ib3R0b21cblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgU2Nhbl9lbGVtXG4gICAgICAobGVmdF90b3QsXG4gICAgICAgKHsgZWxlbV9zaXplID0gc2l6ZTsgdG9rZW4gPSB0b2s7IGxlbmd0aCA9IF87IH0gYXMgcXVldWVfZWxlbSkpIDo6IHQgLT5cbiAgICBsZXQgc2l6ZSA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3QgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW4gY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSBlbHNlXG4gICAgICBiZWdpbiBtYXRjaCB0b2sgd2l0aFxuICAgICAgfCBQcF9icmVhayAoXywgXykgfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLmVsZW1fc2l6ZSA8LSBzaXplX29mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtIHRcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlblxuICAgICAgICBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uZWxlbV9zaXplIDwtIHNpemVfb2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gdFxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZVxuICAgICAgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG4gICAgICBlbmRcbiAgfCBbXSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtXG4gICAgU2Nhbl9lbGVtIChzdGF0ZS5wcF9yaWdodF90b3RhbCwgdG9rKSA6OiBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9iZWdpbiAoaW5kZW50LCBicl90eSkpXG4gICAgICAgIDAgaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlXG4gICAgICAgIHsgZWxlbV9zaXplID0gc2l6ZV9vZl9pbnQgMDsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDA7IH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnX25hbWUgOjogc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHtcbiAgICAgIGVsZW1fc2l6ZSA9IHNpemVfb2ZfaW50IDA7XG4gICAgICB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7XG4gICAgICBlbGVtX3NpemUgPSBzaXplX29mX2ludCAwO1xuICAgICAgdG9rZW4gPSBQcF9jbG9zZV90YWc7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIG1hdGNoIHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCB0YWdfbmFtZSA6OiB0YWdzIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWU7XG4gICAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnc1xuICAgIHwgXyAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgZW5kXG5cblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV90YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl90YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2VfdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZTtcbiAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90Ym94X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgTGlzdC5pdGVyXG4gICAgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSlcbiAgICBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKHNpemVfb2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfaW50IGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSAobWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF9uZXdsaW5lIDApXG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgKG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfaWZfbmV3bGluZSAwKVxuXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9icmVhayAod2lkdGgsIG9mZnNldCkpXG4gICAgICAgIHdpZHRoIGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbigqIFByaW50IGEgc3BhY2UgOlxuICAgYSBzcGFjZSBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgYSBzaW5nbGUgc3BhY2UgaWYgdGhlIGJyZWFrIGRvZXMgbm90XG4gICBzcGxpdCB0aGUgbGluZTtcbiAgIGEgY3V0IGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBub3RoaW5nIGlmIHRoZSBicmVhayBkb2VzIG5vdCBzcGxpdCB0aGVcbiAgIGxpbmUuICopXG5sZXQgcHBfcHJpbnRfc3BhY2Ugc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAxIDBcbmFuZCBwcF9wcmludF9jdXQgc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAwIDBcblxuXG4oKiBUYWJ1bGF0aW9uIGJveGVzLiAqKVxubGV0IHBwX29wZW5fdGJveCBzdGF0ZSAoKSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgKFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSkpIDAgaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfdGVuZCAwIGluXG4gICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtO1xuICAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxXG4gIGVuZFxuXG5cbigqIFByaW50IGEgdGFidWxhdGlvbiBicmVhay4gKilcbmxldCBwcF9wcmludF90YnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF90YnJlYWsgKHdpZHRoLCBvZmZzZXQpKVxuICAgICAgICB3aWR0aCBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfc3RhYiAwIGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gY29udHJvbCB0aGUgcHJldHR5LXByaW50ZXJzXG5cbiopXG5cbigqIFNldF9tYXhfYm94ZXMuICopXG5sZXQgcHBfc2V0X21heF9ib3hlcyBzdGF0ZSBuID0gaWYgbiA+IDEgdGhlbiBzdGF0ZS5wcF9tYXhfYm94ZXMgPC0gblxuXG4oKiBUbyBrbm93IHRoZSBjdXJyZW50IG1heGltdW0gbnVtYmVyIG9mIGJveGVzIGFsbG93ZWQuICopXG5sZXQgcHBfZ2V0X21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG5sZXQgcHBfb3Zlcl9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbigqIEVsbGlwc2lzLiAqKVxubGV0IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0YXRlIHMgPSBzdGF0ZS5wcF9lbGxpcHNpcyA8LSBzXG5hbmQgcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRvIHNldCB0aGUgbWFyZ2luIG9mIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX2xpbWl0IG4gPVxuICBpZiBuIDwgcHBfaW5maW5pdHkgdGhlbiBuIGVsc2UgcHJlZCBwcF9pbmZpbml0eVxuXG5cbigqIEludGVybmFsIHByZXR0eS1wcmludGVyIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWluX3NwYWNlX2xlZnQgPC0gbjtcbiAgICBzdGF0ZS5wcF9tYXhfaW5kZW50IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3Jpbml0IHN0YXRlXG5cblxuKCogSW5pdGlhbGx5LCB3ZSBoYXZlIDpcbiAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdCwgYW5kXG4gICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luLiAqKVxubGV0IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG4gPVxuICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIHMgPSBcIjxcIiBeIHMgXiBcIj5cIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgcyA9IFwiPC9cIiBeIHMgXiBcIj5cIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IG1ha2VfcXVldWUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpKSAwIGluXG4gIGFkZF9xdWV1ZSBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc3lzX3NjYW5fc3RhY2sgPVxuICAgIFNjYW5fZWxlbSAoMSwgc3lzX3RvaykgOjogc2Nhbl9zdGFja19ib3R0b20gaW5cbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc3lzX3NjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gW107XG4gICAgcHBfdGJveF9zdGFjayA9IFtdO1xuICAgIHBwX3RhZ19zdGFjayA9IFtdO1xuICAgIHBwX21hcmtfc3RhY2sgPSBbXTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0sIFtQZXJ2YXNpdmVzLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBQZXJ2YXNpdmVzLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgUGVydmFzaXZlcy5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3RhZyBwcGYgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJylcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl90YWcgcHBmIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIHBwZiBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBwcGYgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IGlmcHJpbnRmIHBwZiA9IGlrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkX2Zvcm1hdHRlciBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgZXJyX2Zvcm1hdHRlciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgKCkgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayAoKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIHBwZiBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIHBwZiBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG4oKiBPdXRwdXQgZXZlcnl0aGluZyBsZWZ0IGluIHRoZSBwcmV0dHkgcHJpbnRlciBxdWV1ZSBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxubGV0ICgpID0gYXRfZXhpdCBwcmludF9mbHVzaFxuXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgayBwcGYgYWNjID0gb3V0cHV0X2FjYyBwcGYgYWNjOyBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2UgaW5cbiAgbWFrZV9wcmludGYgayAoZm9ybWF0dGVyX29mX2J1ZmZlciBiKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbigqIERlcHJlY2F0ZWQgOiBhbGlhcyBmb3Iga3NwcmludGYuICopXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgUGVydmFzaXZlcy5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFBlcnZhc2l2ZXMuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFBlcnZhc2l2ZXMuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtQZXJ2YXNpdmVzLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBQZXJ2YXNpdmVzLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFBlcnZhc2l2ZXMuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFBlcnZhc2l2ZXMgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gUGVydmFzaXZlcy5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFBlcnZhc2l2ZXMuc3RkaW4pKSBQZXJ2YXNpdmVzLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgUGVydmFzaXZlcy5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBQZXJ2YXNpdmVzLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBQZXJ2YXNpdmVzLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFBlcnZhc2l2ZXMuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbUGVydmFzaXZlcy5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtQZXJ2YXNpdmVzLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgUGVydmFzaXZlcy4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoRmxvYXRfRiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2VcbiAgICAgICAgICAgICAgIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZ1xuICAgICAgICAgICAgICAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBzdHJpbmdfdG9fU3RyaW5nIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGxldCBjID0gcy5baV0gaW5cbiAgICBpZiBjID0gJ1xcXCInIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoc3RyaW5nX3RvX1N0cmluZyBzKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHRvX3NlcSB0YmwgPVxuICAgICAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAgICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gICAgICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAgICAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgICAgIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgICAgIHwgQ29ucyAoXywgYywgbmV4dCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGF1eCBpIG5leHQgKClcbiAgICAgICAgICAgICAgfCBTb21lIGtleSwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBhdXggMCBFbXB0eVxuXG4gICAgbGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYXJrIFNoaW53ZWxsIGFuZCBMZW8gV2hpdGUsIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTUtLTIwMTYgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgc3BhY2V0aW1lX2VuYWJsZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3BhY2V0aW1lX2VuYWJsZWRcIiBbQEBub2FsbG9jXVxuXG5sZXQgZW5hYmxlZCA9IHNwYWNldGltZV9lbmFibGVkICgpXG5cbmxldCBpZl9zcGFjZXRpbWVfZW5hYmxlZCBmID1cbiAgaWYgZW5hYmxlZCB0aGVuIGYgKCkgZWxzZSAoKVxuXG5tb2R1bGUgU2VyaWVzID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBjaGFubmVsIDogb3V0X2NoYW5uZWw7XG4gICAgbXV0YWJsZSBjbG9zZWQgOiBib29sO1xuICB9XG5cbiAgZXh0ZXJuYWwgd3JpdGVfbWFnaWNfbnVtYmVyIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3dyaXRlX21hZ2ljX251bWJlclwiXG5cbiAgZXh0ZXJuYWwgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZVwiXG5cbiAgbGV0IGNyZWF0ZSB+cGF0aCA9XG4gICAgaWYgc3BhY2V0aW1lX2VuYWJsZWQgKCkgdGhlbiBiZWdpblxuICAgICAgbGV0IGNoYW5uZWwgPSBvcGVuX291dCBwYXRoIGluXG4gICAgICByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY2hhbm5lbDtcbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBjaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIHdyaXRlX21hZ2ljX251bWJlciB0LmNoYW5uZWw7XG4gICAgICB0XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHsgY2hhbm5lbCA9IHN0ZG91dDsgICgqIGFyYml0cmFyeSB2YWx1ZSAqKVxuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gIGV4dGVybmFsIHNhdmVfZXZlbnQgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudFwiXG5cbiAgbGV0IHNhdmVfZXZlbnQgP3RpbWUgdCB+ZXZlbnRfbmFtZSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgc2F2ZV9ldmVudCA/dGltZSB0LmNoYW5uZWwgfmV2ZW50X25hbWUpXG5cbiAgZXh0ZXJuYWwgc2F2ZV90cmllIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfdHJpZVwiXG5cbiAgbGV0IHNhdmVfYW5kX2Nsb3NlID90aW1lIHQgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIHQuY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBzYXZlX3RyaWUgP3RpbWUgdC5jaGFubmVsO1xuICAgICAgY2xvc2Vfb3V0IHQuY2hhbm5lbDtcbiAgICAgIHQuY2xvc2VkIDwtIHRydWUpXG5lbmRcblxubW9kdWxlIFNuYXBzaG90ID0gc3RydWN0XG4gIGV4dGVybmFsIHRha2UgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfdGFrZV9zbmFwc2hvdFwiXG5cbiAgbGV0IHRha2UgP3RpbWUgeyBTZXJpZXMuY2xvc2VkOyBjaGFubmVsIH0gPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIGNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgR2MubWlub3IgKCk7XG4gICAgICB0YWtlID90aW1lIGNoYW5uZWwpXG5lbmRcblxuZXh0ZXJuYWwgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyA6IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHNcIlxuXG5sZXQgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSA9XG4gIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDMyX2VsdCA9IEZsb2F0MzJfZWx0XG50eXBlIGZsb2F0NjRfZWx0ID0gRmxvYXQ2NF9lbHRcbnR5cGUgaW50OF9zaWduZWRfZWx0ID0gSW50OF9zaWduZWRfZWx0XG50eXBlIGludDhfdW5zaWduZWRfZWx0ID0gSW50OF91bnNpZ25lZF9lbHRcbnR5cGUgaW50MTZfc2lnbmVkX2VsdCA9IEludDE2X3NpZ25lZF9lbHRcbnR5cGUgaW50MTZfdW5zaWduZWRfZWx0ID0gSW50MTZfdW5zaWduZWRfZWx0XG50eXBlIGludDMyX2VsdCA9IEludDMyX2VsdFxudHlwZSBpbnQ2NF9lbHQgPSBJbnQ2NF9lbHRcbnR5cGUgaW50X2VsdCA9IEludF9lbHRcbnR5cGUgbmF0aXZlaW50X2VsdCA9IE5hdGl2ZWludF9lbHRcbnR5cGUgY29tcGxleDMyX2VsdCA9IENvbXBsZXgzMl9lbHRcbnR5cGUgY29tcGxleDY0X2VsdCA9IENvbXBsZXg2NF9lbHRcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgICBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG5cbnR5cGUgY19sYXlvdXQgPSBDX2xheW91dF90eXBcbnR5cGUgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dF90eXAgKCoqKVxuXG50eXBlICdhIGxheW91dCA9XG4gICAgQ19sYXlvdXQ6IGNfbGF5b3V0IGxheW91dFxuICB8IEZvcnRyYW5fbGF5b3V0OiBmb3J0cmFuX2xheW91dCBsYXlvdXRcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGZsb2F0MzIgPSBGbG9hdDMyXG5sZXQgZmxvYXQ2NCA9IEZsb2F0NjRcbmxldCBpbnQ4X3NpZ25lZCA9IEludDhfc2lnbmVkXG5sZXQgaW50OF91bnNpZ25lZCA9IEludDhfdW5zaWduZWRcbmxldCBpbnQxNl9zaWduZWQgPSBJbnQxNl9zaWduZWRcbmxldCBpbnQxNl91bnNpZ25lZCA9IEludDE2X3Vuc2lnbmVkXG5sZXQgaW50MzIgPSBJbnQzMlxubGV0IGludDY0ID0gSW50NjRcbmxldCBpbnQgPSBJbnRcbmxldCBuYXRpdmVpbnQgPSBOYXRpdmVpbnRcbmxldCBjb21wbGV4MzIgPSBDb21wbGV4MzJcbmxldCBjb21wbGV4NjQgPSBDb21wbGV4NjRcbmxldCBjaGFyID0gQ2hhclxuXG5sZXQga2luZF9zaXplX2luX2J5dGVzIDogdHlwZSBhIGIuIChhLCBiKSBraW5kIC0+IGludCA9IGZ1bmN0aW9uXG4gIHwgRmxvYXQzMiAtPiA0XG4gIHwgRmxvYXQ2NCAtPiA4XG4gIHwgSW50OF9zaWduZWQgLT4gMVxuICB8IEludDhfdW5zaWduZWQgLT4gMVxuICB8IEludDE2X3NpZ25lZCAtPiAyXG4gIHwgSW50MTZfdW5zaWduZWQgLT4gMlxuICB8IEludDMyIC0+IDRcbiAgfCBJbnQ2NCAtPiA4XG4gIHwgSW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgTmF0aXZlaW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgQ29tcGxleDMyIC0+IDhcbiAgfCBDb21wbGV4NjQgLT4gMTZcbiAgfCBDaGFyIC0+IDFcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2xheW91dCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgY19sYXlvdXQgPSBDX2xheW91dFxubGV0IGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIEdlbmFycmF5ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgZXh0ZXJuYWwgY3JlYXRlOiAoJ2EsICdiKSBraW5kIC0+ICdjIGxheW91dCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgPSBcImNhbWxfYmFfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2FcbiAgICAgPSBcImNhbWxfYmFfZ2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYSAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX3NldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBvY2FtbC12ZG9tIHBhY2thZ2UsIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiBhbiBNSVQtbGlrZSBsaWNlbnNlLiAgICAgKilcbigqIFNlZSB0aGUgYXR0YWNoZWQgTElDRU5TRSBmaWxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqIENvcHlyaWdodCAyMDE2IGJ5IExleGlGaS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcblxuXG5tb2R1bGUgQ21kID0gc3RydWN0XG4gIHR5cGUgJ21zZyB0ID0gLi5cblxuICB0eXBlICdtc2cgdCArPVxuICAgIHwgRWNobyBvZiAnbXNnXG4gICAgfCBCYXRjaCBvZiAnbXNnIHQgbGlzdFxuICAgIHwgTWFwOiAoJ2EgLT4gJ21zZykgKiAnYSB0IC0+ICdtc2cgdFxuXG4gIGxldCBlY2hvIG1zZyA9IEVjaG8gbXNnXG4gIGxldCBiYXRjaCBsID0gQmF0Y2ggbFxuICBsZXQgbWFwIGYgeCA9IE1hcCAoZiwgeClcbmVuZFxuXG5tb2R1bGUgQ3VzdG9tID0gc3RydWN0XG4gIHR5cGUgdCA9IC4uXG5lbmRcblxudHlwZSBtb3VzZV9ldmVudCA9IHt4OiBpbnQ7IHk6IGludDsgcGFnZV94OiBmbG9hdDsgcGFnZV95OiBmbG9hdDsgYnV0dG9uczogaW50OyBhbHRfa2V5OiBib29sOyBjdHJsX2tleTogYm9vbDsgc2hpZnRfa2V5OiBib29sfVxuXG50eXBlIGtleV9ldmVudCA9IHt3aGljaDogaW50OyBhbHRfa2V5OiBib29sOyBjdHJsX2tleTogYm9vbDsgc2hpZnRfa2V5OiBib29sfVxuXG50eXBlICdtc2cgZXZlbnRfaGFuZGxlciA9XG4gIHwgQ2xpY2sgb2YgKG1vdXNlX2V2ZW50IC0+ICdtc2cpXG4gIHwgRGJsQ2xpY2sgb2YgKG1vdXNlX2V2ZW50IC0+ICdtc2cpXG4gIHwgRm9jdXMgb2YgJ21zZ1xuICB8IEJsdXIgb2YgJ21zZ1xuICB8IElucHV0IG9mIChzdHJpbmcgLT4gJ21zZylcbiAgfCBDaGFuZ2Ugb2YgKHN0cmluZyAtPiAnbXNnKVxuICB8IENoYW5nZUluZGV4IG9mIChpbnQgLT4gJ21zZylcbiAgfCBDaGFuZ2VDaGVja2VkIG9mIChib29sIC0+ICdtc2cpXG4gIHwgTW91c2VNb3ZlIG9mIChtb3VzZV9ldmVudCAtPiAnbXNnKVxuICB8IEtleURvd24gb2YgKGtleV9ldmVudCAtPiAnbXNnKVxuICB8IENvbnRleHRNZW51IG9mIChtb3VzZV9ldmVudCAtPiAnbXNnKVxuXG50eXBlIHByb3BfdmFsID1cbiAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgQm9vbCBvZiBib29sXG5cbnR5cGUgJ21zZyBhdHRyaWJ1dGUgPVxuICB8IFByb3BlcnR5IG9mIHN0cmluZyAqIHByb3BfdmFsXG4gIHwgU3R5bGUgb2Ygc3RyaW5nICogc3RyaW5nXG4gIHwgSGFuZGxlciBvZiAnbXNnIGV2ZW50X2hhbmRsZXJcbiAgfCBBdHRyaWJ1dGUgb2Ygc3RyaW5nICogc3RyaW5nXG5cbmxldCBvbmNsaWNrIG1zZyA9IEhhbmRsZXIgKENsaWNrIG1zZylcbmxldCBvbmRibGNsaWNrIG1zZyA9IEhhbmRsZXIgKERibENsaWNrIG1zZylcbmxldCBvbmNvbnRleHRtZW51IG1zZyA9IEhhbmRsZXIgKENvbnRleHRNZW51IG1zZylcbmxldCBvbmZvY3VzIG1zZyA9IEhhbmRsZXIgKEZvY3VzIG1zZylcbmxldCBvbmlucHV0IG1zZyA9IEhhbmRsZXIgKElucHV0IG1zZylcbmxldCBvbmNoYW5nZSBtc2cgPSBIYW5kbGVyIChDaGFuZ2UgbXNnKVxubGV0IG9uY2hhbmdlX2luZGV4IG1zZyA9IEhhbmRsZXIgKENoYW5nZUluZGV4IG1zZylcbmxldCBvbmNoYW5nZV9jaGVja2VkIG1zZyA9IEhhbmRsZXIgKENoYW5nZUNoZWNrZWQgbXNnKVxubGV0IG9uYmx1ciBtc2cgPSBIYW5kbGVyIChCbHVyIG1zZylcbmxldCBvbm1vdXNlbW92ZSBtc2cgPSBIYW5kbGVyIChNb3VzZU1vdmUgbXNnKVxubGV0IG9ua2V5ZG93biBtc2cgPSBIYW5kbGVyIChLZXlEb3duIG1zZylcblxuXG5sZXQgc3RyX3Byb3AgayB2ID0gUHJvcGVydHkgKGssIFN0cmluZyB2KVxubGV0IGludF9wcm9wIGsgdiA9IFByb3BlcnR5IChrLCBJbnQgdilcbmxldCBib29sX3Byb3AgayB2ID0gUHJvcGVydHkgKGssIEJvb2wgdilcbmxldCBmbG9hdF9wcm9wIGsgdiA9IFByb3BlcnR5IChrLCBGbG9hdCB2KVxubGV0IHN0eWxlIGsgdiA9IFN0eWxlIChrLCB2KVxubGV0IGF0dHIgayB2ID0gQXR0cmlidXRlIChrLCB2KVxubGV0IGludF9hdHRyIGsgdiA9IEF0dHJpYnV0ZSAoaywgc3RyaW5nX29mX2ludCB2KVxubGV0IGZsb2F0X2F0dHIgayB2ID0gQXR0cmlidXRlIChrLCBzdHJpbmdfb2ZfZmxvYXQgdilcbmxldCBzY3JvbGxfdG9fc2hvdyA9IGJvb2xfcHJvcCBcInNjcm9sbC10by1zaG93XCIgdHJ1ZVxubGV0IGF1dG9mb2N1cyA9IGJvb2xfcHJvcCBcImF1dG9mb2N1c1wiIHRydWVcblxubGV0IGNsYXNzXyB4ID0gUHJvcGVydHkgKFwiY2xhc3NOYW1lXCIsIFN0cmluZyB4KVxubGV0IHR5cGVfIHggPSBQcm9wZXJ0eSAoXCJ0eXBlXCIsIFN0cmluZyB4KVxubGV0IHR5cGVfYnV0dG9uID0gdHlwZV8gXCJidXR0b25cIlxubGV0IHZhbHVlIHggPSBQcm9wZXJ0eSAoXCJ2YWx1ZVwiLCBTdHJpbmcgeClcbmxldCBkaXNhYmxlZCB4ID0gUHJvcGVydHkgKFwiZGlzYWJsZWRcIiwgQm9vbCB4KVxuXG5sZXQgYWRkX2NsYXNzIHggYXR0cnMgPVxuICBsZXQgaGFzX2NsYXNzTmFtZSA9XG4gICAgTGlzdC5leGlzdHMgKGZ1bmN0aW9uIFByb3BlcnR5IChcImNsYXNzTmFtZVwiLCBfKSAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgYXR0cnNcbiAgaW5cbiAgaWYgaGFzX2NsYXNzTmFtZSB0aGVuXG4gICAgTGlzdC5tYXAgKGZ1bmN0aW9uXG4gICAgICAgIHwgUHJvcGVydHkgKFwiY2xhc3NOYW1lXCIsIFN0cmluZyBzKSAtPlxuICAgICAgICAgICAgUHJvcGVydHkgKFwiY2xhc3NOYW1lXCIsIFN0cmluZyAoUHJpbnRmLnNwcmludGYgXCIlcyAlc1wiIHMgeCkpXG4gICAgICAgIHwgYSAtPlxuICAgICAgICAgICAgYVxuICAgICAgKSBhdHRyc1xuICBlbHNlXG4gICAgY2xhc3NfIHggOjogYXR0cnNcblxudHlwZSArJ21zZyB2ZG9tID1cbiAgfCBUZXh0IG9mXG4gICAgICB7XG4gICAgICAgIGtleTogc3RyaW5nO1xuICAgICAgICB0eHQ6IHN0cmluZztcbiAgICAgIH1cbiAgfCBFbGVtZW50IG9mXG4gICAgICB7XG4gICAgICAgIGtleTogc3RyaW5nO1xuICAgICAgICBuczogc3RyaW5nO1xuICAgICAgICB0YWc6IHN0cmluZztcbiAgICAgICAgYXR0cmlidXRlczogJ21zZyBhdHRyaWJ1dGUgbGlzdDtcbiAgICAgICAgY2hpbGRyZW46ICdtc2cgdmRvbSBsaXN0O1xuICAgICAgfVxuICB8IE1hcDpcbiAgICAgIHtcbiAgICAgICAga2V5OiBzdHJpbmc7XG4gICAgICAgIGY6ICgnc3VibXNnIC0+ICdtc2cpO1xuICAgICAgICBjaGlsZDogJ3N1Ym1zZyB2ZG9tO1xuICAgICAgfSAtPiAnbXNnIHZkb21cbiAgfCBNZW1vOlxuICAgICAge1xuICAgICAgICBrZXk6IHN0cmluZztcbiAgICAgICAgZjogKCdhIC0+ICdtc2cgdmRvbSk7XG4gICAgICAgIGFyZzogJ2E7XG4gICAgICB9IC0+ICdtc2cgdmRvbVxuICB8IEN1c3RvbSBvZlxuICAgICAge1xuICAgICAgICBrZXk6IHN0cmluZztcbiAgICAgICAgZWx0OiBDdXN0b20udDtcbiAgICAgICAgYXR0cmlidXRlczogJ21zZyBhdHRyaWJ1dGUgbGlzdDtcbiAgICAgIH1cblxubGV0IHRleHQgPyhrZXkgPVwiX3R4dFwiKSB0eHQgPSBUZXh0IHtrZXk7IHR4dH1cblxudHlwZSAoJ21zZywgJ3JlcykgZWx0X2dlbiA9XG4gID9rZXk6c3RyaW5nIC0+XG4gID9hOidtc2cgYXR0cmlidXRlIGxpc3QgLT5cbiAgJ3Jlc1xuXG5sZXQgZWx0ID8obnMgPSBcIlwiKSB0YWcgP2tleSA/KGEgPSBbXSkgbCA9XG4gIEVsZW1lbnRcbiAgICB7XG4gICAgICBrZXkgPSAobWF0Y2gga2V5IHdpdGggTm9uZSAtPiB0YWcgfCBTb21lIGsgLT4gayk7XG4gICAgICBucztcbiAgICAgIHRhZztcbiAgICAgIGNoaWxkcmVuID0gbDtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhO1xuICAgIH1cblxubGV0IHN2Z19ucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxubGV0IHN2Z19lbHQgdGFnID9rZXkgP2EgbCA9IGVsdCB+bnM6c3ZnX25zIHRhZyA/a2V5ID9hIGxcblxubGV0IGRpdiA/a2V5ID9hIGwgPSBlbHQgXCJkaXZcIiA/a2V5ID9hIGxcbmxldCBpbnB1dCA/a2V5ID9hIGwgPSBlbHQgXCJpbnB1dFwiID9rZXkgP2EgbFxubGV0IHR4dF9zcGFuID9rZXkgP2EgcyA9IGVsdCBcInNwYW5cIiA/a2V5ID9hIFt0ZXh0IHNdXG5cbmxldCBtYXBfYXR0ciBmID0gZnVuY3Rpb25cbiAgfCBDdXN0b20gKHsgYXR0cmlidXRlczsgXyB9IGFzIHgpIC0+XG4gICAgICBDdXN0b20geyB4IHdpdGggYXR0cmlidXRlcyA9IGYgYXR0cmlidXRlcyB9XG4gIHwgRWxlbWVudCAoeyBhdHRyaWJ1dGVzOyBfIH0gYXMgeCkgLT5cbiAgICAgIEVsZW1lbnQgeyB4IHdpdGggYXR0cmlidXRlcyA9IGYgYXR0cmlidXRlcyB9XG4gIHwgeCAtPiB4XG5cbmxldCBtYXAgPyhrZXkgPSBcIl9tYXBcIikgZiBjaGlsZCA9IE1hcCB7a2V5OyBmOyBjaGlsZH1cbmxldCBtZW1vID8oa2V5ID0gXCJfbWVtb1wiKSBmIGFyZyA9IE1lbW8ge2tleTsgZjsgYXJnfVxubGV0IGN1c3RvbSA/KGtleSA9XCJfY3VzdG9tXCIpID8oYSA9IFtdKSBlbHQgPSBDdXN0b20ge2tleTsgZWx0OyBhdHRyaWJ1dGVzID0gYX1cblxubGV0IHJldHVybiA/KGMgPSBbXSkgbW9kZWwgPSBtb2RlbCwgQ21kLmJhdGNoIGNcblxudHlwZSAoJ21vZGVsLCAnbXNnKSBhcHAgPVxuICB7XG4gICAgaW5pdDogKCdtb2RlbCAqICdtc2cgQ21kLnQpO1xuICAgIHVwZGF0ZTogKCdtb2RlbCAtPiAnbXNnIC0+ICdtb2RlbCAqICdtc2cgQ21kLnQpO1xuICAgIHZpZXc6ICgnbW9kZWwgLT4gJ21zZyB2ZG9tKTtcbiAgfVxuXG5sZXQgYXBwIH5pbml0IH51cGRhdGUgfnZpZXcgKCkgPVxuICB7aW5pdDsgdXBkYXRlOyB2aWV3fVxuXG5sZXQgc2ltcGxlX2FwcCB+aW5pdCB+dXBkYXRlIH52aWV3ICgpID1cbiAgYXBwXG4gICAgfmluaXQ6KHJldHVybiBpbml0KVxuICAgIH51cGRhdGU6KGZ1biBtb2RlbCBtc2cgLT4gcmV0dXJuICh1cGRhdGUgbW9kZWwgbXNnKSlcbiAgICB+dmlld1xuICAgICgpXG5cblxudHlwZSBldmVudCA9IHtldjogJ21zZy4gKCdtc2cgZXZlbnRfaGFuZGxlciAtPiAnbXNnIG9wdGlvbil9XG5cbmxldCBpbnB1dF9ldmVudCBzID0ge2V2ID0gZnVuY3Rpb24gSW5wdXQgZiAtPiBTb21lIChmIHMpIHwgXyAtPiBOb25lfVxubGV0IGNoZWNrZWRfZXZlbnQgYiA9IHtldiA9IGZ1bmN0aW9uIENoYW5nZUNoZWNrZWQgZiAtPiBTb21lIChmIGIpIHwgXyAtPiBOb25lfVxubGV0IGNoYW5nZV9ldmVudCBzID0ge2V2ID0gZnVuY3Rpb24gQ2hhbmdlIGYgLT4gU29tZSAoZiBzKSB8IF8gLT4gTm9uZX1cbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBvY2FtbC12ZG9tIHBhY2thZ2UsIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiBhbiBNSVQtbGlrZSBsaWNlbnNlLiAgICAgKilcbigqIFNlZSB0aGUgYXR0YWNoZWQgTElDRU5TRSBmaWxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqIENvcHlyaWdodCAyMDE2IGJ5IExleGlGaS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcblxuXG5vcGVuIEpzX2Jyb3dzZXJcbm9wZW4gVmRvbVxuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG5tb2R1bGUgQ21kID0gc3RydWN0XG4gIHR5cGUgJ21zZyBjdHggPVxuICAgIHtcbiAgICAgIHNlbmRfbXNnOiAoJ21zZyAtPiB1bml0KTtcbiAgICB9XG5cbiAgbGV0IHNlbmRfbXNnIGN0eCA9IGN0eC5zZW5kX21zZ1xuXG4gIHR5cGUgaGFuZGxlciA9IHtmOiAnbXNnLiAnbXNnIGN0eCAtPiAnbXNnIFZkb20uQ21kLnQgLT4gYm9vbH1cblxuICBsZXQgcmVjIHJ1bjogdHlwZSB0LiBoYW5kbGVyIGxpc3QgLT4gKHQgLT4gdW5pdCkgLT4gdCBDbWQudCAtPiB1bml0ID0gZnVuIGggcCAtPiBmdW5jdGlvblxuICAgIHwgQ21kLkVjaG8gbXNnIC0+IHAgbXNnXG4gICAgfCBDbWQuQmF0Y2ggbCAtPiBMaXN0Lml0ZXIgKHJ1biBoIHApIGxcbiAgICB8IENtZC5NYXAgKGYsIGNtZCkgLT4gcnVuIGggKGZ1biB4IC0+IHAgKGYgeCkpIGNtZFxuICAgIHwgeCAtPlxuICAgICAgICBsZXQgY3R4ID0ge3NlbmRfbXNnID0gcH0gaW5cbiAgICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgICB8IFtdIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiBcIk5vIGNvbW1hbmQgaGFuZGxlciBmb3VuZCEgKCVzKVwiIChPYmouZXh0ZW5zaW9uX25hbWUgKE9iai5leHRlbnNpb25fY29uc3RydWN0b3IgeCkpKVxuICAgICAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgICAgICAgaWYgaGQuZiBjdHggeCB0aGVuICgpXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCB0bFxuICAgICAgICBpblxuICAgICAgICBsb29wIGhcbmVuZFxuXG5tb2R1bGUgQ3VzdG9tID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgZG9tOiBKc19icm93c2VyLkVsZW1lbnQudDtcbiAgICAgIHN5bmM6IChWZG9tLkN1c3RvbS50IC0+IGJvb2wpO1xuICAgIH1cblxuICB0eXBlIGN0eCA9XG4gICAge1xuICAgICAgc2VuZF9ldmVudDogKFZkb20uZXZlbnQgLT4gdW5pdCk7XG4gICAgfVxuXG4gIHR5cGUgaGFuZGxlciA9IGN0eCAtPiBWZG9tLkN1c3RvbS50IC0+IHQgb3B0aW9uXG5cbiAgbGV0IG1ha2UgfnN5bmMgZG9tID0ge2RvbTsgc3luY31cblxuICBsZXQgc2VuZF9ldmVudCBjdHggPSBjdHguc2VuZF9ldmVudFxuXG4gIGxldCByZWMgZmluZF9oYW5kbGVyIGN0eCB4ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwiVmRvbV9ibGl0OiBubyBjdXN0b20gZWxlbWVudCBoYW5kbGVyIGZvdW5kXCJcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGhkIGN0eCB4IHdpdGhcbiAgICAgICAgfCBTb21lIGYgLT4gZlxuICAgICAgICB8IE5vbmUgLT4gZmluZF9oYW5kbGVyIGN0eCB4IHRsXG4gICAgICAgIGVuZFxuXG4gIGxldCBsb29rdXAgcHJvY2VzcyBlbHQgaGFuZGxlcnMgPVxuICAgIGxldCByZWMgZG9tID0gbGF6eSAoKExhenkuZm9yY2UgZWwpLmRvbSlcbiAgICBhbmQgc2VuZF9ldmVudCBlID0gcHJvY2VzcyAoTGF6eS5mb3JjZSBkb20pIGVcbiAgICBhbmQgZWwgPSBsYXp5IChmaW5kX2hhbmRsZXIge3NlbmRfZXZlbnR9IGVsdCBoYW5kbGVycykgaW5cbiAgICBMYXp5LmZvcmNlIGVsXG5lbmRcblxuKCogQXV0byBzY3JvbGxpbmcgKilcblxubGV0IHJlYyBzY3JvbGxfcGFyZW50IG5vZGUgPVxuICBpZiBub2RlID0gRWxlbWVudC5udWxsIHRoZW5cbiAgICBEb2N1bWVudC5ib2R5IGRvY3VtZW50XG4gIGVsc2VcbiAgICBsZXQgb3ZlcmZsb3dfeSA9IFN0eWxlLmdldCAoV2luZG93LmdldF9jb21wdXRlZF9zdHlsZSB3aW5kb3cgbm9kZSkgXCJvdmVyZmxvd1lcIiBpblxuICAgIGxldCBpc19zY3JvbGxhYmxlID0gb3ZlcmZsb3dfeSA8PiBcInZpc2libGVcIiAmJiBvdmVyZmxvd195IDw+IFwiaGlkZGVuXCIgaW5cbiAgICBpZiBpc19zY3JvbGxhYmxlICYmIEVsZW1lbnQuc2Nyb2xsX2hlaWdodCBub2RlID49IEVsZW1lbnQuY2xpZW50X2hlaWdodCBub2RlIHRoZW5cbiAgICAgIG5vZGVcbiAgICBlbHNlXG4gICAgICBzY3JvbGxfcGFyZW50IChFbGVtZW50LnBhcmVudF9ub2RlIG5vZGUpXG5cbmxldCBzY3JvbGxfdG9fbWFrZV92aXNpYmxlIGNoaWxkID1cbiAgbGV0IG9wZW4gSnNfYnJvd3NlciBpblxuICBsZXQgcGFyZW50ID0gc2Nyb2xsX3BhcmVudCBjaGlsZCBpblxuICBsZXQgcl9wYXJlbnQgPSBFbGVtZW50LmdldF9ib3VuZGluZ19jbGllbnRfcmVjdCBwYXJlbnQgaW5cbiAgbGV0IHJfY2hpbGQgPSBFbGVtZW50LmdldF9ib3VuZGluZ19jbGllbnRfcmVjdCBjaGlsZCBpblxuICBsZXQgeTEgPSBSZWN0LmJvdHRvbSByX3BhcmVudCBhbmQgeTIgPSBSZWN0LmJvdHRvbSByX2NoaWxkIGluXG4gIGlmIHkyID4geTEgdGhlblxuICAgIEVsZW1lbnQuc2V0X3Njcm9sbF90b3AgcGFyZW50IChFbGVtZW50LnNjcm9sbF90b3AgcGFyZW50ICsuIHkyIC0uIHkxKVxuICBlbHNlXG4gICAgbGV0IHkxID0gUmVjdC50b3Agcl9wYXJlbnQgYW5kIHkyID0gUmVjdC50b3Agcl9jaGlsZCBpblxuICAgIGlmIHkyIDwgeTEgdGhlblxuICAgICAgRWxlbWVudC5zZXRfc2Nyb2xsX3RvcCBwYXJlbnQgKEVsZW1lbnQuc2Nyb2xsX3RvcCBwYXJlbnQgKy4geTIgLS4geTEpXG5cbigqIFJlbmRlcmluZyAoVkRPTSAtPiBET00pICopXG5cblxudHlwZSAnbXNnIGN0cmwgPVxuICB8IEJUZXh0IG9mIHt2ZG9tOiAnbXNnIHZkb207IGRvbTogRWxlbWVudC50fVxuICB8IEJFbGVtZW50IG9mIHt2ZG9tOiAnbXNnIHZkb207IGRvbTogRWxlbWVudC50OyBjaGlsZHJlbjogJ21zZyBjdHJsIGxpc3R9XG4gIHwgQk1hcDoge3Zkb206ICdtc2cgdmRvbTsgZG9tOiBFbGVtZW50LnQ7IGY6ICgnc3VibXNnIC0+ICdtc2cpOyBjaGlsZDogJ3N1Ym1zZyBjdHJsfSAtPiAnbXNnIGN0cmxcbiAgfCBCTWVtbzoge3Zkb206ICdtc2cgdmRvbTsgZG9tOiBFbGVtZW50LnQ7IGNoaWxkOiAnbXNnIGN0cmx9IC0+ICdtc2cgY3RybFxuICB8IEJDdXN0b20gb2Yge3Zkb206ICdtc2cgdmRvbTsgZWx0OiBDdXN0b20udH1cblxubGV0IGdldF9kb20gPSBmdW5jdGlvblxuICB8IEJUZXh0IHggLT4geC5kb21cbiAgfCBCRWxlbWVudCB4IC0+IHguZG9tXG4gIHwgQk1hcCB4IC0+IHguZG9tXG4gIHwgQk1lbW8geCAtPiB4LmRvbVxuICB8IEJDdXN0b20geCAtPiB4LmVsdC5kb21cblxubGV0IGdldF92ZG9tID0gZnVuY3Rpb25cbiAgfCBCVGV4dCB4IC0+IHgudmRvbVxuICB8IEJFbGVtZW50IHggLT4geC52ZG9tXG4gIHwgQk1hcCB4IC0+IHgudmRvbVxuICB8IEJNZW1vIHggLT4geC52ZG9tXG4gIHwgQkN1c3RvbSB4IC0+IHgudmRvbVxuXG5sZXQga2V5X29mX3Zkb20gPSBmdW5jdGlvblxuICB8IFRleHQge2tleTsgX31cbiAgfCBFbGVtZW50IHtrZXk7IF99XG4gIHwgTWFwIHtrZXk7IF99XG4gIHwgTWVtbyB7a2V5OyBffVxuICB8IEN1c3RvbSB7a2V5OyBffSAtPlxuICAgICAga2V5XG5cblxubGV0IGV2YWxfcHJvcCA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nIHggLT4gT2pzLnN0cmluZ190b19qcyB4XG4gIHwgSW50IHggLT4gT2pzLmludF90b19qcyB4XG4gIHwgQm9vbCB4IC0+IE9qcy5ib29sX3RvX2pzIHhcbiAgfCBGbG9hdCB4IC0+IE9qcy5mbG9hdF90b19qcyB4XG5cbmxldCBzdHJpbmdfb2ZfcHJvcCA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nIHMgLT4gc1xuICB8IEludCB4IC0+IHN0cmluZ19vZl9pbnQgeFxuICB8IEJvb2wgeCAtPiBzdHJpbmdfb2ZfYm9vbCB4XG4gIHwgRmxvYXQgeCAtPiBzdHJpbmdfb2ZfZmxvYXQgeFxuXG5sZXQgc2FtZV9wcm9wIHYxIHYyID1cbiAgdjEgPT0gdjIgfHxcbiAgbWF0Y2ggdjEsIHYyIHdpdGhcbiAgfCBTdHJpbmcgeDEsIFN0cmluZyB4MiAtPiB4MSA9IHgyXG4gIHwgSW50IHgxLCBJbnQgeDIgLT4geDEgPSB4MlxuICB8IEJvb2wgeDEsIEJvb2wgeDIgLT4geDEgPSB4MlxuICB8IEZsb2F0IHgxLCBGbG9hdCB4MiAtPiB4MSA9IHgyXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgYm1lbW8gdmRvbSBjaGlsZCA9XG4gIEJNZW1vIHt2ZG9tOyBkb20gPSBnZXRfZG9tIGNoaWxkOyBjaGlsZH1cblxubGV0IGFzeW5jIGYgPVxuICBpZ25vcmUgKFdpbmRvdy5zZXRfdGltZW91dCB3aW5kb3cgZiAwKVxuXG5sZXQgY3VzdG9tX2F0dHJpYnV0ZSBkb20gPSBmdW5jdGlvblxuICB8IFwic2Nyb2xsLXRvLXNob3dcIiAtPlxuICAgICAgICBhc3luY1xuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICB0cnkgc2Nyb2xsX3RvX21ha2VfdmlzaWJsZSBkb21cbiAgICAgICAgICAgICB3aXRoIGV4biAtPiBQcmludGYucHJpbnRmIFwic2Nyb2xsOiAlc1xcbiUhXCIgKFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG4gICAgICAgICAgKTtcbiAgICAgICAgdHJ1ZVxuXG4gIHwgXCJhdXRvZm9jdXNcIiAtPlxuICAgICAgYXN5bmMgKGZ1biAoKSAtPiBFbGVtZW50LmZvY3VzIGRvbSk7XG4gICAgICB0cnVlXG5cbiAgfCBfIC0+IGZhbHNlXG5cblxuXG5sZXQgYXBwbHlfYXR0cmlidXRlcyBkb20gYXR0cmlidXRlcyA9XG4gIExpc3QuaXRlclxuICAgIChmdW5jdGlvblxuICAgICAgfCBQcm9wZXJ0eSAoaywgdikgLT5cbiAgICAgICAgICBpZiBub3QgKGN1c3RvbV9hdHRyaWJ1dGUgZG9tIGspIHRoZW5cbiAgICAgICAgICAgIE9qcy5zZXQgKEVsZW1lbnQudF90b19qcyBkb20pIGsgKGV2YWxfcHJvcCB2KVxuXG4gICAgICB8IFN0eWxlIChrLCB2KSAtPlxuICAgICAgICAgIE9qcy5zZXRcbiAgICAgICAgICAgIChPanMuZ2V0IChFbGVtZW50LnRfdG9fanMgZG9tKSBcInN0eWxlXCIpXG4gICAgICAgICAgICBrXG4gICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB2KVxuXG4gICAgICB8IEF0dHJpYnV0ZSAoaywgdikgLT5cbiAgICAgICAgICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgZG9tIGsgdlxuXG4gICAgICB8IF8gLT4gKClcbiAgICApXG4gICAgYXR0cmlidXRlc1xuXG50eXBlIGN0eCA9XG4gIHtcbiAgICBwcm9jZXNzX2N1c3RvbTogKEVsZW1lbnQudCAtPiBldmVudCAtPiB1bml0KTtcbiAgICBjdXN0b21faGFuZGxlcnM6IEN1c3RvbS5oYW5kbGVyIGxpc3Q7XG4gIH1cblxubGV0IHJlYyBibGl0IDogdHlwZSBtc2cuIGN0eCAtPiBtc2cgdmRvbSAtPiBtc2cgY3RybCA9IGZ1biBjdHggdmRvbSAtPlxuICBtYXRjaCB2ZG9tIHdpdGhcbiAgfCBUZXh0IHt0eHQ7IGtleSA9IF99IC0+XG4gICAgICBCVGV4dCB7dmRvbTsgZG9tID0gRG9jdW1lbnQuY3JlYXRlX3RleHRfbm9kZSBkb2N1bWVudCB0eHR9XG5cbiAgfCBNYXAge2Y7IGNoaWxkOyBrZXkgPSBffSAtPlxuICAgICAgbGV0IGNoaWxkID0gYmxpdCBjdHggY2hpbGQgaW5cbiAgICAgIEJNYXAge3Zkb207IGRvbSA9IGdldF9kb20gY2hpbGQ7IGY7IGNoaWxkfVxuXG4gIHwgTWVtbyB7ZjsgYXJnOyBrZXkgPSBffSAtPlxuICAgICAgYm1lbW8gdmRvbSAoYmxpdCBjdHggKGYgYXJnKSlcblxuICB8IEN1c3RvbSB7ZWx0OyBhdHRyaWJ1dGVzOyBrZXkgPSBffSAtPlxuICAgICAgbGV0IGVsdCA9IEN1c3RvbS5sb29rdXAgY3R4LnByb2Nlc3NfY3VzdG9tIGVsdCBjdHguY3VzdG9tX2hhbmRsZXJzIGluXG4gICAgICBhcHBseV9hdHRyaWJ1dGVzIGVsdC5kb20gYXR0cmlidXRlcztcbiAgICAgIEJDdXN0b20ge3Zkb207IGVsdH1cblxuICB8IEVsZW1lbnQge25zOyB0YWc7IGNoaWxkcmVuOyBhdHRyaWJ1dGVzOyBrZXkgPSBffSAtPlxuICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiY3JlYXRlIDwlcz5cXG4lIVwiIHRhZztcbiAgICAgIGxldCBkb20gPVxuICAgICAgICBpZiBucyA9IFwiXCIgdGhlbiBEb2N1bWVudC5jcmVhdGVfZWxlbWVudCBkb2N1bWVudCB0YWdcbiAgICAgICAgZWxzZSBEb2N1bWVudC5jcmVhdGVfZWxlbWVudF9ucyBkb2N1bWVudCBucyB0YWdcbiAgICAgIGluXG4gICAgICBsZXQgY2hpbGRyZW4gPSBMaXN0Lm1hcCAoYmxpdCBjdHgpIGNoaWxkcmVuIGluXG4gICAgICBMaXN0Lml0ZXIgKGZ1biBjIC0+IEVsZW1lbnQuYXBwZW5kX2NoaWxkIGRvbSAoZ2V0X2RvbSBjKSkgY2hpbGRyZW47XG4gICAgICBhcHBseV9hdHRyaWJ1dGVzIGRvbSBhdHRyaWJ1dGVzO1xuICAgICAgQkVsZW1lbnQge3Zkb207IGRvbTsgY2hpbGRyZW59XG5cblxubGV0IHN5bmNfcHJvcHMgdG9fc3RyaW5nIHNhbWUgc2V0IGNsZWFyIGwxIGwyID1cbiAgbGV0IHNvcnQgPSBMaXN0LnNvcnQgKGZ1biAoazEsIF8pIChrMiwgXykgLT4gY29tcGFyZSAoazE6c3RyaW5nKSBrMikgaW5cbiAgbGV0IGwxID0gc29ydCBsMSBhbmQgbDIgPSBzb3J0IGwyIGluXG4gIGxldCByZWMgbG9vcCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBbXSAtPiAoKVxuXG4gICAgfCAoazEsIHYxKSA6OiB0bDEsIChrMiwgXykgOjogXyB3aGVuIGsxIDwgazIgLT5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUHJvcGVydHkgJXMgdW5zZXQgJXMgPT5cXG4lIVwiIGsxICh0b19zdHJpbmcgdjEpO1xuICAgICAgICBjbGVhciBrMTtcbiAgICAgICAgbG9vcCB0bDEgbDJcbiAgICB8IChrMSwgdjEpIDo6IHRsMSwgW10gLT5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUHJvcGVydHkgJXMgdW5zZXQgJXMgPT5cXG4lIVwiIGsxICh0b19zdHJpbmcgdjEpO1xuICAgICAgICBjbGVhciBrMTtcbiAgICAgICAgbG9vcCB0bDEgW11cblxuICAgIHwgKGsxLCBfKSA6OiBfLCAoazIsIHYyKSA6OiB0bDIgd2hlbiBrMiA8IGsxIC0+XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcIlByb3BlcnR5ICVzIHNldCA9PiAlc1xcbiUhXCIgazIgKHRvX3N0cmluZyB2Mik7XG4gICAgICAgIHNldCBrMiB2MjtcbiAgICAgICAgbG9vcCBsMSB0bDJcbiAgICB8IFtdLCAoazIsIHYyKSA6OiB0bDIgLT5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUHJvcGVydHkgJXMgc2V0ID0+ICVzXFxuJSFcIiBrMiAodG9fc3RyaW5nIHYyKTtcbiAgICAgICAgc2V0IGsyIHYyO1xuICAgICAgICBsb29wIFtdIHRsMlxuXG4gICAgfCAoX2sxLCB2MSkgOjogdGwxLCAoazIsIHYyKSA6OiB0bDIgLT5cbiAgICAgICAgKCogazEgPSBrMiAqKVxuICAgICAgICBpZiBub3QgKHNhbWUgdjEgdjIpIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJQcm9wZXJ0eSAlcyBjaGFuZ2VkICVzID0+ICVzXFxuJSFcIiBrMiAodG9fc3RyaW5nIHYxKSAodG9fc3RyaW5nIHYyKTtcbiAgICAgICAgICBzZXQgazIgdjI7XG4gICAgICAgIGVuZDtcbiAgICAgICAgbG9vcCB0bDEgdGwyXG4gIGluXG4gIGxvb3AgbDEgbDJcblxuXG5sZXQgcmVjIGNob29zZSBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBtYXRjaCBmIGhkIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBjaG9vc2UgZiB0bFxuICAgICAgfCBTb21lIHggLT4geCA6OiBjaG9vc2UgZiB0bFxuXG5sZXQganNfZW1wdHlfc3RyaW5nID1cbiAgT2pzLnN0cmluZ190b19qcyBcIlwiXG5cbmxldCBzeW5jX2F0dHJpYnV0ZXMgZG9tIGExIGEyID1cbiAgbGV0IHByb3BzID0gZnVuY3Rpb24gUHJvcGVydHkgKGssIHYpIC0+IFNvbWUgKGssIHYpIHwgU3R5bGUgXyB8IEhhbmRsZXIgXyB8IEF0dHJpYnV0ZSBfIC0+IE5vbmUgaW5cbiAgbGV0IHNldCBrIHYgPVxuICAgIG1hdGNoIGssIHYgd2l0aFxuICAgIHwgXCJ2YWx1ZVwiLCBTdHJpbmcgcyB3aGVuIHMgPSBFbGVtZW50LnZhbHVlIGRvbSAtPiAoKVxuICAgIHwgXyAtPlxuICAgICAgICBpZiBub3QgKGN1c3RvbV9hdHRyaWJ1dGUgZG9tIGspIHRoZW5cbiAgICAgICAgICBPanMuc2V0IChFbGVtZW50LnRfdG9fanMgZG9tKSBrIChldmFsX3Byb3AgdilcbiAgaW5cbiAgbGV0IGNsZWFyIGsgPSBPanMuc2V0IChFbGVtZW50LnRfdG9fanMgZG9tKSBrIE9qcy5udWxsIGluXG4gIHN5bmNfcHJvcHNcbiAgICBzdHJpbmdfb2ZfcHJvcFxuICAgIHNhbWVfcHJvcFxuICAgIHNldCBjbGVhclxuICAgIChjaG9vc2UgcHJvcHMgYTEpXG4gICAgKGNob29zZSBwcm9wcyBhMik7XG5cbiAgbGV0IHN0eWxlcyA9IGZ1bmN0aW9uIFN0eWxlIChrLCB2KSAtPiBTb21lIChrLCBTdHJpbmcgdikgfCBQcm9wZXJ0eSBfIHwgSGFuZGxlciBfIHwgQXR0cmlidXRlIF8gLT4gTm9uZSBpblxuICBsZXQgc2V0IGsgdiA9IE9qcy5zZXQgKE9qcy5nZXQgKEVsZW1lbnQudF90b19qcyBkb20pIFwic3R5bGVcIikgayAoZXZhbF9wcm9wIHYpIGluXG4gIGxldCBjbGVhciBrID0gT2pzLnNldCAoT2pzLmdldCAoRWxlbWVudC50X3RvX2pzIGRvbSkgXCJzdHlsZVwiKSBrIGpzX2VtcHR5X3N0cmluZyBpblxuICBzeW5jX3Byb3BzXG4gICAgc3RyaW5nX29mX3Byb3BcbiAgICBzYW1lX3Byb3BcbiAgICBzZXQgY2xlYXJcbiAgICAoY2hvb3NlIHN0eWxlcyBhMSlcbiAgICAoY2hvb3NlIHN0eWxlcyBhMik7XG5cbiAgbGV0IGF0dHJzID0gZnVuY3Rpb24gQXR0cmlidXRlIChrLCB2KSAtPiBTb21lIChrLCB2KSB8IFN0eWxlIF8gfCBQcm9wZXJ0eSBfIHwgSGFuZGxlciBfIC0+IE5vbmUgaW5cbiAgbGV0IHNldCBrIHYgPSBFbGVtZW50LnNldF9hdHRyaWJ1dGUgZG9tIGsgdiBpblxuICBsZXQgY2xlYXIgayA9IEVsZW1lbnQucmVtb3ZlX2F0dHJpYnV0ZSBkb20gayBpblxuICBzeW5jX3Byb3BzXG4gICAgKGZ1biBzIC0+IHMpXG4gICAgKGZ1biAoczE6IHN0cmluZykgczIgLT4gczEgPSBzMilcbiAgICBzZXQgY2xlYXJcbiAgICAoY2hvb3NlIGF0dHJzIGExKVxuICAgIChjaG9vc2UgYXR0cnMgYTIpXG5cbmxldCByZWMgc3luYyA6IHR5cGUgb2xkX21zZyBtc2cuIGN0eCAtPiBFbGVtZW50LnQgLT4gb2xkX21zZyBjdHJsIC0+IG1zZyB2ZG9tIC0+IG1zZyBjdHJsID1cbiAgZnVuIGN0eCBwYXJlbnQgb2xkIHZkb20gLT5cblxuICBtYXRjaCBvbGQsIHZkb20gd2l0aFxuICB8IF8gd2hlbiAodmRvbSA6IG1zZyB2ZG9tKSA9PSAoT2JqLm1hZ2ljIChnZXRfdmRvbSBvbGQgOiBvbGRfbXNnIHZkb20pKSAtPlxuICAgICAgKCogSWYgb2xkIGFuZCBuZXcgdmRvbSBhcmUgcGh5c2ljYWxseSBpZGVudGljYWwsIGl0IGlzIHNhZmUgdG8gcmV1c2UgdGhlIG9sZCBjdHJsLiAqKVxuICAgICAgKE9iai5tYWdpYyAob2xkIDogb2xkX21zZyBjdHJsKSA6IG1zZyBjdHJsKVxuICB8IEJUZXh0IHt2ZG9tID0gVGV4dCB7dHh0ID0gczE7IGtleSA9IF99OyBkb219LCBUZXh0IHt0eHQgPSBzMjsga2V5ID0gX30gLT5cbiAgICAgIGlmIHMxIDw+IHMyIHRoZW4gRWxlbWVudC5zZXRfbm9kZV92YWx1ZSBkb20gczI7XG4gICAgICBCVGV4dCB7dmRvbTsgZG9tfVxuXG4gIHwgQk1hcCB7Y2hpbGQgPSBjMTsgX30sIE1hcCB7ZjsgY2hpbGQgPSBjMjsga2V5ID0gX30gLT5cbiAgICAgIGxldCBjaGlsZCA9IHN5bmMgY3R4IHBhcmVudCBjMSBjMiBpblxuICAgICAgQk1hcCB7dmRvbTsgZG9tID0gZ2V0X2RvbSBjaGlsZDsgY2hpbGQ7IGZ9XG5cbiAgfCBCTWVtbyB7Y2hpbGQgPSBjMTsgdmRvbSA9IE1lbW8ge2YgPSBmMTsgYXJnID0gYTE7IGtleSA9IF99OyBffSwgTWVtbyB7ZiA9IGYyOyBhcmcgPSBhMjsga2V5ID0gX30gLT5cbiAgICAgICgqIElzIHRoaXMgc2FmZSAhPyAqKVxuICAgICAgaWYgT2JqLm1hZ2ljIGYxID09IGYyICYmIE9iai5tYWdpYyBhMSA9PSBhMiB0aGVuXG4gICAgICAgIGJtZW1vIHZkb20gKE9iai5tYWdpYyAoYzEgOiBvbGRfbXNnIGN0cmwpIDogbXNnIGN0cmwpXG4gICAgICBlbHNlXG4gICAgICAgIGJtZW1vIHZkb20gKHN5bmMgY3R4IHBhcmVudCBjMSAoZjIgYTIpKVxuXG4gIHwgQkN1c3RvbSB7dmRvbSA9IEN1c3RvbSB7a2V5PWtleTE7IGVsdD1hcmcxOyBhdHRyaWJ1dGVzPWExfTsgZWx0fSwgQ3VzdG9tIHtrZXk9a2V5MjsgZWx0PWFyZzI7IGF0dHJpYnV0ZXM9YTJ9XG4gICAgd2hlbiBrZXkxID0ga2V5MiAmJiAoYXJnMSA9PSBhcmcyIHx8IGVsdC5zeW5jIGFyZzIpIC0+XG4gICAgICBzeW5jX2F0dHJpYnV0ZXMgZWx0LmRvbSBhMSBhMjtcbiAgICAgIEJDdXN0b20ge3Zkb207IGVsdH1cblxuICB8IEJFbGVtZW50IHt2ZG9tID0gRWxlbWVudCBlMTsgZG9tOyBjaGlsZHJlbn0sIEVsZW1lbnQgZTIgd2hlbiBlMS50YWcgPSBlMi50YWcgJiYgZTEubnMgPSBlMi5ucyAtPlxuXG4gICAgICAoKiBUT0RPOlxuICAgICAgICAgLSBhZGQgYSBmYXN0LXBhdGggdG8gZGVhbCB3aXRoIHByZWZpeGVzIGFuZCBzdWZmaXhlcyBvZiBvbGQvbmV3IGNoaWxkcmVuIHdpdGggaWRlbnRpY2FsXG4gICAgICAgICAgIGtleXMsIGF2b2lkaW5nIGEgbG90IG9mIGFsbG9jYXRpb25zLlxuICAgICAgICAgLSB1c2UgYSBKUyBvYmplY3QgKG1hcCkgaW5zdGVhZCBvZiBhbiBPQ2FtbCBIYXNodGJsP1xuICAgICAgKilcblxuICAgICAgKCogc3luY2hyb25pemUgY2hpbGRyZW4gKilcblxuICAgICAgbGV0IG9sZF9jaGlsZHJlbiA9IEFycmF5Lm9mX2xpc3QgY2hpbGRyZW4gaW5cbiAgICAgIGxldCBuZXdfY2hpbGRyZW4gPSBBcnJheS5vZl9saXN0IGUyLmNoaWxkcmVuIGluXG5cbiAgICAgICgqIGZvciBlYWNoIGtleSwgZ2V0IGEgbGlzdCBvZiBpbmRpY2VzIGluIG9sZF9jaGlsZHJlbiAqKVxuICAgICAgbGV0IGJ5X2tleSA9IEhhc2h0YmwuY3JlYXRlIDggaW5cbiAgICAgIGZvciBpID0gQXJyYXkubGVuZ3RoIG9sZF9jaGlsZHJlbiAtIDEgZG93bnRvIDAgZG9cbiAgICAgICAgbGV0IGsgPSBrZXlfb2ZfdmRvbSAoZ2V0X3Zkb20gb2xkX2NoaWxkcmVuLihpKSkgaW5cbiAgICAgICAgSGFzaHRibC5hZGQgYnlfa2V5IGsgaVxuICAgICAgICAoKiBlYXJseSBlbGVtZW50cyBhcmUgaW5zZXJ0ZWQgbGFzdDogZm91bmQgZmlyc3QhICopXG4gICAgICBkb25lO1xuXG4gICAgICAoKiBidWlsZCBhbiBhcnJheSB0ZWxsaW5nIHVzLCBmb3IgZWFjaCBwb3NpdGlvbiBpbiB0aGUgXCJuZXdcIiBzZXF1ZW5jZSxcbiAgICAgICAgIHdoZXJlIHRvIHBpY2sgaXQgZnJvbSB0aGUgXCJvbGRcIiBzZXF1ZW5jZS4gKilcbiAgICAgIGxldCBpbmRpY2VzID0gQXJyYXkubWFrZSAoQXJyYXkubGVuZ3RoIG5ld19jaGlsZHJlbikgKC0xKSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBpbmRpY2VzIC0gMSBkb1xuICAgICAgICBsZXQgayA9IGtleV9vZl92ZG9tIG5ld19jaGlsZHJlbi4oaSkgaW5cbiAgICAgICAgbWF0Y2ggSGFzaHRibC5maW5kIGJ5X2tleSBrIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+ICgpICgqIGtlZXAgKC0xKSA9PSBuZWVkIHRvIGJ1aWxkIGZyb20gc2NyYXRjaCAqKVxuICAgICAgICB8IGlkeCAtPlxuICAgICAgICAgICAgaW5kaWNlcy4oaSkgPC0gaWR4O1xuICAgICAgICAgICAgSGFzaHRibC5yZW1vdmUgYnlfa2V5IGs7XG4gICAgICBkb25lO1xuXG4gICAgICBIYXNodGJsLml0ZXJcbiAgICAgICAgKGZ1biBfIGkgLT5cbiAgICAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwicmVtb3ZlICVpXFxuJSFcIiBpO1xuICAgICAgICAgICBFbGVtZW50LnJlbW92ZV9jaGlsZCBkb20gKGdldF9kb20gb2xkX2NoaWxkcmVuLihpKSk7XG4gICAgICAgIClcbiAgICAgICAgYnlfa2V5O1xuXG4gICAgICAoKiBwcm9kdWNlIHRoZSBuZXcgc2VxdWVuY2UsIGZyb20gcmlnaHQtdG8tbGVmdCwgY3JlYXRpbmcgYW5kIHBpY2tpbmcrc3luY2luYyBub2RlcyAqKVxuICAgICAgbGV0IGN0cmxzID0gcmVmIFtdIGluXG4gICAgICBsZXQgbmV4dCA9IHJlZiAoRWxlbWVudC50X29mX2pzIE9qcy5udWxsKSBpblxuICAgICAgZm9yIGkgPSBBcnJheS5sZW5ndGggbmV3X2NoaWxkcmVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgICBsZXQgaWR4ID0gaW5kaWNlcy4oaSkgaW5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwib2xkID0gJWk7IG5ldyA9ICVpOiBcIiBpZHggaTtcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIGlmIGlkeCA8IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgKCogY3JlYXRlICopXG4gICAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJjcmVhdGVcXG4lIVwiO1xuICAgICAgICAgICAgYmxpdCBjdHggbmV3X2NoaWxkcmVuLihpKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcInN5bmMmbW92ZVxcbiUhXCI7XG4gICAgICAgICAgICAoKiBub3RlOiB0aGUgc3luYyBjb3VsZCBsZWFkIHRvIGEgRE9NIHJlcGxhY2UsXG4gICAgICAgICAgICAgICBmb2xsb3dpbmcgYnkgYSBtb3ZlIGJlbG93OyBpbiB0aGF0IGNhc2UsXG4gICAgICAgICAgICAgICBvbmUgc2hvdWxkIGp1c3QgZGVsZXRlIG9sZCArIGluc2VydCBuZXcgKilcbiAgICAgICAgICAgIHN5bmMgY3R4IGRvbSBvbGRfY2hpbGRyZW4uKGlkeCkgbmV3X2NoaWxkcmVuLihpKVxuICAgICAgICAgIGVuZFxuICAgICAgICBpblxuICAgICAgICAoKiB3aGVuIG5leHQgPT0gbnVsbCwgaW5zZXJ0IGF0IHRoZSBlbmQgKilcblxuICAgICAgICAoKiBXZSB0cnkgdG8gYXZvaWQgdXNlbGVzcyBtb3ZlcyBhcyBtdWNoIGFzIHBvc3NpYmxlLCBub3Qgb25seSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uLFxuICAgICAgICAgICBidXQgYWxzbyBiZWNhdXNlIGl0IGNhdXNlcyB0aGUgbG9zcyBvZiBmb2N1cyBvbiBpbnB1dCBmaWVsZHMuXG5cbiAgICAgICAgICAgU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2luY3JlbWVudGFsLWRvbS9pc3N1ZXMvMjM3XG5cbiAgICAgICAgICAgQmV0dGVyIHNvbHV0aW9uczpcbiAgICAgICAgICAgLSBSZXN0b3JlIHRoZSBmb2N1cyBhZnRlciB0aGUgZW50aXJlIHN5bmNocm9uaXphdGlvbiAoUmVhY3Qgc2VlbXMgdG8gZG8gdGhhdCkuXG4gICAgICAgICAgIC0gTmV2ZXIgbW92ZSBhIGZvY3VzZWQgd2lkZ2V0IG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIChyZXF1aXJlIGEgbGVzcyByZWd1bGFyXG4gICAgICAgICAgICAgYWxnb3JpdGhtIHRvIGFwcGx5IHRoZSBkZXNpcmVkIHBlcm11dGF0aW9uKS5cbiAgICAgICAgKilcblxuICAgICAgICBsZXQgbW92ZSA9XG4gICAgICAgICAgaWYgaWR4IDwgMCB0aGVuIHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAoaWYgaSA9IEFycmF5Lmxlbmd0aCBuZXdfY2hpbGRyZW4gLSAxIHRoZW4gaWR4ICE9IEFycmF5Lmxlbmd0aCBvbGRfY2hpbGRyZW4gLSAxXG4gICAgICAgICAgICAgZWxzZSBpbmRpY2VzLihpICsgMSkgIT0gaWR4ICsgMSlcbiAgICAgICAgICAgICYmIEVsZW1lbnQubmV4dF9zaWJsaW5nIChnZXRfZG9tIGMpICE9ICFuZXh0ICgqIGNvdWxkIGF2b2lkIHJlYWRpbmcgZnJvbSB0aGUgRE9NLi4uICopXG4gICAgICAgIGluXG4gICAgICAgIGlmIG1vdmUgdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcInJlYWxseSBtb3ZlXFxuJSFcIjtcbiAgICAgICAgICBFbGVtZW50Lmluc2VydF9iZWZvcmUgZG9tIChnZXRfZG9tIGMpICFuZXh0O1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5leHQgOj0gZ2V0X2RvbSBjO1xuICAgICAgICBjdHJscyA6PSBjIDo6ICFjdHJsc1xuICAgICAgZG9uZTtcblxuICAgICAgbGV0IGNoaWxkcmVuID0gIWN0cmxzIGluXG5cbiAgICAgICgqIHN5bmNocm9uaXplIHByb3BlcnRpZXMgJiBzdHlsZXMgKilcbiAgICAgIHN5bmNfYXR0cmlidXRlcyBkb20gZTEuYXR0cmlidXRlcyBlMi5hdHRyaWJ1dGVzO1xuICAgICAgQkVsZW1lbnQge3Zkb207IGRvbTsgY2hpbGRyZW59XG5cbiAgfCBfIC0+XG4gICAgICBsZXQgeCA9IGJsaXQgY3R4IHZkb20gaW5cbiAgICAgIEVsZW1lbnQucmVwbGFjZV9jaGlsZCBwYXJlbnQgKGdldF9kb20geCkgKGdldF9kb20gb2xkKTtcbiAgICAgIHhcblxudHlwZSAnbXNnIGZpbmQgPVxuICB8IE5vdEZvdW5kXG4gIHwgRm91bmQ6IHttYXBwZXI6ICgnaW5uZXJfbXNnIC0+ICdtc2cpOyBpbm5lcjogJ2lubmVyX21zZyBjdHJsOyBwYXJlbnQ6ICdtc2cgZmluZH0gLT4gJ21zZyBmaW5kXG5cbmxldCByZWMgZm91bmQ6IHR5cGUgaW5uZXJfbXNnIG1zZy4gKGlubmVyX21zZyAtPiBtc2cpIC0+IG1zZyBmaW5kIC0+IGlubmVyX21zZyBjdHJsIC0+IG1zZyBmaW5kID0gZnVuIG1hcHBlciBwYXJlbnQgLT4gZnVuY3Rpb25cbiAgfCBCRWxlbWVudCBfIHwgQlRleHQgXyB8IEJDdXN0b20gXyBhcyBpbm5lciAtPiBGb3VuZCB7bWFwcGVyOyBpbm5lcjsgcGFyZW50fVxuICB8IEJNYXAge2Y7IGNoaWxkOyBffSAtPiBmb3VuZCAoZnVuIHggLT4gbWFwcGVyIChmIHgpKSBwYXJlbnQgY2hpbGRcbiAgfCBCTWVtbyB7Y2hpbGQ7IF99IC0+IGZvdW5kIG1hcHBlciBwYXJlbnQgY2hpbGRcblxuKCogRmluZCBhIGN0cmwgYXNzb2NpYXRlZCB0byBhIERPTSBlbGVtZW50LlxuICAgTm9ybWFsaXplIGJ5IHRyYXZlcnNpbmcgTWFwIG5vZGUsIGFuZCBhbHNvIHJldHVybiB0aGUgY29tcG9zaXRpb24gb2YgYWxsIHN1Y2ggbWFwcGVyc1xuICAgZnJvbSB0aGUgcm9vdCB0byB0aGUgY3RybC4gKilcblxubGV0IHJlYyB2ZG9tX29mX2RvbTogdHlwZSBtc2cuIG1zZyBjdHJsIC0+IEVsZW1lbnQudCAtPiBtc2cgZmluZCA9IGZ1biByb290IGRvbSAtPlxuICAoKiBoYWNrIHRvIGNoZWNrIGRvbSA9PSBudWxsPyAgIFNob3VsZCBtb3ZlIHRoYXQgdG8gT2pzLiAqKVxuICBtYXRjaCBPanMub3B0aW9uX29mX2pzIEVsZW1lbnQudF9vZl9qcyAoRWxlbWVudC50X3RvX2pzIGRvbSkgd2l0aFxuICB8IE5vbmUgLT4gTm90Rm91bmRcbiAgfCBTb21lIGRvbSB3aGVuIGRvbSA9PSBnZXRfZG9tIHJvb3QgLT5cbiAgICAgIGZvdW5kIChmdW4geCAtPiB4KSBOb3RGb3VuZCByb290XG4gIHwgU29tZSBkb20gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHZkb21fb2ZfZG9tIHJvb3QgKEVsZW1lbnQucGFyZW50X25vZGUgZG9tKSB3aXRoXG4gICAgICB8IE5vdEZvdW5kIC0+IE5vdEZvdW5kXG4gICAgICB8IEZvdW5kIHttYXBwZXI7IGlubmVyID0gQkVsZW1lbnQge2NoaWxkcmVuOyBffTsgX30gYXMgcGFyZW50IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggTGlzdC5maW5kIChmdW4gYyAtPiBnZXRfZG9tIGMgPT0gZG9tKSBjaGlsZHJlbiB3aXRoXG4gICAgICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgYyAtPiBmb3VuZCBtYXBwZXIgcGFyZW50IGNcbiAgICAgICAgICBlbmRcbiAgICAgIHwgRm91bmQge21hcHBlciA9IF87IGlubmVyID0gQkN1c3RvbSBfOyBffSAtPlxuICAgICAgICAgIE5vdEZvdW5kXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICBlbmRcblxubGV0IG1vdXNlX2V2ZW50IGUgPVxuICB7XG4gICAgeCA9IEV2ZW50LmNsaWVudF94IGU7XG4gICAgeSA9IEV2ZW50LmNsaWVudF95IGU7XG4gICAgcGFnZV94ID0gRXZlbnQucGFnZV94IGU7XG4gICAgcGFnZV95ID0gRXZlbnQucGFnZV95IGU7XG4gICAgYnV0dG9ucyA9IEV2ZW50LmJ1dHRvbnMgZTtcbiAgICBhbHRfa2V5ID0gRXZlbnQuYWx0X2tleSBlO1xuICAgIGN0cmxfa2V5ID0gRXZlbnQuY3RybF9rZXkgZTtcbiAgICBzaGlmdF9rZXkgPSBFdmVudC5zaGlmdF9rZXkgZTtcbiAgfVxuXG5sZXQga2V5X2V2ZW50IGUgPVxuICB7XG4gICAgd2hpY2ggPSBFdmVudC53aGljaCBlO1xuICAgIGFsdF9rZXkgPSBFdmVudC5hbHRfa2V5IGU7XG4gICAgY3RybF9rZXkgPSBFdmVudC5jdHJsX2tleSBlO1xuICAgIHNoaWZ0X2tleSA9IEV2ZW50LnNoaWZ0X2tleSBlO1xuICB9XG5cbnR5cGUgKCdtb2RlbCwgJ21zZykgYXBwID0ge1xuICBkb206IEpzX2Jyb3dzZXIuRWxlbWVudC50O1xuICBwcm9jZXNzOiAoJ21zZyAtPiB1bml0KTtcbn1cblxubGV0IGRvbSB4ID0geC5kb21cbmxldCBwcm9jZXNzIHggPSB4LnByb2Nlc3NcblxudHlwZSBlbnYgPVxuICB7XG4gICAgY21kczogQ21kLmhhbmRsZXIgbGlzdDtcbiAgICBjdXN0b21zOiBDdXN0b20uaGFuZGxlciBsaXN0O1xuICB9XG5cbmxldCBlbXB0eSA9IHtjbWRzID0gW107IGN1c3RvbXMgPSBbXX1cbmxldCBjbWQgaCA9IHtlbXB0eSB3aXRoIGNtZHMgPSBbaF19XG5sZXQgY3VzdG9tIGggPSB7ZW1wdHkgd2l0aCBjdXN0b21zID0gW2hdfVxubGV0IG1lcmdlIGVudnMgPVxuICB7XG4gICAgY21kcyA9IExpc3QuY29uY2F0IChMaXN0Lm1hcCAoZnVuIGUgLT4gZS5jbWRzKSBlbnZzKTtcbiAgICBjdXN0b21zID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gZSAtPiBlLmN1c3RvbXMpIGVudnMpO1xuICB9XG5cblxubGV0IGdsb2JhbCA9IHJlZiBlbXB0eVxuXG5sZXQgcmVnaXN0ZXIgZSA9IGdsb2JhbCA6PSBtZXJnZSBbZTsgIWdsb2JhbF1cblxubGV0IHJ1biAodHlwZSBtc2cpICh0eXBlIG1vZGVsKSA/KGVudiA9IGVtcHR5KVxuICAgICh7aW5pdCA9IChtb2RlbDAsIGNtZDApOyB1cGRhdGU7IHZpZXd9IDogKG1vZGVsLCBtc2cpIFZkb20uYXBwKSA9XG4gIGxldCBlbnYgPSBtZXJnZSBbZW52OyAhZ2xvYmFsXSBpblxuICBsZXQgY29udGFpbmVyID0gRG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQgZG9jdW1lbnQgXCJkaXZcIiBpblxuXG4gIGxldCBwcm9jZXNzX2N1c3RvbV9md2QgPSByZWYgKGZ1biBfIF8gLT4gYXNzZXJ0IGZhbHNlKSBpblxuXG4gIGxldCBjdHggPSB7cHJvY2Vzc19jdXN0b20gPSAoZnVuIGRvbSBldnQgLT4gIXByb2Nlc3NfY3VzdG9tX2Z3ZCBkb20gZXZ0KTsgY3VzdG9tX2hhbmRsZXJzID0gZW52LmN1c3RvbXN9IGluXG4gIGxldCB4ID0gYmxpdCBjdHggKHZpZXcgbW9kZWwwKSBpblxuXG4gIGxldCBtb2RlbCA9IHJlZiBtb2RlbDAgaW5cbiAgbGV0IGN1cnJlbnQgPSByZWYgeCBpblxuXG5cbiAgbGV0IHBlbmRpbmdfcmVkcmF3ID0gcmVmIGZhbHNlIGluXG4gIGxldCBwb3N0X3JlZHJhdyA9IHJlZiBbXSBpblxuICBsZXQgYWZ0ZXJfcmVkcmF3IGYgPSBwb3N0X3JlZHJhdyA6PSBmIDo6ICFwb3N0X3JlZHJhdyBpblxuICBsZXQgcmVkcmF3IF8gPVxuICAgICgqIFRPRE86XG4gICAgICAgY291bGQgYXZvaWQgY2FsbGluZyB2aWV3L3N5bmMgaWYgbW9kZWwgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgIChiZWNhdXNlIHVwZGF0ZXMgYXJlIG5vdyBiYXRjaGVkXG4gICAgKilcbiAgICBwZW5kaW5nX3JlZHJhdyA6PSBmYWxzZTtcbiAgICBsZXQgbmV3X3Zkb20gPSB2aWV3ICFtb2RlbCBpblxuICAgIGxldCB4ID0gc3luYyBjdHggY29udGFpbmVyICFjdXJyZW50IG5ld192ZG9tIGluXG4gICAgY3VycmVudCA6PSB4O1xuICAgIGxldCBsID0gTGlzdC5yZXYgIXBvc3RfcmVkcmF3ICBpblxuICAgIHBvc3RfcmVkcmF3IDo9IFtdO1xuICAgIExpc3QuaXRlciAoZnVuIGYgLT4gZiAoKSkgbFxuICBpblxuXG4gIGxldCByZWMgcHJvY2VzcyBtc2cgPVxuICAgIGxldCAobmV3X21vZGVsIDogbW9kZWwpLCAoY21kIDogbXNnIFZkb20uQ21kLnQpID0gdXBkYXRlICFtb2RlbCBtc2cgaW5cbiAgICBtb2RlbCA6PSBuZXdfbW9kZWw7XG4gICAgQ21kLnJ1biBlbnYuY21kcyBwcm9jZXNzIGNtZDtcbiAgICBpZiBub3QgIXBlbmRpbmdfcmVkcmF3IHRoZW4gYmVnaW5cbiAgICAgIHBlbmRpbmdfcmVkcmF3IDo9IHRydWU7XG4gICAgICBXaW5kb3cucmVxdWVzdF9hbmltYXRpb25fZnJhbWUgd2luZG93IHJlZHJhd1xuICAgIGVuZFxuICBpblxuXG4gIEVsZW1lbnQuYXBwZW5kX2NoaWxkIGNvbnRhaW5lciAoZ2V0X2RvbSB4KTtcblxuICBsZXQgcHJldl92YWx1ZV9hdHRyaWJ1dGUgPSBcImRhdGEtb2NhbWwtdmRvbS1wcmV2LXZhbHVlXCIgaW5cblxuICBsZXQgb25ldmVudCBldnQgPVxuICAgIGxldCB0eSA9IEV2ZW50LnR5cGVfIGV2dCBpblxuICAgIHRyeVxuICAgICAgbGV0IHRndCA9IEVsZW1lbnQudF9vZl9qcyAoRXZlbnQudGFyZ2V0IGV2dCkgaW5cbiAgICAgIGxldCByZWMgYXBwbHlfaGFuZGxlciBsID1cbiAgICAgICAgbWF0Y2ggdHksIGwgd2l0aFxuICAgICAgICB8IFwiaW5wdXRcIiwgSGFuZGxlciAoSW5wdXQgZikgOjogXy0+IFNvbWUgKGYgKEVsZW1lbnQudmFsdWUgdGd0KSlcbiAgICAgICAgKCogY3Jvc3MgYnJvd3NlciBlbXVsYXRpb24gb2YgY2hhbmdlICopXG4gICAgICAgIHwgXCJibHVyXCIsIEhhbmRsZXIgKENoYW5nZSBmKSA6OiBfIC0+XG4gICAgICAgICAgICBsZXQgY3Vycl92YWx1ZSA9IEVsZW1lbnQudmFsdWUgdGd0IGluXG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9XG4gICAgICAgICAgICAgIG5vdCAoRWxlbWVudC5oYXNfYXR0cmlidXRlIHRndCBwcmV2X3ZhbHVlX2F0dHJpYnV0ZSkgfHxcbiAgICAgICAgICAgICAgRWxlbWVudC5nZXRfYXR0cmlidXRlIHRndCBwcmV2X3ZhbHVlX2F0dHJpYnV0ZSA8PiBjdXJyX3ZhbHVlXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgY2hhbmdlZCB0aGVuIFNvbWUgKGYgY3Vycl92YWx1ZSkgZWxzZSBOb25lXG4gICAgICAgIHwgXCJmb2N1c1wiLCBIYW5kbGVyIChDaGFuZ2UgXykgOjogdGwgLT5cbiAgICAgICAgICAgIGxldCBjdXJyX3ZhbHVlID0gRWxlbWVudC52YWx1ZSB0Z3QgaW5cbiAgICAgICAgICAgIEVsZW1lbnQuc2V0X2F0dHJpYnV0ZSB0Z3QgcHJldl92YWx1ZV9hdHRyaWJ1dGUgY3Vycl92YWx1ZTtcbiAgICAgICAgICAgIGFwcGx5X2hhbmRsZXIgdGxcbiAgICAgICAgfCBcImNoYW5nZVwiLCBIYW5kbGVyIChDaGFuZ2VJbmRleCBmKSA6OiBfIC0+IFNvbWUgKGYgKEVsZW1lbnQuc2VsZWN0ZWRfaW5kZXggdGd0KSlcbiAgICAgICAgfCBcImNoYW5nZVwiLCBIYW5kbGVyIChDaGFuZ2VDaGVja2VkIGYpIDo6IF8gLT4gU29tZSAoZiAoRWxlbWVudC5jaGVja2VkIHRndCkpXG4gICAgICAgIHwgXCJjbGlja1wiLCBIYW5kbGVyIChDbGljayBmKSA6OiBfIC0+IFNvbWUgKGYgKG1vdXNlX2V2ZW50IGV2dCkpXG4gICAgICAgIHwgXCJkYmxjbGlja1wiLCBIYW5kbGVyIChEYmxDbGljayBmKSA6OiBfIC0+IFNvbWUgKGYgKG1vdXNlX2V2ZW50IGV2dCkpXG4gICAgICAgIHwgXCJibHVyXCIsIEhhbmRsZXIgKEJsdXIgbXNnKSA6OiBfIC0+IFNvbWUgbXNnXG4gICAgICAgIHwgXCJmb2N1c1wiLCBIYW5kbGVyIChGb2N1cyBtc2cpIDo6IF8gLT4gU29tZSBtc2dcbiAgICAgICAgfCBcIm1vdXNlbW92ZVwiLCBIYW5kbGVyIChNb3VzZU1vdmUgZikgOjogXyAtPiBTb21lIChmIChtb3VzZV9ldmVudCBldnQpKVxuICAgICAgICB8IFwia2V5ZG93blwiLCBIYW5kbGVyIChLZXlEb3duIGYpIDo6IF8gLT4gU29tZSAoZiAoa2V5X2V2ZW50IGV2dCkpXG4gICAgICAgIHwgXCJjb250ZXh0bWVudVwiLCBIYW5kbGVyIChDb250ZXh0TWVudSBmKSA6OiBfIC0+IEV2ZW50LnByZXZlbnRfZGVmYXVsdCBldnQ7IFNvbWUgKGYgKG1vdXNlX2V2ZW50IGV2dCkpXG4gICAgICAgIHwgXywgXyA6OiB0bCAtPiBhcHBseV9oYW5kbGVyIHRsXG4gICAgICAgIHwgXywgW10gLT4gTm9uZVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgcHJvcGFnYXRlID0gZnVuY3Rpb25cbiAgICAgICAgfCBGb3VuZCB7XG4gICAgICAgICAgICBtYXBwZXI7XG4gICAgICAgICAgICBpbm5lciA9ICggQkVsZW1lbnQge3Zkb20gPSBFbGVtZW50IHthdHRyaWJ1dGVzOyBffTsgX31cbiAgICAgICAgICAgICAgICAgICAgfCBCQ3VzdG9tICB7dmRvbSA9IEN1c3RvbSAge2F0dHJpYnV0ZXM7IF99OyBffSApO1xuICAgICAgICAgICAgcGFyZW50O1xuICAgICAgICAgIH0gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGFwcGx5X2hhbmRsZXIgYXR0cmlidXRlcyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcHJvcGFnYXRlIHBhcmVudFxuICAgICAgICAgICAgfCBTb21lIG1zZyAtPiBwcm9jZXNzIChtYXBwZXIgbXNnKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgKClcbiAgICAgIGluXG5cbiAgICAgIHByb3BhZ2F0ZSAodmRvbV9vZl9kb20gIWN1cnJlbnQgdGd0KTtcblxuICAgICAgaWYgdHkgPSBcImlucHV0XCIgfHwgdHkgPSBcImJsdXJcIiB0aGVuXG4gICAgICAgIGxldCBmICgpID1cbiAgICAgICAgICBtYXRjaCB2ZG9tX29mX2RvbSAhY3VycmVudCB0Z3Qgd2l0aFxuICAgICAgICAgICgqIG5vdGU6IHRoZSBuZXcgdmRvbSBjYW4gYmUgZGlmZmVyZW50IGFmdGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICB0aGUgZXZlbnQgYWJvdmUgKilcbiAgICAgICAgICAoKiAhISBUaGlzIGlzIHByb2JhYmx5IGJyb2tlbiBub3cgdGhhdCB3ZSBkZWxheSB1cGRhdGluZyB0aGUgdmRvbVxuICAgICAgICAgICAgICAgIHdpdGggcmVxdWVzdF9hbmltYXRpb25fZnJhbWUgISEgKilcbiAgICAgICAgICB8IEZvdW5kIHttYXBwZXIgPSBfOyBpbm5lciA9IEJFbGVtZW50IHt2ZG9tID0gRWxlbWVudCB7YXR0cmlidXRlczsgX307IF99OyBffSAtPlxuICAgICAgICAgICAgICBMaXN0Lml0ZXJcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgIHwgUHJvcGVydHkgKFwidmFsdWVcIiwgU3RyaW5nIHMyKSB3aGVuIHMyIDw+IEVsZW1lbnQudmFsdWUgdGd0IC0+IEVsZW1lbnQuc2V0X3ZhbHVlIHRndCBzMlxuICAgICAgICAgICAgICAgICAgfCBQcm9wZXJ0eSAoXCJjaGVja2VkXCIsIEJvb2wgczIpIC0+IEVsZW1lbnQuc2V0X2NoZWNrZWQgdGd0IHMyXG4gICAgICAgICAgICAgICAgICB8IF8gLT4gKClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIHwgXyAtPiAoKVxuICAgICAgICBpblxuICAgICAgICBpZiAhcGVuZGluZ19yZWRyYXcgdGhlbiBhZnRlcl9yZWRyYXcgZiBlbHNlIGYgKClcbiAgICB3aXRoIGV4biAtPlxuICAgICAgUHJpbnRmLnByaW50ZiBcIkVycm9yIGluIGV2ZW50IGhhbmRsZXIgJVM6ICVzXFxuJSFcIiB0eSAoUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbiAgaW5cblxuICBsZXQgcHJvY2Vzc19jdXN0b20gdGd0IGV2ZW50ID1cbiAgICBiZWdpbiBtYXRjaCB2ZG9tX29mX2RvbSAhY3VycmVudCB0Z3Qgd2l0aFxuICAgIHwgRm91bmQge21hcHBlcjsgaW5uZXIgPSBCQ3VzdG9tICB7dmRvbSA9IEN1c3RvbSAge2F0dHJpYnV0ZXM7IF99OyBffTsgX30gLT5cbiAgICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgICB8IEhhbmRsZXIgaCA6OiByZXN0IC0+IGJlZ2luIG1hdGNoIGV2ZW50LmV2IGggd2l0aCBTb21lIF8gYXMgciAtPiByIHwgTm9uZSAtPiBsb29wIHJlc3QgZW5kXG4gICAgICAgICAgfCBfIDo6IHJlc3QgLT4gbG9vcCByZXN0XG4gICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIGxvb3AgYXR0cmlidXRlcyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgbXNnIC0+IHByb2Nlc3MgKG1hcHBlciBtc2cpXG4gICAgICAgIGVuZFxuICAgICAgfCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgIGVuZFxuICAgICAgKCogRG8gd2UgbmVlZCB0byBkbyBzb21ldGhpbmcgc2ltaWxhciB0byB0aGUgXCJpbnB1dFwiIGNhc2UgaW4gb25ldmVudD8gKilcbiAgaW5cbiAgcHJvY2Vzc19jdXN0b21fZndkIDo9IHByb2Nlc3NfY3VzdG9tO1xuICBFbGVtZW50LmFkZF9ldmVudF9saXN0ZW5lciBjb250YWluZXIgXCJjbGlja1wiIG9uZXZlbnQgZmFsc2U7XG4gIEVsZW1lbnQuYWRkX2V2ZW50X2xpc3RlbmVyIGNvbnRhaW5lciBcImRibGNsaWNrXCIgb25ldmVudCBmYWxzZTtcbiAgRWxlbWVudC5hZGRfZXZlbnRfbGlzdGVuZXIgY29udGFpbmVyIFwiaW5wdXRcIiBvbmV2ZW50IGZhbHNlO1xuICBFbGVtZW50LmFkZF9ldmVudF9saXN0ZW5lciBjb250YWluZXIgXCJjaGFuZ2VcIiBvbmV2ZW50IGZhbHNlO1xuICBFbGVtZW50LmFkZF9ldmVudF9saXN0ZW5lciBjb250YWluZXIgXCJmb2N1c1wiIG9uZXZlbnQgdHJ1ZTtcbiAgRWxlbWVudC5hZGRfZXZlbnRfbGlzdGVuZXIgY29udGFpbmVyIFwiYmx1clwiIG9uZXZlbnQgdHJ1ZTtcbiAgRWxlbWVudC5hZGRfZXZlbnRfbGlzdGVuZXIgY29udGFpbmVyIFwibW91c2Vtb3ZlXCIgb25ldmVudCB0cnVlO1xuICBFbGVtZW50LmFkZF9ldmVudF9saXN0ZW5lciBjb250YWluZXIgXCJrZXlkb3duXCIgb25ldmVudCB0cnVlO1xuICBFbGVtZW50LmFkZF9ldmVudF9saXN0ZW5lciBjb250YWluZXIgXCJjb250ZXh0bWVudVwiIG9uZXZlbnQgdHJ1ZTtcbiAgQ21kLnJ1biBlbnYuY21kcyBwcm9jZXNzIGNtZDA7XG4gIHtkb20gPSBjb250YWluZXI7IHByb2Nlc3N9XG4iLCJbQEBAY29tbWVudCBcIiEhIFRoaXMgY29kZSBoYXMgYmVlbiBnZW5lcmF0ZWQgYnkgZ2VuX2pzX2FwaSAhIVwiXVxuW0BAQG9jYW1sLndhcm5pbmcgXCItNy0zMi0zOVwiXVxubW9kdWxlIFN0b3JhZ2UgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4MiAtPiB4MlxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHgxIC0+IHgxXG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgbGV0IChsZW5ndGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg1IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDUpIFwibGVuZ3RoXCIpXG4gICAgbGV0IChrZXkgOiB0IC0+IGludCAtPiBzdHJpbmcgb3B0aW9uKSA9XG4gICAgICBmdW4geDcgLT5cbiAgICAgICAgZnVuIHg2IC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDcpIFwia2V5XCIgW3woT2pzLmludF90b19qcyB4Nil8XSlcbiAgICBsZXQgKGdldF9pdGVtIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvbikgPVxuICAgICAgZnVuIHgxMCAtPlxuICAgICAgICBmdW4geDkgLT5cbiAgICAgICAgICBPanMub3B0aW9uX29mX2pzIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MTApIFwiZ2V0SXRlbVwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDkpfF0pXG4gICAgbGV0IChzZXRfaXRlbSA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDE0IC0+XG4gICAgICAgIGZ1biB4MTIgLT5cbiAgICAgICAgICBmdW4geDEzIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgxNCkgXCJzZXRJdGVtXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MTIpOyhPanMuc3RyaW5nX3RvX2pzIHgxMyl8XSlcbiAgICBsZXQgKHJlbW92ZV9pdGVtIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxNiAtPlxuICAgICAgICBmdW4geDE1IC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDE2KSBcInJlbW92ZUl0ZW1cIiBbfChPanMuc3RyaW5nX3RvX2pzIHgxNSl8XSlcbiAgICBsZXQgKGNsZWFyIDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDE3IC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDE3KSBcImNsZWFyXCIgW3x8XSlcbiAgZW5kXG5tb2R1bGUgUmVnRXhwID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDE5IC0+IHgxOVxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHgxOCAtPiB4MThcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKG5ld19yZWdfZXhwIDogc3RyaW5nIC0+ID9mbGFnczpzdHJpbmcgLT4gdW5pdCAtPiB0KSA9XG4gICAgICBmdW4geDIyIC0+XG4gICAgICAgIGZ1biA/ZmxhZ3M6eDIzIC0+XG4gICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICB0X29mX2pzXG4gICAgICAgICAgICAgIChPanMubmV3X29ial9hcnIgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIlJlZ0V4cFwiKVxuICAgICAgICAgICAgICAgICAobGV0IHgyNCA9IE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJBcnJheVwiKSBbfHxdIGluXG4gICAgICAgICAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsIHgyNCBcInB1c2hcIiBbfChPanMuc3RyaW5nX3RvX2pzIHgyMil8XSk7XG4gICAgICAgICAgICAgICAgICAobWF0Y2ggeDIzIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDI1IC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4MjQgXCJwdXNoXCIgW3woT2pzLnN0cmluZ190b19qcyB4MjUpfF0pXG4gICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgIHgyNCkpXG4gIGVuZFxubW9kdWxlIEpzU3RyaW5nID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDI3IC0+IHgyN1xuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHgyNiAtPiB4MjZcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBPanMuc3RyaW5nX3RvX2pzIHNcbiAgICBsZXQgdG9fc3RyaW5nIHggPSBPanMuc3RyaW5nX29mX2pzIHhcbiAgICBsZXQgKHRvX2xvd2VyX2Nhc2UgOiB0IC0+IHQpID1cbiAgICAgIGZ1biB4MzAgLT4gdF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDMwKSBcInRvTG93ZXJDYXNlXCIgW3x8XSlcbiAgICBsZXQgKHRvX3VwcGVyX2Nhc2UgOiB0IC0+IHQpID1cbiAgICAgIGZ1biB4MzEgLT4gdF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDMxKSBcInRvVXBwZXJDYXNlXCIgW3x8XSlcbiAgICBsZXQgKGNvbmNhdCA6IHQgLT4gdCBsaXN0IC0+IHQpID1cbiAgICAgIGZ1biB4MzUgLT5cbiAgICAgICAgZnVuIHgzMiAtPlxuICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgIChsZXQgeDM2ID0gdF90b19qcyB4MzUgaW5cbiAgICAgICAgICAgICBPanMuY2FsbCAoT2pzLmdldCB4MzYgXCJjb25jYXRcIikgXCJhcHBseVwiXG4gICAgICAgICAgICAgICBbfHgzNjsoKGxldCB4MzMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJBcnJheVwiKSBbfHxdIGluXG4gICAgICAgICAgICAgICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4geDM0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlIChPanMuY2FsbCB4MzMgXCJwdXNoXCIgW3wodF90b19qcyB4MzQpfF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgIHgzMjtcbiAgICAgICAgICAgICAgICAgICAgICAgeDMzKSl8XSlcbiAgICBsZXQgKGluY2x1ZGVzIDogdCAtPiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MzggLT5cbiAgICAgICAgZnVuIHgzNyAtPlxuICAgICAgICAgIE9qcy5ib29sX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDM4KSBcImluY2x1ZGVzXCIgW3wodF90b19qcyB4MzcpfF0pXG4gICAgbGV0IChlbmRzX3dpdGggOiB0IC0+IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuIHg0MCAtPlxuICAgICAgICBmdW4geDM5IC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDApIFwiZW5kc1dpdGhcIiBbfCh0X3RvX2pzIHgzOSl8XSlcbiAgICBsZXQgKGluZGV4X29mIDogdCAtPiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg0MiAtPlxuICAgICAgICBmdW4geDQxIC0+XG4gICAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDQyKSBcImluZGV4T2ZcIiBbfCh0X3RvX2pzIHg0MSl8XSlcbiAgICBsZXQgKHJlcGVhdCA6IHQgLT4gaW50IC0+IHQpID1cbiAgICAgIGZ1biB4NDQgLT5cbiAgICAgICAgZnVuIHg0MyAtPlxuICAgICAgICAgIHRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg0NCkgXCJyZXBlYXRcIiBbfChPanMuaW50X3RvX2pzIHg0Myl8XSlcbiAgICBsZXQgKHNlYXJjaCA6IHQgLT4gUmVnRXhwLnQgLT4gaW50KSA9XG4gICAgICBmdW4geDQ2IC0+XG4gICAgICAgIGZ1biB4NDUgLT5cbiAgICAgICAgICBPanMuaW50X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ2KSBcInNlYXJjaFwiIFt8KFJlZ0V4cC50X3RvX2pzIHg0NSl8XSlcbiAgICBsZXQgKHRyaW0gOiB0IC0+IHQpID1cbiAgICAgIGZ1biB4NDcgLT4gdF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDQ3KSBcInRyaW1cIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBEYXRlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDQ5IC0+IHg0OVxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHg0OCAtPiB4NDhcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKG5ld19kYXRlIDogZmxvYXQgLT4gdCkgPVxuICAgICAgZnVuIHg1MiAtPlxuICAgICAgICB0X29mX2pzXG4gICAgICAgICAgKE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJEYXRlXCIpIFt8KE9qcy5mbG9hdF90b19qcyB4NTIpfF0pXG4gICAgbGV0IChub3cgOiB1bml0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuY2FsbCAoT2pzLmdldCBPanMuZ2xvYmFsIFwiRGF0ZVwiKSBcIm5vd1wiIFt8fF0pXG4gICAgbGV0IChwYXJzZSA6IHN0cmluZyAtPiB0KSA9XG4gICAgICBmdW4geDUzIC0+XG4gICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIkRhdGVcIikgXCJwYXJzZVwiXG4gICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NTMpfF0pXG4gICAgbGV0IChnZXRfZGF0ZSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDU0IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg1NCkgXCJnZXREYXRlXCIgW3x8XSlcbiAgICBsZXQgKGdldF9kYXkgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg1NSAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NTUpIFwiZ2V0RGF5XCIgW3x8XSlcbiAgICBsZXQgKGdldF9mdWxsX3llYXIgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg1NiAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NTYpIFwiZ2V0RnVsbFllYXJcIiBbfHxdKVxuICAgIGxldCAoZ2V0X2hvdXJzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NTcgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDU3KSBcImdldEhvdXJzXCIgW3x8XSlcbiAgICBsZXQgKGdldF9taWxsaXNlY29uZHMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg1OCAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NTgpIFwiZ2V0TWlsbGlzZWNvbmRzXCIgW3x8XSlcbiAgICBsZXQgKGdldF9taW51dGVzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NTkgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDU5KSBcImdldE1pbnV0ZXNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X21vbnRoIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjAgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDYwKSBcImdldE1vbnRoXCIgW3x8XSlcbiAgICBsZXQgKGdldF9zZWNvbmRzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjEgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDYxKSBcImdldFNlY29uZHNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X3RpbWUgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg2MiAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjIpIFwiZ2V0VGltZVwiIFt8fF0pXG4gICAgbGV0IChnZXRfdGltZXpvbmVfb2Zmc2V0IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjMgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDYzKSBcImdldFRpbWV6b25lT2Zmc2V0XCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfZGF0ZSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDY0IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg2NCkgXCJnZXRVVENEYXRlXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfZGF5IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjUgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDY1KSBcImdldFVUQ0RheVwiIFt8fF0pXG4gICAgbGV0IChnZXRfVVRDX2Z1bGxfeWVhciA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDY2IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg2NikgXCJnZXRVVENGdWxsWWVhclwiIFt8fF0pXG4gICAgbGV0IChnZXRfVVRDX2hvdXJzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjcgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDY3KSBcImdldFVUQ0hvdXJzXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfbWlsbGlzZWNvbmRzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NjggLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDY4KSBcImdldFVUQ01pbGxpc2Vjb25kc1wiIFt8fF0pXG4gICAgbGV0IChnZXRfVVRDX21pbnV0ZXMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg2OSAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjkpIFwiZ2V0VVRDTWludXRlc1wiIFt8fF0pXG4gICAgbGV0IChnZXRfVVRDX21vbnRoIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NzAgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDcwKSBcImdldFVUQ01vbnRoXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfc2Vjb25kcyA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDcxIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg3MSkgXCJnZXRVVENTZWNvbmRzXCIgW3x8XSlcbiAgICBsZXQgKGdldF95ZWFyIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NzIgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDcyKSBcImdldFllYXJcIiBbfHxdKVxuICAgIGxldCAoc2V0X2RhdGUgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4geDc0IC0+XG4gICAgICAgIGZ1biB4NzMgLT5cbiAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHg3NCkgXCJzZXREYXRlXCIgW3woT2pzLmludF90b19qcyB4NzMpfF0pXG4gICAgbGV0IChzZXRfZnVsbF95ZWFyIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg3NiAtPlxuICAgICAgICBmdW4geDc1IC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDc2KSBcInNldEZ1bGxZZWFyXCIgW3woT2pzLmludF90b19qcyB4NzUpfF0pXG4gICAgbGV0IChzZXRfaG91cnMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4geDc4IC0+XG4gICAgICAgIGZ1biB4NzcgLT5cbiAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHg3OCkgXCJzZXRIb3Vyc1wiIFt8KE9qcy5pbnRfdG9fanMgeDc3KXxdKVxuICAgIGxldCAoc2V0X21pbGxpc2Vjb25kcyA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4ODAgLT5cbiAgICAgICAgZnVuIHg3OSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg4MCkgXCJzZXRNaWxsaXNlY29uZHNcIiBbfChPanMuaW50X3RvX2pzIHg3OSl8XSlcbiAgICBsZXQgKHNldF9taW51dGVzIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg4MiAtPlxuICAgICAgICBmdW4geDgxIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDgyKSBcInNldE1pbnV0ZXNcIiBbfChPanMuaW50X3RvX2pzIHg4MSl8XSlcbiAgICBsZXQgKHNldF9tb250aCA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4ODQgLT5cbiAgICAgICAgZnVuIHg4MyAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDg0KSBcInNldE1vbnRoXCIgW3woT2pzLmludF90b19qcyB4ODMpfF0pXG4gICAgbGV0IChzZXRfc2Vjb25kcyA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4ODYgLT5cbiAgICAgICAgZnVuIHg4NSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg4NikgXCJzZXRTZWNvbmRzXCIgW3woT2pzLmludF90b19qcyB4ODUpfF0pXG4gICAgbGV0IChzZXRfdGltZSA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4ODggLT5cbiAgICAgICAgZnVuIHg4NyAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDg4KSBcInNldFRpbWVcIiBbfChPanMuaW50X3RvX2pzIHg4Nyl8XSlcbiAgICBsZXQgKHNldF9VVENfZGF0ZSA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4OTAgLT5cbiAgICAgICAgZnVuIHg4OSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5MCkgXCJzZXRVVENEYXRlXCIgW3woT2pzLmludF90b19qcyB4ODkpfF0pXG4gICAgbGV0IChzZXRfVVRDX2Z1bGxfeWVhciA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4OTIgLT5cbiAgICAgICAgZnVuIHg5MSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5MikgXCJzZXRVVENGdWxsWWVhclwiIFt8KE9qcy5pbnRfdG9fanMgeDkxKXxdKVxuICAgIGxldCAoc2V0X1VUQ19ob3VycyA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4OTQgLT5cbiAgICAgICAgZnVuIHg5MyAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5NCkgXCJzZXRVVENIb3Vyc1wiIFt8KE9qcy5pbnRfdG9fanMgeDkzKXxdKVxuICAgIGxldCAoc2V0X1VUQ19taWxsaXNlY29uZHMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4geDk2IC0+XG4gICAgICAgIGZ1biB4OTUgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4OTYpIFwic2V0VVRDTWlsbGlzZWNvbmRzXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5pbnRfdG9fanMgeDk1KXxdKVxuICAgIGxldCAoc2V0X1VUQ19taW51dGVzIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg5OCAtPlxuICAgICAgICBmdW4geDk3IC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDk4KSBcInNldFVUQ01pbnV0ZXNcIiBbfChPanMuaW50X3RvX2pzIHg5Nyl8XSlcbiAgICBsZXQgKHNldF9VVENfbW9udGggOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4geDEwMCAtPlxuICAgICAgICBmdW4geDk5IC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDEwMCkgXCJzZXRVVENNb250aFwiIFt8KE9qcy5pbnRfdG9fanMgeDk5KXxdKVxuICAgIGxldCAoc2V0X1VUQ19zZWNvbmRzIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxMDIgLT5cbiAgICAgICAgZnVuIHgxMDEgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MTAyKSBcInNldFVUQ1NlY29uZHNcIiBbfChPanMuaW50X3RvX2pzIHgxMDEpfF0pXG4gICAgbGV0IChzZXRfeWVhciA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTA0IC0+XG4gICAgICAgIGZ1biB4MTAzIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MTA0KSBcInNldFllYXJcIiBbfChPanMuaW50X3RvX2pzIHgxMDMpfF0pXG4gICAgbGV0ICh0b19kYXRlX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDEwNSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTA1KSBcInRvRGF0ZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19HTVRfc3RyaW5nIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MTA2IC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgxMDYpIFwidG9HTVRTdHJpbmdcIiBbfHxdKVxuICAgIGxldCAodG9fSVNPX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDEwNyAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTA3KSBcInRvSVNPU3RyaW5nXCIgW3x8XSlcbiAgICBsZXQgKHRvX2xvY2FsZV9zdHJpbmcgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHgxMDggLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDEwOCkgXCJ0b0xvY2FsZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19zdHJpbmcgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHgxMDkgLT4gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDEwOSkgXCJ0b1N0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b190aW1lX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDExMCAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTEwKSBcInRvVGltZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19VVENfc3RyaW5nIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MTExIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgxMTEpIFwidG9VVENTdHJpbmdcIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBGaWxlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDExMyAtPiB4MTEzXG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDExMiAtPiB4MTEyXG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgbGV0IChuYW1lIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MTE2IC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDExNikgXCJuYW1lXCIpXG4gICAgbGV0ICh0eXBlXyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDExNyAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxMTcpIFwidHlwZVwiKVxuICBlbmRcbm1vZHVsZSBEYXRhVHJhbnNmZXIgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4MTE5IC0+IHgxMTlcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4MTE4IC0+IHgxMThcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKGZpbGVzIDogdCAtPiBGaWxlLnQgbGlzdCkgPVxuICAgICAgZnVuIHgxMjIgLT5cbiAgICAgICAgT2pzLmxpc3Rfb2ZfanMgRmlsZS50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxMjIpIFwiZmlsZXNcIilcbiAgZW5kXG5tb2R1bGUgRXZlbnQgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4MTI1IC0+IHgxMjVcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4MTI0IC0+IHgxMjRcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKHRhcmdldCA6IHQgLT4gT2pzLnQpID0gZnVuIHgxMjggLT4gT2pzLmdldCAodF90b19qcyB4MTI4KSBcInRhcmdldFwiXG4gICAgbGV0IChwcmV2ZW50X2RlZmF1bHQgOiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTI5IC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDEyOSkgXCJwcmV2ZW50RGVmYXVsdFwiIFt8fF0pXG4gICAgbGV0ICh0eXBlXyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDEzMCAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxMzApIFwidHlwZVwiKVxuICAgIGxldCAoaW5pdF9ldmVudCA6IHQgLT4gc3RyaW5nIC0+IGJvb2wgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4geDEzNCAtPlxuICAgICAgICBmdW4geDEzMSAtPlxuICAgICAgICAgIGZ1biB4MTMyIC0+XG4gICAgICAgICAgICBmdW4geDEzMyAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDEzNCkgXCJpbml0RXZlbnRcIlxuICAgICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDEzMSk7KE9qcy5ib29sX3RvX2pzIHgxMzIpOyhPanMuYm9vbF90b19qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTMzKXxdKVxuICAgIGxldCAoY2xpZW50X3ggOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgxMzUgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MTM1KSBcImNsaWVudFhcIilcbiAgICBsZXQgKGNsaWVudF95IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4MTM2IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDEzNikgXCJjbGllbnRZXCIpXG4gICAgbGV0IChwYWdlX3ggOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDEzNyAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDEzNykgXCJwYWdlWFwiKVxuICAgIGxldCAocGFnZV95IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHgxMzggLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxMzgpIFwicGFnZVlcIilcbiAgICBsZXQgKHNjcmVlbl94IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4MTM5IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDEzOSkgXCJzY3JlZW5YXCIpXG4gICAgbGV0IChzY3JlZW5feSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDE0MCAtPiBPanMuaW50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNDApIFwic2NyZWVuWVwiKVxuICAgIGxldCAobW92ZW1lbnRfeCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDE0MSAtPiBPanMuaW50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNDEpIFwibW92ZW1lbnRYXCIpXG4gICAgbGV0IChtb3ZlbWVudF95IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4MTQyIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE0MikgXCJtb3ZlbWVudFlcIilcbiAgICBsZXQgKGJ1dHRvbnMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgxNDMgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MTQzKSBcImJ1dHRvbnNcIilcbiAgICBsZXQgKGFsdF9rZXkgOiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MTQ0IC0+IE9qcy5ib29sX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNDQpIFwiYWx0S2V5XCIpXG4gICAgbGV0IChjdHJsX2tleSA6IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuIHgxNDUgLT4gT2pzLmJvb2xfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE0NSkgXCJjdHJsS2V5XCIpXG4gICAgbGV0IChzaGlmdF9rZXkgOiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MTQ2IC0+IE9qcy5ib29sX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNDYpIFwic2hpZnRLZXlcIilcbiAgICBsZXQgKHdoaWNoIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4MTQ3IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE0NykgXCJ3aGljaFwiKVxuICAgIGxldCAoY29kZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDE0OCAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNDgpIFwiY29kZVwiKVxuICAgIGxldCAoa2V5IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MTQ5IC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE0OSkgXCJrZXlcIilcbiAgICBsZXQgKGRlbHRhX3kgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE1MCAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE1MCkgXCJkZWx0YVlcIilcbiAgICBsZXQgKGRlbHRhX3ggOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE1MSAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE1MSkgXCJkZWx0YVhcIilcbiAgICBsZXQgKGRhdGFfdHJhbnNmZXIgOiB0IC0+IERhdGFUcmFuc2Zlci50KSA9XG4gICAgICBmdW4geDE1MiAtPlxuICAgICAgICBEYXRhVHJhbnNmZXIudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MTUyKSBcImRhdGFUcmFuc2ZlclwiKVxuICAgIGxldCAoZGF0YSA6IHQgLT4gT2pzLnQpID0gZnVuIHgxNTMgLT4gT2pzLmdldCAodF90b19qcyB4MTUzKSBcImRhdGFcIlxuICAgIGxldCAob3JpZ2luIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MTU0IC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE1NCkgXCJvcmlnaW5cIilcbiAgZW5kXG5tb2R1bGUgUmVjdCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHgxNTYgLT4geDE1NlxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHgxNTUgLT4geDE1NVxuICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgIGxldCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gdF90b19qc1xuICAgIGxldCAoaGVpZ2h0IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHgxNTkgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNTkpIFwiaGVpZ2h0XCIpXG4gICAgbGV0ICh3aWR0aCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biB4MTYwIC0+IE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MTYwKSBcIndpZHRoXCIpXG4gICAgbGV0IChsZWZ0IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHgxNjEgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNjEpIFwibGVmdFwiKVxuICAgIGxldCAocmlnaHQgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE2MiAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE2MikgXCJyaWdodFwiKVxuICAgIGxldCAodG9wIDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHgxNjMgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNjMpIFwidG9wXCIpXG4gICAgbGV0IChib3R0b20gOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE2NCAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE2NCkgXCJib3R0b21cIilcbiAgZW5kXG5tb2R1bGUgU1ZHUmVjdCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHgxNjYgLT4geDE2NlxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHgxNjUgLT4geDE2NVxuICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgIGxldCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gdF90b19qc1xuICAgIGxldCAoeCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biB4MTY5IC0+IE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MTY5KSBcInhcIilcbiAgICBsZXQgKHkgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE3MCAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE3MCkgXCJ5XCIpXG4gICAgbGV0IChoZWlnaHQgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4geDE3MSAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDE3MSkgXCJoZWlnaHRcIilcbiAgICBsZXQgKHdpZHRoIDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHgxNzIgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgxNzIpIFwid2lkdGhcIilcbiAgZW5kXG5tb2R1bGUgU3R5bGUgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4MTc0IC0+IHgxNzRcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4MTczIC0+IHgxNzNcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgc2V0IHN0eWxlIHByb3AgdmFsdWUgPVxuICAgICAgT2pzLnNldCAodF90b19qcyBzdHlsZSkgcHJvcCAoT2pzLnN0cmluZ190b19qcyB2YWx1ZSlcbiAgICBsZXQgKHNldF9jb2xvciA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTc3IC0+XG4gICAgICAgIGZ1biB4MTc4IC0+IE9qcy5zZXQgKHRfdG9fanMgeDE3NykgXCJjb2xvclwiIChPanMuc3RyaW5nX3RvX2pzIHgxNzgpXG4gICAgbGV0IChzZXRfYm9yZGVyIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxNzkgLT5cbiAgICAgICAgZnVuIHgxODAgLT4gT2pzLnNldCAodF90b19qcyB4MTc5KSBcImJvcmRlclwiIChPanMuc3RyaW5nX3RvX2pzIHgxODApXG4gICAgbGV0IChzZXRfYmFja2dyb3VuZCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTgxIC0+XG4gICAgICAgIGZ1biB4MTgyIC0+XG4gICAgICAgICAgT2pzLnNldCAodF90b19qcyB4MTgxKSBcImJhY2tncm91bmRcIiAoT2pzLnN0cmluZ190b19qcyB4MTgyKVxuICAgIGxldCAoc2V0X2JhY2tncm91bmRfY29sb3IgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDE4MyAtPlxuICAgICAgICBmdW4geDE4NCAtPlxuICAgICAgICAgIE9qcy5zZXQgKHRfdG9fanMgeDE4MykgXCJiYWNrZ3JvdW5kQ29sb3JcIiAoT2pzLnN0cmluZ190b19qcyB4MTg0KVxuICAgIGxldCAoc2V0X2hlaWdodCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTg1IC0+XG4gICAgICAgIGZ1biB4MTg2IC0+IE9qcy5zZXQgKHRfdG9fanMgeDE4NSkgXCJoZWlnaHRcIiAoT2pzLnN0cmluZ190b19qcyB4MTg2KVxuICAgIGxldCAoc2V0X3dpZHRoIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxODcgLT5cbiAgICAgICAgZnVuIHgxODggLT4gT2pzLnNldCAodF90b19qcyB4MTg3KSBcIndpZHRoXCIgKE9qcy5zdHJpbmdfdG9fanMgeDE4OClcbiAgICBsZXQgKHNldF9ib3R0b20gOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDE4OSAtPlxuICAgICAgICBmdW4geDE5MCAtPiBPanMuc2V0ICh0X3RvX2pzIHgxODkpIFwiYm90dG9tXCIgKE9qcy5zdHJpbmdfdG9fanMgeDE5MClcbiAgICBsZXQgKHNldF9sZWZ0IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxOTEgLT5cbiAgICAgICAgZnVuIHgxOTIgLT4gT2pzLnNldCAodF90b19qcyB4MTkxKSBcImxlZnRcIiAoT2pzLnN0cmluZ190b19qcyB4MTkyKVxuICAgIGxldCAoc2V0X3RvcCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MTkzIC0+XG4gICAgICAgIGZ1biB4MTk0IC0+IE9qcy5zZXQgKHRfdG9fanMgeDE5MykgXCJ0b3BcIiAoT2pzLnN0cmluZ190b19qcyB4MTk0KVxuICAgIGxldCAoc2V0X3JpZ2h0IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgxOTUgLT5cbiAgICAgICAgZnVuIHgxOTYgLT4gT2pzLnNldCAodF90b19qcyB4MTk1KSBcInJpZ2h0XCIgKE9qcy5zdHJpbmdfdG9fanMgeDE5NilcbiAgICBsZXQgKHNldF9jdXJzb3IgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDE5NyAtPlxuICAgICAgICBmdW4geDE5OCAtPiBPanMuc2V0ICh0X3RvX2pzIHgxOTcpIFwiY3Vyc29yXCIgKE9qcy5zdHJpbmdfdG9fanMgeDE5OClcbiAgICBsZXQgZ2V0IHN0eWxlIHByb3AgPSBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHN0eWxlKSBwcm9wKVxuICBlbmRcbm1vZHVsZSBFbGVtZW50ID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDIwMCAtPiB4MjAwXG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDE5OSAtPiB4MTk5XG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgbGV0IG51bGwgPSB0X29mX2pzIE9qcy5udWxsXG4gICAgbGV0IChjbG9uZV9ub2RlIDogdCAtPiBib29sIC0+IHQpID1cbiAgICAgIGZ1biB4MjA0IC0+XG4gICAgICAgIGZ1biB4MjAzIC0+XG4gICAgICAgICAgdF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyMDQpIFwiY2xvbmVOb2RlXCIgW3woT2pzLmJvb2xfdG9fanMgeDIwMyl8XSlcbiAgICBsZXQgKGNvbnRhaW5zIDogdCAtPiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MjA2IC0+XG4gICAgICAgIGZ1biB4MjA1IC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjA2KSBcImNvbnRhaW5zXCIgW3wodF90b19qcyB4MjA1KXxdKVxuICAgIGxldCAoYXBwZW5kX2NoaWxkIDogdCAtPiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MjA4IC0+XG4gICAgICAgIGZ1biB4MjA3IC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MjA4KSBcImFwcGVuZENoaWxkXCIgW3wodF90b19qcyB4MjA3KXxdKVxuICAgIGxldCAoaW5zZXJ0X2JlZm9yZSA6IHQgLT4gdCAtPiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MjExIC0+XG4gICAgICAgIGZ1biB4MjA5IC0+XG4gICAgICAgICAgZnVuIHgyMTAgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDIxMSkgXCJpbnNlcnRCZWZvcmVcIlxuICAgICAgICAgICAgICAgICBbfCh0X3RvX2pzIHgyMDkpOyh0X3RvX2pzIHgyMTApfF0pXG4gICAgbGV0IChyZXBsYWNlX2NoaWxkIDogdCAtPiB0IC0+IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyMTQgLT5cbiAgICAgICAgZnVuIHgyMTIgLT5cbiAgICAgICAgICBmdW4geDIxMyAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjE0KSBcInJlcGxhY2VDaGlsZFwiXG4gICAgICAgICAgICAgICAgIFt8KHRfdG9fanMgeDIxMik7KHRfdG9fanMgeDIxMyl8XSlcbiAgICBsZXQgKHJlbW92ZV9jaGlsZCA6IHQgLT4gdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDIxNiAtPlxuICAgICAgICBmdW4geDIxNSAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDIxNikgXCJyZW1vdmVDaGlsZFwiIFt8KHRfdG9fanMgeDIxNSl8XSlcbiAgICBsZXQgKGZpcnN0X2NoaWxkIDogdCAtPiB0KSA9XG4gICAgICBmdW4geDIxNyAtPiB0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyMTcpIFwiZmlyc3RDaGlsZFwiKVxuICAgIGxldCAobGFzdF9jaGlsZCA6IHQgLT4gdCkgPVxuICAgICAgZnVuIHgyMTggLT4gdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjE4KSBcImxhc3RDaGlsZFwiKVxuICAgIGxldCAobmV4dF9zaWJsaW5nIDogdCAtPiB0KSA9XG4gICAgICBmdW4geDIxOSAtPiB0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyMTkpIFwibmV4dFNpYmxpbmdcIilcbiAgICBsZXQgcmVtb3ZlX2FsbF9jaGlsZHJlbiB4ID1cbiAgICAgIGxldCByZWMgbG9vcCBjaGlsZCA9XG4gICAgICAgIGlmIGNoaWxkID0gbnVsbFxuICAgICAgICB0aGVuICgpXG4gICAgICAgIGVsc2UgKHJlbW92ZV9jaGlsZCB4IGNoaWxkOyBsb29wIChmaXJzdF9jaGlsZCB4KSkgaW5cbiAgICAgIGxvb3AgKGZpcnN0X2NoaWxkIHgpXG4gICAgbGV0IChoYXNfY2hpbGRfbm9kZXMgOiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MjIwIC0+XG4gICAgICAgIE9qcy5ib29sX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MjIwKSBcImhhc0NoaWxkTm9kZXNcIiBbfHxdKVxuICAgIGxldCAoYWRkX2V2ZW50X2xpc3RlbmVyIDpcbiAgICAgIHQgLT4gc3RyaW5nIC0+IChFdmVudC50IC0+IHVuaXQpIC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyMjUgLT5cbiAgICAgICAgZnVuIHgyMjEgLT5cbiAgICAgICAgICBmdW4geDIyMiAtPlxuICAgICAgICAgICAgZnVuIHgyMjQgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyMjUpIFwiYWRkRXZlbnRMaXN0ZW5lclwiXG4gICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MjIxKTsoT2pzLmZ1bl90b19qcyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIHgyMjMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyMjIgKEV2ZW50LnRfb2ZfanMgeDIyMykpKTsoXG4gICAgICAgICAgICAgICAgICAgICBPanMuYm9vbF90b19qcyB4MjI0KXxdKVxuICAgIGxldCAoaW5uZXJfdGV4dCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDIyNiAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyMjYpIFwiaW5uZXJUZXh0XCIpXG4gICAgbGV0IChnZXRfZWxlbWVudHNfYnlfdGFnX25hbWUgOiB0IC0+IHN0cmluZyAtPiB0IGFycmF5KSA9XG4gICAgICBmdW4geDIyOCAtPlxuICAgICAgICBmdW4geDIyNyAtPlxuICAgICAgICAgIE9qcy5hcnJheV9vZl9qcyB0X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDIyOCkgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyMjcpfF0pXG4gICAgbGV0IChoYXNfYXR0cmlidXRlIDogdCAtPiBzdHJpbmcgLT4gYm9vbCkgPVxuICAgICAgZnVuIHgyMzEgLT5cbiAgICAgICAgZnVuIHgyMzAgLT5cbiAgICAgICAgICBPanMuYm9vbF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyMzEpIFwiaGFzQXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDIzMCl8XSlcbiAgICBsZXQgKGdldF9hdHRyaWJ1dGUgOiB0IC0+IHN0cmluZyAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MjMzIC0+XG4gICAgICAgIGZ1biB4MjMyIC0+XG4gICAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyMzMpIFwiZ2V0QXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDIzMil8XSlcbiAgICBsZXQgKHJlbW92ZV9hdHRyaWJ1dGUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDIzNSAtPlxuICAgICAgICBmdW4geDIzNCAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyMzUpIFwicmVtb3ZlQXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDIzNCl8XSlcbiAgICBsZXQgKHNldF9hdHRyaWJ1dGUgOiB0IC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyMzggLT5cbiAgICAgICAgZnVuIHgyMzYgLT5cbiAgICAgICAgICBmdW4geDIzNyAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjM4KSBcInNldEF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDIzNik7KE9qcy5zdHJpbmdfdG9fanMgeDIzNyl8XSlcbiAgICBsZXQgKGdldF9ib3VuZGluZ19jbGllbnRfcmVjdCA6IHQgLT4gUmVjdC50KSA9XG4gICAgICBmdW4geDIzOSAtPlxuICAgICAgICBSZWN0LnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgyMzkpIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgW3x8XSlcbiAgICBsZXQgKGdldF9ib3VuZGluZ19ib3ggOiB0IC0+IFNWR1JlY3QudCkgPVxuICAgICAgZnVuIHgyNDAgLT4gU1ZHUmVjdC50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MjQwKSBcImdldEJCb3hcIiBbfHxdKVxuICAgIGxldCAobm9ybWFsaXplIDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDI0MSAtPiBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgyNDEpIFwibm9ybWFsaXplXCIgW3x8XSlcbiAgICBsZXQgKHZhbHVlIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MjQyIC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDI0MikgXCJ2YWx1ZVwiKVxuICAgIGxldCAoc2V0X3ZhbHVlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyNDMgLT5cbiAgICAgICAgZnVuIHgyNDQgLT4gT2pzLnNldCAodF90b19qcyB4MjQzKSBcInZhbHVlXCIgKE9qcy5zdHJpbmdfdG9fanMgeDI0NClcbiAgICBsZXQgKHNlbGVjdCA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyNDUgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MjQ1KSBcInNlbGVjdFwiIFt8fF0pXG4gICAgbGV0IChmaWxlcyA6IHQgLT4gRmlsZS50IGxpc3QpID1cbiAgICAgIGZ1biB4MjQ2IC0+XG4gICAgICAgIE9qcy5saXN0X29mX2pzIEZpbGUudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjQ2KSBcImZpbGVzXCIpXG4gICAgbGV0IChzZWxlY3RlZF9pbmRleCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDI0OCAtPiBPanMuaW50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNDgpIFwic2VsZWN0ZWRJbmRleFwiKVxuICAgIGxldCAoY2hlY2tlZCA6IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuIHgyNDkgLT4gT2pzLmJvb2xfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDI0OSkgXCJjaGVja2VkXCIpXG4gICAgbGV0IChzZXRfY2hlY2tlZCA6IHQgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4geDI1MCAtPlxuICAgICAgICBmdW4geDI1MSAtPiBPanMuc2V0ICh0X3RvX2pzIHgyNTApIFwiY2hlY2tlZFwiIChPanMuYm9vbF90b19qcyB4MjUxKVxuICAgIGxldCAobm9kZV92YWx1ZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDI1MiAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNTIpIFwibm9kZVZhbHVlXCIpXG4gICAgbGV0IChzZXRfbm9kZV92YWx1ZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MjUzIC0+XG4gICAgICAgIGZ1biB4MjU0IC0+XG4gICAgICAgICAgT2pzLnNldCAodF90b19qcyB4MjUzKSBcIm5vZGVWYWx1ZVwiIChPanMuc3RyaW5nX3RvX2pzIHgyNTQpXG4gICAgbGV0IChwYXJlbnRfbm9kZSA6IHQgLT4gdCkgPVxuICAgICAgZnVuIHgyNTUgLT4gdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjU1KSBcInBhcmVudE5vZGVcIilcbiAgICBsZXQgKG5vZGVfbmFtZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDI1NiAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNTYpIFwibm9kZU5hbWVcIilcbiAgICBsZXQgKGRpc3BhdGNoX2V2ZW50IDogdCAtPiBFdmVudC50IC0+IGJvb2wpID1cbiAgICAgIGZ1biB4MjU4IC0+XG4gICAgICAgIGZ1biB4MjU3IC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjU4KSBcImRpc3BhdGNoRXZlbnRcIiBbfChFdmVudC50X3RvX2pzIHgyNTcpfF0pXG4gICAgbGV0IChzdHlsZSA6IHQgLT4gU3R5bGUudCkgPVxuICAgICAgZnVuIHgyNTkgLT4gU3R5bGUudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjU5KSBcInN0eWxlXCIpXG4gICAgbGV0IChzZXRfaW5uZXJfSFRNTCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MjYwIC0+XG4gICAgICAgIGZ1biB4MjYxIC0+XG4gICAgICAgICAgT2pzLnNldCAodF90b19qcyB4MjYwKSBcImlubmVySFRNTFwiIChPanMuc3RyaW5nX3RvX2pzIHgyNjEpXG4gICAgbGV0IChzZXRfdGV4dF9jb250ZW50IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyNjIgLT5cbiAgICAgICAgZnVuIHgyNjMgLT5cbiAgICAgICAgICBPanMuc2V0ICh0X3RvX2pzIHgyNjIpIFwidGV4dENvbnRlbnRcIiAoT2pzLnN0cmluZ190b19qcyB4MjYzKVxuICAgIGxldCAoc2V0X2NsYXNzX25hbWUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDI2NCAtPlxuICAgICAgICBmdW4geDI2NSAtPlxuICAgICAgICAgIE9qcy5zZXQgKHRfdG9fanMgeDI2NCkgXCJjbGFzc05hbWVcIiAoT2pzLnN0cmluZ190b19qcyB4MjY1KVxuICAgIGxldCAoY2xhc3NfbmFtZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDI2NiAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNjYpIFwiY2xhc3NOYW1lXCIpXG4gICAgbGV0IChjbGllbnRfd2lkdGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgyNjcgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjY3KSBcImNsaWVudFdpZHRoXCIpXG4gICAgbGV0IChjbGllbnRfaGVpZ2h0IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4MjY4IC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDI2OCkgXCJjbGllbnRIZWlnaHRcIilcbiAgICBsZXQgKHNjcm9sbF93aWR0aCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDI2OSAtPiBPanMuaW50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNjkpIFwic2Nyb2xsV2lkdGhcIilcbiAgICBsZXQgKHNjcm9sbF9oZWlnaHQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgyNzAgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjcwKSBcInNjcm9sbEhlaWdodFwiKVxuICAgIGxldCAod2lkdGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgyNzEgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjcxKSBcIndpZHRoXCIpXG4gICAgbGV0IChoZWlnaHQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgyNzIgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjcyKSBcImhlaWdodFwiKVxuICAgIGxldCAoc2Nyb2xsX3RvcCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biB4MjczIC0+IE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MjczKSBcInNjcm9sbFRvcFwiKVxuICAgIGxldCAoc2V0X3Njcm9sbF90b3AgOiB0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4Mjc0IC0+XG4gICAgICAgIGZ1biB4Mjc1IC0+IE9qcy5zZXQgKHRfdG9fanMgeDI3NCkgXCJzY3JvbGxUb3BcIiAoT2pzLmZsb2F0X3RvX2pzIHgyNzUpXG4gICAgbGV0IChmb2N1cyA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyNzYgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4Mjc2KSBcImZvY3VzXCIgW3x8XSlcbiAgICBsZXQgKHNlbGVjdGlvbl9zdGFydCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4geDI3NyAtPiBPanMuaW50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgyNzcpIFwic2VsZWN0aW9uU3RhcnRcIilcbiAgICBsZXQgKHNlbGVjdGlvbl9lbmQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgyNzggLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4Mjc4KSBcInNlbGVjdGlvbkVuZFwiKVxuICAgIGxldCAoc2V0X3NlbGVjdGlvbl9zdGFydCA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4Mjc5IC0+XG4gICAgICAgIGZ1biB4MjgwIC0+XG4gICAgICAgICAgT2pzLnNldCAodF90b19qcyB4Mjc5KSBcInNlbGVjdGlvblN0YXJ0XCIgKE9qcy5pbnRfdG9fanMgeDI4MClcbiAgICBsZXQgKHNldF9zZWxlY3Rpb25fZW5kIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgyODEgLT5cbiAgICAgICAgZnVuIHgyODIgLT5cbiAgICAgICAgICBPanMuc2V0ICh0X3RvX2pzIHgyODEpIFwic2VsZWN0aW9uRW5kXCIgKE9qcy5pbnRfdG9fanMgeDI4MilcbiAgZW5kXG5tb2R1bGUgRG9jdW1lbnQgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4Mjg0IC0+IHgyODRcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4MjgzIC0+IHgyODNcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKGNyZWF0ZV9lbGVtZW50IDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4geDI4OCAtPlxuICAgICAgICBmdW4geDI4NyAtPlxuICAgICAgICAgIEVsZW1lbnQudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyODgpIFwiY3JlYXRlRWxlbWVudFwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyODcpfF0pXG4gICAgbGV0IChjcmVhdGVfZWxlbWVudF9ucyA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiBFbGVtZW50LnQpID1cbiAgICAgIGZ1biB4MjkxIC0+XG4gICAgICAgIGZ1biB4Mjg5IC0+XG4gICAgICAgICAgZnVuIHgyOTAgLT5cbiAgICAgICAgICAgIEVsZW1lbnQudF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDI5MSkgXCJjcmVhdGVFbGVtZW50TlNcIlxuICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyODkpOyhPanMuc3RyaW5nX3RvX2pzIHgyOTApfF0pXG4gICAgbGV0IChjcmVhdGVfdGV4dF9ub2RlIDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4geDI5MyAtPlxuICAgICAgICBmdW4geDI5MiAtPlxuICAgICAgICAgIEVsZW1lbnQudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyOTMpIFwiY3JlYXRlVGV4dE5vZGVcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MjkyKXxdKVxuICAgIGxldCAoY3JlYXRlX2V2ZW50IDogdCAtPiBzdHJpbmcgLT4gRXZlbnQudCkgPVxuICAgICAgZnVuIHgyOTUgLT5cbiAgICAgICAgZnVuIHgyOTQgLT5cbiAgICAgICAgICBFdmVudC50X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDI5NSkgXCJjcmVhdGVFdmVudFwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyOTQpfF0pXG4gICAgbGV0IChnZXRfZWxlbWVudF9ieV9pZCA6IHQgLT4gc3RyaW5nIC0+IEVsZW1lbnQudCBvcHRpb24pID1cbiAgICAgIGZ1biB4Mjk3IC0+XG4gICAgICAgIGZ1biB4Mjk2IC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mjk3KSBcImdldEVsZW1lbnRCeUlkXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDI5Nil8XSlcbiAgICBsZXQgKGdldF9lbGVtZW50c19ieV9jbGFzc19uYW1lIDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50IGFycmF5KSA9XG4gICAgICBmdW4geDMwMCAtPlxuICAgICAgICBmdW4geDI5OSAtPlxuICAgICAgICAgIE9qcy5hcnJheV9vZl9qcyBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzAwKSBcImdldEVsZW1lbnRzQnlDbGFzc05hbWVcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4Mjk5KXxdKVxuICAgIGxldCAoYm9keSA6IHQgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4geDMwMiAtPiBFbGVtZW50LnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDMwMikgXCJib2R5XCIpXG4gICAgbGV0IChjb29raWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHgzMDMgLT4gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MzAzKSBcImNvb2tpZVwiKVxuICAgIGxldCAoc2V0X2Nvb2tpZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzA0IC0+XG4gICAgICAgIGZ1biB4MzA1IC0+IE9qcy5zZXQgKHRfdG9fanMgeDMwNCkgXCJjb29raWVcIiAoT2pzLnN0cmluZ190b19qcyB4MzA1KVxuICAgIGxldCAoc2V0X3RpdGxlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzMDYgLT5cbiAgICAgICAgZnVuIHgzMDcgLT4gT2pzLnNldCAodF90b19qcyB4MzA2KSBcInRpdGxlXCIgKE9qcy5zdHJpbmdfdG9fanMgeDMwNylcbiAgICBsZXQgKG9wZW5fIDpcbiAgICAgIHQgLT4gP21pbWVfdHlwZTpzdHJpbmcgLT4gP2hpc3RvcnlfbW9kZTpzdHJpbmcgLT4gdW5pdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDMxMyAtPlxuICAgICAgICBmdW4gP21pbWVfdHlwZTp4MzA4IC0+XG4gICAgICAgICAgZnVuID9oaXN0b3J5X21vZGU6eDMwOSAtPlxuICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChsZXQgeDMxNCA9IHRfdG9fanMgeDMxMyBpblxuICAgICAgICAgICAgICAgICBPanMuY2FsbCAoT2pzLmdldCB4MzE0IFwib3BlblwiKSBcImFwcGx5XCJcbiAgICAgICAgICAgICAgICAgICBbfHgzMTQ7KChsZXQgeDMxMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMubmV3X29iaiAoT2pzLmdldCBPanMuZ2xvYmFsIFwiQXJyYXlcIikgW3x8XSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4MzA4IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHgzMTIgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDMxMCBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgzMTIpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHgzMDkgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDMxMSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4MzEwIFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDMxMSl8XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MzEwKSl8XSlcbiAgICBsZXQgKHdyaXRlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzMTYgLT5cbiAgICAgICAgZnVuIHgzMTUgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzE2KSBcIndyaXRlXCIgW3woT2pzLnN0cmluZ190b19qcyB4MzE1KXxdKVxuICAgIGxldCAod3JpdGVsbiA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzE4IC0+XG4gICAgICAgIGZ1biB4MzE3IC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDMxOCkgXCJ3cml0ZWxuXCIgW3woT2pzLnN0cmluZ190b19qcyB4MzE3KXxdKVxuICAgIGxldCAoY2xvc2UgOiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzE5IC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDMxOSkgXCJjbG9zZVwiIFt8fF0pXG4gICAgbGV0IChleGVjX2NvbW1hbmQgOiB0IC0+IHN0cmluZyAtPiBib29sKSA9XG4gICAgICBmdW4geDMyMSAtPlxuICAgICAgICBmdW4geDMyMCAtPlxuICAgICAgICAgIE9qcy5ib29sX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDMyMSkgXCJleGVjQ29tbWFuZFwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgzMjApfF0pXG4gICAgbGV0IChxdWVyeV9zZWxlY3RvciA6IHQgLT4gc3RyaW5nIC0+IEVsZW1lbnQudCkgPVxuICAgICAgZnVuIHgzMjMgLT5cbiAgICAgICAgZnVuIHgzMjIgLT5cbiAgICAgICAgICBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzIzKSBcInF1ZXJ5U2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MzIyKXxdKVxuICBlbmRcbm1vZHVsZSBIaXN0b3J5ID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDMyNSAtPiB4MzI1XG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDMyNCAtPiB4MzI0XG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgbGV0IChsZW5ndGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHgzMjggLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MzI4KSBcImxlbmd0aFwiKVxuICAgIGxldCAoYmFjayA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzMjkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MzI5KSBcImJhY2tcIiBbfHxdKVxuICAgIGxldCAoZm9yd2FyZCA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzMzAgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MzMwKSBcImZvcndhcmRcIiBbfHxdKVxuICAgIGxldCAoZ28gOiB0IC0+IFsgYE9mZnNldCBvZiBpbnQgIHwgYFVybCBvZiBzdHJpbmcgXSAtPiB1bml0KSA9XG4gICAgICBmdW4geDMzNCAtPlxuICAgICAgICBmdW4geDMzMSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzMzQpIFwiZ29cIlxuICAgICAgICAgICAgICAgW3woKG1hdGNoIHgzMzEgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgYE9mZnNldCB4MzMyIC0+IE9qcy5pbnRfdG9fanMgeDMzMlxuICAgICAgICAgICAgICAgICAgIHwgYFVybCB4MzMzIC0+IE9qcy5zdHJpbmdfdG9fanMgeDMzMykpfF0pXG4gICAgbGV0IChyZXBsYWNlX3N0YXRlIDogdCAtPiBPanMudCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzM4IC0+XG4gICAgICAgIGZ1biB4MzM1IC0+XG4gICAgICAgICAgZnVuIHgzMzYgLT5cbiAgICAgICAgICAgIGZ1biB4MzM3IC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzM4KSBcInJlcGxhY2VTdGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW3x4MzM1OyhPanMuc3RyaW5nX3RvX2pzIHgzMzYpOyhPanMuc3RyaW5nX3RvX2pzIHgzMzcpfF0pXG4gICAgbGV0IChwdXNoX3N0YXRlIDogdCAtPiBPanMudCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzQyIC0+XG4gICAgICAgIGZ1biB4MzM5IC0+XG4gICAgICAgICAgZnVuIHgzNDAgLT5cbiAgICAgICAgICAgIGZ1biB4MzQxIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzQyKSBcInB1c2hTdGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW3x4MzM5OyhPanMuc3RyaW5nX3RvX2pzIHgzNDApOyhPanMuc3RyaW5nX3RvX2pzIHgzNDEpfF0pXG4gIGVuZFxubW9kdWxlIExvY2F0aW9uID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDM0NCAtPiB4MzQ0XG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDM0MyAtPiB4MzQzXG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgbGV0IChnZXRfaGFzaCA6IHVuaXQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldCAoT2pzLmdldCBPanMuZ2xvYmFsIFwibG9jYXRpb25cIikgXCJoYXNoXCIpXG4gICAgbGV0IChzZXRfaGFzaCA6IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDM0NyAtPlxuICAgICAgICBPanMuc2V0IChPanMuZ2V0IE9qcy5nbG9iYWwgXCJsb2NhdGlvblwiKSBcImhhc2hcIlxuICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHgzNDcpXG4gICAgbGV0IChob3N0IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MzQ4IC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDM0OCkgXCJob3N0XCIpXG4gICAgbGV0IChzZXRfaG9zdCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzQ5IC0+XG4gICAgICAgIGZ1biB4MzUwIC0+IE9qcy5zZXQgKHRfdG9fanMgeDM0OSkgXCJob3N0XCIgKE9qcy5zdHJpbmdfdG9fanMgeDM1MClcbiAgICBsZXQgKGhvc3RuYW1lIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4MzUxIC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDM1MSkgXCJob3N0bmFtZVwiKVxuICAgIGxldCAoc2V0X2hvc3RuYW1lIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzNTIgLT5cbiAgICAgICAgZnVuIHgzNTMgLT4gT2pzLnNldCAodF90b19qcyB4MzUyKSBcImhvc3RuYW1lXCIgKE9qcy5zdHJpbmdfdG9fanMgeDM1MylcbiAgICBsZXQgKGhyZWYgOiB1bml0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICgpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKE9qcy5nZXQgT2pzLmdsb2JhbCBcImxvY2F0aW9uXCIpIFwiaHJlZlwiKVxuICAgIGxldCAoc2V0X2hyZWYgOiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzNTQgLT5cbiAgICAgICAgT2pzLnNldCAoT2pzLmdldCBPanMuZ2xvYmFsIFwibG9jYXRpb25cIikgXCJocmVmXCJcbiAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4MzU0KVxuICAgIGxldCAocGF0aG5hbWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHgzNTUgLT4gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MzU1KSBcInBhdGhuYW1lXCIpXG4gICAgbGV0IChzZXRfcGF0aG5hbWUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDM1NiAtPlxuICAgICAgICBmdW4geDM1NyAtPiBPanMuc2V0ICh0X3RvX2pzIHgzNTYpIFwicGF0aG5hbWVcIiAoT2pzLnN0cmluZ190b19qcyB4MzU3KVxuICAgIGxldCAocG9ydCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDM1OCAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgzNTgpIFwicG9ydFwiKVxuICAgIGxldCAoc2V0X3BvcnQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDM1OSAtPlxuICAgICAgICBmdW4geDM2MCAtPiBPanMuc2V0ICh0X3RvX2pzIHgzNTkpIFwicG9ydFwiIChPanMuc3RyaW5nX3RvX2pzIHgzNjApXG4gICAgbGV0IChwcm90b2NvbCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDM2MSAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHgzNjEpIFwicHJvdG9jb2xcIilcbiAgICBsZXQgKHNldF9wcm90b2NvbCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzYyIC0+XG4gICAgICAgIGZ1biB4MzYzIC0+IE9qcy5zZXQgKHRfdG9fanMgeDM2MikgXCJwcm90b2NvbFwiIChPanMuc3RyaW5nX3RvX2pzIHgzNjMpXG4gICAgbGV0IChzZWFyY2ggOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHgzNjQgLT4gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldCAodF90b19qcyB4MzY0KSBcInNlYXJjaFwiKVxuICAgIGxldCAoc2V0X3NlYXJjaCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4MzY1IC0+XG4gICAgICAgIGZ1biB4MzY2IC0+IE9qcy5zZXQgKHRfdG9fanMgeDM2NSkgXCJzZWFyY2hcIiAoT2pzLnN0cmluZ190b19qcyB4MzY2KVxuICAgIGxldCAoYXNzaWduIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzNjggLT5cbiAgICAgICAgZnVuIHgzNjcgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzY4KSBcImFzc2lnblwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDM2Nyl8XSlcbiAgICBsZXQgKHJlbG9hZCA6IHQgLT4gP2ZvcmNlOmJvb2wgLT4gdW5pdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDM3MiAtPlxuICAgICAgICBmdW4gP2ZvcmNlOngzNjkgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAobGV0IHgzNzMgPSB0X3RvX2pzIHgzNzIgaW5cbiAgICAgICAgICAgICAgIE9qcy5jYWxsIChPanMuZ2V0IHgzNzMgXCJyZWxvYWRcIikgXCJhcHBseVwiXG4gICAgICAgICAgICAgICAgIFt8eDM3MzsoKGxldCB4MzcwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMubmV3X29iaiAoT2pzLmdldCBPanMuZ2xvYmFsIFwiQXJyYXlcIikgW3x8XSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDM2OSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDM3MSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHgzNzAgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5ib29sX3RvX2pzIHgzNzEpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4MzcwKSl8XSlcbiAgICBsZXQgKHJlcGxhY2UgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDM3NSAtPlxuICAgICAgICBmdW4geDM3NCAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzNzUpIFwicmVwbGFjZVwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDM3NCl8XSlcbiAgZW5kXG5tb2R1bGUgV2luZG93ID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDM3NyAtPiB4Mzc3XG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDM3NiAtPiB4Mzc2XG4gICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgbGV0ICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSB0X3RvX2pzXG4gICAgdHlwZSB0aW1lb3V0X2lkID0gT2pzLnRcbiAgICBsZXQgcmVjICh0aW1lb3V0X2lkX29mX2pzIDogT2pzLnQgLT4gdGltZW91dF9pZCkgPSBmdW4geDM4MSAtPiB4MzgxXG4gICAgYW5kICh0aW1lb3V0X2lkX3RvX2pzIDogdGltZW91dF9pZCAtPiBPanMudCkgPSBmdW4geDM4MCAtPiB4MzgwXG4gICAgbGV0ICh0aW1lb3V0X2lkX29mX2pzIDogT2pzLnQgLT4gdGltZW91dF9pZCkgPSB0aW1lb3V0X2lkX29mX2pzXG4gICAgbGV0ICh0aW1lb3V0X2lkX3RvX2pzIDogdGltZW91dF9pZCAtPiBPanMudCkgPSB0aW1lb3V0X2lkX3RvX2pzXG4gICAgbGV0IChhZGRfZXZlbnRfbGlzdGVuZXIgOlxuICAgICAgdCAtPiBzdHJpbmcgLT4gKEV2ZW50LnQgLT4gdW5pdCkgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4geDM4OCAtPlxuICAgICAgICBmdW4geDM4NCAtPlxuICAgICAgICAgIGZ1biB4Mzg1IC0+XG4gICAgICAgICAgICBmdW4geDM4NyAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDM4OCkgXCJhZGRFdmVudExpc3RlbmVyXCJcbiAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgzODQpOyhPanMuZnVuX3RvX2pzIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4geDM4NiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDM4NSAoRXZlbnQudF9vZl9qcyB4Mzg2KSkpOyhcbiAgICAgICAgICAgICAgICAgICAgIE9qcy5ib29sX3RvX2pzIHgzODcpfF0pXG4gICAgbGV0IChkb2N1bWVudCA6IHQgLT4gRG9jdW1lbnQudCkgPVxuICAgICAgZnVuIHgzODkgLT4gRG9jdW1lbnQudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4Mzg5KSBcImRvY3VtZW50XCIpXG4gICAgbGV0IChzZXRfb25sb2FkIDogdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0KSA9XG4gICAgICBmdW4geDM5MCAtPlxuICAgICAgICBmdW4geDM5MSAtPlxuICAgICAgICAgIE9qcy5zZXQgKHRfdG9fanMgeDM5MCkgXCJvbmxvYWRcIlxuICAgICAgICAgICAgKE9qcy5mdW5fdG9fanMgMSAoZnVuIF8gLT4geDM5MSAoKSkpXG4gICAgbGV0IChzZXRfaW50ZXJ2YWwgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IGludCAtPiB0aW1lb3V0X2lkKSA9XG4gICAgICBmdW4geDM5NCAtPlxuICAgICAgICBmdW4geDM5MiAtPlxuICAgICAgICAgIGZ1biB4MzkzIC0+XG4gICAgICAgICAgICB0aW1lb3V0X2lkX29mX2pzXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mzk0KSBcInNldEludGVydmFsXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZ1bl90b19qcyAxIChmdW4gXyAtPiB4MzkyICgpKSk7KE9qcy5pbnRfdG9fanMgeDM5Myl8XSlcbiAgICBsZXQgKHNldF90aW1lb3V0IDogdCAtPiAodW5pdCAtPiB1bml0KSAtPiBpbnQgLT4gdGltZW91dF9pZCkgPVxuICAgICAgZnVuIHgzOTcgLT5cbiAgICAgICAgZnVuIHgzOTUgLT5cbiAgICAgICAgICBmdW4geDM5NiAtPlxuICAgICAgICAgICAgdGltZW91dF9pZF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDM5NykgXCJzZXRUaW1lb3V0XCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZ1bl90b19qcyAxIChmdW4gXyAtPiB4Mzk1ICgpKSk7KE9qcy5pbnRfdG9fanMgeDM5Nil8XSlcbiAgICBsZXQgKGNsZWFyX3RpbWVvdXQgOiB0IC0+IHRpbWVvdXRfaWQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHgzOTkgLT5cbiAgICAgICAgZnVuIHgzOTggLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mzk5KSBcImNsZWFyVGltZW91dFwiXG4gICAgICAgICAgICAgICBbfCh0aW1lb3V0X2lkX3RvX2pzIHgzOTgpfF0pXG4gICAgbGV0IChyZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZSA6IHQgLT4gKGZsb2F0IC0+IHVuaXQpIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NDAyIC0+XG4gICAgICAgIGZ1biB4NDAwIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQwMikgXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIlxuICAgICAgICAgICAgICAgW3woT2pzLmZ1bl90b19qcyAxIChmdW4geDQwMSAtPiB4NDAwIChPanMuZmxvYXRfb2ZfanMgeDQwMSkpKXxdKVxuICAgIGxldCAob3Blbl8gOlxuICAgICAgdCAtPlxuICAgICAgICA/dXJsOnN0cmluZyAtPlxuICAgICAgICAgID9uYW1lOnN0cmluZyAtPiA/ZmVhdHVyZXM6c3RyaW5nIC0+ID9yZXBsYWNlOmJvb2wgLT4gdW5pdCAtPiB0KVxuICAgICAgPVxuICAgICAgZnVuIHg0MTIgLT5cbiAgICAgICAgZnVuID91cmw6eDQwMyAtPlxuICAgICAgICAgIGZ1biA/bmFtZTp4NDA0IC0+XG4gICAgICAgICAgICBmdW4gP2ZlYXR1cmVzOng0MDUgLT5cbiAgICAgICAgICAgICAgZnVuID9yZXBsYWNlOng0MDYgLT5cbiAgICAgICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgICAgICAgICAgKGxldCB4NDEzID0gdF90b19qcyB4NDEyIGluXG4gICAgICAgICAgICAgICAgICAgICBPanMuY2FsbCAoT2pzLmdldCB4NDEzIFwib3BlblwiKSBcImFwcGx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgW3x4NDEzOygobGV0IHg0MDcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJBcnJheVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3x8XSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDQwMyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDQxMSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg0MDcgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDQxMSl8XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4NDA0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NDEwIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDQwNyBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDEwKXxdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg0MDUgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg0MDkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4NDA3IFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0MDkpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDQwNiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDQwOCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg0MDcgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5ib29sX3RvX2pzIHg0MDgpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4NDA3KSl8XSlcbiAgICBsZXQgKGFsZXJ0IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg0MTUgLT5cbiAgICAgICAgZnVuIHg0MTQgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDE1KSBcImFsZXJ0XCIgW3woT2pzLnN0cmluZ190b19qcyB4NDE0KXxdKVxuICAgIGxldCAoc2Vzc2lvbl9zdG9yYWdlIDogdCAtPiBTdG9yYWdlLnQgb3B0aW9uKSA9XG4gICAgICBmdW4geDQxNiAtPlxuICAgICAgICBPanMub3B0aW9uX29mX2pzIFN0b3JhZ2UudF9vZl9qc1xuICAgICAgICAgIChPanMuZ2V0ICh0X3RvX2pzIHg0MTYpIFwic2Vzc2lvblN0b3JhZ2VcIilcbiAgICBsZXQgKGxvY2FsX3N0b3JhZ2UgOiB0IC0+IFN0b3JhZ2UudCBvcHRpb24pID1cbiAgICAgIGZ1biB4NDE4IC0+XG4gICAgICAgIE9qcy5vcHRpb25fb2ZfanMgU3RvcmFnZS50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXQgKHRfdG9fanMgeDQxOCkgXCJsb2NhbFN0b3JhZ2VcIilcbiAgICBsZXQgKGlubmVyX3dpZHRoIDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHg0MjAgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg0MjApIFwiaW5uZXJXaWR0aFwiKVxuICAgIGxldCAoaW5uZXJfaGVpZ2h0IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuIHg0MjEgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg0MjEpIFwiaW5uZXJIZWlnaHRcIilcbiAgICBsZXQgKHBhZ2VfeF9vZmZzZXQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg0MjIgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NDIyKSBcInBhZ2VYT2Zmc2V0XCIpXG4gICAgbGV0IChwYWdlX3lfb2Zmc2V0IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biB4NDIzIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDQyMykgXCJwYWdlWU9mZnNldFwiKVxuICAgIGxldCAoc2Nyb2xsX2J5IDogdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NDI2IC0+XG4gICAgICAgIGZ1biB4NDI0IC0+XG4gICAgICAgICAgZnVuIHg0MjUgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQyNikgXCJzY3JvbGxCeVwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5pbnRfdG9fanMgeDQyNCk7KE9qcy5pbnRfdG9fanMgeDQyNSl8XSlcbiAgICBsZXQgKHNjcm9sbF90byA6IHQgLT4gaW50IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4geDQyOSAtPlxuICAgICAgICBmdW4geDQyNyAtPlxuICAgICAgICAgIGZ1biB4NDI4IC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0MjkpIFwic2Nyb2xsVG9cIlxuICAgICAgICAgICAgICAgICBbfChPanMuaW50X3RvX2pzIHg0MjcpOyhPanMuaW50X3RvX2pzIHg0MjgpfF0pXG4gICAgbGV0IChoaXN0b3J5IDogdCAtPiBIaXN0b3J5LnQpID1cbiAgICAgIGZ1biB4NDMwIC0+IEhpc3RvcnkudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NDMwKSBcImhpc3RvcnlcIilcbiAgICBsZXQgKGxvY2F0aW9uIDogdCAtPiBMb2NhdGlvbi50KSA9XG4gICAgICBmdW4geDQzMSAtPiBMb2NhdGlvbi50X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg0MzEpIFwibG9jYXRpb25cIilcbiAgICBsZXQgKGdldF9jb21wdXRlZF9zdHlsZSA6IHQgLT4gRWxlbWVudC50IC0+IFN0eWxlLnQpID1cbiAgICAgIGZ1biB4NDMzIC0+XG4gICAgICAgIGZ1biB4NDMyIC0+XG4gICAgICAgICAgU3R5bGUudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0MzMpIFwiZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgICAgICAgICAgICBbfChFbGVtZW50LnRfdG9fanMgeDQzMil8XSlcbiAgZW5kXG5tb2R1bGUgSUZyYW1lID1cbiAgc3RydWN0XG4gICAgbGV0IChjb250ZW50X3dpbmRvdyA6IEVsZW1lbnQudCAtPiBXaW5kb3cudCBvcHRpb24pID1cbiAgICAgIGZ1biB4NDM0IC0+XG4gICAgICAgIE9qcy5vcHRpb25fb2ZfanMgV2luZG93LnRfb2ZfanNcbiAgICAgICAgICAoT2pzLmdldCAoRWxlbWVudC50X3RvX2pzIHg0MzQpIFwiY29udGVudFdpbmRvd1wiKVxuICAgIGxldCAoY29udGVudF9kb2N1bWVudCA6IEVsZW1lbnQudCAtPiBEb2N1bWVudC50IG9wdGlvbikgPVxuICAgICAgZnVuIHg0MzYgLT5cbiAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBEb2N1bWVudC50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXQgKEVsZW1lbnQudF90b19qcyB4NDM2KSBcImNvbnRlbnREb2N1bWVudFwiKVxuICBlbmRcbm1vZHVsZSBKU09OID1cbiAgc3RydWN0XG4gICAgbGV0IChwYXJzZSA6IHN0cmluZyAtPiBPanMudCkgPVxuICAgICAgZnVuIHg0MzggLT5cbiAgICAgICAgT2pzLmNhbGwgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIkpTT05cIikgXCJwYXJzZVwiXG4gICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDM4KXxdXG4gICAgbGV0IChzdHJpbmdpZnkgOiBPanMudCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4NDM5IC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIkpTT05cIikgXCJzdHJpbmdpZnlcIiBbfHg0Mzl8XSlcbiAgZW5kXG5tb2R1bGUgRmlsZVJlYWRlciA9XG4gIHN0cnVjdFxuICAgIHR5cGUgc3RhdGUgPVxuICAgICAgfCBFbXB0eSBcbiAgICAgIHwgTG9hZGluZyBcbiAgICAgIHwgRG9uZSBcbiAgICBsZXQgcmVjIChzdGF0ZV9vZl9qcyA6IE9qcy50IC0+IHN0YXRlKSA9XG4gICAgICBmdW4geDQ0MSAtPlxuICAgICAgICBsZXQgeDQ0MiA9IHg0NDEgaW5cbiAgICAgICAgbWF0Y2ggT2pzLmludF9vZl9qcyB4NDQyIHdpdGhcbiAgICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICAgIHwgMSAtPiBMb2FkaW5nXG4gICAgICAgIHwgMiAtPiBEb25lXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBhbmQgKHN0YXRlX3RvX2pzIDogc3RhdGUgLT4gT2pzLnQpID1cbiAgICAgIGZ1biB4NDQwIC0+XG4gICAgICAgIG1hdGNoIHg0NDAgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IE9qcy5pbnRfdG9fanMgMFxuICAgICAgICB8IExvYWRpbmcgLT4gT2pzLmludF90b19qcyAxXG4gICAgICAgIHwgRG9uZSAtPiBPanMuaW50X3RvX2pzIDJcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NDQ0IC0+IHg0NDRcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4NDQzIC0+IHg0NDNcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICBsZXQgKG5ld19maWxlX3JlYWRlciA6IHVuaXQgLT4gdCkgPVxuICAgICAgZnVuICgpIC0+IHRfb2ZfanMgKE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJGaWxlUmVhZGVyXCIpIFt8fF0pXG4gICAgbGV0IChyZWFkeV9zdGF0ZSA6IHQgLT4gc3RhdGUpID1cbiAgICAgIGZ1biB4NDQ3IC0+IHN0YXRlX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg0NDcpIFwicmVhZHlTdGF0ZVwiKVxuICAgIGxldCAocmVzdWx0IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4NDQ4IC0+IE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDQ0OCkgXCJyZXN1bHRcIilcbiAgICBsZXQgKHNldF9vbmxvYWQgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NDQ5IC0+XG4gICAgICAgIGZ1biB4NDUwIC0+XG4gICAgICAgICAgT2pzLnNldCAodF90b19qcyB4NDQ5KSBcIm9ubG9hZFwiXG4gICAgICAgICAgICAoT2pzLmZ1bl90b19qcyAxIChmdW4gXyAtPiB4NDUwICgpKSlcbiAgICBsZXQgKHJlYWRfYXNfdGV4dCA6IHQgLT4gRmlsZS50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NDUyIC0+XG4gICAgICAgIGZ1biB4NDUxIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ1MikgXCJyZWFkQXNUZXh0XCIgW3woRmlsZS50X3RvX2pzIHg0NTEpfF0pXG4gIGVuZFxubW9kdWxlIFhIUiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHg0NTQgLT4geDQ1NFxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHg0NTMgLT4geDQ1M1xuICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgIGxldCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gdF90b19qc1xuICAgIGxldCAoY3JlYXRlIDogdW5pdCAtPiB0KSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgdF9vZl9qcyAoT2pzLm5ld19vYmogKE9qcy5nZXQgT2pzLmdsb2JhbCBcIlhNTEh0dHBSZXF1ZXN0XCIpIFt8fF0pXG4gICAgbGV0IChvcGVuXyA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDQ1OSAtPlxuICAgICAgICBmdW4geDQ1NyAtPlxuICAgICAgICAgIGZ1biB4NDU4IC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0NTkpIFwib3BlblwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDQ1Nyk7KE9qcy5zdHJpbmdfdG9fanMgeDQ1OCl8XSlcbiAgICBsZXQgKHNlbmQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDQ2MSAtPlxuICAgICAgICBmdW4geDQ2MCAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDQ2MSkgXCJzZW5kXCIgW3woT2pzLnN0cmluZ190b19qcyB4NDYwKXxdKVxuICAgIGxldCAoc2V0X3JlcXVlc3RfaGVhZGVyIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NDY0IC0+XG4gICAgICAgIGZ1biB4NDYyIC0+XG4gICAgICAgICAgZnVuIHg0NjMgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ2NCkgXCJzZXRSZXF1ZXN0SGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDYyKTsoT2pzLnN0cmluZ190b19qcyB4NDYzKXxdKVxuICAgIGxldCAoZ2V0X3Jlc3BvbnNlX2hlYWRlciA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb24pID1cbiAgICAgIGZ1biB4NDY2IC0+XG4gICAgICAgIGZ1biB4NDY1IC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ2NikgXCJnZXRSZXNwb25zZUhlYWRlclwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0NjUpfF0pXG4gICAgbGV0IChvdmVycmlkZV9taW1lX3R5cGUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDQ2OSAtPlxuICAgICAgICBmdW4geDQ2OCAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0NjkpIFwib3ZlcnJpZGVNaW1lVHlwZVwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0NjgpfF0pXG4gICAgbGV0IChzZXRfd2l0aF9jcmVkZW50aWFscyA6IHQgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4geDQ3MCAtPlxuICAgICAgICBmdW4geDQ3MSAtPlxuICAgICAgICAgIE9qcy5zZXQgKHRfdG9fanMgeDQ3MCkgXCJ3aXRoQ3JlZGVudGlhbHNcIiAoT2pzLmJvb2xfdG9fanMgeDQ3MSlcbiAgICB0eXBlIHJlYWR5X3N0YXRlID1cbiAgICAgIHwgVW5zZW50IFxuICAgICAgfCBPcGVuZWQgXG4gICAgICB8IEhlYWRlcnNfcmVjZWl2ZWQgXG4gICAgICB8IExvYWRpbmcgXG4gICAgICB8IERvbmUgXG4gICAgICB8IE90aGVyIG9mIGludCBcbiAgICBsZXQgcmVjIChyZWFkeV9zdGF0ZV9vZl9qcyA6IE9qcy50IC0+IHJlYWR5X3N0YXRlKSA9XG4gICAgICBmdW4geDQ3NCAtPlxuICAgICAgICBsZXQgeDQ3NSA9IHg0NzQgaW5cbiAgICAgICAgbWF0Y2ggT2pzLmludF9vZl9qcyB4NDc1IHdpdGhcbiAgICAgICAgfCAwIC0+IFVuc2VudFxuICAgICAgICB8IDEgLT4gT3BlbmVkXG4gICAgICAgIHwgMiAtPiBIZWFkZXJzX3JlY2VpdmVkXG4gICAgICAgIHwgMyAtPiBMb2FkaW5nXG4gICAgICAgIHwgNCAtPiBEb25lXG4gICAgICAgIHwgeDQ3NiAtPiBPdGhlciB4NDc2XG4gICAgYW5kIChyZWFkeV9zdGF0ZV90b19qcyA6IHJlYWR5X3N0YXRlIC0+IE9qcy50KSA9XG4gICAgICBmdW4geDQ3MiAtPlxuICAgICAgICBtYXRjaCB4NDcyIHdpdGhcbiAgICAgICAgfCBVbnNlbnQgLT4gT2pzLmludF90b19qcyAwXG4gICAgICAgIHwgT3BlbmVkIC0+IE9qcy5pbnRfdG9fanMgMVxuICAgICAgICB8IEhlYWRlcnNfcmVjZWl2ZWQgLT4gT2pzLmludF90b19qcyAyXG4gICAgICAgIHwgTG9hZGluZyAtPiBPanMuaW50X3RvX2pzIDNcbiAgICAgICAgfCBEb25lIC0+IE9qcy5pbnRfdG9fanMgNFxuICAgICAgICB8IE90aGVyIHg0NzMgLT4gT2pzLmludF90b19qcyB4NDczXG4gICAgbGV0IChzdGF0dXMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuIHg0NzcgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NDc3KSBcInN0YXR1c1wiKVxuICAgIGxldCAocmVhZHlfc3RhdGUgOiB0IC0+IHJlYWR5X3N0YXRlKSA9XG4gICAgICBmdW4geDQ3OCAtPiByZWFkeV9zdGF0ZV9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NDc4KSBcInJlYWR5U3RhdGVcIilcbiAgICBsZXQgKHJlc3BvbnNlX3RleHQgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHg0NzkgLT4gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NDc5KSBcInJlc3BvbnNlVGV4dFwiKVxuICAgIGxldCAoc2V0X29ucmVhZHlzdGF0ZWNoYW5nZSA6IHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg0ODAgLT5cbiAgICAgICAgZnVuIHg0ODEgLT5cbiAgICAgICAgICBPanMuc2V0ICh0X3RvX2pzIHg0ODApIFwib25yZWFkeXN0YXRlY2hhbmdlXCJcbiAgICAgICAgICAgIChPanMuZnVuX3RvX2pzIDEgKGZ1biBfIC0+IHg0ODEgKCkpKVxuICBlbmRcbm1vZHVsZSBXZWJTb2NrZXQgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NDgzIC0+IHg0ODNcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4NDgyIC0+IHg0ODJcbiAgICBsZXQgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IHRfb2ZfanNcbiAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICB0eXBlIHJlYWR5X3N0YXRlID1cbiAgICAgIHwgQ29ubmVjdGluZyBcbiAgICAgIHwgT3BlbiBcbiAgICAgIHwgQ2xvc2luZyBcbiAgICAgIHwgQ2xvc2VkIFxuICAgIGxldCByZWMgKHJlYWR5X3N0YXRlX29mX2pzIDogT2pzLnQgLT4gcmVhZHlfc3RhdGUpID1cbiAgICAgIGZ1biB4NDg3IC0+XG4gICAgICAgIGxldCB4NDg4ID0geDQ4NyBpblxuICAgICAgICBtYXRjaCBPanMuaW50X29mX2pzIHg0ODggd2l0aFxuICAgICAgICB8IDAgLT4gQ29ubmVjdGluZ1xuICAgICAgICB8IDEgLT4gT3BlblxuICAgICAgICB8IDIgLT4gQ2xvc2luZ1xuICAgICAgICB8IDMgLT4gQ2xvc2VkXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBhbmQgKHJlYWR5X3N0YXRlX3RvX2pzIDogcmVhZHlfc3RhdGUgLT4gT2pzLnQpID1cbiAgICAgIGZ1biB4NDg2IC0+XG4gICAgICAgIG1hdGNoIHg0ODYgd2l0aFxuICAgICAgICB8IENvbm5lY3RpbmcgLT4gT2pzLmludF90b19qcyAwXG4gICAgICAgIHwgT3BlbiAtPiBPanMuaW50X3RvX2pzIDFcbiAgICAgICAgfCBDbG9zaW5nIC0+IE9qcy5pbnRfdG9fanMgMlxuICAgICAgICB8IENsb3NlZCAtPiBPanMuaW50X3RvX2pzIDNcbiAgICBsZXQgKGNyZWF0ZSA6IHN0cmluZyAtPiA/cHJvdG9jb2xzOnN0cmluZyBsaXN0IC0+IHVuaXQgLT4gdCkgPVxuICAgICAgZnVuIHg0ODkgLT5cbiAgICAgICAgZnVuID9wcm90b2NvbHM6eDQ5MCAtPlxuICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgdF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLm5ld19vYmpfYXJyIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJXZWJTb2NrZXRcIilcbiAgICAgICAgICAgICAgICAgKGxldCB4NDkxID0gT2pzLm5ld19vYmogKE9qcy5nZXQgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFt8fF0gaW5cbiAgICAgICAgICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgeDQ5MSBcInB1c2hcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg0ODkpfF0pO1xuICAgICAgICAgICAgICAgICAgKG1hdGNoIHg0OTAgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NDkyIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4NDkxIFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmxpc3RfdG9fanMgT2pzLnN0cmluZ190b19qcyB4NDkyKXxdKVxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICB4NDkxKSlcbiAgICBsZXQgKHNlbmQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDQ5NSAtPlxuICAgICAgICBmdW4geDQ5NCAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDQ5NSkgXCJzZW5kXCIgW3woT2pzLnN0cmluZ190b19qcyB4NDk0KXxdKVxuICAgIGxldCAoY2xvc2UgOiB0IC0+ID9jb2RlOmludCAtPiA/cmVhc29uOnN0cmluZyAtPiB1bml0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTAxIC0+XG4gICAgICAgIGZ1biA/Y29kZTp4NDk2IC0+XG4gICAgICAgICAgZnVuID9yZWFzb246eDQ5NyAtPlxuICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChsZXQgeDUwMiA9IHRfdG9fanMgeDUwMSBpblxuICAgICAgICAgICAgICAgICBPanMuY2FsbCAoT2pzLmdldCB4NTAyIFwiY2xvc2VcIikgXCJhcHBseVwiXG4gICAgICAgICAgICAgICAgICAgW3x4NTAyOygobGV0IHg0OTggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLm5ld19vYmogKE9qcy5nZXQgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFt8fF0gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDQ5NiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NTAwIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg0OTggXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmludF90b19qcyB4NTAwKXxdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4NDk3IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg0OTkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDQ5OCBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0OTkpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDQ5OCkpfF0pXG4gICAgbGV0IChiaW5hcnlfdHlwZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4geDUwMyAtPiBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg1MDMpIFwiYmluYXJ5VHlwZVwiKVxuICAgIGxldCAoc2V0X2JpbmFyeV90eXBlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1MDQgLT5cbiAgICAgICAgZnVuIHg1MDUgLT5cbiAgICAgICAgICBPanMuc2V0ICh0X3RvX2pzIHg1MDQpIFwiYmluYXJ5VHlwZVwiIChPanMuc3RyaW5nX3RvX2pzIHg1MDUpXG4gICAgbGV0IChyZWFkeV9zdGF0ZSA6IHQgLT4gcmVhZHlfc3RhdGUpID1cbiAgICAgIGZ1biB4NTA2IC0+IHJlYWR5X3N0YXRlX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg1MDYpIFwicmVhZHlTdGF0ZVwiKVxuICAgIGxldCAoYWRkX2V2ZW50X2xpc3RlbmVyIDpcbiAgICAgIHQgLT4gc3RyaW5nIC0+IChFdmVudC50IC0+IHVuaXQpIC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1MTEgLT5cbiAgICAgICAgZnVuIHg1MDcgLT5cbiAgICAgICAgICBmdW4geDUwOCAtPlxuICAgICAgICAgICAgZnVuIHg1MTAgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1MTEpIFwiYWRkRXZlbnRMaXN0ZW5lclwiXG4gICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NTA3KTsoT2pzLmZ1bl90b19qcyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIHg1MDkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg1MDggKEV2ZW50LnRfb2ZfanMgeDUwOSkpKTsoXG4gICAgICAgICAgICAgICAgICAgICBPanMuYm9vbF90b19qcyB4NTEwKXxdKVxuICAgIG1vZHVsZSBDbG9zZUV2ZW50ID1cbiAgICAgIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBFdmVudC50XG4gICAgICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IEV2ZW50LnRfb2ZfanNcbiAgICAgICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBFdmVudC50X3RvX2pzXG4gICAgICAgIGxldCAoY29kZSA6IHQgLT4gaW50KSA9XG4gICAgICAgICAgZnVuIHg1MTQgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NTE0KSBcImNvZGVcIilcbiAgICAgIGVuZFxuICBlbmRcbmxldCAod2luZG93IDogV2luZG93LnQpID0gV2luZG93LnRfb2ZfanMgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIndpbmRvd1wiKVxubGV0IChkb2N1bWVudCA6IERvY3VtZW50LnQpID1cbiAgRG9jdW1lbnQudF9vZl9qcyAoT2pzLmdldCBPanMuZ2xvYmFsIFwiZG9jdW1lbnRcIilcbm1vZHVsZSBDYW52YXMgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGNvbnRleHQgPSBPanMudFxuICAgIGxldCByZWMgKGNvbnRleHRfb2ZfanMgOiBPanMudCAtPiBjb250ZXh0KSA9IGZ1biB4NTE2IC0+IHg1MTZcbiAgICBhbmQgKGNvbnRleHRfdG9fanMgOiBjb250ZXh0IC0+IE9qcy50KSA9IGZ1biB4NTE1IC0+IHg1MTVcbiAgICBsZXQgKGNvbnRleHRfb2ZfanMgOiBPanMudCAtPiBjb250ZXh0KSA9IGNvbnRleHRfb2ZfanNcbiAgICBsZXQgKGNvbnRleHRfdG9fanMgOiBjb250ZXh0IC0+IE9qcy50KSA9IGNvbnRleHRfdG9fanNcbiAgICB0eXBlIGdyYWRpZW50ID0gT2pzLnRcbiAgICBsZXQgcmVjIChncmFkaWVudF9vZl9qcyA6IE9qcy50IC0+IGdyYWRpZW50KSA9IGZ1biB4NTIwIC0+IHg1MjBcbiAgICBhbmQgKGdyYWRpZW50X3RvX2pzIDogZ3JhZGllbnQgLT4gT2pzLnQpID0gZnVuIHg1MTkgLT4geDUxOVxuICAgIGxldCAoZ3JhZGllbnRfb2ZfanMgOiBPanMudCAtPiBncmFkaWVudCkgPSBncmFkaWVudF9vZl9qc1xuICAgIGxldCAoZ3JhZGllbnRfdG9fanMgOiBncmFkaWVudCAtPiBPanMudCkgPSBncmFkaWVudF90b19qc1xuICAgIHR5cGUgY3NzX2NvbG9yID0gc3RyaW5nXG4gICAgbGV0IHJlYyAoY3NzX2NvbG9yX29mX2pzIDogT2pzLnQgLT4gY3NzX2NvbG9yKSA9IE9qcy5zdHJpbmdfb2ZfanNcbiAgICBhbmQgKGNzc19jb2xvcl90b19qcyA6IGNzc19jb2xvciAtPiBPanMudCkgPSBPanMuc3RyaW5nX3RvX2pzXG4gICAgdHlwZSBjb250ZXh0X2F0dHJpYnV0ZSA9IHtcbiAgICAgIGFscGhhOiBib29sIH1cbiAgICBsZXQgcmVjIChjb250ZXh0X2F0dHJpYnV0ZV9vZl9qcyA6IE9qcy50IC0+IGNvbnRleHRfYXR0cmlidXRlKSA9XG4gICAgICBmdW4geDUyNiAtPiB7IGFscGhhID0gKE9qcy5ib29sX29mX2pzIChPanMuZ2V0IHg1MjYgXCJhbHBoYVwiKSkgfVxuICAgIGFuZCAoY29udGV4dF9hdHRyaWJ1dGVfdG9fanMgOiBjb250ZXh0X2F0dHJpYnV0ZSAtPiBPanMudCkgPVxuICAgICAgZnVuIHg1MjUgLT4gT2pzLm9iaiBbfChcImFscGhhXCIsIChPanMuYm9vbF90b19qcyB4NTI1LmFscGhhKSl8XVxuICAgIGxldCAoZ2V0X2NvbnRleHRfaW50ZXJuYWwgOlxuICAgICAgRWxlbWVudC50IC0+IHN0cmluZyAtPiBjb250ZXh0X2F0dHJpYnV0ZSAtPiBjb250ZXh0IG9wdGlvbikgPVxuICAgICAgZnVuIHg1MjkgLT5cbiAgICAgICAgZnVuIHg1MjcgLT5cbiAgICAgICAgICBmdW4geDUyOCAtPlxuICAgICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBjb250ZXh0X29mX2pzXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoRWxlbWVudC50X3RvX2pzIHg1MjkpIFwiZ2V0Q29udGV4dFwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDUyNyk7KGNvbnRleHRfYXR0cmlidXRlX3RvX2pzIHg1MjgpfF0pXG4gICAgbGV0IGdldF9jb250ZXh0ID8oYWxwaGE9IHRydWUpICBjYW52YXMgPVxuICAgICAgZ2V0X2NvbnRleHRfaW50ZXJuYWwgY2FudmFzIFwiMmRcIiB7IGFscGhhIH1cbiAgICBsZXQgKHRvX2RhdGFfVVJMIDogRWxlbWVudC50IC0+IHN0cmluZykgPVxuICAgICAgZnVuIHg1MzEgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKEVsZW1lbnQudF90b19qcyB4NTMxKSBcInRvRGF0YVVSTFwiIFt8fF0pXG4gICAgbGV0IChzZXRfZmlsbF9zdHlsZSA6XG4gICAgICBjb250ZXh0IC0+IFsgYENvbG9yIG9mIGNzc19jb2xvciAgfCBgR3JhZGllbnQgb2YgZ3JhZGllbnQgXSAtPiB1bml0KSA9XG4gICAgICBmdW4geDUzMiAtPlxuICAgICAgICBmdW4geDUzMyAtPlxuICAgICAgICAgIE9qcy5zZXQgKGNvbnRleHRfdG9fanMgeDUzMikgXCJmaWxsU3R5bGVcIlxuICAgICAgICAgICAgKG1hdGNoIHg1MzMgd2l0aFxuICAgICAgICAgICAgIHwgYENvbG9yIHg1MzQgLT4gY3NzX2NvbG9yX3RvX2pzIHg1MzRcbiAgICAgICAgICAgICB8IGBHcmFkaWVudCB4NTM1IC0+IGdyYWRpZW50X3RvX2pzIHg1MzUpXG4gICAgbGV0IChzZXRfc3Ryb2tlX3N0eWxlIDpcbiAgICAgIGNvbnRleHQgLT4gWyBgQ29sb3Igb2YgY3NzX2NvbG9yICB8IGBHcmFkaWVudCBvZiBncmFkaWVudCBdIC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTM2IC0+XG4gICAgICAgIGZ1biB4NTM3IC0+XG4gICAgICAgICAgT2pzLnNldCAoY29udGV4dF90b19qcyB4NTM2KSBcInN0cm9rZVN0eWxlXCJcbiAgICAgICAgICAgIChtYXRjaCB4NTM3IHdpdGhcbiAgICAgICAgICAgICB8IGBDb2xvciB4NTM4IC0+IGNzc19jb2xvcl90b19qcyB4NTM4XG4gICAgICAgICAgICAgfCBgR3JhZGllbnQgeDUzOSAtPiBncmFkaWVudF90b19qcyB4NTM5KVxuICAgIGxldCAoc2V0X2xpbmVfd2lkdGggOiBjb250ZXh0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTQwIC0+XG4gICAgICAgIGZ1biB4NTQxIC0+XG4gICAgICAgICAgT2pzLnNldCAoY29udGV4dF90b19qcyB4NTQwKSBcImxpbmVXaWR0aFwiIChPanMuZmxvYXRfdG9fanMgeDU0MSlcbiAgICBsZXQgKGNyZWF0ZV9saW5lYXJfZ3JhZGllbnQgOlxuICAgICAgY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBncmFkaWVudCkgPVxuICAgICAgZnVuIHg1NDYgLT5cbiAgICAgICAgZnVuIHg1NDIgLT5cbiAgICAgICAgICBmdW4geDU0MyAtPlxuICAgICAgICAgICAgZnVuIHg1NDQgLT5cbiAgICAgICAgICAgICAgZnVuIHg1NDUgLT5cbiAgICAgICAgICAgICAgICBncmFkaWVudF9vZl9qc1xuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg1NDYpIFwiY3JlYXRlTGluZWFyR3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg1NDIpOyhPanMuZmxvYXRfdG9fanMgeDU0Myk7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDU0NCk7KE9qcy5mbG9hdF90b19qcyB4NTQ1KXxdKVxuICAgIGxldCAoYWRkX2NvbG9yX3N0b3AgOiBncmFkaWVudCAtPiBmbG9hdCAtPiBjc3NfY29sb3IgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1NDkgLT5cbiAgICAgICAgZnVuIHg1NDcgLT5cbiAgICAgICAgICBmdW4geDU0OCAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoZ3JhZGllbnRfdG9fanMgeDU0OSkgXCJhZGRDb2xvclN0b3BcIlxuICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDU0Nyk7KGNzc19jb2xvcl90b19qcyB4NTQ4KXxdKVxuICAgIGxldCAoYmVnaW5fcGF0aCA6IGNvbnRleHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1NTAgLT4gaWdub3JlIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTUwKSBcImJlZ2luUGF0aFwiIFt8fF0pXG4gICAgbGV0IChjbG9zZV9wYXRoIDogY29udGV4dCAtPiB1bml0KSA9XG4gICAgICBmdW4geDU1MSAtPiBpZ25vcmUgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg1NTEpIFwiY2xvc2VQYXRoXCIgW3x8XSlcbiAgICBsZXQgKGFyYyA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdClcbiAgICAgID1cbiAgICAgIGZ1biB4NTU3IC0+XG4gICAgICAgIGZ1biB4NTUyIC0+XG4gICAgICAgICAgZnVuIHg1NTMgLT5cbiAgICAgICAgICAgIGZ1biB4NTU0IC0+XG4gICAgICAgICAgICAgIGZ1biB4NTU1IC0+XG4gICAgICAgICAgICAgICAgZnVuIHg1NTYgLT5cbiAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDU1NykgXCJhcmNcIlxuICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDU1Mik7KE9qcy5mbG9hdF90b19qcyB4NTUzKTsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgT2pzLmZsb2F0X3RvX2pzIHg1NTQpOyhPanMuZmxvYXRfdG9fanMgeDU1NSk7KFxuICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5mbG9hdF90b19qcyB4NTU2KXxdKVxuICAgIGxldCAobW92ZV90byA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1NjAgLT5cbiAgICAgICAgZnVuIHg1NTggLT5cbiAgICAgICAgICBmdW4geDU1OSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTYwKSBcIm1vdmVUb1wiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4NTU4KTsoT2pzLmZsb2F0X3RvX2pzIHg1NTkpfF0pXG4gICAgbGV0IChsaW5lX3RvIDogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDU2MyAtPlxuICAgICAgICBmdW4geDU2MSAtPlxuICAgICAgICAgIGZ1biB4NTYyIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg1NjMpIFwibGluZVRvXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg1NjEpOyhPanMuZmxvYXRfdG9fanMgeDU2Mil8XSlcbiAgICBsZXQgKGZpbGwgOiBjb250ZXh0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTY0IC0+IGlnbm9yZSAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDU2NCkgXCJmaWxsXCIgW3x8XSlcbiAgICBsZXQgKHN0cm9rZSA6IGNvbnRleHQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1NjUgLT4gaWdub3JlIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTY1KSBcInN0cm9rZVwiIFt8fF0pXG4gICAgbGV0IChzdHJva2VfcmVjdCA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1NzAgLT5cbiAgICAgICAgZnVuIHg1NjYgLT5cbiAgICAgICAgICBmdW4geDU2NyAtPlxuICAgICAgICAgICAgZnVuIHg1NjggLT5cbiAgICAgICAgICAgICAgZnVuIHg1NjkgLT5cbiAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTcwKSBcInN0cm9rZVJlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg1NjYpOyhPanMuZmxvYXRfdG9fanMgeDU2Nyk7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDU2OCk7KE9qcy5mbG9hdF90b19qcyB4NTY5KXxdKVxuICAgIGxldCAoZmlsbF9yZWN0IDogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4geDU3NSAtPlxuICAgICAgICBmdW4geDU3MSAtPlxuICAgICAgICAgIGZ1biB4NTcyIC0+XG4gICAgICAgICAgICBmdW4geDU3MyAtPlxuICAgICAgICAgICAgICBmdW4geDU3NCAtPlxuICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg1NzUpIFwiZmlsbFJlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg1NzEpOyhPanMuZmxvYXRfdG9fanMgeDU3Mik7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDU3Myk7KE9qcy5mbG9hdF90b19qcyB4NTc0KXxdKVxuICAgIGxldCAoc2V0X2ZvbnQgOiBjb250ZXh0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4geDU3NiAtPlxuICAgICAgICBmdW4geDU3NyAtPlxuICAgICAgICAgIE9qcy5zZXQgKGNvbnRleHRfdG9fanMgeDU3NikgXCJmb250XCIgKE9qcy5zdHJpbmdfdG9fanMgeDU3NylcbiAgICBsZXQgKGZpbGxfdGV4dCA6IGNvbnRleHQgLT4gc3RyaW5nIC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTgxIC0+XG4gICAgICAgIGZ1biB4NTc4IC0+XG4gICAgICAgICAgZnVuIHg1NzkgLT5cbiAgICAgICAgICAgIGZ1biB4NTgwIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTgxKSBcImZpbGxUZXh0XCJcbiAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg1NzgpOyhPanMuZmxvYXRfdG9fanMgeDU3OSk7KFxuICAgICAgICAgICAgICAgICAgICAgT2pzLmZsb2F0X3RvX2pzIHg1ODApfF0pXG4gICAgbGV0IChzdHJva2VfdGV4dCA6IGNvbnRleHQgLT4gc3RyaW5nIC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NTg1IC0+XG4gICAgICAgIGZ1biB4NTgyIC0+XG4gICAgICAgICAgZnVuIHg1ODMgLT5cbiAgICAgICAgICAgIGZ1biB4NTg0IC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTg1KSBcInN0cm9rZVRleHRcIlxuICAgICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDU4Mik7KE9qcy5mbG9hdF90b19qcyB4NTgzKTsoXG4gICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDU4NCl8XSlcbiAgICBtb2R1bGUgVGV4dE1ldHJpY3MgPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NTg3IC0+IHg1ODdcbiAgICAgICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDU4NiAtPiB4NTg2XG4gICAgICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgICAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICAgICAgbGV0ICh3aWR0aCA6IHQgLT4gZmxvYXQpID1cbiAgICAgICAgICBmdW4geDU5MCAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDU5MCkgXCJ3aWR0aFwiKVxuICAgICAgZW5kXG4gICAgbGV0IChtZWFzdXJlX3RleHQgOiBjb250ZXh0IC0+IHN0cmluZyAtPiBUZXh0TWV0cmljcy50KSA9XG4gICAgICBmdW4geDU5MiAtPlxuICAgICAgICBmdW4geDU5MSAtPlxuICAgICAgICAgIFRleHRNZXRyaWNzLnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTkyKSBcIm1lYXN1cmVUZXh0XCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDU5MSl8XSlcbiAgICBsZXQgKHJvdGF0ZSA6IGNvbnRleHQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1OTQgLT5cbiAgICAgICAgZnVuIHg1OTMgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTk0KSBcInJvdGF0ZVwiXG4gICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDU5Myl8XSlcbiAgICBsZXQgKHRyYW5zbGF0ZSA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg1OTcgLT5cbiAgICAgICAgZnVuIHg1OTUgLT5cbiAgICAgICAgICBmdW4geDU5NiAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NTk3KSBcInRyYW5zbGF0ZVwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4NTk1KTsoT2pzLmZsb2F0X3RvX2pzIHg1OTYpfF0pXG4gICAgbGV0IChzY2FsZSA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg2MDAgLT5cbiAgICAgICAgZnVuIHg1OTggLT5cbiAgICAgICAgICBmdW4geDU5OSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NjAwKSBcInNjYWxlXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg1OTgpOyhPanMuZmxvYXRfdG9fanMgeDU5OSl8XSlcbiAgICBsZXQgKGNsZWFyX3JlY3QgOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NjA1IC0+XG4gICAgICAgIGZ1biB4NjAxIC0+XG4gICAgICAgICAgZnVuIHg2MDIgLT5cbiAgICAgICAgICAgIGZ1biB4NjAzIC0+XG4gICAgICAgICAgICAgIGZ1biB4NjA0IC0+XG4gICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDYwNSkgXCJjbGVhclJlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg2MDEpOyhPanMuZmxvYXRfdG9fanMgeDYwMik7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDYwMyk7KE9qcy5mbG9hdF90b19qcyB4NjA0KXxdKVxuICBlbmRcbm1vZHVsZSBQZXJmb3JtYW5jZSA9XG4gIHN0cnVjdFxuICAgIGxldCAobm93IDogdW5pdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICgpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qc1xuICAgICAgICAgIChPanMuY2FsbCAoT2pzLmdldCBPanMuZ2xvYmFsIFwicGVyZm9ybWFuY2VcIikgXCJub3dcIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBDb25zb2xlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDYwNyAtPiB4NjA3XG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDYwNiAtPiB4NjA2XG4gICAgbGV0IChsb2cgOiB0IC0+IE9qcy50IC0+IHVuaXQpID1cbiAgICAgIGZ1biB4NjA5IC0+IGZ1biB4NjA4IC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDYwOSkgXCJsb2dcIiBbfHg2MDh8XSlcbiAgZW5kXG5sZXQgKGNvbnNvbGUgOiBDb25zb2xlLnQpID0gQ29uc29sZS50X29mX2pzIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJjb25zb2xlXCIpXG5tb2R1bGUgQXJyYXlCdWZmZXIgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NjExIC0+IHg2MTFcbiAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4NjEwIC0+IHg2MTBcbiAgICBsZXQgKGNyZWF0ZSA6IGludCAtPiB0KSA9XG4gICAgICBmdW4geDYxMiAtPlxuICAgICAgICB0X29mX2pzXG4gICAgICAgICAgKE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJBcnJheUJ1ZmZlclwiKVxuICAgICAgICAgICAgIFt8KE9qcy5pbnRfdG9fanMgeDYxMil8XSlcbiAgZW5kXG5tb2R1bGUgVWludDhBcnJheSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHg2MTQgLT4geDYxNFxuICAgIGFuZCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gZnVuIHg2MTMgLT4geDYxM1xuICAgIGxldCAoZnJvbV9idWZmZXIgOiBBcnJheUJ1ZmZlci50IC0+IHQpID1cbiAgICAgIGZ1biB4NjE1IC0+XG4gICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAoT2pzLm5ld19vYmogKE9qcy5nZXQgT2pzLmdsb2JhbCBcIlVpbnQ4QXJyYXlcIilcbiAgICAgICAgICAgICBbfChBcnJheUJ1ZmZlci50X3RvX2pzIHg2MTUpfF0pXG4gICAgbGV0IChzZXQgOiB0IC0+IGludCBhcnJheSAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg2MTkgLT5cbiAgICAgICAgZnVuIHg2MTYgLT5cbiAgICAgICAgICBmdW4geDYxOCAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjE5KSBcInNldFwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5hcnJheV90b19qcyBPanMuaW50X3RvX2pzIHg2MTYpOyhPanMuaW50X3RvX2pzIHg2MTgpfF0pXG4gIGVuZFxubW9kdWxlIEJsb2IgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIG9wdGlvbnMgPSBPanMudFxuICAgIGxldCByZWMgKG9wdGlvbnNfb2ZfanMgOiBPanMudCAtPiBvcHRpb25zKSA9IGZ1biB4NjIxIC0+IHg2MjFcbiAgICBhbmQgKG9wdGlvbnNfdG9fanMgOiBvcHRpb25zIC0+IE9qcy50KSA9IGZ1biB4NjIwIC0+IHg2MjBcbiAgICBsZXQgKG9wdGlvbnMgOiA/dHlwZV86c3RyaW5nIC0+ID9lbmRpbmdzOnN0cmluZyAtPiB1bml0IC0+IG9wdGlvbnMpID1cbiAgICAgIGZ1biA/dHlwZV86eDYyMiAtPlxuICAgICAgICBmdW4gP2VuZGluZ3M6eDYyMyAtPlxuICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgbGV0IHg2MjQgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAobWF0Y2ggeDYyMiB3aXRoXG4gICAgICAgICAgICAgfCBTb21lIHg2MjYgLT4gT2pzLnNldCB4NjI0IFwidHlwZVwiIChPanMuc3RyaW5nX3RvX2pzIHg2MjYpXG4gICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgIChtYXRjaCB4NjIzIHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgeDYyNSAtPiBPanMuc2V0IHg2MjQgXCJlbmRpbmdzXCIgKE9qcy5zdHJpbmdfdG9fanMgeDYyNSlcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgb3B0aW9uc19vZl9qcyB4NjI0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSBmdW4geDYyOCAtPiB4NjI4XG4gICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDYyNyAtPiB4NjI3XG4gICAgbGV0IChjcmVhdGUgOlxuICAgICAgWyBgQXJyYXlCdWZmZXIgb2YgQXJyYXlCdWZmZXIudCBdIGxpc3QgLT4gP29wdGlvbnM6b3B0aW9ucyAtPiB1bml0IC0+IHQpXG4gICAgICA9XG4gICAgICBmdW4geDYyOSAtPlxuICAgICAgICBmdW4gP29wdGlvbnM6eDYzMCAtPlxuICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgdF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLm5ld19vYmpfYXJyIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJCbG9iXCIpXG4gICAgICAgICAgICAgICAgIChsZXQgeDYzMSA9IE9qcy5uZXdfb2JqIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJBcnJheVwiKSBbfHxdIGluXG4gICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg2MzEgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmxpc3RfdG9fanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIHg2MzMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCB4NjMzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGBBcnJheUJ1ZmZlciB4NjM0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfdG9fanMgeDYzNCkgeDYyOSl8XSk7XG4gICAgICAgICAgICAgICAgICAobWF0Y2ggeDYzMCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBTb21lIHg2MzIgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlIChPanMuY2FsbCB4NjMxIFwicHVzaFwiIFt8KG9wdGlvbnNfdG9fanMgeDYzMil8XSlcbiAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgeDYzMSkpXG4gIGVuZFxubW9kdWxlIE9iamVjdFVSTCA9XG4gIHN0cnVjdFxuICAgIGxldCAob2ZfYmxvYiA6IEJsb2IudCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biB4NjM1IC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXQgT2pzLmdsb2JhbCBcIlVSTFwiKSBcImNyZWF0ZU9iamVjdFVSTFwiXG4gICAgICAgICAgICAgW3woQmxvYi50X3RvX2pzIHg2MzUpfF0pXG4gICAgbGV0IChyZXZva2UgOiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuIHg2MzYgLT5cbiAgICAgICAgaWdub3JlXG4gICAgICAgICAgKE9qcy5jYWxsIChPanMuZ2V0IE9qcy5nbG9iYWwgXCJVUkxcIikgXCJyZXZva2VPYmplY3RVUkxcIlxuICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDYzNil8XSlcbiAgZW5kXG5tb2R1bGUgU3ZnID1cbiAgc3RydWN0XG4gICAgbW9kdWxlIExlbmd0aCA9XG4gICAgICBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHg2MzggLT4geDYzOFxuICAgICAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4NjM3IC0+IHg2MzdcbiAgICAgICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgICAgIGxldCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gdF90b19qc1xuICAgICAgICBsZXQgKHVuaXRfdHlwZSA6IHQgLT4gaW50KSA9XG4gICAgICAgICAgZnVuIHg2NDEgLT4gT2pzLmludF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NjQxKSBcInVuaXRUeXBlXCIpXG4gICAgICAgIGxldCAodmFsdWUgOiB0IC0+IGZsb2F0KSA9XG4gICAgICAgICAgZnVuIHg2NDIgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NDIpIFwidmFsdWVcIilcbiAgICAgICAgbGV0ICh2YWx1ZV9hc19zdHJpbmcgOiB0IC0+IHN0cmluZykgPVxuICAgICAgICAgIGZ1biB4NjQzIC0+XG4gICAgICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NDMpIFwidmFsdWVBc1N0cmluZ1wiKVxuICAgICAgICBsZXQgKHZhbHVlX2luX3NwZWNpZmllZF91bml0cyA6IHQgLT4gZmxvYXQpID1cbiAgICAgICAgICBmdW4geDY0NCAtPlxuICAgICAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NDQpIFwidmFsdWVJblNwZWNpZmllZFVuaXRzXCIpXG4gICAgICBlbmRcbiAgICBtb2R1bGUgQW5pbWF0ZWRMZW5ndGggPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NjQ2IC0+IHg2NDZcbiAgICAgICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDY0NSAtPiB4NjQ1XG4gICAgICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgICAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICAgICAgbGV0IChhbmltX3ZhbCA6IHQgLT4gTGVuZ3RoLnQpID1cbiAgICAgICAgICBmdW4geDY0OSAtPiBMZW5ndGgudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NjQ5KSBcImFuaW1WYWxcIilcbiAgICAgICAgbGV0IChiYXNlX3ZhbCA6IHQgLT4gTGVuZ3RoLnQpID1cbiAgICAgICAgICBmdW4geDY1MCAtPiBMZW5ndGgudF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NjUwKSBcImJhc2VWYWxcIilcbiAgICAgIGVuZFxuICAgIHR5cGUgcGF0aF9zZWdfdHlwZSA9XG4gICAgICB8IFVua25vd24gXG4gICAgICB8IENsb3NlX3BhdGggXG4gICAgICB8IE1vdmV0b19hYnMgXG4gICAgICB8IE1vdmV0b19yZWwgXG4gICAgICB8IExpbmV0b19hYnMgXG4gICAgICB8IExpbmV0b19yZWwgXG4gICAgICB8IEN1cnZldG9fY3ViaWNfYWJzIFxuICAgICAgfCBDdXJ2ZXRvX2N1YmljX3JlbCBcbiAgICAgIHwgQ3VydmV0b19xdWFkcmF0aWNfYWJzIFxuICAgICAgfCBDdXJ2ZXRvX3F1YWRyYXRpY19yZWwgXG4gICAgbGV0IHJlYyAocGF0aF9zZWdfdHlwZV9vZl9qcyA6IE9qcy50IC0+IHBhdGhfc2VnX3R5cGUpID1cbiAgICAgIGZ1biB4NjUyIC0+XG4gICAgICAgIGxldCB4NjUzID0geDY1MiBpblxuICAgICAgICBtYXRjaCBPanMuaW50X29mX2pzIHg2NTMgd2l0aFxuICAgICAgICB8IDAgLT4gVW5rbm93blxuICAgICAgICB8IDEgLT4gQ2xvc2VfcGF0aFxuICAgICAgICB8IDIgLT4gTW92ZXRvX2Fic1xuICAgICAgICB8IDMgLT4gTW92ZXRvX3JlbFxuICAgICAgICB8IDQgLT4gTGluZXRvX2Fic1xuICAgICAgICB8IDUgLT4gTGluZXRvX3JlbFxuICAgICAgICB8IDYgLT4gQ3VydmV0b19jdWJpY19hYnNcbiAgICAgICAgfCA3IC0+IEN1cnZldG9fY3ViaWNfcmVsXG4gICAgICAgIHwgOCAtPiBDdXJ2ZXRvX3F1YWRyYXRpY19hYnNcbiAgICAgICAgfCA5IC0+IEN1cnZldG9fcXVhZHJhdGljX3JlbFxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgYW5kIChwYXRoX3NlZ190eXBlX3RvX2pzIDogcGF0aF9zZWdfdHlwZSAtPiBPanMudCkgPVxuICAgICAgZnVuIHg2NTEgLT5cbiAgICAgICAgbWF0Y2ggeDY1MSB3aXRoXG4gICAgICAgIHwgVW5rbm93biAtPiBPanMuaW50X3RvX2pzIDBcbiAgICAgICAgfCBDbG9zZV9wYXRoIC0+IE9qcy5pbnRfdG9fanMgMVxuICAgICAgICB8IE1vdmV0b19hYnMgLT4gT2pzLmludF90b19qcyAyXG4gICAgICAgIHwgTW92ZXRvX3JlbCAtPiBPanMuaW50X3RvX2pzIDNcbiAgICAgICAgfCBMaW5ldG9fYWJzIC0+IE9qcy5pbnRfdG9fanMgNFxuICAgICAgICB8IExpbmV0b19yZWwgLT4gT2pzLmludF90b19qcyA1XG4gICAgICAgIHwgQ3VydmV0b19jdWJpY19hYnMgLT4gT2pzLmludF90b19qcyA2XG4gICAgICAgIHwgQ3VydmV0b19jdWJpY19yZWwgLT4gT2pzLmludF90b19qcyA3XG4gICAgICAgIHwgQ3VydmV0b19xdWFkcmF0aWNfYWJzIC0+IE9qcy5pbnRfdG9fanMgOFxuICAgICAgICB8IEN1cnZldG9fcXVhZHJhdGljX3JlbCAtPiBPanMuaW50X3RvX2pzIDlcbiAgICBtb2R1bGUgUGF0aFNlZyA9XG4gICAgICBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gZnVuIHg2NTUgLT4geDY1NVxuICAgICAgICBhbmQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IGZ1biB4NjU0IC0+IHg2NTRcbiAgICAgICAgbGV0ICh0X29mX2pzIDogT2pzLnQgLT4gdCkgPSB0X29mX2pzXG4gICAgICAgIGxldCAodF90b19qcyA6IHQgLT4gT2pzLnQpID0gdF90b19qc1xuICAgICAgICBsZXQgKHggOiB0IC0+IGZsb2F0KSA9XG4gICAgICAgICAgZnVuIHg2NTggLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NTgpIFwieFwiKVxuICAgICAgICBsZXQgKHkgOiB0IC0+IGZsb2F0KSA9XG4gICAgICAgICAgZnVuIHg2NTkgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NTkpIFwieVwiKVxuICAgICAgICBsZXQgKHgxIDogdCAtPiBmbG9hdCkgPVxuICAgICAgICAgIGZ1biB4NjYwIC0+IE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NjYwKSBcIngxXCIpXG4gICAgICAgIGxldCAoeTEgOiB0IC0+IGZsb2F0KSA9XG4gICAgICAgICAgZnVuIHg2NjEgLT4gT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NjEpIFwieTFcIilcbiAgICAgICAgbGV0ICh4MiA6IHQgLT4gZmxvYXQpID1cbiAgICAgICAgICBmdW4geDY2MiAtPiBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDY2MikgXCJ4MlwiKVxuICAgICAgICBsZXQgKHkyIDogdCAtPiBmbG9hdCkgPVxuICAgICAgICAgIGZ1biB4NjYzIC0+IE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldCAodF90b19qcyB4NjYzKSBcInkyXCIpXG4gICAgICAgIGxldCAocGF0aF9zZWdfdHlwZSA6IHQgLT4gcGF0aF9zZWdfdHlwZSkgPVxuICAgICAgICAgIGZ1biB4NjY0IC0+XG4gICAgICAgICAgICBwYXRoX3NlZ190eXBlX29mX2pzIChPanMuZ2V0ICh0X3RvX2pzIHg2NjQpIFwicGF0aFNlZ1R5cGVcIilcbiAgICAgICAgbGV0IChwYXRoX3NlZ190eXBlX2FzX2xldHRlciA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICAgICAgZnVuIHg2NjUgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDY2NSkgXCJwYXRoU2VnVHlwZUFzTGV0dGVyXCIpXG4gICAgICBlbmRcbiAgICBtb2R1bGUgUGF0aFNlZ0xpc3QgPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4NjY3IC0+IHg2NjdcbiAgICAgICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDY2NiAtPiB4NjY2XG4gICAgICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgICAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICAgICAgbGV0IChudW1iZXJfb2ZfaXRlbXMgOiB0IC0+IGludCkgPVxuICAgICAgICAgIGZ1biB4NjcwIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDY3MCkgXCJudW1iZXJPZkl0ZW1zXCIpXG4gICAgICAgIGxldCAoZ2V0X2l0ZW0gOiB0IC0+IGludCAtPiBQYXRoU2VnLnQpID1cbiAgICAgICAgICBmdW4geDY3MiAtPlxuICAgICAgICAgICAgZnVuIHg2NzEgLT5cbiAgICAgICAgICAgICAgUGF0aFNlZy50X29mX2pzXG4gICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg2NzIpIFwiZ2V0SXRlbVwiIFt8KE9qcy5pbnRfdG9fanMgeDY3MSl8XSlcbiAgICAgICAgbGV0IChpbnNlcnRfaXRlbV9iZWZvcmUgOiB0IC0+IFBhdGhTZWcudCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgICAgIGZ1biB4Njc1IC0+XG4gICAgICAgICAgICBmdW4geDY3MyAtPlxuICAgICAgICAgICAgICBmdW4geDY3NCAtPlxuICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg2NzUpIFwiaW5zZXJ0SXRlbUJlZm9yZVwiXG4gICAgICAgICAgICAgICAgICAgICBbfChQYXRoU2VnLnRfdG9fanMgeDY3Myk7KE9qcy5pbnRfdG9fanMgeDY3NCl8XSlcbiAgICAgICAgbGV0IChyZXBsYWNlX2l0ZW0gOiB0IC0+IFBhdGhTZWcudCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgICAgIGZ1biB4Njc4IC0+XG4gICAgICAgICAgICBmdW4geDY3NiAtPlxuICAgICAgICAgICAgICBmdW4geDY3NyAtPlxuICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg2NzgpIFwicmVwbGFjZUl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgW3woUGF0aFNlZy50X3RvX2pzIHg2NzYpOyhPanMuaW50X3RvX2pzIHg2NzcpfF0pXG4gICAgICAgIGxldCAocmVtb3ZlX2l0ZW0gOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICAgICAgZnVuIHg2ODAgLT5cbiAgICAgICAgICAgIGZ1biB4Njc5IC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjgwKSBcInJlbW92ZUl0ZW1cIlxuICAgICAgICAgICAgICAgICAgIFt8KE9qcy5pbnRfdG9fanMgeDY3OSl8XSlcbiAgICAgICAgbGV0IChhcHBlbmRfaXRlbSA6IHQgLT4gUGF0aFNlZy50IC0+IHVuaXQpID1cbiAgICAgICAgICBmdW4geDY4MiAtPlxuICAgICAgICAgICAgZnVuIHg2ODEgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg2ODIpIFwiYXBwZW5kSXRlbVwiXG4gICAgICAgICAgICAgICAgICAgW3woUGF0aFNlZy50X3RvX2pzIHg2ODEpfF0pXG4gICAgICBlbmRcbiAgICBtb2R1bGUgUGF0aEVsZW1lbnQgPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgKHRfb2ZfanMgOiBPanMudCAtPiB0KSA9IGZ1biB4Njg0IC0+IHg2ODRcbiAgICAgICAgYW5kICh0X3RvX2pzIDogdCAtPiBPanMudCkgPSBmdW4geDY4MyAtPiB4NjgzXG4gICAgICAgIGxldCAodF9vZl9qcyA6IE9qcy50IC0+IHQpID0gdF9vZl9qc1xuICAgICAgICBsZXQgKHRfdG9fanMgOiB0IC0+IE9qcy50KSA9IHRfdG9fanNcbiAgICAgICAgbGV0IChwYXRoX3NlZ19saXN0IDogdCAtPiBQYXRoU2VnTGlzdC50KSA9XG4gICAgICAgICAgZnVuIHg2ODcgLT5cbiAgICAgICAgICAgIFBhdGhTZWdMaXN0LnRfb2ZfanMgKE9qcy5nZXQgKHRfdG9fanMgeDY4NykgXCJwYXRoU2VnTGlzdFwiKVxuICAgICAgICBsZXQgKG5vcm1hbGl6ZWRfcGF0aF9zZWdfbGlzdCA6IHQgLT4gUGF0aFNlZ0xpc3QudCkgPVxuICAgICAgICAgIGZ1biB4Njg4IC0+XG4gICAgICAgICAgICBQYXRoU2VnTGlzdC50X29mX2pzXG4gICAgICAgICAgICAgIChPanMuZ2V0ICh0X3RvX2pzIHg2ODgpIFwibm9ybWFsaXplZFBhdGhTZWdMaXN0XCIpXG4gICAgICAgIGxldCAoYW5pbWF0ZWRfcGF0aF9zZWdfbGlzdCA6IHQgLT4gUGF0aFNlZ0xpc3QudCkgPVxuICAgICAgICAgIGZ1biB4Njg5IC0+XG4gICAgICAgICAgICBQYXRoU2VnTGlzdC50X29mX2pzXG4gICAgICAgICAgICAgIChPanMuZ2V0ICh0X3RvX2pzIHg2ODkpIFwiYW5pbWF0ZWRQYXRoU2VnTGlzdFwiKVxuICAgICAgICBsZXQgKGFuaW1hdGVkX25vcm1hbGl6ZWRfcGF0aF9zZWdfbGlzdCA6IHQgLT4gUGF0aFNlZ0xpc3QudCkgPVxuICAgICAgICAgIGZ1biB4NjkwIC0+XG4gICAgICAgICAgICBQYXRoU2VnTGlzdC50X29mX2pzXG4gICAgICAgICAgICAgIChPanMuZ2V0ICh0X3RvX2pzIHg2OTApIFwiYW5pbWF0ZWROb3JtYWxpemVkUGF0aFNlZ0xpc3RcIilcbiAgICAgICAgbGV0IChjcmVhdGVfY2xvc2VfcGF0aCA6IHQgLT4gdW5pdCAtPiBQYXRoU2VnLnQpID1cbiAgICAgICAgICBmdW4geDY5MSAtPlxuICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgIFBhdGhTZWcudF9vZl9qc1xuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjkxKSBcImNyZWF0ZVNWR1BhdGhTZWdDbG9zZVBhdGhcIiBbfHxdKVxuICAgICAgICBsZXQgKGNyZWF0ZV9tb3ZldG9fYWJzIDogdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBQYXRoU2VnLnQpID1cbiAgICAgICAgICBmdW4geDY5NCAtPlxuICAgICAgICAgICAgZnVuIHg2OTIgLT5cbiAgICAgICAgICAgICAgZnVuIHg2OTMgLT5cbiAgICAgICAgICAgICAgICBQYXRoU2VnLnRfb2ZfanNcbiAgICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Njk0KSBcImNyZWF0ZVNWR1BhdGhTZWdNb3ZldG9BYnNcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg2OTIpOyhPanMuZmxvYXRfdG9fanMgeDY5Myl8XSlcbiAgICAgICAgbGV0IChjcmVhdGVfbW92ZXRvX3JlbCA6IHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gUGF0aFNlZy50KSA9XG4gICAgICAgICAgZnVuIHg2OTcgLT5cbiAgICAgICAgICAgIGZ1biB4Njk1IC0+XG4gICAgICAgICAgICAgIGZ1biB4Njk2IC0+XG4gICAgICAgICAgICAgICAgUGF0aFNlZy50X29mX2pzXG4gICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDY5NykgXCJjcmVhdGVTVkdQYXRoU2VnTW92ZXRvUmVsXCJcbiAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4Njk1KTsoT2pzLmZsb2F0X3RvX2pzIHg2OTYpfF0pXG4gICAgICAgIGxldCAoY3JlYXRlX2xpbmV0b19hYnMgOiB0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IFBhdGhTZWcudCkgPVxuICAgICAgICAgIGZ1biB4NzAwIC0+XG4gICAgICAgICAgICBmdW4geDY5OCAtPlxuICAgICAgICAgICAgICBmdW4geDY5OSAtPlxuICAgICAgICAgICAgICAgIFBhdGhTZWcudF9vZl9qc1xuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg3MDApIFwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Fic1wiXG4gICAgICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDY5OCk7KE9qcy5mbG9hdF90b19qcyB4Njk5KXxdKVxuICAgICAgICBsZXQgKGNyZWF0ZV9saW5ldG9fcmVsIDogdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBQYXRoU2VnLnQpID1cbiAgICAgICAgICBmdW4geDcwMyAtPlxuICAgICAgICAgICAgZnVuIHg3MDEgLT5cbiAgICAgICAgICAgICAgZnVuIHg3MDIgLT5cbiAgICAgICAgICAgICAgICBQYXRoU2VnLnRfb2ZfanNcbiAgICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NzAzKSBcImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9SZWxcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg3MDEpOyhPanMuZmxvYXRfdG9fanMgeDcwMil8XSlcbiAgICAgIGVuZFxuICBlbmRcbiIsInR5cGUgaGFuZCA9IExlZnQgfCBSaWdodFxudHlwZSBmaW5nZXIgPSBQaW5reSB8IFJpbmcgfCBNaWRkbGUgfCBJbmRleCB8IFRodW1iXG5cbnR5cGUga2V5ID1cbiAgfCBTKCpzaW5nbGUqKSBvZiBjaGFyXG4gIHwgSCgqaG9tZSopIG9mIGNoYXIgKiBoYW5kICogZmluZ2VyXG4gIHwgRSgqZW1wdHkgc3BhY2UqKVxuXG50eXBlIG5vZGUgPSB7XG4gIGM6IGNoYXIgb3B0aW9uO1xuICB4OiBpbnQ7XG4gIHk6IGludDtcbiAgbXV0YWJsZSBoYW5kOiBoYW5kO1xuICBtdXRhYmxlIGZpbmdlcjogZmluZ2VyO1xuICBtdXRhYmxlIGRpc3Q6IGludDtcbiAgbXV0YWJsZSBvcGVuZWQ6IGJvb2w7XG4gIG11dGFibGUgcXVldWVkOiBib29sO1xufVxuXG50eXBlIGRhdGFfdCA9IGtleSBsaXN0IGxpc3RcblxudHlwZSBsb29rdXBfdCA9IChjaGFyLCAoaGFuZCAqIGZpbmdlciAqIGludCkpIEhhc2h0YmwudFxuXG5cbmxldCBzdHJpbmdfb2ZfaGFuZCA9IGZ1bmN0aW9uXG4gIHwgTGVmdCAtPiBcImxlZnRcIlxuICB8IFJpZ2h0IC0+IFwicmlnaHRcIlxuXG5sZXQgc3RyaW5nX29mX2ZpbmdlciA9IGZ1bmN0aW9uXG4gIHwgUGlua3kgLT4gXCJwaW5reVwiXG4gIHwgUmluZyAtPiBcInJpbmdcIlxuICB8IE1pZGRsZSAtPiBcIm1pZGRsZVwiXG4gIHwgSW5kZXggLT4gXCJpbmRleFwiXG4gIHwgVGh1bWIgLT4gXCJ0aHVtYlwiXG5cbmxldCBzYW1wbGVfZHZvcmFrX2RhdGE6ZGF0YV90ID0gW1xuICBbIFMoJ2AnKTsgIFMoJzEnKTsgIFMoJzInKTsgUygnMycpOyBTKCc0Jyk7IFMoJzUnKTsgUygnNicpOyBTKCc3Jyk7IFMoJzgnKTsgUygnOScpOyBTKCcwJyk7IFMoJ1snKTsgUygnXScpOyAgXTtcbiAgWyBFOyAgICAgICBTKCdcXCcnKTsgUygnLCcpOyBTKCcuJyk7IFMoJ1AnKTsgUygnWScpOyBTKCdGJyk7IFMoJ0cnKTsgUygnQycpOyBTKCdSJyk7IFMoJ0wnKTsgUygnLycpOyBTKCc9Jyk7ICBdO1xuICBbIEU7ICAgICAgIEgoJ0EnLCBMZWZ0LCBQaW5reSk7ICBIKCdPJywgTGVmdCwgUmluZyk7IEgoJ0UnLCBMZWZ0LCBNaWRkbGUpOyBIKCdVJywgTGVmdCwgSW5kZXgpOyBTKCdJJyk7IFMoJ0QnKTsgSCgnSCcsIFJpZ2h0LCBJbmRleCk7IEgoJ1QnLCBSaWdodCwgTWlkZGxlKTsgSCgnTicsIFJpZ2h0LCBSaW5nKTsgSCgnUycsIFJpZ2h0LCBQaW5reSk7IFMoJy0nKTsgUygnXFxcXCcpOyBdO1xuICBbIFMoJzwnKTsgIFMoJzsnKTsgIFMoJ1EnKTsgUygnSicpOyBTKCdLJyk7IFMoJ1gnKTsgUygnQicpOyBTKCdNJyk7IFMoJ1cnKTsgUygnVicpOyBTKCdaJyk7IEU7ICAgICAgRTsgICAgICAgXTtcbl1cbmxldCBzYW1wbGVfY29sZW1ha19kYXRhOmRhdGFfdCA9IFtcbiAgWyBTKCdgJyk7ICBTKCcxJyk7ICBTKCcyJyk7IFMoJzMnKTsgUygnNCcpOyBTKCc1Jyk7IFMoJzYnKTsgUygnNycpOyBTKCc4Jyk7IFMoJzknKTsgUygnMCcpOyBTKCctJyk7IFMoJz0nKTsgRSBdO1xuICBbIEU7ICAgICAgIFMoJ1EnKTsgUygnVycpOyBTKCdGJyk7IFMoJ1AnKTsgUygnRycpOyBTKCdKJyk7IFMoJ0wnKTsgUygnVScpOyBTKCdZJyk7IFMoJzsnKTsgUygnWycpOyBTKCddJyk7IFMoJ1xcXFwnKSBdO1xuICBbIEU7ICAgICAgIEgoJ0EnLCBMZWZ0LCBQaW5reSk7ICBIKCdSJywgTGVmdCwgUmluZyk7IEgoJ1MnLCBMZWZ0LCBNaWRkbGUpOyBIKCdUJywgTGVmdCwgSW5kZXgpOyBTKCdEJyk7IFMoJ0gnKTsgSCgnTicsIFJpZ2h0LCBJbmRleCk7IEgoJ0UnLCBSaWdodCwgTWlkZGxlKTsgSCgnSScsIFJpZ2h0LCBSaW5nKTsgSCgnTycsIFJpZ2h0LCBQaW5reSk7IFMoJ1xcJycpOyBFOyBFIF07XG4gIFsgRTsgICAgICAgUygnWicpOyAgUygnWCcpOyBTKCdDJyk7IFMoJ1YnKTsgUygnQicpOyBTKCdLJyk7IFMoJ00nKTsgUygnLCcpOyBTKCcuJyk7IFMoJy8nKTsgRTsgRTsgRV07XG5dXG5sZXQgc2FtcGxlX3F3ZXJ0eV9kYXRhOmRhdGFfdCA9IFtcbiAgWyBTKCdcIicpOyAgUygnMScpOyAgUygnMicpOyBTKCczJyk7IFMoJzQnKTsgUygnNScpOyBTKCc2Jyk7IFMoJzcnKTsgUygnOCcpOyBTKCc5Jyk7IFMoJzAnKTsgUygnKicpOyBTKCctJyk7ICBdO1xuICBbIEU7ICAgICAgIFMoJ1EnKTsgUygnVycpOyBTKCdFJyk7IFMoJ1InKTsgUygnVCcpOyBTKCdZJyk7IFMoJ1UnKTsgUygnSScpOyBTKCdPJyk7IFMoJ1AnKTsgUygnRycpOyBTKCdVJyk7ICBdO1xuICBbIEU7ICAgICAgIEgoJ0EnLCBMZWZ0LCBQaW5reSk7ICBIKCdTJywgTGVmdCwgUmluZyk7IEgoJ0QnLCBMZWZ0LCBNaWRkbGUpOyBIKCdGJywgTGVmdCwgSW5kZXgpOyBTKCdHJyk7IFMoJ0gnKTsgSCgnSicsIFJpZ2h0LCBJbmRleCk7IEgoJ0snLCBSaWdodCwgTWlkZGxlKTsgSCgnTCcsIFJpZ2h0LCBSaW5nKTsgSCgnUycsIFJpZ2h0LCBQaW5reSk7IFMoJ0knKTsgUygnOycpOyBdO1xuICBbIFMoJzwnKTsgIFMoJ1onKTsgIFMoJ1gnKTsgUygnQycpOyBTKCdWJyk7IFMoJ0InKTsgUygnTicpOyBTKCdNJyk7IFMoJywnKTsgUygnLicpOyBTKCcvJyk7IEU7ICAgICAgRTsgICAgICAgXTtcbl1cblxubGV0IGxvb2t1cF9vZl9kYXRhIGxheW91dCA6bG9va3VwX3QgPVxuICAoKiBUT0RPIGFzc2VydCBhbGwgcm93cyBhcmUgZXF1YWwgbGVuZ3RoICopXG4gIGxldCBmaW5kX2hvbWVfcG9zaXRpb25zID1cbiAgICBsZXQgcmVjIGF1eCByZXN1bHRzIHkgeCA9IGZ1bmN0aW9uXG4gICAgICB8IChoIDo6IHQpIDo6IHJvd3MgLT5cbiAgICAgICAgIGxldCByZXN1bHRzJyA9IG1hdGNoIGggd2l0aFxuICAgICAgICAgICB8IEggXyAtPiAoeCwgeSkgOjogcmVzdWx0c1xuICAgICAgICAgICB8IF8gLT4gcmVzdWx0c1xuICAgICAgICAgaW5cbiAgICAgICAgICAgYXV4IHJlc3VsdHMnIHkgKHggKyAxKSAodCA6OiByb3dzKVxuICAgICAgfCBbXSA6OiByb3dzIC0+IGF1eCByZXN1bHRzICh5ICsgMSkgMCByb3dzXG4gICAgICB8IFtdIC0+IHJlc3VsdHNcbiAgICBpblxuICAgICAgYXV4IFtdIDAgMFxuICBpblxuICAgIHByaW50X2VuZGxpbmUgXCJob21lIHBvc2l0aW9ubnMgbm93LlwiO1xuICBsZXQgaG9tZV9wb3NpdGlvbnMgPSBmaW5kX2hvbWVfcG9zaXRpb25zIGxheW91dCBpblxuICAgIFByaW50Zi5wcmludGYgXCJob21lX3Bvc2l0aW9uczogJXNcXG5cIiAoU3RyaW5nLmNvbmNhdCBcIiwgXCIgKExpc3QubWFwIChmdW4gKHgsIHkpIC0+IFByaW50Zi5zcHJpbnRmIFwiKCVkLCAlZClcIiB4IHkpIGhvbWVfcG9zaXRpb25zKSk7XG4gIGxldCBtYXRyaXggPSBsYXlvdXRcbiAgICAgICAgICAgICAgIHw+IExpc3QubWFwaSAoZnVuIHkgY29scyAtPiBMaXN0Lm1hcGkgKGZ1biB4IGsgLT5cbiAgICAgICAgICAgICAgICAgICBtYXRjaCBrIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFMgYyAtPiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHg7IHk7XG4gICAgICAgICAgICAgICAgICAgICAgIGMgPSBTb21lIGM7XG4gICAgICAgICAgICAgICAgICAgICAgIGhhbmQgPSBMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXIgPSBUaHVtYjtcbiAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgIG9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB8IEggKGMsIGhhbmQsIGZpbmdlcikgLT4ge1xuICAgICAgICAgICAgICAgICAgICAgICB4OyB5O1xuICAgICAgICAgICAgICAgICAgICAgICBjID0gU29tZSBjO1xuICAgICAgICAgICAgICAgICAgICAgICBoYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXI7XG4gICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICBvcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfCBFIC0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgeDsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgICAgIGhhbmQgPSBMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXIgPSBUaHVtYjtcbiAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgIG9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICApIGNvbHMpXG4gICAgICAgICAgICAgICB8PiBMaXN0Lm1hcCAoQXJyYXkub2ZfbGlzdClcbiAgICAgICAgICAgICAgIHw+IEFycmF5Lm9mX2xpc3RcbiAgaW5cbiAgbGV0IHdpZHRoID0gQXJyYXkubGVuZ3RoIG1hdHJpeC4oMCkgaW5cbiAgbGV0IGhlaWdodCA9IEFycmF5Lmxlbmd0aCBtYXRyaXggaW5cbiAgbGV0IGZpbmRfbmVpZ2hib3VycyB4IHkgPVxuICAgIExpc3QuZmxhdHRlbiBbXG4gICAgICBpZiB4ID4gMCAgICAgICAgICB0aGVuIFttYXRyaXguKHkpLih4IC0gMSldIGVsc2UgW107XG4gICAgICBpZiB5ID4gMCAgICAgICAgICB0aGVuIFttYXRyaXguKHkgLSAxKS4oeCldIGVsc2UgW107XG4gICAgICBpZiB4ICsgMSA8IHdpZHRoICB0aGVuIFttYXRyaXguKHkpLih4ICsgMSldIGVsc2UgW107XG4gICAgICBpZiB5ICsgMSA8IGhlaWdodCB0aGVuIFttYXRyaXguKHkgKyAxKS4oeCldIGVsc2UgW107XG4gICAgXVxuICBpblxuICBsZXQgcSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgbWFwID0gSGFzaHRibC5jcmVhdGUgKHdpZHRoICogaGVpZ2h0KSBpblxuICAgIExpc3QuaXRlciAoZnVuICh4LCB5IGFzIGl0KSAtPlxuICAgICAgICBtYXRyaXguKHkpLih4KS5xdWV1ZWQgPC0gdHJ1ZTtcbiAgICAgICAgUXVldWUucHVzaCBpdCBxO1xuICAgICAgKSBob21lX3Bvc2l0aW9ucztcbiAgICB3aGlsZSBub3QgKFF1ZXVlLmlzX2VtcHR5IHEpIGRvXG4gICAgICBsZXQgbm9kZV94LCBub2RlX3kgPSBRdWV1ZS5wb3AgcSBpblxuICAgICAgbGV0IG5vZGUgPSBtYXRyaXguKG5vZGVfeSkuKG5vZGVfeCkgaW5cbiAgICAgIGxldCBteV9kaXN0ID0gbm9kZS5kaXN0ICsgMSBpblxuICAgICAgICAobWF0Y2ggbm9kZS5jIHdpdGhcbiAgICAgICAgIHwgU29tZSBjIC0+XG4gICAgICAgICAgICBQcmludGYucHJpbnRmIFwiJWMgd2l0aCAlcyAlcyBhdCAlZFxcblwiIGNcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9oYW5kIG5vZGUuaGFuZClcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9maW5nZXIgbm9kZS5maW5nZXIpXG4gICAgICAgICAgICAgIG5vZGUuZGlzdDtcbiAgICAgICAgICAgIEhhc2h0YmwuYWRkIG1hcCBjIChub2RlLmhhbmQsIG5vZGUuZmluZ2VyLCBub2RlLmRpc3QpXG4gICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgKTtcbiAgICAgICAgZmluZF9uZWlnaGJvdXJzIG5vZGVfeCBub2RlX3lcbiAgICAgICAgfD4gTGlzdC5pdGVyIChmdW5jdGlvblxuICAgICAgICAgICAgfCB7b3BlbmVkID0gdHJ1ZTsgX30gLT4gKClcbiAgICAgICAgICAgIHwge3F1ZXVlZCA9IGZhbHNlOyB4OyB5OyBffSBhcyBuIC0+XG4gICAgICAgICAgICAgICBuLmhhbmQgPC0gbm9kZS5oYW5kO1xuICAgICAgICAgICAgICAgbi5maW5nZXIgPC0gbm9kZS5maW5nZXI7XG4gICAgICAgICAgICAgICBuLmRpc3QgPC0gbXlfZGlzdDtcbiAgICAgICAgICAgICAgIG4ucXVldWVkIDwtIHRydWU7XG4gICAgICAgICAgICAgICBRdWV1ZS5wdXNoICh4LCB5KSBxO1xuICAgICAgICAgICAgfCB7cXVldWVkID0gdHJ1ZTsgZGlzdDsgX30gYXMgbiB3aGVuIGRpc3QgPiAgbXlfZGlzdCAtPlxuICAgICAgICAgICAgICAgbi5oYW5kIDwtIG5vZGUuaGFuZDtcbiAgICAgICAgICAgICAgIG4uZmluZ2VyIDwtIG5vZGUuZmluZ2VyO1xuICAgICAgICAgICAgICAgbi5kaXN0IDwtIG15X2Rpc3Q7XG4gICAgICAgICAgICB8IF8gLT4gKClcbiAgICAgICAgICApO1xuICAgIGRvbmU7XG4gICAgbWFwXG5cbmxldCB2aWV3ID8oaGlnaGxpdF9rZXk9Tm9uZSkgPyhpbl9lZGl0PWZhbHNlKSB+b25yZW1vdmUgbGFiZWwgbGF5b3V0ID1cbiAgbGV0IG9wZW4gVmRvbSBpblxuICBsZXQgbCA9IDQwIGluXG4gIGxldCBrZXlfYnV0dG9ucyA9IGxheW91dFxuICAgICAgICAgICAgICAgICAgICB8PiBMaXN0Lm1hcGkgKGZ1biByb3cgY29scyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgKExpc3QuZm9sZF9sZWZ0IChmdW4gKGNvbCwgcmVjdHMpIGtleSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBrZXkgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEUgLT4gY29sICsgMSwgcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBIIChjLCBfLCBfKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFMgYyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsbCA9IChtYXRjaCBoaWdobGl0X2tleSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWUgYycgd2hlbiBjID0gYycgLT4gXCIjRkZBMEEwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXyAtPiBcIndoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3NfeCA9IGNvbCAqIGwgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvc195ID0gcm93ICogbCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHN2Z19lbHQgXCJyZWN0XCIgW10gfmE6W2ludF9hdHRyIFwieFwiIHBvc194O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRfYXR0ciBcInlcIiBwb3NfeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50X2F0dHIgXCJ3aWR0aFwiIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludF9hdHRyIFwiaGVpZ2h0XCIgbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciAgXCJmaWxsXCIgZmlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0JyA9IHN2Z19lbHQgXCJ0ZXh0XCIgW3RleHQgKFN0cmluZy5tYWtlIDEgYyldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfmE6W2ludF9hdHRyIFwieFwiIChwb3NfeCArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRfYXR0ciBcInlcIiAocG9zX3kgKyAxNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHRoZSBvcmRlciBvZiBlbGVtZW50cyBkZXRlcm1pbmUgd2hpY2ggc2hvd3Mgb24gdG9wICopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbCArIDEpLCAodGV4dCcgOjogcmVjdCA6OiByZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKDAsIFtdKSBjb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgfD4gc25kXG4gICAgICAgICAgICAgICAgICAgICAgICAgfD4gTGlzdC5yZXZcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHw+IExpc3QuZmxhdHRlblxuICBpblxuICBsZXQgbWF4X3Jvd19sZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyBsIC0+IG1heCBhY2MgKExpc3QubGVuZ3RoIGwpKSAwIGxheW91dFxuICBpblxuICAgIGVsdCBcImtleWJvYXJkXCIgfmE6W2NsYXNzXyAoaWYgaW5fZWRpdCB0aGVuIFwiaW4tZWRpdFwiIGVsc2UgXCJcIildIFtcbiAgICAgIGRpdiB+YTpbY2xhc3NfIFwidGl0bGVcIl0gW3RleHQgbGFiZWxdO1xuXG4gICAgICBzdmdfZWx0IFwic3ZnXCIgfmE6W2ludF9hdHRyIFwid2lkdGhcIiAobWF4X3Jvd19sZW4gKiBsKTsgaW50X2F0dHIgXCJoZWlnaHRcIiAoNCAqIGwpXVxuICAgICAgICBrZXlfYnV0dG9ucztcblxuICAgICAgZGl2IH5hOltjbGFzc18gXCJjb250ZW50IGN1cnRhaW5cIl0gW1xuICAgICAgICAoZWx0IFwiYVwiIH5hOltvbmNsaWNrIG9ucmVtb3ZlOyBjbGFzc18gXCJpbnRlcmFjdGl2ZVwiXSBbdGV4dCBcInJlbW92ZVwiXSlcbiAgICAgIF1cbiAgICBdXG4iLCJsZXQgY2hhcnNfb2Zfc3RyaW5nIHMgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiBzLltpXSA6OiBhdXggKGkgKyAxKVxuICAgIGVsc2UgW11cbiAgaW5cbiAgICBhdXggMFxuXG5sZXQgc3RyaW5nX29mX2NoYXJzIGNoYXJzID1cbiAgY2hhcnNcbiAgfD4gTGlzdC5tYXAgKFN0cmluZy5tYWtlIDEpXG4gIHw+IFN0cmluZy5jb25jYXQgXCJcIlxuXG5sZXQgZmluZF9iZXN0X2luX2xpc3QgY21wIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBoIDo6IHQgLT4gTGlzdC5mb2xkX2xlZnQgY21wIGggdFxuICB8IFtdIC0+IGZhaWx3aXRoIFwibGlzdCBjYW4ndCBiZSBlbXB0eVwiXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBWZG9tXG5cbm1vZHVsZSBTdGF0cyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSB7XG4gICAgc2FtZV9oYW5kOiAnYTtcbiAgICBzYW1lX2ZpbmdlcjogJ2E7XG4gICAgZGlzdGFuY2U6ICdhO1xuICB9XG5cbiAgdHlwZSBrZXkgPSBTYW1lX2hhbmRcbiAgICAgICAgICAgfCBTYW1lX2ZpbmdlclxuICAgICAgICAgICB8IERpc3RhbmNlXG5cbiAgbGV0IGdldCB4ID0gZnVuY3Rpb25cbiAgICB8IFNhbWVfaGFuZCAtPiB4LnNhbWVfaGFuZFxuICAgIHwgU2FtZV9maW5nZXIgLT4geC5zYW1lX2ZpbmdlclxuICAgIHwgRGlzdGFuY2UgLT4geC5kaXN0YW5jZVxuXG4gIGxldCBtYXAgZiB4ID0ge1xuICAgIHNhbWVfaGFuZCA9IGYgeC5zYW1lX2hhbmQ7XG4gICAgc2FtZV9maW5nZXIgPSBmIHguc2FtZV9maW5nZXI7XG4gICAgZGlzdGFuY2UgPSBmIHguZGlzdGFuY2U7XG4gIH1cblxuICBsZXQgbWFwMiBmIHggeSA9IHtcbiAgICBzYW1lX2hhbmQgPSBmIHguc2FtZV9oYW5kIHkuc2FtZV9oYW5kO1xuICAgIHNhbWVfZmluZ2VyID0gZiB4LnNhbWVfZmluZ2VyIHkuc2FtZV9maW5nZXI7XG4gICAgZGlzdGFuY2UgPSBmIHguZGlzdGFuY2UgeS5kaXN0YW5jZTtcbiAgfVxuXG4gIGxldCBpbml0IHggPSB7XG4gICAgc2FtZV9oYW5kID0geDtcbiAgICBzYW1lX2ZpbmdlciA9IHg7XG4gICAgZGlzdGFuY2UgPSB4O1xuICB9XG5cbiAgbGV0IHN0cmluZ19vZl9rZXkgPSBmdW5jdGlvblxuICAgIHwgU2FtZV9oYW5kIC0+IFwiU2FtZSBIYW5kXCJcbiAgICB8IFNhbWVfZmluZ2VyIC0+IFwiU2FtZSBGaW5nZXJcIlxuICAgIHwgRGlzdGFuY2UgLT4gXCJEaXN0YW5jZVwiXG5lbmRcblxudHlwZSB0eXBpbmdfYW5hbHlzaXMgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgbGF5b3V0X2RhdGE6IEtiZGxheW91dC5kYXRhX3Q7XG4gIGtleWJvYXJkOiBLYmRsYXlvdXQubG9va3VwX3Q7XG4gIHN0YXRzOiBpbnQgU3RhdHMudDtcbiAgbGFzdF9oYW5kOiBLYmRsYXlvdXQuaGFuZDtcbiAgbGFzdF9maW5nZXI6IEtiZGxheW91dC5maW5nZXI7XG59XG5cbnR5cGUgdGV4dF9wbGF5ZXJfc3RhdGUgPSBSZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICB8IFBsYXlpbmcgb2YgaW50XG4gICAgICAgICAgICAgICAgICAgICAgIHwgRmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgfCBFZGl0aW5nXG5cbnR5cGUgbW9kZWwgPSB7XG4gIHN0YXRlOiB0ZXh0X3BsYXllcl9zdGF0ZTtcbiAgYW5hbHlzZXM6IHR5cGluZ19hbmFseXNpcyBsaXN0O1xuICBwYXNzYWdlOiBzdHJpbmc7XG59XG5cbnR5cGUgdXBkYXRlX21zZyA9IFN0YXJ0XG4gICAgICAgICAgICAgICAgfCBFbmRcbiAgICAgICAgICAgICAgICB8IE5leHRDaGFyXG4gICAgICAgICAgICAgICAgfCBSZXNldFxuICAgICAgICAgICAgICAgIHwgVG9nZ2xlRWRpdFxuICAgICAgICAgICAgICAgIHwgQ2hhbmdlVGV4dCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICB8IFJlbW92ZUtleWJvYXJkIG9mIHR5cGluZ19hbmFseXNpc1xuICAgICAgICAgICAgICAgIHwgQWRkS2V5Ym9hcmQgb2Ygc3RyaW5nICogS2JkbGF5b3V0LmRhdGFfdFxuICAgICAgICAgICAgICAgIHwgRG9Ob3RoaW5nXG5cbmxldCB1cGRhdGVfYW5hbHlzaXMgbGV0dGVyIGFuYWx5c2lzID1cbiAgbWF0Y2ggSGFzaHRibC5maW5kX29wdCBhbmFseXNpcy5rZXlib2FyZCBsZXR0ZXIgd2l0aFxuICB8IFNvbWUgKGhhbmQsIGZpbmdlciwgZGlzdCkgLT5cbiAgICAgbGV0IHtzdGF0czsgbGFzdF9oYW5kOyBsYXN0X2ZpbmdlcjsgX30gPSBhbmFseXNpcyBpblxuICAgICAgIHsgYW5hbHlzaXMgd2l0aFxuICAgICAgICAgc3RhdHMgPSB7XG4gICAgICAgICAgIHNhbWVfaGFuZCA9IHN0YXRzLnNhbWVfaGFuZCArIChpZiBoYW5kID0gbGFzdF9oYW5kIHRoZW4gMSBlbHNlIDApO1xuICAgICAgICAgICBzYW1lX2ZpbmdlciA9IHN0YXRzLnNhbWVfZmluZ2VyICsgKGlmIGZpbmdlciA9IGxhc3RfZmluZ2VyIHRoZW4gMSBlbHNlIDApO1xuICAgICAgICAgICBkaXN0YW5jZSA9IHN0YXRzLmRpc3RhbmNlICsgZGlzdDtcbiAgICAgICAgIH07XG4gICAgICAgICBsYXN0X2hhbmQgPSBoYW5kO1xuICAgICAgICAgbGFzdF9maW5nZXIgPSBmaW5nZXI7XG4gICAgICAgfVxuICB8IE5vbmUgLT4gYW5hbHlzaXNcblxubGV0IGZpbmlzaF9hbmFseXNlcyBtb2RlbCA9XG4gIGxldCByZWMgYXV4IGFuYWx5c2VzID0gZnVuY3Rpb25cbiAgICB8IFBsYXlpbmcgaSB3aGVuIChpICsgMSkgPCBTdHJpbmcubGVuZ3RoIG1vZGVsLnBhc3NhZ2UgLT5cbiAgICAgIGxldCBjID0gQ2hhci51cHBlcmNhc2VfYXNjaWkgbW9kZWwucGFzc2FnZS5baV0gaW5cbiAgICAgICAgYXV4IChMaXN0Lm1hcCAodXBkYXRlX2FuYWx5c2lzIGMpIGFuYWx5c2VzKSAoUGxheWluZyAoaSArIDEpKVxuICAgIHwgUGxheWluZyBfXG4gICAgfCBGaW5pc2hlZFxuICAgIHwgRWRpdGluZyAtPiBhbmFseXNlc1xuICAgIHwgUmVhZHkgLT4gYXV4IGFuYWx5c2VzIChQbGF5aW5nIDApXG4gIGluXG4gICAge21vZGVsIHdpdGggc3RhdGUgPSBGaW5pc2hlZDtcbiAgICAgICAgICAgICAgICBhbmFseXNlcyA9IGF1eCBtb2RlbC5hbmFseXNlcyBtb2RlbC5zdGF0ZX1cblxubGV0IGdyb3VwX3R5cGluZ19hbmFseXNlcyAoYW5hbHlzZXM6dHlwaW5nX2FuYWx5c2lzIGxpc3QpID1cbiAgTGlzdC5mb2xkX2xlZnRcbiAgICAoZnVuIGFjYyBpdCAtPiAoU3RhdHMubWFwMiAoZnVuIGEgYiAtPiAoaXQubmFtZSwgYikgOjogYSkgYWNjIGl0LnN0YXRzKSlcbiAgICAoU3RhdHMuaW5pdCBbXSlcbiAgICBhbmFseXNlc1xuICB8PiBTdGF0cy5tYXAgTGlzdC5yZXZcblxubGV0IGZpbmRfYmVzdF9zdGF0cyBsID1cbiAgbGV0IGNtcCAoXywgYV92YWwgYXMgYSkgKF8sIGJfdmFsIGFzIGIpID1cbiAgICBpZiBhX3ZhbCA8IGJfdmFsXG4gICAgdGhlbiBhXG4gICAgZWxzZSBiXG4gIGluXG4gICAgU3RhdHMubWFwIChmdW4gYSAtPiBhXG4gICAgICAgICAgICAgICAgICAgICAgICB8PiBmaW5kX2Jlc3RfaW5fbGlzdCBjbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHw+IGZzdFxuICAgICAgICAgICAgICApXG4gICAgICAoZ3JvdXBfdHlwaW5nX2FuYWx5c2VzIGwpXG5cbmxldCBpbml0ID0ge1xuICBzdGF0ZSA9IFJlYWR5O1xuICBwYXNzYWdlID0gU2FtcGxldGV4dHMuc2VudGVuY2U7XG4gIGFuYWx5c2VzID0gW1xuICAgIHtcbiAgICAgIG5hbWUgPSBcIkR2b3Jha1wiO1xuICAgICAgbGF5b3V0X2RhdGEgPSBLYmRsYXlvdXQuc2FtcGxlX2R2b3Jha19kYXRhO1xuICAgICAga2V5Ym9hcmQgPSBLYmRsYXlvdXQubG9va3VwX29mX2RhdGEgS2JkbGF5b3V0LnNhbXBsZV9kdm9yYWtfZGF0YTtcbiAgICAgIHN0YXRzID0gU3RhdHMuaW5pdCAwO1xuICAgICAgbGFzdF9oYW5kID0gS2JkbGF5b3V0LkxlZnQ7XG4gICAgICBsYXN0X2ZpbmdlciA9IEtiZGxheW91dC5UaHVtYjtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcIlF3ZXJ0eVwiO1xuICAgICAgbGF5b3V0X2RhdGEgPSBLYmRsYXlvdXQuc2FtcGxlX3F3ZXJ0eV9kYXRhO1xuICAgICAga2V5Ym9hcmQgPSBLYmRsYXlvdXQubG9va3VwX29mX2RhdGEgS2JkbGF5b3V0LnNhbXBsZV9xd2VydHlfZGF0YTtcbiAgICAgIHN0YXRzID0gU3RhdHMuaW5pdCAwO1xuICAgICAgbGFzdF9oYW5kID0gS2JkbGF5b3V0LkxlZnQ7XG4gICAgICBsYXN0X2ZpbmdlciA9IEtiZGxheW91dC5UaHVtYjtcbiAgICB9XG4gIF07XG59XG5cbmxldCB1cGRhdGUgbW9kZWwgPSBmdW5jdGlvblxuICB8IFN0YXJ0IC0+IHttb2RlbCB3aXRoXG4gICAgICAgICAgICAgICBzdGF0ZSA9IFBsYXlpbmcgMDtcbiAgICAgICAgICAgICAgIGFuYWx5c2VzID0gTGlzdC5tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIGFuYWx5c2lzIC0+IHsgYW5hbHlzaXMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lX2hhbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWVfZmluZ2VyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfaGFuZCA9IEtiZGxheW91dC5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2ZpbmdlciA9IEtiZGxheW91dC5UaHVtYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYW5hbHlzZXM7XG4gICAgICAgICAgICAgIH1cbiAgfCBFbmQgLT4gZmluaXNoX2FuYWx5c2VzIG1vZGVsXG4gIHwgTmV4dENoYXIgLT4gKG1hdGNoIG1vZGVsLnN0YXRlIHdpdGhcbiAgICAgIHwgUGxheWluZyBpIHdoZW4gKGkgKyAxKSA8IFN0cmluZy5sZW5ndGggbW9kZWwucGFzc2FnZSAtPlxuICAgICAgICAgbGV0IGMgPSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBtb2RlbC5wYXNzYWdlLltpXSBpblxuICAgICAgICAgICB7IG1vZGVsIHdpdGhcbiAgICAgICAgICAgICBzdGF0ZSA9IFBsYXlpbmcgKGkgKyAxKTtcbiAgICAgICAgICAgICBhbmFseXNlcyA9IExpc3QubWFwICh1cGRhdGVfYW5hbHlzaXMgYykgbW9kZWwuYW5hbHlzZXM7XG4gICAgICAgICAgIH1cbiAgICAgIHwgUGxheWluZyBfIC0+IHsgbW9kZWwgd2l0aCBzdGF0ZSA9IEZpbmlzaGVkIH1cbiAgICAgIHwgcyAtPiB7IG1vZGVsIHdpdGggc3RhdGUgPSBzIH1cbiAgICApXG4gIHwgUmVzZXQgLT4ge21vZGVsIHdpdGggc3RhdGUgPSAobWF0Y2ggbW9kZWwuc3RhdGUgd2l0aFxuICAgICAgfCBQbGF5aW5nIF8gLT4gUmVhZHlcbiAgICAgIHwgRmluaXNoZWQgLT4gUmVhZHlcbiAgICAgIHwgcyAtPiBzXG4gICAgKX1cbiAgfCBUb2dnbGVFZGl0IC0+IHttb2RlbCB3aXRoIHN0YXRlID0gKG1hdGNoIG1vZGVsLnN0YXRlIHdpdGhcbiAgICAgIHwgUGxheWluZyBfIGFzIHMgLT4gc1xuICAgICAgfCBFZGl0aW5nIC0+IFJlYWR5XG4gICAgICB8IFJlYWR5IHwgRmluaXNoZWQgLT4gRWRpdGluZ1xuICAgICl9XG4gIHwgQ2hhbmdlVGV4dCBwYXNzYWdlIC0+IHttb2RlbCB3aXRoIHBhc3NhZ2V9XG4gIHwgUmVtb3ZlS2V5Ym9hcmQgYW5hbHlzaXMgLT4ge21vZGVsIHdpdGggYW5hbHlzZXMgPSBMaXN0LmZpbHRlciAoKDw+KSBhbmFseXNpcykgbW9kZWwuYW5hbHlzZXN9XG4gIHwgQWRkS2V5Ym9hcmQgKG5hbWUsIGxheW91dF9kYXRhKSAtPiB7bW9kZWwgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuYWx5c2VzID0gKHtuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRfZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmQgPSBLYmRsYXlvdXQubG9va3VwX29mX2RhdGEgbGF5b3V0X2RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzID0gU3RhdHMuaW5pdCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2hhbmQgPSBLYmRsYXlvdXQuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9maW5nZXIgPSBLYmRsYXlvdXQuVGh1bWI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6OiBtb2RlbC5hbmFseXNlcyl9XG4gIHwgRG9Ob3RoaW5nIC0+IG1vZGVsXG5cblxubGV0IGJ1dHRvbiB0eHQgbXNnID0gaW5wdXQgW10gfmE6W29uY2xpY2sgKGZ1biBfIC0+IG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZV9idXR0b247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NfIFwiaW50ZXJhY3RpdmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0eHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cblxubGV0IHN0YXRzX2NoYXJ0IChhbmFseXNlczp0eXBpbmdfYW5hbHlzaXMgbGlzdCkgPVxuICBsZXQgc3RhdHNfYnlfbmFtZXMgPSBncm91cF90eXBpbmdfYW5hbHlzZXMgYW5hbHlzZXMgaW5cbiAgbGV0IGZhY3RvcnMgPSBTdGF0cy5tYXAgKExpc3QubWFwIHNuZCkgc3RhdHNfYnlfbmFtZXNcbiAgICAgICAgICAgICAgICB8PiBTdGF0cy5tYXAgKGZpbmRfYmVzdF9pbl9saXN0IG1heClcbiAgICAgICAgICAgICAgICB8PiBTdGF0cy5tYXAgKGZ1biB4IC0+IDIwMC4wIC8uIChmbG9hdF9vZl9pbnQgeCkpIGluXG4gICAgc3ZnX2VsdCBcInN2Z1wiIH5hOltpbnRfYXR0ciBcImhlaWdodFwiICgzMCArIDg1ICogTGlzdC5sZW5ndGggYW5hbHlzZXMpXSAoXG4gICAgICBMaXN0LmZvbGRfbGVmdCAoZnVuICh5MCwgYWNjKSBrIC0+XG4gICAgICAgICAgbGV0IGZhY3RvciA9IFN0YXRzLmdldCBmYWN0b3JzIGsgaW5cbiAgICAgICAgICBsZXQgc3RhdHNfYnlfbmFtZXMnID0gU3RhdHMuZ2V0IHN0YXRzX2J5X25hbWVzIGsgaW5cbiAgICAgICAgICBsZXQgbGVnZW5kID0gc3ZnX2VsdCBcInRleHRcIiB+YTpbaW50X2F0dHIgXCJ5XCIgKHkwICsgMTUpXSBbdGV4dCAoU3RhdHMuc3RyaW5nX29mX2tleSBrKV0gaW5cbiAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gKHkwLCBhY2MnKSAobmFtZSwgdikgLT5cbiAgICAgICAgICAgICAgICBsZXQgdyA9IGludF9vZl9mbG9hdCAoZmFjdG9yICouIChmbG9hdF9vZl9pbnQgdikpIGluXG4gICAgICAgICAgICAgICAgbGV0IHIgPSBzdmdfZWx0IFwicmVjdFwiIH5hOltpbnRfYXR0ciBcInhcIiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludF9hdHRyIFwieVwiIHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludF9hdHRyIFwid2lkdGhcIiB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludF9hdHRyIFwiaGVpZ2h0XCIgMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIFtdIGluXG4gICAgICAgICAgICAgICAgbGV0IHQgPSBzdmdfZWx0IFwidGV4dFwiIH5hOltpbnRfYXR0ciBcInhcIiAodyArIDI1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRfYXR0ciBcInlcIiAoeTAgKyAxNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIFt0ZXh0IG5hbWVdIGluXG4gICAgICAgICAgICAgICAgICAoKHkwICsgMjIpLCByIDo6IHQgOjogYWNjJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAoeTAgKyAyMCwgbGVnZW5kIDo6IGFjYylcbiAgICAgICAgICAgICAgc3RhdHNfYnlfbmFtZXMnXG4gICAgICAgIClcbiAgICAgICAgKDUsIFtdKVxuICAgICAgICBbU3RhdHMuU2FtZV9oYW5kOyBTdGF0cy5TYW1lX2ZpbmdlcjsgU3RhdHMuRGlzdGFuY2VdXG4gICAgICB8PiBzbmRcbiAgICApXG5cbmxldCB2aWV3IG1vZGVsID1cbiAgbGV0IHBsYXlfYnV0dG9uIHN0YXRlID0gZGl2IH5hOltzdHlsZSBcImRpc3BsYXlcIiBcImlubGluZS1ibG9ja1wiXSAobWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgfCBQbGF5aW5nIF8gLT4gWyBidXR0b24gXCLil7wgc3RvcFwiIFJlc2V0OyBidXR0b24gXCLilrbilrYgZW5kXCIgRW5kICBdXG4gICAgICB8IEZpbmlzaGVkICAtPiBbIGJ1dHRvbiBcIuKXgOKXgCByZXNldFwiIFJlc2V0IF1cbiAgICAgIHwgUmVhZHkgICAgIC0+IFsgYnV0dG9uIFwi4pa2IHBsYXlcIiBTdGFydCBdXG4gICAgICB8IEVkaXRpbmcgICAtPiBbIGlucHV0IFtdIH5hOlt0eXBlX2J1dHRvbjsgZGlzYWJsZWQgdHJ1ZTsgdmFsdWUgXCLilrcgcGxheVwiXSBdXG4gICAgKSBpblxuICBsZXQgZWRpdF9idXR0b24gc3RhdGUgPVxuICAgIGlucHV0IFtdIH5hOlt0eXBlX2J1dHRvbjtcbiAgICAgICAgICAgICAgICAgb25jbGljayAoZnVuIF8gLT4gVG9nZ2xlRWRpdCk7XG4gICAgICAgICAgICAgICAgIGNsYXNzXyBcImludGVyYWN0aXZlXCI7XG4gICAgICAgICAgICAgICAgIGRpc2FibGVkIChtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IFBsYXlpbmcgXyAtPiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICB8IF8gICAgICAgICAtPiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgIHZhbHVlIChtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IEVkaXRpbmcgLT4gXCLinJMgc2F2ZVwiXG4gICAgICAgICAgICAgICAgICAgICB8IF8gICAgICAgICAgIC0+IFwi4pyOIGVkaXRcIlxuICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgXTsgaW5cbiAgbGV0IHNjcm9sbGluZ190ZXh0IHN0YXRlIHBhc3NhZ2UgPVxuICAgIGxldCBpID0gKG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBQbGF5aW5nIGkgLT4gaVxuICAgICAgICB8IF8gLT4gMFxuICAgICAgKSBpblxuICAgICAgZGl2IFtcbiAgICAgICAgZGl2IH5hOlthdHRyIFwiaWRcIiBcInBhc3NhZ2VcIl1cbiAgICAgICAgICAobWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICAgICB8IEVkaXRpbmcgLT4gWyBlbHQgXCJzZWxlY3RcIiB+YTpbXG4gICAgICAgICAgICAgICBvbmlucHV0IChmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgIHwgXCJvbmUgc2VudGVuY2VcIiAgICAtPiBDaGFuZ2VUZXh0IFNhbXBsZXRleHRzLnNlbnRlbmNlXG4gICAgICAgICAgICAgICAgICAgfCBcInNoZXJsb2NrIGhvbG1lc1wiIC0+IENoYW5nZVRleHQgU2FtcGxldGV4dHMuc2hlcmxvY2tcbiAgICAgICAgICAgICAgICAgICB8IF8gLT4gRG9Ob3RoaW5nXG4gICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgXSBbXG4gICAgICAgICAgICAgICBlbHQgXCJvcHRpb25cIiB+YTpbYXR0ciBcInNlbGVjdGVkXCIgXCJcIjsgZGlzYWJsZWQgdHJ1ZV0gW3RleHQgXCJTYW1wbGUgVGV4dHNcIl07XG4gICAgICAgICAgICAgICBlbHQgXCJvcHRpb25cIiBbdGV4dCBcIm9uZSBzZW50ZW5jZVwiXTtcbiAgICAgICAgICAgICAgIGVsdCBcIm9wdGlvblwiIFt0ZXh0IFwic2hlcmxvY2sgaG9sbWVzXCJdO1xuICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICBlbHQgXCJiclwiIFtdO1xuICAgICAgICAgICAgICAgZWx0IFwidGV4dGFyZWFcIiB+YTpbaW50X2F0dHIgXCJyb3dzXCIgMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50X2F0dHIgXCJjb2xzXCIgODA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dCAoZnVuIHMgLT4gQ2hhbmdlVGV4dCBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICBbdGV4dCBwYXNzYWdlXVxuICAgICAgICAgICAgIF1cbiAgICAgICAgICAgfCBfIC0+IFsgdGV4dCAoU3RyaW5nLnN1YiBwYXNzYWdlIGkgKFN0cmluZy5sZW5ndGggcGFzc2FnZSAtIGkpKSBdXG4gICAgICAgICAgKVxuICAgICAgXVxuICBpblxuICBsZXQgdmlld19zdGF0cyBzdGF0ZSBhbmFseXNlcyA9XG4gICAgbGV0IGJlc3Rfc3RhdHMgPSBmaW5kX2Jlc3Rfc3RhdHMgYW5hbHlzZXMgaW5cbiAgICBsZXQgY2xhc3NlcyA9IG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgUGxheWluZyBfIC0+IFwiXCJcbiAgICAgIHwgXyAgICAgICAgIC0+IFwiaGlkZGVuXCJcbiAgICBpblxuICAgICAgZGl2IH5hOltjbGFzc18gY2xhc3Nlc10gW1xuICAgICAgICBlbHQgXCJ0YWJsZVwiIH5hOlthdHRyIFwiaWRcIiBcInN0YXRzXCJdIChcbiAgICAgICAgICBlbHQgXCJ0clwiIFtcbiAgICAgICAgICAgIGVsdCBcInRoXCIgW107XG4gICAgICAgICAgICBlbHQgXCJ0aFwiIH5hOltjbGFzc18gXCJudW1lcmljYWxcIl0gW3RleHQgXCJzYW1lIGhhbmRcIl07XG4gICAgICAgICAgICBlbHQgXCJ0aFwiIH5hOltjbGFzc18gXCJudW1lcmljYWxcIl0gW3RleHQgXCJzYW1lIGZpbmdlclwiXTtcbiAgICAgICAgICAgIGVsdCBcInRoXCIgfmE6W2NsYXNzXyBcIm51bWVyaWNhbFwiXSBbdGV4dCBcImRpc3RhbmNlXCJdO1xuICAgICAgICAgIF1cbiAgICAgICAgICA6OiBMaXN0Lm1hcCAoZnVuIHtuYW1lOyBzdGF0czsgX30gLT4gXG4gICAgICAgICAgICAgIGxldCBzdGF0X2NlbGwgayA9IFxuICAgICAgICAgICAgICAgIGVsdCBcInRkXCIgfmE6W2NsYXNzXyAoXCJudW1lcmljYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKGlmIG5hbWUgPSBTdGF0cy5nZXQgYmVzdF9zdGF0cyBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiBiZXN0LXN0YXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICldXG4gICAgICAgICAgICAgICAgICBbdGV4dCAoc3RyaW5nX29mX2ludCAoU3RhdHMuZ2V0IHN0YXRzIGspKV07XG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgZWx0IFwidHJcIiBbXG4gICAgICAgICAgICAgICAgICAoZWx0IFwidGhcIiBbdGV4dCBuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAoc3RhdF9jZWxsIFN0YXRzLlNhbWVfaGFuZCk7XG4gICAgICAgICAgICAgICAgICAoc3RhdF9jZWxsIFN0YXRzLlNhbWVfZmluZ2VyKTtcbiAgICAgICAgICAgICAgICAgIChzdGF0X2NlbGwgU3RhdHMuRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICkgYW5hbHlzZXNcbiAgICAgICAgKTtcbiAgICAgICAgZWx0IFwiYnJcIiBbXTtcbiAgICAgICAgc3RhdHNfY2hhcnQgYW5hbHlzZXNcbiAgICAgIF0gaW5cbiAgbGV0IHZpZXdfYW5hbHlzaXMgcGFzc2FnZSBzdGF0ZSBhbmFseXNpcyA9XG4gICAgbGV0IGhpZ2hsaXRfa2V5ID0gKG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBQbGF5aW5nIGkgLT4gU29tZSAoQ2hhci51cHBlcmNhc2VfYXNjaWkgcGFzc2FnZS5baV0pXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICApIGluXG4gICAgbGV0IGluX2VkaXQgPSAobWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVkaXRpbmcgd2hlbiAoTGlzdC5sZW5ndGggbW9kZWwuYW5hbHlzZXMgPiAxKSAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgKSBpblxuICAgICAgS2JkbGF5b3V0LnZpZXcgfmhpZ2hsaXRfa2V5IH5pbl9lZGl0IH5vbnJlbW92ZTooZnVuIF8gLT4gUmVtb3ZlS2V5Ym9hcmQgYW5hbHlzaXMpIGFuYWx5c2lzLm5hbWUgYW5hbHlzaXMubGF5b3V0X2RhdGE7IGluXG4gIGxldCBjcmVhdGVfa2V5Ym9hcmQgc3RhdGUgPVxuICAgIGxldCBpbl9lZGl0ID0gKG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFZGl0aW5nIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGZhbHNlXG4gICAgICApIGluXG4gICAgbGV0IGxheW91dF9leGlzdHMgbmFtZSA9IExpc3QuZXhpc3RzIChmdW4gYSAtPiBhLm5hbWUgPSBuYW1lKSBtb2RlbC5hbmFseXNlcyBpblxuICAgICAgZWx0IFwia2V5Ym9hcmRcIiB+YTpbY2xhc3NfIChpZiBpbl9lZGl0IHRoZW4gXCJpbi1lZGl0XCIgZWxzZSBcImhpZGRlblwiKV0gW1xuICAgICAgICBkaXYgfmE6W2NsYXNzXyBcInRpdGxlXCJdIFt0ZXh0IFwiQWRkIE5ld1wiXTtcbiAgICAgICAgZGl2IH5hOlthdHRyIFwiaWRcIiBcImNyZWF0ZS1rZXlib2FyZC1idXR0b25cIjsgY2xhc3NfIFwiY29udGVudFwiXSBbXG4gICAgICAgICAgZWx0IFwic2VsZWN0XCIgfmE6W29uaW5wdXQgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgXCJDb2xlbWFrXCIgLT4gQWRkS2V5Ym9hcmQgKFwiQ29sZW1ha1wiLCBLYmRsYXlvdXQuc2FtcGxlX2NvbGVtYWtfZGF0YSlcbiAgICAgICAgICAgICAgfCBcIkR2b3Jha1wiICAtPiBBZGRLZXlib2FyZCAoXCJEdm9yYWtcIiwgS2JkbGF5b3V0LnNhbXBsZV9kdm9yYWtfZGF0YSlcbiAgICAgICAgICAgICAgfCBcIlF3ZXJ0eVwiICAtPiBBZGRLZXlib2FyZCAoXCJRd2VydHlcIiwgS2JkbGF5b3V0LnNhbXBsZV9xd2VydHlfZGF0YSlcbiAgICAgICAgICAgICAgfCBfIC0+IERvTm90aGluZ1xuICAgICAgICAgICAgKTsgY2xhc3NfIFwiaW50ZXJhY3RpdmVcIl0gKFxuICAgICAgICAgICAgZWx0IFwib3B0aW9uXCIgfmE6W2F0dHIgXCJzZWxlY3RlZFwiIFwiXCI7IGRpc2FibGVkIHRydWVdIFt0ZXh0IFwic2VsZWN0XCJdXG4gICAgICAgICAgICA6OiAoTGlzdC5tYXBcbiAgICAgICAgICAgICAgICAgIChmdW4gbmFtZSAtPiAoZWx0IFwib3B0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+YTpbZGlzYWJsZWQgKGxheW91dF9leGlzdHMgbmFtZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RleHQgbmFtZV0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBbXCJDb2xlbWFrXCI7IFwiRHZvcmFrXCI7IFwiUXdlcnR5XCJdXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICBdXG4gIGluXG4gICAgZGl2IH5hOltzdHlsZSBcInRleHQtYWxpZ25cIiBcImNlbnRlclwiXSBbXG4gICAgICBkaXYgfmE6W2F0dHIgXCJpZFwiIFwia2V5Ym9hcmRzXCJdIChjcmVhdGVfa2V5Ym9hcmQgbW9kZWwuc3RhdGUgOjogKExpc3QubWFwICh2aWV3X2FuYWx5c2lzIG1vZGVsLnBhc3NhZ2UgbW9kZWwuc3RhdGUpIG1vZGVsLmFuYWx5c2VzKSk7XG4gICAgICBkaXYgW1xuICAgICAgICAocGxheV9idXR0b24gbW9kZWwuc3RhdGUpO1xuICAgICAgICAoZWRpdF9idXR0b24gbW9kZWwuc3RhdGUpO1xuICAgICAgXTtcbiAgICAgIChzY3JvbGxpbmdfdGV4dCBtb2RlbC5zdGF0ZSBtb2RlbC5wYXNzYWdlKTtcbiAgICAgICh2aWV3X3N0YXRzIG1vZGVsLnN0YXRlIG1vZGVsLmFuYWx5c2VzKTtcbiAgICBdXG5cbmxldCBhcHAgPSBzaW1wbGVfYXBwIH5pbml0IH52aWV3IH51cGRhdGUgKClcblxubGV0ICgpID1cbiAgbGV0IG9wZW4gSnNfYnJvd3NlciBpblxuICBsZXQgcnVuICgpID0gVmRvbV9ibGl0LnJ1biBhcHBcbiAgICAgICAgICAgICAgIHw+IChmdW4gYXBwJyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBfID0gV2luZG93LnNldF9pbnRlcnZhbCB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biAoKSAtPiBWZG9tX2JsaXQucHJvY2VzcyBhcHAnIE5leHRDaGFyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MFxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICBhcHAnXG4gICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgIHw+IFZkb21fYmxpdC5kb21cbiAgICAgICAgICAgICAgIHw+IEVsZW1lbnQuYXBwZW5kX2NoaWxkIChtYXRjaCBEb2N1bWVudC5nZXRfZWxlbWVudF9ieV9pZCBkb2N1bWVudCBcImNvbnRhaW5lclwiIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgY29udGFpbmVyIC0+IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBEb2N1bWVudC5ib2R5IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgIClcbiAgaW5cbiAgICBXaW5kb3cuc2V0X29ubG9hZCB3aW5kb3cgcnVuXG4iXX0=